<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>22条商规</title>
    <url>/2017/08/31/22%E6%9D%A1%E5%95%86%E8%A7%84/</url>
    <content><![CDATA[<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul>
<li>定位和聚焦定位非常重要，反其道而行之也许就是机会。</li>
<li>定位不是一成不变的，应把握分化趋势，适时重定位。</li>
<li>每个人只能为每个品类留下两个品牌空间，即就能记住俩品牌！例如空调，就记住了格力和美的</li>
<li>定位4步法：</li>
<li>第一步，分析整个外部环境，确定我们的竞争对手是谁，竞争对手的价值是什么</li>
<li>第二步，避开竞争对手在顾客心智中的强势，或是利用其强势中蕴含的弱点，确立品牌的优势位置：定位</li>
<li>第三步，为这一定位寻求一个可靠的证明：信任状</li>
<li>第四步，将这一定位整合进企业内部运营的方方面面，特别是传播上要有足够的资源，以将这定位植入顾客心智</li>
<li>夺取心智资源。每个人精力时间都优先，第一时间想到什么品牌，就很可能用什么品牌</li>
<li>定位激发品牌生产力。</li>
<li>定位提升运营绩效。更聚焦有效的，剔除无效的</li>
<li>定位客观存在，要么在正确、精准的定位上，要么在错误、模糊的定位上</li>
<li>所有组织和个人都需要定位</li>
<li>美国企业哲学就是聚焦、狭窄而深入，中国企业哲学是宽泛而浅显</li>
<li>企业很难仅仅通过满足客户需求的方式在营销中获得成功。更应该聚焦</li>
</ul>
<h3 id="商规"><a href="#商规" class="headerlink" title="商规"></a>商规</h3><h4 id="领先定律"><a href="#领先定律" class="headerlink" title="领先定律"></a>领先定律</h4><ul>
<li>成为第一胜过做的最好，第一能占领客户心智，最好却无法界定。</li>
<li>创造一个你能成为第一的新领域。</li>
<li>时机很重要，天时地利人和。</li>
<li>首创品牌通常能保持自己的领先地位，甚至成为品类的代名词</li>
</ul>
<h4 id="品类定律"><a href="#品类定律" class="headerlink" title="品类定律"></a>品类定律</h4><ul>
<li>如果你不能第一个进入某品类，那么就创造一个品类使自己成为第一。</li>
<li>首先要问并不是“与竞争对手相比，这个产品有哪些优势”，而是“这个产品能在哪个品类成为第一”。</li>
<li>几乎每个人都会对新品类产生兴趣，很少有人会对更好的产品产生兴趣</li>
</ul>
<h4 id="心智定律"><a href="#心智定律" class="headerlink" title="心智定律"></a>心智定律</h4><ul>
<li>市场营销是一场争夺认知而不是产品的战争，在进入市场之前应该率先进入心智。</li>
<li>在市场营销中最为徒劳的就是试图改变人们的认知。</li>
<li>应采用迅猛而非渐进的方式给别人留下一个深刻印象，不要想着逐渐影响别人以博得好感！</li>
</ul>
<h4 id="认知定律"><a href="#认知定律" class="headerlink" title="认知定律"></a>认知定律</h4><ul>
<li>市场营销领域并不存在客观现实性，也不存在事实，更不存在最好的产品。</li>
<li>存在的只是顾客心智中的认知，其他都是幻觉！</li>
<li>大多数人都认为自己的认知能力比别人强，认为自己总是正确的。</li>
<li>人们总是相信自己愿意相信的东西。</li>
<li>另外一点就是从众效应，认同的人越多，认同的人越多</li>
</ul>
<h4 id="聚焦定律"><a href="#聚焦定律" class="headerlink" title="聚焦定律"></a>聚焦定律</h4><ul>
<li>市场营销的要点就是聚焦，收缩经营范围将使你更强大，追逐所有目标将使你一事无成。</li>
<li>最有效的代名词应该是简洁、能体现优势的词语。</li>
<li>光环效应，专注于某一优势，用户会带来更多优势。</li>
<li>你不能讲其他公司的代名词据为己有，避免正面战斗选择迂回战术。</li>
<li>你不能讲焦点集中在质量或是诸如如此类不存在对立面的概念上。</li>
<li>有了自己的代名词要进行专利注册，但允许别人使用。要全力保护自己概念在市场上地位。</li>
</ul>
<h4 id="专有定律"><a href="#专有定律" class="headerlink" title="专有定律"></a>专有定律</h4><ul>
<li>当你的竞争对手已经在潜在顾客心智中拥有一个代名词或定位时，你若再想拥有同一个代名词将是徒劳无益的。</li>
<li>花更多的钱去抢别人的代名词不但抢不到，而且会提升对手的影响力。</li>
<li>用户想要什么，和我们在广告中强调什么没关系，强调的应该是自己的代名词。</li>
</ul>
<h4 id="阶梯定律"><a href="#阶梯定律" class="headerlink" title="阶梯定律"></a>阶梯定律</h4><ul>
<li>产品都非生来平等，潜在顾客在做购买决定时总会对各品牌进行排序，对于每一个品类，顾客的心智中都会形成一个选购顺序阶梯，每个品牌占有一层阶梯。你的营销战略应该根据你的品牌占据了心智阶梯的位置来决定。</li>
<li>通常人们只接受与自己认知相一致的新信息，其他的都会被置之不理。</li>
<li>有时候在大品类的阶梯上屈居第三要胜过在小品类的阶梯上独占鳌头</li>
<li>在营销中，心智决定市场；品牌的心智地位决定市场地位；心智份额决定市场份额</li>
</ul>
<h4 id="二元定律"><a href="#二元定律" class="headerlink" title="二元定律"></a>二元定律</h4><ul>
<li>从总体和长远角度来看，你会发现市场往往演化成两大品牌竞争的局面。</li>
<li>当你处于第三的位置，你无法通过直接攻击两个强大的领先者来获得更大发展，而他们却可能从中渔利。</li>
<li>明确自己的定位，采用符合自己定位的手段</li>
<li>顾客相信市场营销是一场产品的较量，因为他们相信领先品牌总是更好一些，他们开始购买领先品牌</li>
</ul>
<h4 id="对立定律"><a href="#对立定律" class="headerlink" title="对立定律"></a>对立定律</h4><ul>
<li>若想成为市场第二，那么你的战略应由第一决定。知己知彼，任何第二都有机会干掉第一</li>
<li>必须发现领导者强大的本质，然后以与其相对立的定位出现在潜在顾客面前！不要试图变得更好，但要试图变得不同</li>
<li>模仿领先者是徒劳的</li>
<li>不要一味地打击你的竞争对手。要求你不断宣传竞争对手的弱点（必须以事实为根据），是你的潜在顾客很快就能意识到这个问题，接着迅速调转矛头</li>
</ul>
<h4 id="分化定律"><a href="#分化定律" class="headerlink" title="分化定律"></a>分化定律</h4><ul>
<li>每个品类总是始于某一个单一的品类，但在一段时间之后，这个品类开始分化成几个小品类</li>
<li>是领先者保持其对市场已有统治的方法之一，是给新产品起新名字</li>
</ul>
<h4 id="长效定律"><a href="#长效定律" class="headerlink" title="长效定律"></a>长效定律</h4><ul>
<li>短期内，促销能够增加公司的销售额；但从长期来看，促销只会减少公司销售额。因为它教会顾客不要在”正常“价格是买东西</li>
</ul>
<h4 id="延伸定律"><a href="#延伸定律" class="headerlink" title="延伸定律"></a>延伸定律</h4><ul>
<li>产品越多，市场越大，阵线越长，赚的钱反而越少</li>
<li>我宁愿在某一方面强，也不愿在所有方面都弱</li>
<li>误区：虽然长期来看品牌延伸是一个失败的战略，但就短期而言，它却可以让你成功</li>
</ul>
<h4 id="牺牲定律"><a href="#牺牲定律" class="headerlink" title="牺牲定律"></a>牺牲定律</h4><ul>
<li>你如果想取得成功，就应该牺牲一些东西。有三样东西是你需要牺牲的：产品线、目标市场和不断的变化</li>
<li>市场营销是一场心智之战，它是认知的竞争，而不是产品或服务的竞争</li>
<li>集中产品焦点，深化产品内容</li>
<li>更大的网可以捕捉更多的顾客，但事实恰恰相反</li>
<li>你所明确的市场营销目标并不就是实际上购买你的产品的那些人。尽管百事可乐的营销目标是青少年，但市场却包括所有人</li>
<li>如果你视图追随市场的每一个潮流与风头，你将注定要被淘汰出局。保持稳固地位的最好方法是从一开始就不要改变你的战略</li>
</ul>
<h4 id="特性定律"><a href="#特性定律" class="headerlink" title="特性定律"></a>特性定律</h4><ul>
<li>必须有自己独特的认识或特性，并以此为中心展开营销</li>
<li>必须努力拥有最为重要的特性</li>
<li>你无法估量具有新特征的产品开拓市场的潜力，因此绝不要嘲笑它</li>
</ul>
<h4 id="坦诚定律"><a href="#坦诚定律" class="headerlink" title="坦诚定律"></a>坦诚定律</h4><ul>
<li>慎用，很容易玩砸了！</li>
<li>是自己的产品深入人心最有效的方法是首先承认自己的不足（广泛被人们认为的缺点），当人们开始关注你时，在转向正面的宣传</li>
<li>承认自己的弱点是违背公司和个人本性的</li>
<li>最重要的是坦诚可以解除顾客的戒备心理</li>
<li>如果你的名字不好，那么你将面临两个选择：换一个名字或调侃它，但不要轻视它</li>
</ul>
<h4 id="唯一定律"><a href="#唯一定律" class="headerlink" title="唯一定律"></a>唯一定律</h4><ul>
<li>在大多数情况下，你的竞争者只有一个容易被攻破的薄弱环节，正是这个环境应该成为你全力攻击的焦点</li>
<li>在市场营销中，更努力的工作并不一定是成功的秘诀</li>
<li>在市场营销中能够凑效的战略与在军事上的战略相同：出其不意</li>
<li>营销人员必须亲临市场竞争第一线，知道什么能做什么不能做</li>
</ul>
<h4 id="莫测定律"><a href="#莫测定律" class="headerlink" title="莫测定律"></a>莫测定律</h4><ul>
<li>未来不可准确预测，只能着眼于未来趋势</li>
<li>意想不到的事总会发生，但我们必须努力</li>
<li>预见未来和对未来下注是两码事</li>
</ul>
<h4 id="成功定律"><a href="#成功定律" class="headerlink" title="成功定律"></a>成功定律</h4><ul>
<li>成功往往会导致 盲目 贸然 延伸产品线！容易骄傲和自大</li>
<li>民众关于现实情况的真实看法才是最主要的！</li>
</ul>
<h4 id="失败定律"><a href="#失败定律" class="headerlink" title="失败定律"></a>失败定律</h4><ul>
<li>尽早发现错误并及时采取措施以停止损失。补救、 放弃</li>
<li>试验不可怕，失败不可怕，可怕的是没复盘同一个地方失败两次</li>
</ul>
<h4 id="炒作定律"><a href="#炒作定律" class="headerlink" title="炒作定律"></a>炒作定律</h4><ul>
<li>炒作就是炒作。事情进展顺利，不需要宣传炒作，当它需要炒作时，一般意味着它遇到了麻烦。</li>
<li>炒作的本质并不是这个新产品正在走向成功，而是宣告现有的产品要过时</li>
<li>真正的革命会在午夜悄无声息的到来</li>
</ul>
<h4 id="趋势定律"><a href="#趋势定律" class="headerlink" title="趋势定律"></a>趋势定律</h4><ul>
<li>如果你面对一个正在迅速崛起的行业，具有时尚的一切特征，那么你最好能够淡化时尚。通过淡化时尚，你就能使之流行的时间延长，从而使它更像一种趋势</li>
</ul>
<h4 id="资源定律"><a href="#资源定律" class="headerlink" title="资源定律"></a>资源定律</h4><ul>
<li>一分钱难倒英雄汉！</li>
<li>平时，一毛钱不赚就是赔</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>APP运行理论</title>
    <url>/2017/08/11/APP%E8%BF%90%E8%A1%8C%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<p>转载自：<a href="https://zhidao.baidu.com/question/1370352051634002499.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1370352051634002499.html</a></p>
<p>main() 执行前发生的事<br><br>Mach-O 格式<br><br>虚拟内存基础<br><br>Mach-O 二进制的加载<br><br>理论速成<br><br>Mach-O 术语<br><br>Mach-O 是针对不同运行时可执行文件的文件类型。<br><br>文件类型：<br><br>Executable： 应用的主要二进制<br><br>Dylib： 动态链接库（又称 DSO 或 DLL）<br><br>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。<br><br>Image： executable，dylib 或 bundle<br><br>Framework： 包含 Dylib 以及资源文件和头文件的文件夹<br><br>Mach-O 镜像文件<br><br>Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。<br><br>segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。<br><br>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。<br><br>几乎所有 Mach-O 都包含这三个段（segment）： <strong>TEXT , </strong>DATA 和 <strong>LINKEDIT ：<br>
</strong>TEXT 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。<br><br><strong>DATA 包含全局变量，静态变量等。可读写（rw-）。<br>
</strong>LINKEDIT 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。<br><br>Mach-O Universal 文件<br><br>FAT 二进制 文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。<br><br>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。<br><br>虚拟内存<br><br>虚拟内存就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。<br><br>对于文件可以不用一次性读入整个文件，可以使用分页映射（ mmap() ）的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。<br><br>也就是说 Mach-O 文件中的 <strong>TEXT 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。 </strong>DATA 段是可读写的。这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。<br><br>Mach-O 镜像 加载<br><br>所以在多个进程加载 Mach-O 镜像时 <strong>TEXT 和 </strong>LINKEDIT 因为只读，都是可以共享内存的。而 <strong>DATA 因为可读写，就会产生 dirty page。当 dyld 执行结束后， </strong>LINKEDIT 就没用了，对应的内存页会被回收。<br><br>安全<br><br>ASLR（Address Space Layout Randomization）：地址空间布局随机化，镜像会在随机的地址上加载。这其实是一二十年前的旧技术了。<br><br>代码签名：可能我们认为 Xcode 会把整个文件都做加密 hash 并用做数字签名。其实为了在运行时验证 Mach-O 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 <strong>LINKEDIT 中。这使得文件每页的内容都能及时被校验确并保不被篡改。<br><br>从 exec() 到 main()<br><br>exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围 至少 是 4KB；对于 64 位进程则 至少 是 4GB。NULL 指针引用和指针截断误差都是会被它捕获。<br><br>dyld 加载 dylib 文件<br><br>Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 dyld ，其他 Unix 系统也有ld.so 。 当内核完成映射进程的工作后会将名字为 dyld 的Mach-O 文件映射到进程中的随机地址，它将 PC 寄存器设为 dyld 的地址并运行。 dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。<br><br>下面的步骤构成了 dyld 的时间线：<br><br>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers<br><br>加载 Dylib<br><br>从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap() 。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。<br><br>Fix-ups<br><br>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。<br><br>现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 </strong>DATA 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。<br><br>所以 dyld 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。<br><br>Rebasing 和 Binding<br><br>Rebasing：在镜像内部调整指针的指向<br><br>Binding：将指针指向镜像外部的内容<br><br>可以通过命令行查看 rebase 和 bind 等信息：<br><br>xcrun dyldinfo -rebase -bind -lazy_bind myapp.app/myapp<br></p>
<p>通过这个命令可以查看所有的 Fix-up。rebase，bind，weak_bind，lazy_bind 都存储在 <strong>LINKEDIT 段中，并可通过 LC_DYLD_INFO_ONLY 查看各种信息的偏移量和大小。<br><br>建议用 MachOView 查看更加方便直观。<br><br>从 dyld 源码层面简要介绍下 Rebasing 和 Binding 的流程。<br><br>ImageLoader 是一个用于加载可执行文件的基类，它负责链接镜像，但不关心具体文件格式，因为这些都交给子类去实现。每个可执行文件都会对应一个 ImageLoader实例。 ImageLoaderMachO 是用于加载 Mach-O 格式文件的 ImageLoader 子类，而ImageLoaderMachOClassic 和 ImageLoaderMachOCompressed 都继承于 ImageLoaderMachO ，分别用于加载那些 </strong>LINKEDIT 段为传统格式和压缩格式的 Mach-O 文件。<br><br>因为 dylib 之间有依赖关系，所以 ImageLoader 中的好多操作都是沿着依赖链递归操作的，Rebasing 和 Binding 也不例外，分别对应着 recursiveBind() 和 recursiveBind() 这两个方法。因为是递归，所以会自底向上地分别调用 doRebase() 和 doBind() 方法，这样被依赖的 dylib 总是先于依赖它的 dylib 执行 Rebasing 和 Binding。传入 doRebase() 和 doBind() 的参数包含一个 LinkContext 上下文，存储了可执行文件的一堆状态和相关的函数。<br><br>在 Rebasing 和 Binding 前会判断是否已经 Prebinding。如果已经进行过预绑定（Prebinding），那就不需要 Rebasing 和 Binding 这些 Fix-up 流程了，因为已经在预先绑定的地址加载好了。<br><br>ImageLoaderMachO 实例 不使用预绑 定会有四个原因：<br><br>Mach-O Header 中 MH_PREBOUND 标志位为 0<br><br>镜像加载地址有偏移（这个后面会讲到）<br><br>依赖的库有变化<br><br>镜像使用 flat-namespace，预绑定的一部分会被忽略<br><br>LinkContext 的环境变量禁止了预绑定<br><br>ImageLoaderMachO 中 doRebase() 做的事情大致如下：<br><br>如果使用预绑定， fgImagesWithUsedPrebinding 计数加一，并 return ;否则进入第二步<br><br>如果 MH_PREBOUND 标志位为 1 （也就是可以预绑定但没使用），且镜像在共享内存中，重置上下文中所有的 lazy pointer。（如果镜像在共享内存中，稍后会在 Binding 过程中绑定，所以无需重置）<br><br>如果镜像加载地址偏移量为0，则无需 Rebasing，直接 return ；否则进入第四步<br><br>调用 rebase() 方法，这才是真正做 Rebasing 工作的方法。如果开启 TEXT_RELOC_SUPPORT 宏，会允许 rebase() 方法对 <strong>TEXT 段做写操作来对其进行 Fix-up。所以其实 </strong>TEXT 只读属性并不是绝对的。<br><br>ImageLoaderMachOClassic 和 ImageLoaderMachOCompressed 分别实现了自己的doRebase() 方法。实现逻辑大同小异，同样会判断是否使用预绑定，并在真正的 Binding 工作时判断 TEXT_RELOC_SUPPORT 宏来决定是否对 <strong>TEXT 段做写操作。最后都会调用 setupLazyPointerHandler 在镜像中设置 dyld 的 entry point，放在最后调用是为了让主可执行文件设置好 </strong>dyld 或 <strong>program_vars 。<br><br>Rebasing<br><br>在过去，会把 dylib 加载到指定地址，所有指针和数据对于代码来说都是对的， dyld 就无需做任何 fix-up 了。如今用了 ASLR 后悔将 dylib 加载到新的随机地址(actual_address)，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有偏差，dyld 需要修正这个偏差(slide)，做法就是将 dylib 内部的指针地址都加上这个偏移量，偏移量的计算方法如下：<br><br>Slide = actual_address - preferred_address<br><br>然后就是重复不断地对 </strong>DATA 段中需要 rebase 的指针加上这个偏移量。这就又涉及到 page fault 和 COW。这可能会产生 I/O 瓶颈，但因为 rebase 的顺序是按地址排列的，所以从内核的角度来看这是个有次序的任务，它会预先读入数据，减少 I/O 消耗。<br><br>Binding<br><br>Binding 是处理那些指向 dylib 外部的指针，它们实际上被符号（symbol）名称绑定，也就是个字符串。之前提到 <strong>LINKEDIT 段中也存储了需要 bind 的指针，以及指针需要指向的符号。 dyld 需要找到 symbol 对应的实现，这需要很多计算，去符号表里查找。找到后会将内容存储到 </strong>DATA 段中的那个指针中。Binding 看起来计算量比 Rebasing 更大，但其实需要的 I/O 操作很少，因为之前 Rebasing 已经替 Binding 做过了。<br><br>ObjC Runtime<br><br>Objective-C 中有很多数据结构都是靠 Rebasing 和 Binding 来修正（fix-up）的，比如 Class 中指向超类的指针和指向方法的指针。<br><br>ObjC 是个动态语言，可以用类的名字来实例化一个类的对象。这意味着 ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时，其定义的所有的类都需要被注册到这个全局表中。<br><br>C++ 中有个问题叫做易碎的基类（fragile base class）。ObjC 就没有这个问题，因为会在加载时通过 fix-up 动态类中改变实例变量的偏移量。<br><br>在 ObjC 中可以通过定义类别（Category）的方式改变一个类的方法。有时你想要添加方法的类在另一个 dylib 中，而不在你的镜像中（也就是对系统或别人的类动刀），这时也需要做些 fix-up。<br><br>ObjC 中的 selector 必须是唯一的。<br><br>Initializers<br><br>C++ 会为静态创建的对象生成初始化器。而在 ObjC 中有个叫 +load 的方法，然而它被废弃了，现在建议使用 +initialize 。对比详见： <a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" target="_blank" rel="noopener">http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do</a><br><br>现在有了主执行文件，一堆 dylib，其依赖关系构成了一张巨大的有向图，那么执行初始化器的顺序是什么？自顶向上！按照依赖关系，先加载叶子节点，然后逐步向上加载中间节点，直至最后加载根节点。这种加载顺序确保了安全性，加载某个 dylib 前，其所依赖的其余 dylib 文件肯定已经被预先加载。<br><br>最后 dyld 会调用 main() 函数。 main() 会调用 UIApplicationMain() 。<br><br>改善启动时间<br><br>从点击 App 图标到加载 App 闪屏之间会有个动画，我们希望 App 启动速度比这个动画更快。虽然不同设备上 App 启动速度不一样，但启动时间最好控制在 400ms。需要注意的是启动时间一旦超过 20s，系统会认为发生了死循环并杀掉 App 进程。当然启动时间最好以 App 所支持的最低配置设备为准。直到 applicationWillFinishLaunching 被调动，App 才启动结束。<br><br>测量启动时间<br><br>Warm launch: App 和数据已经在内存中<br><br>Cold launch: App 不在内核缓冲存储器中<br><br>冷启动（Cold launch）耗时才是我们需要测量的重要数据，为了准确测量冷启动耗时，测量前需要重启设备。在 main() 方法执行前测量是很难的，好在 dyld 提供了内建的测量方法：在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 1 。控制台输出的内容如下：<br><br>Total pre-main time:228.41 milliseconds (100.0%)<br><br>dylib loading time:82.35 milliseconds (36.0%)<br><br>rebase/binding time:6.12 milliseconds (2.6%)<br><br>ObjC setup time:7.82 milliseconds (3.4%)<br><br>initializer time:132.02 milliseconds (57.8%)<br><br>slowest intializers :libSystem.B.dylib:122.07 milliseconds (53.4%)<br><br>CoreFoundation:5.59 milliseconds (2.4%)<br><br>优化启动时间<br><br>可以针对 App 启动前的每个步骤进行相应的优化工作。<br><br>加载 Dylib<br><br>之前提到过加载系统的 dylib 很快，因为有优化。但加载内嵌（embedded）的 dylib 文件很占时间，所以尽可能把多个内嵌 dylib 合并成一个来加载，或者使用 static archive。使用 dlopen() 来在运行时懒加载是不建议的，这么做可能会带来一些问题，并且总的开销更大。<br><br>Rebase/Binding<br><br>之前提过 Rebaing 消耗了大量时间在 I/O 上，而在之后的 Binding 就不怎么需要 I/O 了，而是将时间耗费在计算上。所以这两个步骤的耗时是混在一起的。<br><br>之前说过可以从查看 <strong>DATA 段中需要修正（fix-up）的指针，所以减少指针数量才会减少这部分工作的耗时。对于 ObjC 来说就是减少 Class , selector 和category 这些元数据的数量。从编码原则和设计模式之类的理论都会鼓励大家多写精致短小的类和方法，并将每部分方法独立出一个类别，其实这会增加启动时间。对于 C++ 来说需要减少虚方法，因为虚方法会创建 vtable，这也会在 </strong>DATA 段中创建结构。虽然 C++ 虚方法对启动耗时的增加要比 ObjC 元数据要少，但依然不可忽视。最后推荐使用 Swift 结构体，它需要 fix-up 的内容较少。<br><br>ObjC Setup<br><br>针对这步所能事情很少，几乎都靠 Rebasing 和 Binding 步骤中减少所需 fix-up 内容。因为前面的工作也会使得这步耗时减少。<br><br>Initializer<br><br>显式初始化<br><br>使用 +initialize 来替代 +load<br><br>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_once() , pthread_once() 或 std::once() 。也就是在第一次使用时才初始化，推迟了一部分工作耗时。<br><br>隐式初始化<br><br>对于带有 复杂（non-trivial）构造器 的 C++ 静态变量：<br><br>在调用的地方使用初始化器。<br><br>只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算__DATA 中的数据，无需再进行 fix-up 工作。<br><br>使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。<br><br>使用 Swift 重写代码，因为 Swift 已经预先处理好了，强力推荐。<br><br>不要在初始化方法中调用 dlopen() ，对性能有影响。因为 dyld 在 App 开始前运行，由于此时是单线程运行所以系统会取消加锁，但 dlopen() 开启了多线程，系统不得不加锁，这就严重影响了性能，还可能会造成死锁以及产生未知的后果。所以也不要在初始化器中创建线程。<br></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpha&amp;Hidden&amp;Opaque</title>
    <url>/2014/10/31/Alpha-Hidden-Opaque/</url>
    <content><![CDATA[<h4 id="Alpha"><a href="#Alpha" class="headerlink" title="Alpha"></a>Alpha</h4><ul>
<li>alpha是不透明度，属性为浮点类型的值，取值范围从0到1.0，表示从完全透明到完全不透明，默认1.0完全不透明。</li>
<li>alpha值会影响到UIView跟其所有subview，如果当前View的alpha为0，则当前View和所有的subview都看不到了</li>
<li>在动画块中设置alpha具有动画效果</li>
<li>当前view的alpha为0时，当前UIView会从响应者链中移除，而响应者链中的下一个会成为第一响应者。</li>
</ul>
<h4 id="Hidden"><a href="#Hidden" class="headerlink" title="Hidden"></a>Hidden</h4><ul>
<li>Hidden属性为BOOL值，用来表示UIView是否隐藏，<strong>默认值是NO即不隐藏，隐藏为YES！</strong></li>
<li>当Hidden为YES时，当前的UIView和subview都会被隐藏，而不管subview的hidden值为多少</li>
<li>当Hidden为YES时，当前UIView会从响应者链中移除，而响应者链中的下一个会成为第一响应者</li>
<li>在动画块中设置hidden没有动画效果</li>
<li>复杂交互中，可以先加载所有subViews，然后根据状态来设置某个view的hidden属性，避免重复开销</li>
</ul>
<h4 id="Opaque"><a href="#Opaque" class="headerlink" title="Opaque"></a>Opaque</h4><ul>
<li><p>opaque也是表示当前的UIView的不透明度,默认YES,官方文档:alpha为1,则opaque为YES；alpha小于1，opaque为NO，但是如果反了，产生的后果是不可预料的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">An opaque view is expected to fill its bounds with entirely opaque content—that is, the content should have an alpha value of 1.0. If the view is opaque and either does not fill its bounds or contains wholly or partially transparent content,the results are unpredictable. You should always set the value of this property to NO if the view is fully or partially transparent.</span><br></pre></td></tr></table></figure>
</li>
<li><p>当opaque属性被设为YES时，GPU就不会再利用图层颜色合成公式去合成真正的色值，节省性能</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>AFN都干了什么？</title>
    <url>/2017/10/08/AFN%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<ol>
<li>TargetConditionals.h 内置很多条件判断的宏 <a href="https://www.jianshu.com/p/dc0404c09060" target="_blank" rel="noopener">https://www.jianshu.com/p/dc0404c09060</a></li>
<li><p>修复ios8的bug，同步方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/Qsir/article/details/86496346" target="_blank" rel="noopener"><strong>typeof</strong>() 、 __typeof（） 、 typeof（）的区别</a></p>
</li>
<li><p>字典绑定task和回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">// 这是NSLock</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    [self removeNotificationObserverForTask:task];</span><br><span class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hook问题？沿着继承链找到第一个并hook! 惊艳点！！！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    /**</span><br><span class="line">     WARNING: Trouble Ahead</span><br><span class="line">     https://github.com/AFNetworking/AFNetworking/pull/2702</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</span><br><span class="line">        /**</span><br><span class="line">         iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky.</span><br><span class="line">         Many Unit Tests have been built to validate as much of this behavior has possible.</span><br><span class="line">         Here is what we know:</span><br><span class="line">            - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn&apos;t actually the type of class you will get back.</span><br><span class="line">            - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there.</span><br><span class="line">            - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`.</span><br><span class="line">            - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`.</span><br><span class="line">            - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled.</span><br><span class="line">            - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled.</span><br><span class="line">            - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there.</span><br><span class="line">        </span><br><span class="line">         Some Assumptions:</span><br><span class="line">            - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we&apos;d need to handle it.</span><br><span class="line">            - No background task classes override `resume` or `suspend`</span><br><span class="line">         </span><br><span class="line">         The current solution:</span><br><span class="line">            1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task.</span><br><span class="line">            2) Grab a pointer to the original implementation of `af_resume`</span><br><span class="line">            3) Check to see if the current class has an implementation of resume. If so, continue to step 4.</span><br><span class="line">            4) Grab the super class of the current class.</span><br><span class="line">            5) Grab a pointer for the current class to the current implementation of `resume`.</span><br><span class="line">            6) Grab a pointer for the super class to the current implementation of `resume`.</span><br><span class="line">            7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods</span><br><span class="line">            8) Set the current class to the super class, and repeat steps 3-8</span><br><span class="line">         */</span><br><span class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask class];</span><br><span class="line">        </span><br><span class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</span><br><span class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发数1，串行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFNetworking里的GET,POST,HEAD,PUT,PATCH,DELETE请求均经过dispatch_queue_t，由外部传入，可以是并行也可以是串行，如果没有传入则使用dispatch_get_main_queue</p>
</li>
<li><p>AF做了一些workround苹果bug的事情：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）iOS8之前苹果的bug，在concurrent queue创建NSURLSessionTask，会导致不正确的completionHandlers的调用，AFNetworking做了安全保护，在iOS8之前都在 serial queue中创建NSURLSessionTask</span><br><span class="line">2）iOS7苹果的bug，NSURLSession创建UploadTask的时候，有时会返回nil，AF会尝试重试三次创建，来workround这个bug</span><br><span class="line">3）初始化NSURLSession的时候，对于NSURLSessionConfiguration的处理不一样，iOS9以下是将config做为引用，而在9及其以上是copy了一份</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFNetworking内部是使用一个completion dispatch group 和一个processing concurrent dispatch queue，来管理成功或者失败block的回掉的</p>
</li>
<li><p>AFNetworking的maxconcurrentcount是1，所以没有做并发量的控制，就是一个单线程队列管理，但是AFImageDownloader里做了并发数的限制，最大下载数是4</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>App的生命周期</title>
    <url>/2015/01/31/App%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h4 id="应用程序的状态"><a href="#应用程序的状态" class="headerlink" title="应用程序的状态"></a>应用程序的状态</h4><ul>
<li>Not running（未运行），程序没启动</li>
<li>Inactive（未激活），程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态</li>
<li>Active（激活），程序在前台运行而且接收到了事件。这也是前台的一个正常的模式</li>
<li>Backgroud（后台），程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态</li>
<li><p>Suspended（挂起），程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。</p>
</li>
<li><p>下图是程序状态变化图：<br><img src="http://api.cocoachina.com/uploads/20150623/1435046880459183.png" alt="image"></p>
</li>
</ul>
<ul>
<li>各个程序运行状态时代理的回调：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在App启动时调用表示应用加载进程已经开始,常用来处理应用状态的存储和恢复</span><br><span class="line">- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">// 告诉代理启动基本完成程序准备开始运行</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">// 当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</span><br><span class="line">- (void)applicationWillResignActive:(UIApplication *)application</span><br><span class="line">// 当应用程序入活动状态执行，这个刚好跟上面那个方法相反</span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application</span><br><span class="line">// 当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</span><br><span class="line">- (void)applicationDidEnterBackground:(UIApplication *)application</span><br><span class="line">// 当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</span><br><span class="line">- (void)applicationWillEnterForeground:(UIApplication *)application</span><br><span class="line">// 当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置UIApplicationExitsOnSuspend的键值。</span><br><span class="line">- (void)applicationWillTerminate:(UIApplication *)application</span><br><span class="line">// 当程序载入后执行</span><br><span class="line">- (void)applicationDidFinishLaunching:(UIApplication*)application</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h4><ul>
<li>iOS8中,App会在根控制器初始化后调用viewDidAppear方法之后才会调用applicationDidBecomeActive</li>
<li>而在iOS7中,App在调用applicationDidBecomeActive方法后才会调用根控制器的viewDidAppear</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html" target="_blank" rel="noopener">https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html</a></li>
<li><a href="https://blog.csdn.net/totogo2010/article/details/8048652/" target="_blank" rel="noopener">iOS应用程序生命周期(前后台切换,应用的各种状态)详解</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Aspects都干了什么？</title>
    <url>/2017/10/01/Aspects%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<ol>
<li>使用的OSSpinLockLock锁，不安全了! 详情</li>
<li>@”retain”, @”release”, @”autorelease”, @”forwardInvocation:”为黑名单不能hook</li>
<li>AspectPositionBefore is the only valid position when hooking dealloc.</li>
<li>Unable to find selector，即不能hook未识别方法</li>
<li>检查子类是否hook，子类hook相应方法super不再hook</li>
<li>由于使用的block，需要做blockSignature 和 selecterSignature校验</li>
<li><a href="https://developer.apple.com/documentation/foundation/nsmethodsignature" target="_blank" rel="noopener">NSMethodSignature官网</a>其中Type Encodings需要了解一下</li>
<li>类似KVO，生成一个subClass_Aspects_的子类</li>
<li>IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)<strong>ASPECTS_ARE_BEING_CALLED</strong>, “v@:@”);// If there is no method, replace will act like class_addMethod.</li>
<li><p>替换class，想不到吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line"></span><br><span class="line">static void aspect_hookedGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">    NSCParameterAssert(class);</span><br><span class="line">    NSCParameterAssert(statedClass);</span><br><span class="line">    Method method = class_getInstanceMethod(class, @selector(class));</span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">        return statedClass;</span><br><span class="line">    &#125;);</span><br><span class="line">    class_replaceMethod(class, @selector(class), newIMP, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把的subClass_Aspects_相关方法指向_objc_msgForward，// We use forwardInvocation to hook in.</p>
</li>
<li>如果没hook成功，则调用原来的((void( <em>)(id, SEL, NSInvocation </em>))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</li>
<li>用before、after和instand三个数组来处理替换前替换后地或不调用原IMP</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Block基本使用</title>
    <url>/2014/11/09/Block%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Block是啥？"><a href="#Block是啥？" class="headerlink" title="Block是啥？"></a>Block是啥？</h3><ul>
<li>个人理解：就是一个函数指针，java的代码块</li>
<li>生命周期：block里面代码执行完</li>
<li>参数捕获：block能捕获外部变量，并copy到block内部使用！用__block可破</li>
<li>循环引用：block捕获了self，self又强持有block！用<strong>weak </strong>strong可破</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 声明一种block类型，以后拿来直接用</span><br><span class="line">typedef int(^block4Type)(int, int);</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">// 注意block5即是block的“函数名”，也是属性的属性名</span><br><span class="line">@property (nonatomic, copy) int(^block5)(int, int);</span><br><span class="line">@property (nonatomic, copy) NSString *str;</span><br><span class="line">// 当然也可使用block4Type类型</span><br><span class="line">@property (nonatomic, copy) block4Type block6;</span><br><span class="line">//</span><br><span class="line">@property (nonatomic, copy) void(^cycleBlock)(NSString *title);</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// Do any additional setup after loading the view.</span><br><span class="line">// 有参数有返回值</span><br><span class="line">int (^block1)(int, int) = ^(int num1, int num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block1：%d&quot;,block1(5,4));</span><br><span class="line">// 无返回 void</span><br><span class="line">void (^block2)(int, int) = ^(int num1, int num2) &#123;</span><br><span class="line">NSLog(@&quot;block2：%d&quot;,num1 + num2);</span><br><span class="line">&#125;;</span><br><span class="line">block2(4,5);</span><br><span class="line">// 注意没参数也要有括号，实现部分有没有参数括号都行</span><br><span class="line">int (^block3)() = ^ &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block3：%d&quot;,block3());</span><br><span class="line">// 使用声明的block类型，初始化一个block实例</span><br><span class="line">block4Type block4 = ^(int num1, int num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block4：%d&quot;,block4(5,4));</span><br><span class="line">// Block作为属性</span><br><span class="line">self.block5 =  ^(int num1, int num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block5：%d&quot;,self.block5(5,4));</span><br><span class="line">self.block6 =  ^(int num1, int num2) &#123;</span><br><span class="line">return num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block6：%d&quot;,self.block6(5,4));</span><br><span class="line">// block捕获外部变量</span><br><span class="line">int total7 = 4;</span><br><span class="line">int (^block7)(int) = ^(int num)&#123;</span><br><span class="line">//        total7 += num; // 报错，提示需要__block</span><br><span class="line">return total7 + num;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block7：%d, total:%d&quot;,block7(4), total7);</span><br><span class="line">//</span><br><span class="line">__block int total8 = 4;</span><br><span class="line">int (^block8)(int) = ^(int num)&#123;</span><br><span class="line">total8 += num;</span><br><span class="line">return total8;</span><br><span class="line">&#125;;</span><br><span class="line">NSLog(@&quot;block8：%d, total:%d&quot;,block8(4), total8);</span><br><span class="line">// 以下代码会报错误： Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle</span><br><span class="line">//    self.cycleBlock = ^(NSString *title) &#123;</span><br><span class="line">//        self.title = [NSString stringWithFormat:@&quot;hello, %@&quot;,title];</span><br><span class="line">//    &#125;;</span><br><span class="line">//    self.cycleBlock(@&quot;world&quot;);</span><br><span class="line"></span><br><span class="line">// 破解循环引用</span><br><span class="line">__weak typeof(self)weakSelf = self;</span><br><span class="line">self.cycleBlock = ^(NSString *title) &#123;</span><br><span class="line">//        __strong typeof(weakSelf)self = weakSelf; //如果你需要强制有self实例，需打开此注释</span><br><span class="line">weakSelf.title = [NSString stringWithFormat:@&quot;hello, %@&quot;,title];</span><br><span class="line">&#125;;</span><br><span class="line">self.cycleBlock(@&quot;world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="同步？异步？"><a href="#同步？异步？" class="headerlink" title="同步？异步？"></a>同步？异步？</h4><ul>
<li>试验1<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;第一行&quot;);</span><br><span class="line">void (^firstBlock)(void) = ^&#123;</span><br><span class="line">sleep(3);</span><br><span class="line">NSLog(@&quot;第二行&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">firstBlock();</span><br><span class="line">NSLog(@&quot;第三行&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;结论：block是同步的，先执行为2，再执行3</p>
<ul>
<li>试验2<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;第4行&quot;);</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">NSLog(@&quot;第5行&quot;);</span><br><span class="line">void (^secondBlock)(void) = ^&#123;</span><br><span class="line">sleep(3);</span><br><span class="line">NSLog(@&quot;第6行&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">secondBlock();</span><br><span class="line">NSLog(@&quot;第7行&quot;);</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">sleep(3);</span><br><span class="line">NSLog(@&quot;第8行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;第9行&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog(@&quot;第10行&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;结论：dispatch_async是异步的</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Category原理</title>
    <url>/2016/05/19/Category%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="1-Category结构"><a href="#1-Category结构" class="headerlink" title="1 Category结构"></a>1 Category结构</h3><p>&emsp;&emsp;先看rutnime里category_t的<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">源码</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">const char *name; // 类的名字</span><br><span class="line">classref_t cls;   // 类</span><br><span class="line">struct method_list_t *instanceMethods; // 实例方法</span><br><span class="line">struct method_list_t *classMethods;    // 类方法</span><br><span class="line">struct protocol_list_t *protocols;     // 协议</span><br><span class="line">struct property_list_t *instanceProperties; // 属性</span><br><span class="line">// Fields below this point are not always present on disk.</span><br><span class="line">struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">if (isMeta) return classMethods;</span><br><span class="line">else return instanceMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;待测试代码h文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject &#123;</span><br><span class="line">NSString *clsIvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *clsProperty1;</span><br><span class="line">@property (nonatomic, copy) NSString *clsProperty2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person (MyTest)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *clsProperty1;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;m文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">static NSString *kClsProperty1 = @&quot;kClsProperty1&quot;;</span><br><span class="line">static NSString *kClsProperty3 = @&quot;kClsProperty3&quot;;</span><br><span class="line">@interface Person () &#123;</span><br><span class="line">NSString *_extensionIvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *extensionProperty;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">NSLog(@&quot;method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">NSLog(@&quot;method2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person (MyTest)</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">NSLog(@&quot;category method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">NSLog(@&quot;category method3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setClsProperty1:(NSString*)propertyValue &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty1, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)clsProperty1 &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty1);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setClsProperty3:(NSString*)propertyValue &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty3, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)clsProperty3 &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty3);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;查看编译后文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSString *kClsProperty1 = (NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_0;</span><br><span class="line">static NSString *kClsProperty3 = (NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_1;</span><br><span class="line">/** interface Person () &#123;</span><br><span class="line">NSString *_extensionIvar;</span><br><span class="line">**/ </span><br><span class="line"></span><br><span class="line">// @property (nonatomic, copy) NSString *extensionProperty;</span><br><span class="line"></span><br><span class="line">/* @end */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation Person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_method1(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_method2(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_clsProperty1(Person * self, SEL _cmd) &#123; return (*(NSString * _Nonnull __strong *)((char *)self + OBJC_IVAR_$_Person$_clsProperty1)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Person_setClsProperty1_(Person * self, SEL _cmd, NSString * _Nonnull clsProperty1) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _clsProperty1), (id)clsProperty1, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_clsProperty2(Person * self, SEL _cmd) &#123; return (*(NSString * _Nonnull __strong *)((char *)self + OBJC_IVAR_$_Person$_clsProperty2)); &#125;</span><br><span class="line">static void _I_Person_setClsProperty2_(Person * self, SEL _cmd, NSString * _Nonnull clsProperty2) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _clsProperty2), (id)clsProperty2, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Person_extensionProperty(Person * self, SEL _cmd) &#123; return (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_Person$_extensionProperty)); &#125;</span><br><span class="line">static void _I_Person_setExtensionProperty_(Person * self, SEL _cmd, NSString *extensionProperty) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _extensionProperty), (id)extensionProperty, 0, 1); &#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">// @implementation Person (MyTest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_method1(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_method3(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_setClsProperty1_(Person * self, SEL _cmd, NSString *__strong  _Nonnull propertyValue) &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty1, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_MyTest_clsProperty1(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty1);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_setClsProperty3_(Person * self, SEL _cmd, NSString *__strong  _Nonnull propertyValue) &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty3, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_MyTest_clsProperty3(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty3);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">struct _prop_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _protocol_t;</span><br><span class="line"></span><br><span class="line">struct _objc_method &#123;</span><br><span class="line">struct objc_selector * _cmd;</span><br><span class="line">const char *method_type;</span><br><span class="line">void  *_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _protocol_t &#123;</span><br><span class="line">void * isa;  // NULL</span><br><span class="line">const char *protocol_name;</span><br><span class="line">const struct _protocol_list_t * protocol_list; // super protocols</span><br><span class="line">const struct method_list_t *instance_methods;</span><br><span class="line">const struct method_list_t *class_methods;</span><br><span class="line">const struct method_list_t *optionalInstanceMethods;</span><br><span class="line">const struct method_list_t *optionalClassMethods;</span><br><span class="line">const struct _prop_list_t * properties;</span><br><span class="line">const unsigned int size;  // sizeof(struct _protocol_t)</span><br><span class="line">const unsigned int flags;  // = 0</span><br><span class="line">const char ** extendedMethodTypes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _ivar_t &#123;</span><br><span class="line">unsigned long int *offset;  // pointer to ivar offset location</span><br><span class="line">const char *name;</span><br><span class="line">const char *type;</span><br><span class="line">unsigned int alignment;</span><br><span class="line">unsigned int  size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _class_ro_t &#123;</span><br><span class="line">unsigned int flags;</span><br><span class="line">unsigned int instanceStart;</span><br><span class="line">unsigned int instanceSize;</span><br><span class="line">unsigned int reserved;</span><br><span class="line">const unsigned char *ivarLayout;</span><br><span class="line">const char *name;</span><br><span class="line">const struct _method_list_t *baseMethods;</span><br><span class="line">const struct _objc_protocol_list *baseProtocols;</span><br><span class="line">const struct _ivar_list_t *ivars;</span><br><span class="line">const unsigned char *weakIvarLayout;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _class_t &#123;</span><br><span class="line">struct _class_t *isa;</span><br><span class="line">struct _class_t *superclass;</span><br><span class="line">void *cache;</span><br><span class="line">void *vtable;</span><br><span class="line">struct _class_ro_t *ro;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct objc_cache _objc_empty_cache;</span><br><span class="line">#pragma warning(disable:4273)</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$clsIvar __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, clsIvar);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_extensionIvar __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _extensionIvar);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_clsProperty1 __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _clsProperty1);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_clsProperty2 __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _clsProperty2);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_extensionProperty __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _extensionProperty);</span><br><span class="line"></span><br><span class="line">static struct /*_ivar_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count;</span><br><span class="line">struct _ivar_t ivar_list[5];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_ivar_t),</span><br><span class="line">5,</span><br><span class="line">&#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$clsIvar, &quot;clsIvar&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_extensionIvar, &quot;_extensionIvar&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_clsProperty1, &quot;_clsProperty1&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_clsProperty2, &quot;_clsProperty2&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_extensionProperty, &quot;_extensionProperty&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[8];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">8,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;method1&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_method1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;method2&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_method2&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty1&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_clsProperty1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty1:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setClsProperty1_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty2&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_clsProperty2&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty2:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setClsProperty2_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;extensionProperty&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_extensionProperty&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setExtensionProperty:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setExtensionProperty_&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[2];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">2,</span><br><span class="line">&#123;&#123;&quot;clsProperty1&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_clsProperty1&quot;&#125;,</span><br><span class="line">&#123;&quot;clsProperty2&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_clsProperty2&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct _class_ro_t _OBJC_METACLASS_RO_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">1, sizeof(struct _class_t), sizeof(struct _class_t), </span><br><span class="line">(unsigned int)0, </span><br><span class="line">0, </span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct _class_ro_t _OBJC_CLASS_RO_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">0, __OFFSETOFIVAR__(struct Person, clsIvar), sizeof(struct Person_IMPL), </span><br><span class="line">(unsigned int)0, </span><br><span class="line">0, </span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_Person,</span><br><span class="line">0, </span><br><span class="line">(const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_Person,</span><br><span class="line">0, </span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_METACLASS_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_data&quot;))) = &#123;</span><br><span class="line">0, // &amp;OBJC_METACLASS_$_NSObject,</span><br><span class="line">0, // &amp;OBJC_METACLASS_$_NSObject,</span><br><span class="line">0, // (void *)&amp;_objc_empty_cache,</span><br><span class="line">0, // unused, was (void *)&amp;_objc_empty_vtable,</span><br><span class="line">&amp;_OBJC_METACLASS_RO_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_NSObject;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_data&quot;))) = &#123;</span><br><span class="line">0, // &amp;OBJC_METACLASS_$_Person,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_NSObject,</span><br><span class="line">0, // (void *)&amp;_objc_empty_cache,</span><br><span class="line">0, // unused, was (void *)&amp;_objc_empty_vtable,</span><br><span class="line">&amp;_OBJC_CLASS_RO_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CLASS_SETUP_$_Person(void ) &#123;</span><br><span class="line">OBJC_METACLASS_$_Person.isa = &amp;OBJC_METACLASS_$_NSObject;</span><br><span class="line">OBJC_METACLASS_$_Person.superclass = &amp;OBJC_METACLASS_$_NSObject;</span><br><span class="line">OBJC_METACLASS_$_Person.cache = &amp;_objc_empty_cache;</span><br><span class="line">OBJC_CLASS_$_Person.isa = &amp;OBJC_METACLASS_$_Person;</span><br><span class="line">OBJC_CLASS_$_Person.superclass = &amp;OBJC_CLASS_$_NSObject;</span><br><span class="line">OBJC_CLASS_$_Person.cache = &amp;_objc_empty_cache;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CLASS_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CLASS_SETUP_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[6];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">6,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;method1&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_MyTest_method1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;method3&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_MyTest_method3&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty1:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_MyTest_setClsProperty1_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty1&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_MyTest_clsProperty1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty3:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_MyTest_setClsProperty3_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty3&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_MyTest_clsProperty3&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[2];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">2,</span><br><span class="line">&#123;&#123;&quot;clsProperty1&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;,</span><br><span class="line">&#123;&quot;clsProperty3&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </span><br><span class="line">&#123;</span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_Person,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_MyTest,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person_$_MyTest,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_Person_$_MyTest(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Person_$_MyTest.cls = &amp;OBJC_CLASS_$_Person;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_Person_$_MyTest,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Person_$_MyTest,</span><br><span class="line">&#125;;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过观察编译代码得知</p>
<ol>
<li>extension不是匿名Category，两者无关！extension是编译到类里的</li>
<li>使用category的方法需要引入对应的头文件，因为category是单独编译（如果把MyTest单独成一个文件，编译Person的时候是看不到MyTest相关代码的）</li>
<li>Category是运行期决议的，因为如果编译阶段就决议必然会有重名错误问题</li>
<li>category不能添加ivar, category_t数据结构里没有，编译后代码也没相关逻辑</li>
<li>所有类和category编译后都是struct结构体，在DATA段下有 <strong>objc_classlist 和 </strong>objc_catlist ，再通过<em>OBJC</em>$_CATEGORY_Person_$_MyTest.cls = &amp;OBJC_CLASS_$_Person;方式指明category和类的关系</li>
<li>category的h文件声明的属性如果没手动实现getter和setter方法会报错的原因就是编译器没自动生成（废话，但这次是从源码角度看的）</li>
</ol>
<h3 id="2-Category加载"><a href="#2-Category加载" class="headerlink" title="2 Category加载"></a>2 Category加载</h3><p>&emsp;&emsp;category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images中有对category的处理，源码太长了, 只贴把category的实例方法、协议以及属性添加到类上的代码,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Process this category.</span><br><span class="line">// First, register the category with its target class.</span><br><span class="line">// Then, rebuild the class&apos;s method lists (etc) if</span><br><span class="line">// the class is realized.</span><br><span class="line">bool classExists = NO;</span><br><span class="line">if (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">||  cat-&gt;instanceProperties)</span><br><span class="line">&#123;</span><br><span class="line">// addUnattachedCategoryForClass只是把类和category做一个关联映射</span><br><span class="line">addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">if (cls-&gt;isRealized()) &#123;</span><br><span class="line">remethodizeClass(cls);</span><br><span class="line">classExists = YES;</span><br><span class="line">&#125;</span><br><span class="line">if (PrintConnecting) &#123;</span><br><span class="line">_objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">cls-&gt;nameForLogging(), cat-&gt;name,</span><br><span class="line">classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//接下来是把category的类方法和协议添加到类的metaclass上的代码，逻辑一样参数改成cls-&gt;ISA()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;remethodizeClass最后会把Category的method、properties和protocols添加到cls里<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Attach method lists and properties and protocols from categories to a class.</span><br><span class="line">// Assumes the categories in cats are all loaded and sorted by load order, </span><br><span class="line">// oldest categories first.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是</p>
<ol>
<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</li>
</ol>
<h3 id="3-关联对象"><a href="#3-关联对象" class="headerlink" title="3 关联对象"></a>3 关联对象</h3><p>&emsp;&emsp;上面说到category没法添加ivar，而我们都知道可以通过关联对象的方式给category添加“实例变量”，它是怎么实现的？从runtime的objc_setAssociatedObject和objc_getAssociatedObject两个函数入手查看源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">_object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">// retain the new value (if any) outside the lock.</span><br><span class="line">ObjcAssociation old_association(0, nil);</span><br><span class="line">id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">&#123;</span><br><span class="line">AssociationsManager manager;</span><br><span class="line">AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">if (new_value) &#123;</span><br><span class="line">// break any existing association.</span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i != associations.end()) &#123;</span><br><span class="line">// secondary table exists</span><br><span class="line">ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123;</span><br><span class="line">old_association = j-&gt;second;</span><br><span class="line">j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// create the new association (first time).</span><br><span class="line">ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">associations[disguised_object] = refs;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">object-&gt;setHasAssociatedObjects();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// setting the association to nil breaks the association.</span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i !=  associations.end()) &#123;</span><br><span class="line">ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123;</span><br><span class="line">old_association = j-&gt;second;</span><br><span class="line">refs-&gt;erase(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// release the old value (outside of the lock).</span><br><span class="line">if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 不用看异常逻辑，代码很简单，直接copy美团的结论吧！所有的关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。</p>
<p>&emsp;&emsp; 对象的销毁逻辑里面也会清除关联对象</p>
<h3 id="4-其它问题"><a href="#4-其它问题" class="headerlink" title="4 其它问题"></a>4 其它问题</h3><h4 id="4-1-在类和category中都可以有-load方法，那么有两个问题："><a href="#4-1-在类和category中都可以有-load方法，那么有两个问题：" class="headerlink" title="4.1 在类和category中都可以有+load方法，那么有两个问题："></a>4.1 在类和category中都可以有+load方法，那么有两个问题：</h4><ol>
<li>在类的+load方法调用的时候，我们可以调用category中声明的方法么？可以调用，因为附加category到类的工作会先于+load方法的执行</li>
<li>这么些个+load方法，调用顺序是咋样的呢？ +load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的</li>
</ol>
<h4 id="4-2-怎么调用到原来类中被category覆盖掉的方法？"><a href="#4-2-怎么调用到原来类中被category覆盖掉的方法？" class="headerlink" title="4.2 怎么调用到原来类中被category覆盖掉的方法？"></a>4.2 怎么调用到原来类中被category覆盖掉的方法？</h4><p>&emsp;&emsp; 对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</p>
<h4 id="4-3-initialize方法什么时候调用"><a href="#4-3-initialize方法什么时候调用" class="headerlink" title="4.3 +initialize方法什么时候调用"></a>4.3 +initialize方法什么时候调用</h4><p>&emsp;&emsp; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次！initialize先初始化父类，之后再初始化子类。如果分类实现了+initialize，就覆盖类本身的+initialize调用</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>&emsp;&emsp;美团的<a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>，差距真的不是一点点！美团童鞋在15年就研究过相关问题了，我到17年才看到…</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Category和关联对象的使用</title>
    <url>/2015/08/02/Category%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><p>&emsp;&emsp;个人觉得Category才是OC最好玩的地方，如果不用category我们能怎么办？继承！对最好的方式就是继承，但继承的问题总所周知：层级关系复杂，使用不便，最主要的还是麻烦！category就很爽了！</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>&emsp;&emsp;分类就是对一个类的功能进行扩展,利用OC的动态运行时分配机制，Category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象类的子类就能为现有的类添加新的方法，可以为任何已经存在的类添加方法，包括系统框架UIKit等</p>
<ul>
<li>优点</li>
<li>分散功能，可将体积比较大的类拆分成几个小类，减少依赖提高复用率</li>
<li>方便代码的管理。将同类功能放到同一category里面是一个非常不错的选择，UIKit也是这么做的</li>
<li>减少继承，编码核心就是能用组合用组合，实在没办法再用继承</li>
<li>声明私有方法</li>
<li>缺点</li>
<li>同名方法有可能被覆盖掉！处理办法是增加前缀，注意OC里主要通过前缀来代替包，而且apple声称拥有任何两个字母的使用权，开发者最好使用三个或三个以上字母作为前缀</li>
<li>由于功能分散，非常考验命名</li>
<li>多人协作时，最好将同一个类的category放到同一文件夹，增加冲突可能性</li>
</ul>
<p>&emsp;&emsp;category和extension的区别</p>
<ul>
<li>extension固定为 ClassName()，外部引用不到 ； category需要起个好名字，外部能引用到</li>
<li>extension 能直接增加成员变量， category需要借助于关联对象</li>
<li>extension 只能在.m文件中，用于隐藏相关信息；category可单独一个文件</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>&emsp;&emsp;新建category: new file -&gt; Object-C File -&gt; File Type -&gt; Category</p>
<h5 id="1-实例：给NSMutableArray添加安全方法"><a href="#1-实例：给NSMutableArray添加安全方法" class="headerlink" title="1. 实例：给NSMutableArray添加安全方法"></a>1. 实例：给NSMutableArray添加安全方法</h5><ul>
<li><p>.h 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface NSMutableArray (Safely)</span><br><span class="line"></span><br><span class="line">- (void)addObjectSafely:(id)anObject;</span><br><span class="line">- (void)insertObjectSafely:(id)anObject atIndex:(NSUInteger)index;</span><br><span class="line">- (void)removeObjectAtIndexSafely:(NSUInteger)index;</span><br><span class="line">- (void)replaceObjectAtIndexSafely:(NSUInteger)index withObject:(id)anObject;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>.m文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation NSMutableArray (Safely)</span><br><span class="line"></span><br><span class="line">- (void)addObjectSafely:(id)anObject &#123;</span><br><span class="line">if (nil != anObject) &#123;</span><br><span class="line">[self addObject:anObject];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)insertObjectSafely:(id)anObject atIndex:(NSUInteger)index &#123;</span><br><span class="line">if (nil != anObject &amp;&amp; index &lt; [self count]) &#123;</span><br><span class="line">[self insertObject:anObject atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)removeObjectAtIndexSafely:(NSUInteger)index &#123;</span><br><span class="line">if (index &lt; [self count]) &#123;</span><br><span class="line">[self removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)replaceObjectAtIndexSafely:(NSUInteger)index withObject:(id)anObject &#123;</span><br><span class="line">if (nil != anObject &amp;&amp; index &lt; [self count]) &#123;</span><br><span class="line">[self replaceObjectAtIndex:index withObject:anObject];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-声明私有方法"><a href="#2-声明私有方法" class="headerlink" title="2. 声明私有方法"></a>2. 声明私有方法</h5><ul>
<li><p>原文件 MyClass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line">// 注意原来类中没有暴露somePrivateMethod方法</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">- (void)somePrivateMethod &#123;</span><br><span class="line">NSLog(@&quot;就是不想让你用！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>category暴露私有方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// .h文件</span><br><span class="line">@interface MyClass (Public)</span><br><span class="line">// 暴露somePrivateMethod方法，注意不要在category的m文件实现。实现就覆盖了</span><br><span class="line">- (void)somePrivateMethod;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">@implementation MyClass (Public)</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用私有方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 注意声明私有方法时必须两个都要引入</span><br><span class="line">#import &quot;MyClass.h&quot;</span><br><span class="line">#import &quot;MyClass+Public.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">MyClass *my = [[MyClass alloc] init];</span><br><span class="line">[my somePrivateMethod];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h3><p>&emsp;&emsp;为什么把关联对象放到这里写？因为关联对象一般都在category里；更因为category可以给原类增加方法，关联对象正好可以给原来增加实例变量，参考：<a href="https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category" target="_blank" rel="noopener">https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category</a></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul>
<li><p>.h文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MyClass (Public)</span><br><span class="line"></span><br><span class="line">@property (copy, nonatomic) NSString *someProperty;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>.m文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 注意引入runtime</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *kAssociatedObjectKey = @&quot;kAssociatedObjectKey&quot;;</span><br><span class="line"></span><br><span class="line">@implementation MyClass (Public)</span><br><span class="line"></span><br><span class="line">// setter和getter必须都要写</span><br><span class="line">// setter方法</span><br><span class="line">- (void)setSomeProperty:(NSString*)propertyValue &#123;</span><br><span class="line">/*</span><br><span class="line">OBJC_ASSOCIATION_ASSIGN            //@property(assign)。</span><br><span class="line">OBJC_ASSOCIATION_RETAIN_NONATOMIC  //@property(strong, nonatomic)。</span><br><span class="line">OBJC_ASSOCIATION_COPY_NONATOMIC    //@property(copy, nonatomic)。</span><br><span class="line">OBJC_ASSOCIATION_RETAIN            //@property(strong,atomic)。</span><br><span class="line">OBJC_ASSOCIATION_COPY              //@property(copy, atomic)。</span><br><span class="line">*/</span><br><span class="line">// 注意propertyValue只能给类，int、NSInterger、Bool时需要转成NSNumber</span><br><span class="line">objc_setAssociatedObject(self, &amp;kAssociatedObjectKey, propertyValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// getter</span><br><span class="line">- (NSString *)someProperty &#123;</span><br><span class="line">// int、NSInterger、Bool时需要将NSNumber转成对应类型</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kAssociatedObjectKey);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Clang笔记</title>
    <url>/2017/08/31/Clang%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;前一段时间学了下LLVM的知识，LLVM非常强大，确实很好玩！但学起来确实挺多挺枯燥的，也没发现有什么用处（其实就是啃不动英文文档了），过了刚开始的冲劲也就停滞不前了，平时开发还是Clang用的稍微多一点，今天就水水clang吧</p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>&emsp;&emsp;Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。<a href="http://clang.llvm.org/get_started.html" target="_blank" rel="noopener">官方入门</a>,详细内容参考：<a href="http://clang.llvm.org" target="_blank" rel="noopener">官网</a> </p>
<p>&emsp;&emsp;Clang是基于库的，在Clang的官方文档<a href="http://clang.llvm.org/docs/InternalsManual.html" target="_blank" rel="noopener">“Clang” CFE Internals Manual</a>中，对Clang内部的介绍也是依据库来进行分类的。</p>
<h4 id="1-1-AST"><a href="#1-1-AST" class="headerlink" title="1.1 AST"></a>1.1 AST</h4><p>&emsp;&emsp;一般编译器有以下工作步骤：</p>
<ul>
<li>词法分析（Lexical analysis）：此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符流进行扫描然后根据构词规则识别 单词（Token），完成这个任务的组件是 词法分析器（Lexical analyzer，简称Lexer），也叫 扫描器（Scanner）；</li>
<li>语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser）；</li>
<li>目标码生成： 此阶段编译器会遍历上一步生成的抽象语法树，然后为每个节点生成 机器 / 字节码。</li>
<li>编译器完成编译后，由链接器（Linker）将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。</li>
</ul>
<p>&emsp;&emsp;关于Clang AST，有一个<a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">官方文档</a> 。基于AST可以进行程序转换，现在Clang下面已经有一些额外的工具：比如clang-modernize实现的就是对C+ +程序中可以使用C ++ 11的地方进行转换，转换成在这些地方使用C++11特性的程序，等于直接在程序上进行的修改，是一个source-to-source的转换工具。</p>
<h4 id="1-2-libclang"><a href="#1-2-libclang" class="headerlink" title="1.2 libclang"></a>1.2 libclang</h4><p>&emsp;&emsp;现在的Clang，不仅仅是一个编译器前端，同时也可以作为一个库使用。作为一个库使用的时候，可以用它去分析C/C++/ObjectC语言代码，可以分析源码得到AST，也可以获取已经分析好的AST，也可以遍历AST，还可以获取AST中基本元素的物理源码位置。这就是libclang。</p>
<p>&emsp;&emsp;其它库介绍：</p>
<ul>
<li>LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。</li>
<li>The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。</li>
<li>The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。</li>
<li>Precompiled Headers - Clang 支持预编译 headers 的两个实现。</li>
<li>The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。</li>
<li>The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。</li>
<li>The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。</li>
<li>The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。</li>
</ul>
<h4 id="1-3-Clang-driver"><a href="#1-3-Clang-driver" class="headerlink" title="1.3 Clang driver"></a>1.3 Clang driver</h4><p>&emsp;&emsp;Clang driver是一个驱动，一个包含编译全部阶段的驱动，不同于前端Clang，也不同于编译器Clang。命令行使用的“clang”其实并不是前端Clang，而是指的是Clang driver；在命令行使用的“Clang cc1”也指的不是前端Clang，而指的是Clang编译器，这其中不仅包含了前端Clang，还包含了LLVM Core部分等。Clang driver不仅仅调用了前端Clang，同时还调用了LLVM Core</p>
<h3 id="Clang命令（大小写敏感）"><a href="#Clang命令（大小写敏感）" class="headerlink" title="Clang命令（大小写敏感）"></a>Clang命令（大小写敏感）</h3><h4 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h4><p>&emsp;&emsp;最重要的命令是什么？我个人认为，无论什么脚本语言，最重要的命令永远是<strong>帮助</strong>：clang –help。Clang命令高达700+，这里仅介绍常用的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USAGE: clang [options] &lt;inputs&gt;</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">-###                    Print (but do not run) the commands to run for this compilation 查看操作内部命令，一般用于分析流程</span><br><span class="line">--analyze               Run the static analyzer 运行静态代码检查器</span><br><span class="line">-B &lt;dir&gt;                Add &lt;dir&gt; to search path for binaries and object files used implicitly 将&lt;dir&gt;添加到搜索路径</span><br><span class="line">-CC                     Include comments from within macros in preprocessed output 在预处理的输出中包含宏在内的注释，非常重要</span><br><span class="line">--config &lt;value&gt;        Specifies configuration file  配置文件</span><br><span class="line">-C                      Include comments in preprocessed output 在预处理的输出中包含注释，非常重要</span><br><span class="line">-c                      Only run preprocess, compile, and assemble steps 仅运行预处理、编译和组装步骤</span><br><span class="line">-emit-ast               Emit Clang AST files for source inputs</span><br><span class="line">-E                      Only run the preprocessor 只运行预处理</span><br><span class="line">-fblocks                Enable the &apos;blocks&apos; language feature</span><br><span class="line">-fcolor-diagnostics     Use colors in diagnostics 诊断中可以使用颜色</span><br><span class="line">-fcxx-exceptions        Enable C++ exceptions  启用C++类型异常</span><br><span class="line">-fexceptions            Enable support for exception handling 启用异常</span><br><span class="line">-fmodules               Enable the &apos;modules&apos; language feature 启用“模块”语言功能</span><br><span class="line">-fplugin=&lt;dsopath&gt;      Load the named plugin (dynamic shared object) 启用插件</span><br><span class="line">-ObjC++                 Treat source input files as Objective-C++ inputs 把源文件当做OC++</span><br><span class="line">-ObjC                   Treat source input files as Objective-C inputs 把源文件当做OC</span><br><span class="line">-g                      Generate source-level debug information 生成完整的调试信息。</span><br><span class="line">-o &lt;file&gt;               Write output to &lt;file&gt; 输出文件</span><br><span class="line">-print-file-name=&lt;file&gt; Print the full library path of &lt;file&gt; 输出文件所在路径</span><br><span class="line">-print-ivar-layout      Enable Objective-C Ivar layout bitmap print trace 启用OC的ivar布局</span><br><span class="line">-pthread                Support POSIX threads in generated code 在生成的代码中支持POSIX线程</span><br><span class="line">-rewrite-objc           Rewrite Objective-C source to C++ 将OC重写成C++</span><br><span class="line">-S                      Only run preprocess and compilation steps 仅运行预处理和编译步骤</span><br><span class="line">--target=&lt;value&gt;        Generate code for the given target 为给定目标生成代码</span><br><span class="line">-w                      Suppress all warnings 禁用警告</span><br><span class="line">-Xclang &lt;arg&gt;           Pass &lt;arg&gt; to the clang compiler 向clang编译器传递参数</span><br></pre></td></tr></table></figure></p>
<h4 id="常用组合命令"><a href="#常用组合命令" class="headerlink" title="常用组合命令"></a>常用组合命令</h4><ul>
<li><p>查看编译的几个阶段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -ccc-print-phases main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看预编译过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -E main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看操作内部命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -### main.m -o main</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写成C++，<a href="https://blog.csdn.net/majiakun1/article/details/52842010" target="_blank" rel="noopener">报错</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fobjc-arc -framework Foundation HelloWord.m -o HelloWord</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">-x 编译语言比如objective-c</span><br><span class="line">-arch 编译的架构，比如arm7</span><br><span class="line">-f 以-f开头的。</span><br><span class="line">-W 以-W开头的，可以通过这些定制编译警告</span><br><span class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</span><br><span class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</span><br><span class="line">-I 把编译信息写入指定的辅助文件</span><br><span class="line">-F 需要的Framework</span><br><span class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</span><br><span class="line">-o 编译结果</span><br><span class="line">*/</span><br><span class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://clang.llvm.org" target="_blank" rel="noopener">官网</a> </li>
<li><a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">更多clang工具</a></li>
<li><a href="https://blog.csdn.net/snsn1984/column/info/hacking-clang" target="_blank" rel="noopener">深入研究Clang</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPod问题</title>
    <url>/2016/10/16/CocoaPod%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天pod install 遇到 Unable to add a source with url问题，着实折腾了半天才弄好！想想cocoapod遇到的坑也有不少，在此记录一下吧！最最主要的是没水过cocoapod，哈哈，一举多得！</p>
<h4 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h4><ul>
<li><a href="https://cocoapods.org" target="_blank" rel="noopener">Cocoapod官网</a></li>
<li><a href="https://guides.cocoapods.org/syntax/podfile.html" target="_blank" rel="noopener">Podfile语法</a></li>
</ul>
<h4 id="cocoapod安装问题"><a href="#cocoapod安装问题" class="headerlink" title="cocoapod安装问题"></a>cocoapod安装问题</h4><ul>
<li>升级ruby：sudo gem update –system</li>
<li><p>源：gen sources 后接 -l 查看命令  –remove  移除命令   –add 添加命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources --remove https://rubygems.org/</span><br><span class="line">gem sources -a https://gems.ruby-china.org/</span><br><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装： sudo gem install cocoapods 当出现not permitted也就是没权限的时候，可以指定安装到bin下目录： sudo gem install -n /usr/local/bin cocoapods </p>
</li>
<li>pod setup 命令的速度太慢：直接去  <a href="https://github.com/CocoaPods/Specs/archive/master.zip" target="_blank" rel="noopener">https://github.com/CocoaPods/Specs/archive/master.zip</a> 然后解压缩到~/.cocoapods/repos/master</li>
</ul>
<h4 id="pod-install-遇到-Unable-to-add-a-source-with-url问题"><a href="#pod-install-遇到-Unable-to-add-a-source-with-url问题" class="headerlink" title="pod install 遇到 Unable to add a source with url问题"></a>pod install 遇到 Unable to add a source with url问题</h4><ul>
<li>多个xcode的话，需要xcode -&gt; preferences -&gt; locations -&gt; commond line tools 指定xcode</li>
<li>pod的问题，最好卸载重装，卸载命令：witch pod 然后用 sudo gem uninstall 卸载所有cocoapod相关的</li>
<li>权限的问题，SSH是否配置了？用户名等config（在~/.ssh目录下）是否配对了？多个host的话需要在config中多次指定</li>
<li>xcode-select -–install  安装XcodeCommandLineTools</li>
<li>使用brew安装carthage时碰到报错  Error: Permission denied @ dir_s_mkdir - /usr/local/Frameworks   处理办法   sudo mkdir /usr/local/Frameworks；sudo chown $(whoami):admin /usr/local/Frameworks</li>
</ul>
<h4 id="pod-repo-update是啥？"><a href="#pod-repo-update是啥？" class="headerlink" title="pod repo update是啥？"></a>pod repo update是啥？</h4><ul>
<li>意思是本地没有相应版本的库，需要更新本地库索引。默认情况下，执行pod install不会自动执行pod repo update命令</li>
</ul>
<h4 id="pod-install-pod-update"><a href="#pod-install-pod-update" class="headerlink" title="pod install ? pod update ?"></a>pod install ? pod update ?</h4><ul>
<li>pod update 库名 来更新某个特定的库，或公司内部的库</li>
<li>pod install 第一次使用或新增库</li>
</ul>
<h4 id="新建Podfile文件"><a href="#新建Podfile文件" class="headerlink" title="新建Podfile文件"></a>新建Podfile文件</h4><ul>
<li>在终端中使用pod init命令可以直接产生一个Podfile文件</li>
</ul>
<h4 id="bin目录权限问题"><a href="#bin目录权限问题" class="headerlink" title="bin目录权限问题"></a>bin目录权限问题</h4><ul>
<li>一般情况：sudo chmod -R 777 你要修改文件上层目录的路径</li>
<li>但如果电脑启用了SIP（System Integrity Protection），增加了rootless机制</li>
<li>A，重启，过程中按住 command+R，进入保护模式</li>
<li>B，打开terminal终端，输入 csrutil disable</li>
<li>C，再次重启，即可对 usr/bin 目录下文件进行修改</li>
<li>如果要恢复保护机制，重新进入保护模式，输入 csrutil enable</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreGraphics1：基础</title>
    <url>/2016/07/17/CoreGraphics1%EF%BC%9A%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="序：CoreGraphics-与-Quartz-2D"><a href="#序：CoreGraphics-与-Quartz-2D" class="headerlink" title="序：CoreGraphics 与 Quartz 2D"></a>序：CoreGraphics 与 Quartz 2D</h3><ul>
<li>Core Graphic框架是一组基于C的API，UIKit用Core Graphics将“显示”绘制在屏幕上</li>
<li>Quartz 2D API是Core Graphic框架的一部分，因此其中的很多数据类型和方法都是以CG开头的。会经常见到Quartz 2D（Quartz）和Core Graphics两个术语交互使用！Quartz 2D与分辨率和设备无关，因此在使用Quartz 2D绘图时，无需考虑最终绘图的目标设备</li>
<li>Core Graphic是线程安全的，可以异步绘制回调刷新</li>
<li><a href="https://developer.apple.com/library/archive/samplecode/QuartzDemo/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007531" target="_blank" rel="noopener">官方dome</a></li>
</ul>
<h3 id="1-Quartz-2D数据类型"><a href="#1-Quartz-2D数据类型" class="headerlink" title="1 Quartz 2D数据类型"></a>1 Quartz 2D数据类型</h3><h4 id="1-1-常用类型解释"><a href="#1-1-常用类型解释" class="headerlink" title="1.1 常用类型解释"></a>1.1 常用类型解释</h4><ul>
<li>CGPathRef：用于向量图，可创建路径，并进行填充或描画(stroke)</li>
<li>CGImageRef：用于表示bitmap图像和基于采样数据的bitmap图像遮罩</li>
<li>CGLayerRef：用于表示可用于重复绘制(如背景)和幕后 (offscreen)绘制的绘画层</li>
<li>CGShadingRef、CGGradientRef：用于绘制渐变</li>
<li>CGFunctionRef：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型</li>
<li>CGColorRef, CGColorSpaceRef：一般用[UIColor redColor].CGColor之类</li>
<li>CGImageSourceRef,CGImageDestinationRef：用于在Quartz中移入移出数据</li>
<li>CGFontRef：用于绘制文本</li>
<li>CGPatternRef：用于重绘图</li>
</ul>
<h4 id="1-2-内存管理"><a href="#1-2-内存管理" class="headerlink" title="1.2 内存管理"></a>1.2 内存管理</h4><ul>
<li>谁开辟谁释放（类似MRC原则），使用含有”Create”或“Copy”单词的函数获取一个对象，当使用完后必须释放 xxxRelease。其它情况不用释放</li>
<li>也可以用过 retain和release 来持有一个对象</li>
<li>不能传NULL值来释放，必须通过对应的release方法</li>
</ul>
<h3 id="2-上下文"><a href="#2-上下文" class="headerlink" title="2 上下文"></a>2 上下文</h3><h4 id="2-1-注意事项"><a href="#2-1-注意事项" class="headerlink" title="2.1 注意事项"></a>2.1 注意事项</h4><ul>
<li>Quartz提供了 5 种类型的 Graphics Context。Bitmap Graphics Context、PDF Graphics Context、Window Graphics Context、Layer Context、Post Graphics Context。</li>
<li>使用Core Graphics之前需要指定一个用于绘图的图形上下文（CGContextRef）</li>
<li>通过drawRect、drawRect: inContext 可用UIGraphicsGetCurrentContext获得当前UIView的绘图上下文，直接绘图</li>
<li>使用UIGraphicsBeginImageContextWithOptions时，不仅创建了一个绘图上下文，并且该上下文也属于当前上下文</li>
<li>回调方法所持有的context：参数并不会让任何上下文成为当前图形上下文。只是引用了一下。</li>
<li>如果想持有一个别人的context时，必须通过UIGraphicsPushContext 将该上下文转化为当前上下文，最后通过UIGraphicsPopContext恢复上下文环境</li>
</ul>
<h4 id="2-2-获取上下文的方式"><a href="#2-2-获取上下文的方式" class="headerlink" title="2.2 获取上下文的方式"></a>2.2 获取上下文的方式</h4><ul>
<li>drawRect获取</li>
<li>不应该手动调用drawRect：方法</li>
<li>在UIView子类的drawRect：方法中无需调用super</li>
<li>如果你想调用drawRect：方法更新视图，只需发送setNeedsDisplay方法</li>
<li>不要覆盖drawRect：例，在UIImageView子类中覆盖drawRect：方法是不合法的，你将得不到你绘制的图形。</li>
<li><p>当视图的backgroundColor为nil并且opaque属性为YES，视图的背景颜色就会变成黑色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void) drawRect: (CGRect) rect &#123; </span><br><span class="line">CGContextRef con = UIGraphicsGetCurrentContext();// 用不到可不获取，例如直接用UIBezierPath画个圈</span><br><span class="line"></span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIGraphicsBeginImageContextWithOptions</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// size区域大小，opaque是否透明，scale屏幕分辨率, 0表示 [UIScreen mainScreen].scale</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0); </span><br><span class="line">// UIGraphicsBeginImageContext(CGSize size);方法相当于opaque参数为NO,scale为1.0。</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();// 用不到可不获取，例如直接用UIBezierPath画个圈</span><br><span class="line"></span><br><span class="line">// do something</span><br><span class="line"></span><br><span class="line">// only return a 8-bit per channel context in the DeviceRGB color space.</span><br><span class="line">UIImage* im = UIGraphicsGetImageFromCurrentImageContext(); </span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p>drawLayer:inContext：没用过</p>
</li>
</ul>
<h4 id="2-3-坐标问题"><a href="#2-3-坐标问题" class="headerlink" title="2.3 坐标问题"></a>2.3 坐标问题</h4><ul>
<li>Core Graphics源于Mac OS X系统，在Mac OS X中Y轴是朝上的，而在iOS中Y轴是朝下的，正好相反！需用CTM转换到目标设备</li>
<li>以下情况不要CTM，不需要转换</li>
<li>别人给你的，即当做参数传过来的，包括系统创建的</li>
<li>使用 UIGraphicsBeginImageContextWithOptions 返回的绘图</li>
<li>[UIImage imageWithCGImage:];返回的绘图</li>
</ul>
<h3 id="3-绘图"><a href="#3-绘图" class="headerlink" title="3 绘图"></a>3 绘图</h3><h4 id="3-1-一般绘图模式"><a href="#3-1-一般绘图模式" class="headerlink" title="3.1 一般绘图模式"></a>3.1 一般绘图模式</h4><ul>
<li>绘图的一般过程是先设定好图形上下文参数，然后绘图。比方说，要画一根红线，接着画一根蓝线。那么首先需要将上下文的线条颜色属性设定为为红色，然后画红线；接着设置上下文的线条颜色属性为蓝色，再画出蓝线。表面上看,红线和蓝线是分开的，但事实上，在你画每一条线时，线条颜色却是整个上下文的属性</li>
<li>在绘图之前调用CGContextSaveGState函数保存当前状态，接着根据需要设置某些上下文状态，然后绘图，最后调用CGContextRestoreGState函数将当前状态恢复到绘图之前的状态。要注意的是，CGContextSaveGState函数和CGContextRestoreGState函数必须成对出现，否则绘图很可能出现意想不到的错误，这里有一个简单的做法避免这种情况。代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSaveGState(ctx);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">// 绘图代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGContextRestoreGState(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-path"><a href="#3-2-path" class="headerlink" title="3.2 path"></a>3.2 path</h4><ul>
<li><p>设置起点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextMoveToPoint(context, 0, 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加几条直线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextAddLineToPoint(context, 200, 0);</span><br><span class="line">CGPoint point2 = CGPointMake(200, 200);</span><br><span class="line">CGPoint point3 = CGPointMake(200, 0);</span><br><span class="line">CGPoint points[2] = &#123;point2, point3&#125;;</span><br><span class="line">CGContextAddLines(context, points, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置虚线样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGFloat dashWidth = 5; // 线宽度</span><br><span class="line">CGFloat spaceWidth = 3; // 间隔宽度</span><br><span class="line">CGFloat lengths[2] = &#123;dashWidth, spaceWidth&#125;;</span><br><span class="line">// phase表示在第一个虚线绘制的时候跳过多少个点, lengths 绘制规则，count 表示lengths数组count</span><br><span class="line">CGContextSetLineDash(context, 0, lengths, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>画圆形或矩形</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 画一个椭圆或圆形</span><br><span class="line">CGContextAddEllipseInRect(context, CGRectMake(0, 0, 100, 200));</span><br><span class="line">// 画一个矩形</span><br><span class="line">CGContextAddRect(context, CGRectMake(200, 400, 100, 200));</span><br><span class="line">// CGContextAddRects</span><br></pre></td></tr></table></figure>
</li>
<li><p>画圆弧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 根据圆形和弧度画弧线</span><br><span class="line">CGContextAddArc(context, 200, 200, 100, 0, M_PI_2, 0);</span><br><span class="line">// 当前点到(x1, y1)，当前点到(x2, y2)的两条切线 和 圆弧半径画弧线</span><br><span class="line">CGContextAddArcToPoint(context, 200, 400, 400, 400, 100);</span><br></pre></td></tr></table></figure>
</li>
<li><p>画贝塞尔曲线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过一个控点画贝塞尔曲线</span><br><span class="line">CGContextAddQuadCurveToPoint(context, 0, 100, 200, 100);</span><br><span class="line">// 通过两个控点画贝塞尔曲线</span><br><span class="line">CGContextAddCurveToPoint(context, 100, 400, 200, 300, 100, 200);</span><br></pre></td></tr></table></figure>
</li>
<li><p>画虚线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGFloat dashWidth = 5; // 线宽度</span><br><span class="line">CGFloat spaceWidth = 3; // 间隔宽度</span><br><span class="line">CGFloat lengths[2] = &#123;dashWidth, spaceWidth&#125;;</span><br><span class="line">// phase表示在第一个虚线绘制的时候跳过多少个点, lengths 绘制规则，count 表示lengths数组count</span><br><span class="line">CGContextSetLineDash(context, 0, lengths, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设置线宽</span><br><span class="line">CGContextSetLineWidth(context, 20);</span><br><span class="line"></span><br><span class="line">// 设置线帽，即线条的起始点样式</span><br><span class="line">//    kCGLineCapButt：无端点</span><br><span class="line">//    kCGLineCapRound：圆形端点</span><br><span class="line">//    kCGLineCapSquare：方形端点（样式上和kCGLineCapButt是一样的，但是比kCGLineCapButt长一点）</span><br><span class="line">CGContextSetLineCap(context, kCGLineCapButt);</span><br><span class="line"></span><br><span class="line">//设置线条的拐角的样式</span><br><span class="line">//    kCGLineJoinMiter, 尖角</span><br><span class="line">//    kCGLineJoinRound, 圆角</span><br><span class="line">//    kCGLineJoinBevel  缺角</span><br><span class="line">CGContextSetLineJoin(context, kCGLineJoinRound);</span><br><span class="line">//</span><br><span class="line">//    kCGLineJoinMiter 下最大倾斜长度，边角的角度越小，斜接长度就会越大</span><br><span class="line">CGContextSetMiterLimit(context, 10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 线条颜色(描边)</span><br><span class="line">// CGContextSetRGBStrokeColor、CGContextSetGrayStrokeColor没用过</span><br><span class="line">CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);</span><br><span class="line">// 填充颜色</span><br><span class="line">// CGContextSetRGBFillColor、CGContextSetGrayFillColor</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor yellowColor].CGColor);</span><br><span class="line">// 设置颜色混合模式</span><br><span class="line">CGContextSetBlendMode(context, kCGBlendModeNormal);</span><br></pre></td></tr></table></figure>
</li>
<li><p>透明度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 整体透明度</span><br><span class="line">CGContextSetAlpha(context, 0.5);</span><br><span class="line">// 擦除一个区域内的所有已存在的绘图,上下文颜色如果不是透明的，剪切区域显示黑色，如果是透明的，则显示透明的</span><br><span class="line">CGContextClearRect(context, CGRectMake(10, 10, 100, 200));</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充路径规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//    使用奇偶规则填充当前路径,等于CGContextDrawPath(context, kCGPathFill);</span><br><span class="line">//    CGContextEOFillPath(context);</span><br><span class="line">//    使用非零绕数规则填充当前路径</span><br><span class="line">//    CGContextFillPath(context);</span><br><span class="line">// 注意：CGContextStrokePath(context) 和 CGContextFillPath(context) 不能同时使用。</span><br><span class="line">CGContextStrokePath(context);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">kCGPathFill 填充路径</span><br><span class="line">kCGPathEOFill 使用奇偶规则填充路径</span><br><span class="line">kCGPathStroke 描边路径</span><br><span class="line">kCGPathFillStroke 填充并描边路径</span><br><span class="line">kCGPathEOFillStroke 使用奇偶规则填充并描边</span><br><span class="line">*/</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭合路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 闭合路径，如果你打算填充一段路径，那么就不需要使用该命令，因为该命令会被自动调用。</span><br><span class="line">CGContextClosePath(context); </span><br><span class="line">// 当画完一部分，需抬起画笔画另一部分的时候（例：同心圆）需</span><br><span class="line">CGContextBeginPath(context);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后别忘了释放内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// xxxRelease</span><br><span class="line">CGColorRelease(color);</span><br><span class="line">CGFontRelease(cgFont);</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreImage基本用法</title>
    <url>/2017/01/05/CoreImage%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1 基础"></a>1 基础</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185" target="_blank" rel="noopener">Core Image</a>，允许编写自定义滤镜与系统滤镜（或滤镜链）来处理静止和视频图像</li>
<li>一个滤镜是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。</li>
<li>一个滤镜图表是一个链接在一起的滤镜链条，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。我们将在下面看到如何连接滤镜来创建一个复古的拍照效果。</li>
<li>当多个滤镜连接成一个滤镜图表，Core Image 便把内核串在一起来构建一个可在 GPU 上运行的高效程序。只要有可能，Core Image 都会把工作延迟。通常情况下，直到滤镜图表的最后一个滤镜的输出被请求之前都不会发生分配或处理。</li>
</ul>
<h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><ul>
<li>CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。</li>
<li>CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。系统提供的<a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html" target="_blank" rel="noopener">滤镜列表</a></li>
<li>CIContext 表示上下文，CoreImage的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。建立一个上下文是非常昂贵的，所以你会经常想创建一个反复使用的上下文。接下来我们将看到如何创建一个上下文</li>
</ul>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h3><ul>
<li><p>基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIImage *)filterImage:(UIImage *)originImage filterName:(NSString *)filterName &#123;</span><br><span class="line">/*</span><br><span class="line">注意： 直接使用originImage.CIImage获取CIImage可能为nil</span><br><span class="line">@property(nullable,nonatomic,readonly) CIImage *CIImage NS_AVAILABLE_IOS(5_0); // returns underlying CIImage or nil if CGImageRef based</span><br><span class="line">*/</span><br><span class="line">CIImage *ciImage = [[CIImage alloc] initWithImage:originImage];</span><br><span class="line">if (!ciImage) &#123;</span><br><span class="line">return originImage;</span><br><span class="line">&#125;</span><br><span class="line">// 创建滤镜</span><br><span class="line">CIFilter *filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey, ciImage, nil];</span><br><span class="line">// 设置相关参数</span><br><span class="line">[filter setValue:@(10.f) forKey:@&quot;inputRadius&quot;];</span><br><span class="line">// 渲染并输出CIImage</span><br><span class="line">CIImage *outputImage = [filter outputImage];</span><br><span class="line">// 建立一个上下文是非常昂贵的，最好设成属性</span><br><span class="line">CIContext *context = [CIContext contextWithOptions:nil];</span><br><span class="line">/*</span><br><span class="line">注意： 直接 用UIImage *image = [UIImage imageWithCGImage:outputImage]; 也是可以的，</span><br><span class="line">但这种方法有点让人郁闷：如果你试图在一个 UIImageView 上显示这样的图像，其 contentMode 属性将被忽略。</span><br><span class="line">使用过渡的 CGImage 则需要一个额外的步骤，但可以省去这一烦恼。</span><br><span class="line">*/</span><br><span class="line">CGImageRef cgImage = [context createCGImage:outputImage fromRect:[outputImage extent]];</span><br><span class="line">UIImage *image = [UIImage imageWithCGImage:cgImage];</span><br><span class="line">// CIImage、CIFilter和CIContext都是继承NSObject，故只需要手动release CGImage</span><br><span class="line">CGImageRelease(cgImage);</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滤镜太多记不住？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html</span><br><span class="line">按效果分类：</span><br><span class="line">kCICategoryDistortionEffect 扭曲效果，比如bump、旋转、hole</span><br><span class="line">kCICategoryGeometryAdjustment 几何开着调整，比如仿射变换、平切、透视转换</span><br><span class="line">kCICategoryCompositeOperation 合并，比如源覆盖（source over）、最小化、源在顶（source atop）、色彩混合模式</span><br><span class="line">kCICategoryHalftoneEffect Halftone效果，比如screen、line screen、hatched</span><br><span class="line">kCICategoryColorAdjustment 色彩调整，比如伽马调整、白点调整、曝光</span><br><span class="line">kCICategoryColorEffect 色彩效果，比如色调调整、posterize</span><br><span class="line">kCICategoryTransition 图像间转换，比如dissolve、disintegrate with mask、swipe</span><br><span class="line">kCICategoryTileEffect 瓦片效果，比如parallelogram、triangle</span><br><span class="line">kCICategoryGenerator 图像生成器，比如stripes、constant color、checkerboard</span><br><span class="line">kCICategoryGradient 渐变，比如轴向渐变、仿射渐变、高斯渐变</span><br><span class="line">kCICategoryStylize 风格化，比如像素化、水晶化</span><br><span class="line">kCICategorySharpen 锐化、发光</span><br><span class="line">kCICategoryBlur 模糊，比如高斯模糊、焦点模糊、运动模糊</span><br><span class="line"></span><br><span class="line">按使用场景分类：</span><br><span class="line">kCICategoryStillImage 用于静态图像</span><br><span class="line">kCICategoryVideo 用于视频</span><br><span class="line">kCICategoryInterlaced 用于交错图像</span><br><span class="line">kCICategoryNonSquarePixels 用于非矩形像素</span><br><span class="line">kCICategoryHighDynamicRange 用于HDR</span><br><span class="line">*/</span><br><span class="line">NSArray *names = [CIFilter filterNamesInCategory:kCICategoryBuiltIn];</span><br></pre></td></tr></table></figure>
</li>
<li><p>滤镜参数在哪里？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 特别注意入参的数据类型，通过KVC设置的，没类型检查，别弄错了</span><br><span class="line">CIFilter *filter = [CIFilter filterWithName:@&quot;CIMotionBlur&quot;];</span><br><span class="line">NSLog(@&quot;输入参数 : %@&quot;,[filter inputKeys]);</span><br><span class="line">NSLog(@&quot;输入参数的详细信息 : %@&quot;,[filter attributes]);</span><br><span class="line">NSLog(@&quot;输出参数 : %@&quot;,[filter outputKeys]);</span><br><span class="line">//    输入参数的详细信息</span><br><span class="line">//    &#123;</span><br><span class="line">//        &quot;CIAttributeFilterAvailable_Mac&quot; = &quot;10.4&quot;;</span><br><span class="line">//        &quot;CIAttributeFilterAvailable_iOS&quot; = &quot;8.3&quot;;</span><br><span class="line">//        CIAttributeFilterCategories =     (</span><br><span class="line">//                                           CICategoryBlur,</span><br><span class="line">//                                           CICategoryStillImage,</span><br><span class="line">//                                           CICategoryVideo,</span><br><span class="line">//                                           CICategoryBuiltIn</span><br><span class="line">//                                           );</span><br><span class="line">//        CIAttributeFilterDisplayName = &quot;Motion Blur&quot;;</span><br><span class="line">//        CIAttributeFilterName = CIMotionBlur;</span><br><span class="line">//        CIAttributeReferenceDocumentation = &quot;http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur&quot;;</span><br><span class="line">//        inputAngle =     &#123;</span><br><span class="line">//            CIAttributeClass = NSNumber;</span><br><span class="line">//            CIAttributeDefault = 0;</span><br><span class="line">//            CIAttributeDescription = &quot;The angle of the motion determines which direction the blur smears.&quot;;</span><br><span class="line">//            CIAttributeDisplayName = Angle;</span><br><span class="line">//            CIAttributeIdentity = 0;</span><br><span class="line">//            CIAttributeSliderMax = &quot;3.141592653589793&quot;;</span><br><span class="line">//            CIAttributeSliderMin = &quot;-3.141592653589793&quot;;</span><br><span class="line">//            CIAttributeType = CIAttributeTypeAngle;</span><br><span class="line">//        &#125;;</span><br><span class="line">//        inputImage =     &#123;</span><br><span class="line">//            CIAttributeClass = CIImage;</span><br><span class="line">//            CIAttributeDescription = &quot;The image to use as an input image. For filters that also use a background image, this is the foreground image.&quot;;</span><br><span class="line">//            CIAttributeDisplayName = Image;</span><br><span class="line">//            CIAttributeType = CIAttributeTypeImage;</span><br><span class="line">//        &#125;;</span><br><span class="line">//        inputRadius =     &#123;</span><br><span class="line">//            CIAttributeClass = NSNumber;</span><br><span class="line">//            CIAttributeDefault = 20;</span><br><span class="line">//            CIAttributeDescription = &quot;The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result.&quot;;</span><br><span class="line">//            CIAttributeDisplayName = Radius;</span><br><span class="line">//            CIAttributeIdentity = 0;</span><br><span class="line">//            CIAttributeMin = 0;</span><br><span class="line">//            CIAttributeSliderMax = 100;</span><br><span class="line">//            CIAttributeSliderMin = 0;</span><br><span class="line">//            CIAttributeType = CIAttributeTypeDistance;</span><br><span class="line">//        &#125;;</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否需要指定OpenGL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">使用nil方式创建基于 GPU 的 CIContext 对象是最优选择</span><br><span class="line">它内部的渲染器会根据设备最优选择。依次为 Metal，OpenGLES，CoreGraphics。</span><br><span class="line">*/ </span><br><span class="line">CIContext *context = [CIContext contextWithOptions: nil];</span><br><span class="line"></span><br><span class="line">// 强制使用OpenGL</span><br><span class="line">EAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];</span><br><span class="line">context = [CIContext contextWithEAGLContext:eaglctx];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://objccn.io/issue-21-6/" target="_blank" rel="noopener">Core Image 介绍</a></li>
<li><a href="https://github.com/FlexMonkey/Filterpedia" target="_blank" rel="noopener">Core Image Filter Explorer &amp; Showcase</a></li>
<li><a href="http://colin1994.github.io/2016/10/21/Core-Image-OverView/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">Core Image 你需要了解的那些事~</a></li>
<li><a href="http://colin1994.github.io/2016/10/21/Core-Image-Custom-Filter/" target="_blank" rel="noopener">Core Image 之自定义 Filter~</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreGraphics2：进阶</title>
    <url>/2016/07/19/CoreGraphics2%EF%BC%9A%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h4 id="3-3-Quartz变换函数"><a href="#3-3-Quartz变换函数" class="headerlink" title="3.3 Quartz变换函数"></a>3.3 Quartz变换函数</h4><ul>
<li><p>平移绘图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextTranslateCTM(context, 100, 200);</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转绘图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextRotateCTM(context, M_PI_4);</span><br></pre></td></tr></table></figure>
</li>
<li><p>缩放绘图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextScaleCTM(context, 0.5, 0.8);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要即平移又旋转怎么办？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">CGAffineTransform 处理形变的类,二维坐标系,即向右为x轴正方向,向上为y轴正方向</span><br><span class="line">方法简介：</span><br><span class="line">CGAffineTransformTranslate // x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformScale // x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformRotate // 逆时针旋转弧度,M_PI=180角度)</span><br><span class="line"></span><br><span class="line">以下都是针对视图的原定最初位置的中心点为起始参照进行相应操作的，</span><br><span class="line">CGAffineTransformMakeTranslation // 将坐标系统x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformMakeScale // 将坐标系统x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformMakeRotation // 将坐标系统逆时针旋转弧度,M_PI=180角度)</span><br><span class="line">*/</span><br><span class="line">CGAffineTransform transform = CGAffineTransformIdentity;</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, newSize.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI);</span><br><span class="line">// 得到一个倒置矩阵。应用倒置矩阵将抵消原矩阵的变换效果。</span><br><span class="line">// CGAffineTransform invertTransform = CGAffineTransformInvert(transform);</span><br><span class="line">// 判断仿射变换是否相等。</span><br><span class="line">// CGAffineTransformEqualToTransform(invertTransform, transform) </span><br><span class="line">// 判断仿射变换是否为单位变换。单位变换没有平移、缩放和旋转操作。</span><br><span class="line">// CGAffineTransformIsIdentity(invertTransform)</span><br><span class="line"></span><br><span class="line">// 合并多个变换函数</span><br><span class="line">CGContextConcatCTM(context, invertTransform);</span><br><span class="line"></span><br><span class="line">// 在操作结束之后可对设置量进行还原：</span><br><span class="line">view.transform＝CGAffineTransformIdentity;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-4-颜色与颜色空间"><a href="#3-4-颜色与颜色空间" class="headerlink" title="3.4 颜色与颜色空间"></a>3.4 颜色与颜色空间</h4><ul>
<li><p>创建设备依赖颜色空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建设备依赖RGB颜色空间。</span><br><span class="line">// CGColorSpaceCreateDeviceGray(); CGColorSpaceCreateDeviceCMYK();</span><br><span class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">// 设置填充的颜色空间</span><br><span class="line">CGContextSetFillColorSpace(context, colorSpace);</span><br><span class="line">// 设置描边的颜色空间</span><br><span class="line">CGContextSetStrokeColorSpace(context, colorSpace);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并填充颜色</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1, 使用颜色空间创建颜色</span><br><span class="line">CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">CGFloat components[] = &#123;250/255.0, 100/255.0, 70/255.0, 1.0&#125;;</span><br><span class="line">CGColorRef color = CGColorCreate(colorspace, components);</span><br><span class="line">CGContextSetStrokeColorWithColor(context, color);</span><br><span class="line">CGContextSetFillColorWithColor(context, color);</span><br><span class="line"></span><br><span class="line">// 2，快速设置依赖RGB颜色的颜色值。</span><br><span class="line">CGContextSetRGBStrokeColor(context, 1, 0, 0, 1);</span><br><span class="line">CGContextSetRGBFillColor(context, 1, 0, 0, 1);</span><br><span class="line"></span><br><span class="line">// 3, 使用UI函数设置颜色值</span><br><span class="line">CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-5-阴影"><a href="#3-5-阴影" class="headerlink" title="3.5 阴影"></a>3.5 阴影</h4><ul>
<li>阴影被设置后，任何绘制的对象都有一个阴影，如果需多个阴影投射在一起，可使用一个透明层；该图层类似一个先是叠加所有绘图然后加上阴影的一个子上下文</li>
<li>关闭阴影：如果在设置阴影之前保存了图形状态，就可以通过恢复图形状态来关闭阴影。也可以通过设置阴影颜色为 NULL 来关闭阴影。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 阴影的位置表示为CGSize，如果CGSize的两个值都是正数，则表示阴影是朝下和朝右的。模糊度被表示为任何一个正数</span><br><span class="line">CGContextSetShadowWithColor(myContext, CGSizeMake(15, 20), 5, [UIColor redColor].CGColor);</span><br><span class="line">// 默认颜色 RGBA 值 &#123;0, 0, 0, 1.0 / 3.0&#125;</span><br><span class="line">CGContextSetShadow(context, CGSizeMake(15, 20), 5);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-渐变"><a href="#3-6-渐变" class="headerlink" title="3.6 渐变"></a>3.6 渐变</h4><ul>
<li><p>CGGradient 绘制径向和轴向渐变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 绘制渐变</span><br><span class="line">// 颜色数组和位置数组必须一一对应，最少两个：起点和终点</span><br><span class="line">CGFloat locs[3] = &#123; 0.0, 0.5, 1.0 &#125;;</span><br><span class="line">CGFloat colors[12] = &#123;</span><br><span class="line">0.3,0.3,0.3,0.8, // 开始颜色</span><br><span class="line">0.0,0.0,0.0,1.0, // 中间颜色</span><br><span class="line">0.3,0.3,0.3,0.8 // 末尾颜色</span><br><span class="line">&#125;;</span><br><span class="line">CGColorSpaceRef sp = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">CGGradientRef grad = CGGradientCreateWithColorComponents (sp, colors, locs, 3);</span><br><span class="line">// 绘制轴向渐变</span><br><span class="line">/*</span><br><span class="line">CGContextRef cg_nullable c,</span><br><span class="line">CGGradientRef cg_nullable gradient,</span><br><span class="line">CGPoint startPoint, 起点</span><br><span class="line">CGPoint endPoint,   终点</span><br><span class="line">CGGradientDrawingOptions options</span><br><span class="line">kCGGradientDrawsBeforeStartLocation 向外渐变</span><br><span class="line">kCGGradientDrawsAfterEndLocation 向里渐变</span><br><span class="line">*/</span><br><span class="line">//    CGContextDrawLinearGradient(context, grad, CGPointMake(50,0), CGPointMake(100,0), 0);</span><br><span class="line"></span><br><span class="line">// 绘制径向渐变</span><br><span class="line">/*</span><br><span class="line">CGContextRef cg_nullable c,</span><br><span class="line">CGGradientRef cg_nullable gradient,</span><br><span class="line">CGPoint startCenter, 外圈中心点</span><br><span class="line">CGFloat startRadius, 外圈半径</span><br><span class="line">CGPoint endCenter,   内圈中心点</span><br><span class="line">CGFloat endRadius,   内圈半径</span><br><span class="line">CGGradientDrawingOptions options</span><br><span class="line">*/</span><br><span class="line">CGContextDrawRadialGradient(context, grad, CGPointMake(100, 200), 5, CGPointMake(100, 200), 50, 0);</span><br><span class="line">CGColorSpaceRelease(sp);</span><br><span class="line">CGGradientRelease(grad);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CGShading 绘制径向和轴向渐变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// to do</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-7-透明层"><a href="#3-7-透明层" class="headerlink" title="3.7 透明层"></a>3.7 透明层</h4><ul>
<li>透明层通过组合两个或多个对象来生成一个组合图形。把它当场一个单独对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 给两个圆组成的大眼睛绘制阴影</span><br><span class="line">CGContextSetShadowWithColor(context, CGSizeZero, 10, [UIColor grayColor].CGColor);</span><br><span class="line">// 开始透明层，begin和end之间的当做一个单独对象对待</span><br><span class="line">CGContextBeginTransparencyLayer(context, NULL);</span><br><span class="line">// 添点料</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);</span><br><span class="line">CGContextFillEllipseInRect(context, CGRectMake(100, 150, 100, 100));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor blueColor].CGColor);</span><br><span class="line">CGContextFillEllipseInRect(context, CGRectMake(150, 150, 100, 100));</span><br><span class="line">// 结束透明层，生成一个组合图层，begin和end必须一一对应</span><br><span class="line">CGContextEndTransparencyLayer(context);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-8-抗锯齿"><a href="#3-8-抗锯齿" class="headerlink" title="3.8 抗锯齿"></a>3.8 抗锯齿</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextSetShouldAntialias(context, YES); // 打开抗锯齿</span><br></pre></td></tr></table></figure>
<h4 id="3-9模板"><a href="#3-9模板" class="headerlink" title="3.9模板"></a>3.9模板</h4><ul>
<li>模板表示为CGPattern（具体类型为CGPatternRef）。你可以创建一个模板并使用它进行描边或填充。跟帖瓷砖差不多<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void drawTile(void *info,CGContextRef context) &#123;</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(0, 0, 30, 30));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor grayColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(0, 30, 30, 30));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor blueColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(30, 0, 30, 30));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor purpleColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(30, 30, 30, 30));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">//填充模式回调函数结构体</span><br><span class="line">/*</span><br><span class="line">version 回调结构体的版本号，可以设置为 0</span><br><span class="line">drawPattern 指向绘制回调的指针。</span><br><span class="line">releaseInfo 该回调在释放 CGPatternRef 对象时被调用，如果不用可传NULL</span><br><span class="line">*/ </span><br><span class="line">CGPatternCallbacks callback = &#123;0,drawTile,NULL&#125;;</span><br><span class="line"></span><br><span class="line">//设置砖块样式</span><br><span class="line">/*</span><br><span class="line">void *infoCGRect</span><br><span class="line">bounds    每块瓷砖的大小</span><br><span class="line">CGAffineTransform matrix     变换矩阵，如果不用变换可以传入CGAffineTransformIdentity</span><br><span class="line">CGFloat xStep, CGFloat yStep  指定瓷砖块横向和纵向的间距，如果大于瓷砖大小，瓷砖间会有间隙</span><br><span class="line">CGPatternTiling tiling  平铺模式 kCGPatternTilingNoDistortion 无失真,kCGPatternTilingConstantSpacingMinimalDistortion 恒定间距的最小失真,kCGPatternTilingConstantSpacing恒定间距平铺</span><br><span class="line">bool isColored    瓷砖是否有颜色</span><br><span class="line">const CGPatternCallbacks *callbacks   回调函数结构体</span><br><span class="line">*/</span><br><span class="line">CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 60, 60), CGAffineTransformIdentity, 60, 60, kCGPatternTilingNoDistortion, true, &amp;callback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置颜色空间</span><br><span class="line">//设备无关的颜色空间 CGColorSpaceCreateDeviceRGB();</span><br><span class="line">//模式填充颜色空间,注意对于有颜色填充模式，这里传NULL</span><br><span class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreatePattern(NULL);</span><br><span class="line">CGContextSetFillColorSpace(context, colorSpace);</span><br><span class="line">CGContextSetStrokeColorSpace(context, colorSpace);</span><br><span class="line"></span><br><span class="line">float alpha = 1;</span><br><span class="line">////最后一个参数对于有颜色瓷砖指定为透明度的参数地址，对于无颜色瓷砖则指定当前颜色空间对应的颜色数组</span><br><span class="line">CGContextSetFillPattern(context, pattern, &amp;alpha);</span><br><span class="line">CGContextSetStrokePattern(context, pattern, &amp;alpha);</span><br><span class="line"></span><br><span class="line">//绘制</span><br><span class="line">CGContextFillRect(context, CGRectMake(0, 20, 155, 155));</span><br><span class="line">CGContextStrokeRectWithWidth(context, CGRectMake(165,20, 155, 155), 5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-10-怎么绘制1像素的线"><a href="#3-10-怎么绘制1像素的线" class="headerlink" title="3.10 怎么绘制1像素的线"></a>3.10 怎么绘制1像素的线</h4><ul>
<li>Core Graphics做了大量操作，一般不需要关注x y坐标中点和实际上屏幕显示的像素关系！</li>
<li>像素到点的转化，可以通过 除以 UIView的contentScaleFactor属性</li>
<li>最精确的方式绘制一条水平或垂直的线条的方式不是描边路径，而是填充路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGContextFillRect(context, CGRectMake(0,0,1.0/self.contentScaleFactor,100));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-11-每次都setNeedsDisplay好烦呀"><a href="#3-11-每次都setNeedsDisplay好烦呀" class="headerlink" title="3.11 每次都setNeedsDisplay好烦呀"></a>3.11 每次都setNeedsDisplay好烦呀</h4><ul>
<li><p>可以通过修改view的contentMode为UIViewContentModeRedraw，这将引起缓存内容的自动缩放和重定位被关闭，最终结果是视图的setNeedsDisplay方法将被调用，触发drawRect：方法重绘视图内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View.contentMode = UIViewContentModeRedraw;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只是暂时调整大小，例如动画变大再还原，正确设置contentMode的值是UIViewContentModeScaleToFill，被伸缩的内容仅仅是视图内容的一副缓存图片，所以它运行起来十分的高效</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Crash分析与总结</title>
    <url>/2016/12/18/Crash%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="1-Crash日志格式"><a href="#1-Crash日志格式" class="headerlink" title="1 Crash日志格式"></a>1 Crash日志格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 进程信息</span><br><span class="line">// 1.1 崩溃报告的唯一标识符</span><br><span class="line">Incident Identifier: AC8D216D-65CA-414C-B354-1E5AD05E6981</span><br><span class="line">// 1.2 设备标识符，注意不是真正的设备标识符，但可做唯一标志使用</span><br><span class="line">CrashReporter Key:   bb1c1545a3cae67e42a2e210ae253f10096200e7</span><br><span class="line">// 1.3 设备类型，这里是iPhone 7 Plus</span><br><span class="line">Hardware Model:      iPhone9,2</span><br><span class="line">// 1.4 应用名称[闪退时的进程ID]</span><br><span class="line">Process:             有道云笔记 [54279]</span><br><span class="line">// 1.5 应用路径</span><br><span class="line">Path:                /private/var/containers/Bundle/Application/0A4AF891-56D6-4384-9B45-061500D6C8C3/有道云笔记.app/有道云笔记</span><br><span class="line">// 1.6 bound id</span><br><span class="line">Identifier:          com.youdao.note.iphone</span><br><span class="line">// 1.7 build &amp; version</span><br><span class="line">Version:             1213 (4.5.7)</span><br><span class="line">// 1.8 以下除了Code Type: ARM-64 (Native) 稍微有点用，其它都不用管</span><br><span class="line">AppStoreTools:       10G3</span><br><span class="line">AppVariant:          1:iPhone10,3:11</span><br><span class="line">Code Type:           ARM-64 (Native)</span><br><span class="line">Role:                Non UI</span><br><span class="line">Parent Process:      launchd [1]</span><br><span class="line">Coalition:           com.youdao.note.iphone [9927]</span><br><span class="line"></span><br><span class="line">// 2 基本信息</span><br><span class="line">// 2.1 崩溃时间</span><br><span class="line">Date/Time:           2019-07-23 07:42:53.4906 +0800</span><br><span class="line">// 2.2 启动时间</span><br><span class="line">Launch Time:         2019-07-23 07:42:33.4417 +0800</span><br><span class="line">// 2.3 ios系统版本</span><br><span class="line">OS Version:          iPhone OS 9.3.0 (16F203)</span><br><span class="line">Baseband Version:    3.60.01</span><br><span class="line">Report Version:      104</span><br><span class="line"></span><br><span class="line">// 3 异常</span><br><span class="line">// 3.1 异常类型</span><br><span class="line">Exception Type:  EXC_CRASH (SIGKILL)</span><br><span class="line">// 3.2 异常编码</span><br><span class="line">Exception Codes: 0x0000000000000000, 0x0000000000000000</span><br><span class="line">Exception Note:  EXC_CORPSE_NOTIFY</span><br><span class="line">Termination Reason: Namespace SPRINGBOARD, Code 0x8badf00d</span><br><span class="line">Termination Description: SPRINGBOARD, scene-create watchdog transgression: com.youdao.note.iphone exhausted real (wall clock) time allowance of 19.59 seconds | ProcessVisibility: Foreground | ProcessState: Running | WatchdogEvent: scene-create | WatchdogVisibility: Foreground | WatchdogCPUStatistics: ( | &quot;Elapsed total CPU time (seconds): 13.190 (user 13.190, system 0.000), 11% CPU&quot;, | &quot;Elapsed application CPU time (seconds): 1.093, 1% CPU&quot; | )</span><br><span class="line">Triggered by Thread:  0</span><br><span class="line"></span><br><span class="line">// 4 线程回顾</span><br><span class="line">// 4.1 线程编号和名称</span><br><span class="line">Thread 0 name:  Dispatch queue: NSPersistentStoreCoordinator 0x2811a8080</span><br><span class="line">Thread 0 Crashed:</span><br><span class="line">// 4.2 调动方法顺序和各列含义</span><br><span class="line">//帧编号 | 库的名称                |方法地址          | 基本地址和偏移量</span><br><span class="line">0   libsystem_kernel.dylib          0x00000001b164a400 __semwait_signal + 8</span><br><span class="line">1   libsystem_c.dylib               0x00000001b15c156c nanosleep + 212</span><br><span class="line">2   libsystem_c.dylib               0x00000001b15c136c sleep + 44</span><br><span class="line">3   CoreData                        0x00000001b4524da4 -[NSXPCStore sendMessage:fromContext:interrupts:error:] + 836</span><br><span class="line">4   CoreData                        0x00000001b4589bfc -[NSXPCStore loadMetadata:] + 344</span><br><span class="line">5   CoreData                        0x00000001b466963c __91-[NSPersistentStoreCoordinator addPersistentStoreWithType:configuration:URL:options:error:]_block_invoke + 1616</span><br><span class="line">6   CoreData                        0x00000001b46751a4</span><br></pre></td></tr></table></figure>
<ul>
<li>注意: 在后台任务列表中关闭已挂起的应用不会产生崩溃日志。 一旦应用被挂起，它何时被终止都是合理的。所以不会产生崩溃日志</li>
</ul>
<h3 id="2-CPU-type"><a href="#2-CPU-type" class="headerlink" title="2 CPU type"></a>2 CPU type</h3><ul>
<li>i386 或 x86_64 ：模拟器</li>
<li>armv6：iPhone、iPhone2、iPhone3G、iPod Touch(第一代)、iPod Touch(第二代)</li>
<li>armv7：iPhone3Gs、iPhone4、iPhone4s、iPad、iPad 2</li>
<li>armv7s：iPhone5、iPhone5c</li>
<li>arm64：iPhone5s、iPhone6、iPhone6p、iPhone6s、iPhone6sp、iPhone7、iPhone7p、iPhone8、iPhone8p、iPhoneX</li>
<li>arm64e：iPhone XS、iPhone XS Max、iPhone XR</li>
</ul>
<h3 id="3-Exception-Codes"><a href="#3-Exception-Codes" class="headerlink" title="3 Exception Codes"></a>3 Exception Codes</h3><ul>
<li>0x8badf00d：读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的</li>
<li>0xbad22222: 该编码表示 VoIP（网络语音电话） 应用因为过于频繁重启而被终止。</li>
<li>0xdead10cc: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。</li>
<li>0xdeadfa11: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面。</li>
<li>0xbaaaaaad 表明这个日志是整个系统的堆栈记录，而不是一份崩溃报告。</li>
<li>0xc00010ff 表明这个应用由于过热事件被系统杀掉了。</li>
<li>0x2bad45ec 表明由于安全违规问题被杀掉了</li>
</ul>
<h3 id="4-Exception-Type"><a href="#4-Exception-Type" class="headerlink" title="4 Exception Type"></a>4 Exception Type</h3><h4 id="4-1-EXC-BAD-ACCESS、SIGSEGV和SIGBUS"><a href="#4-1-EXC-BAD-ACCESS、SIGSEGV和SIGBUS" class="headerlink" title="4.1 EXC_BAD_ACCESS、SIGSEGV和SIGBUS"></a>4.1 EXC_BAD_ACCESS、SIGSEGV和SIGBUS</h4><ul>
<li>野指针、非法访问等内存问题</li>
<li>解决方案</li>
<li>开启僵尸对象：Producrt -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; Zombie object</li>
<li>如果有 gpus_ReturnNotPermittedKillClient是非主线程渲染，参考： QA1766: How to fix OpenGL ES application crashes when moving to the background</li>
<li>Address Sanitizer </li>
</ul>
<h4 id="4-2-EXC-BAD-INSTRUCTION、SIGILL"><a href="#4-2-EXC-BAD-INSTRUCTION、SIGILL" class="headerlink" title="4.2 EXC_BAD_INSTRUCTION、SIGILL"></a>4.2 EXC_BAD_INSTRUCTION、SIGILL</h4><ul>
<li>非法的指令，往往是运行指令的参数不对</li>
</ul>
<h4 id="4-3-EXC-RESOURCE"><a href="#4-3-EXC-RESOURCE" class="headerlink" title="4.3 EXC_RESOURCE"></a>4.3 EXC_RESOURCE</h4><ul>
<li>cpu使用过高，一般都有cpu usage字段</li>
<li>内存不足，一般都有 page信息</li>
</ul>
<h4 id="4-4-EXC-GUARD"><a href="#4-4-EXC-GUARD" class="headerlink" title="4.4 EXC_GUARD"></a>4.4 EXC_GUARD</h4><ul>
<li>C函数异常</li>
</ul>
<h4 id="4-5-SIGTRAP"><a href="#4-5-SIGTRAP" class="headerlink" title="4.5 SIGTRAP"></a>4.5 SIGTRAP</h4><ul>
<li>不是一个真正的崩溃信号</li>
<li>解决方案：重启-&gt; clean -&gt; build</li>
</ul>
<h4 id="4-6-EXC-ARITHETIC"><a href="#4-6-EXC-ARITHETIC" class="headerlink" title="4.6 EXC_ARITHETIC"></a>4.6 EXC_ARITHETIC</h4><ul>
<li>被除数是0</li>
</ul>
<h3 id="5-常见Crash"><a href="#5-常见Crash" class="headerlink" title="5 常见Crash"></a>5 常见Crash</h3><h4 id="5-1-doesNotRecognizeSelector-未实现方法"><a href="#5-1-doesNotRecognizeSelector-未实现方法" class="headerlink" title="5.1 doesNotRecognizeSelector 未实现方法"></a>5.1 doesNotRecognizeSelector 未实现方法</h4><ol>
<li>类型问题，常见于json和id的使用，例如NSArray调用了NSMutableArray的addobject方法; </li>
<li>.h和.m 文件声明方法不一致；常见的就是.m方法名改了几次，.h文件忘改了</li>
</ol>
<ul>
<li>预防：强制消除所有警告，</li>
<li>解决方案，首选：添加相关方法，备选：消息转发</li>
</ul>
<h4 id="5-1-dNSRangeException-越界"><a href="#5-1-dNSRangeException-越界" class="headerlink" title="5.1 dNSRangeException 越界"></a>5.1 dNSRangeException 越界</h4><ul>
<li>数组越界问题，常见就是超过数组范围</li>
<li>字符串越界问题，常见字符串截取和NSAttributeString的使用</li>
<li>解决方案：尽量用相关属性，而不是写死的数值</li>
</ul>
<h4 id="5-2-NSNULL问题"><a href="#5-2-NSNULL问题" class="headerlink" title="5.2 NSNULL问题"></a>5.2 NSNULL问题</h4><ul>
<li>常见json转化时，</li>
<li>解决办法：增加 [someValue isEqual:[NSNull null]判断</li>
</ul>
<h4 id="5-3-数组和字典的nil问题"><a href="#5-3-数组和字典的nil问题" class="headerlink" title="5.3 数组和字典的nil问题"></a>5.3 数组和字典的nil问题</h4><ul>
<li>数组 addObject: nil 会crash</li>
<li>字典 setOejct：nil 会crash</li>
</ul>
<h4 id="5-4-UI在非主线程绘制"><a href="#5-4-UI在非主线程绘制" class="headerlink" title="5.4 UI在非主线程绘制"></a>5.4 UI在非主线程绘制</h4><h4 id="5-5-NSTimer忘了删除"><a href="#5-5-NSTimer忘了删除" class="headerlink" title="5.5 NSTimer忘了删除"></a>5.5 NSTimer忘了删除</h4><h4 id="5-6-KVO重复添加或忘了删除"><a href="#5-6-KVO重复添加或忘了删除" class="headerlink" title="5.6 KVO重复添加或忘了删除"></a>5.6 KVO重复添加或忘了删除</h4><h4 id="5-7-通知忘了删除"><a href="#5-7-通知忘了删除" class="headerlink" title="5.7 通知忘了删除"></a>5.7 通知忘了删除</h4><h4 id="5-8-子线程刷新UI"><a href="#5-8-子线程刷新UI" class="headerlink" title="5.8 子线程刷新UI"></a>5.8 子线程刷新UI</h4><ul>
<li>一般crash子线程（非0）会有setNeedsDisplay等方法</li>
</ul>
<h4 id="5-9-多线程问题"><a href="#5-9-多线程问题" class="headerlink" title="5.9 多线程问题"></a>5.9 多线程问题</h4><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cocoachina.com/articles/6677" target="_blank" rel="noopener">http://www.cocoachina.com/articles/6677</a></li>
<li><a href="https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-ANALYZING_CRASH_REPORTS" target="_blank" rel="noopener">https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-ANALYZING_CRASH_REPORTS</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>FishHook都干了什么？</title>
    <url>/2017/10/10/FishHook%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h4 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h4><p>APP启动的时候是会去链接很多动态库，如UIKit，UIFoundation等。函数的调用是通过跳转指令跳到函数对应的内存地址，而动态库是在程序启动时才去链接的，因此动态库中函数的地址在一开始是不知道的，所以这些函数的地址存放在<strong>DATA,</strong>la_symbol_prt表中，也就是所谓的PIC(位置无关代码)。在函数第一次调用的时候例如NSLog()函数，这个表中的地址不是直接指向NSLog的正确地址，而是指向了dyld_stub_binder函数地址，它的作用就是去计算出NSLog的真正地址，然后将<strong>DATA,</strong>la_symbol_prt中NSLog对应的地址改为它的实际地址，这样第二次调用的时候就是直接调用到NSLog。另外除了<strong>la_symbol_prt表之外，还有与之对应的indirect Symbols、Symbol Table以及String Table。它们之间的关系是，**首先通过符号在</strong>la_symbol_prt的index，加上在Load Command中对__la_symbol_prt的描述信息reversed1，找到indirect Symbols中 index+reversed1 位置的数据index2，然后在找到Symbol Table中index2位置的数据拿到偏移地址offset，最后在String Table中找offset处的数据，该数据就是函数名”_NSLog”。**</p>
<p>fishhook是怎么hook懒加载和非懒加载的</p>
<h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p><a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">https://github.com/facebook/fishhook</a></p>
<p>dyld binds lazy and non-lazy symbols by updating pointers in particular sections of the __DATA segment of a Mach-O binary. fishhook re-binds these symbols by determining the locations to update for each of the symbol names passed to rebind_symbols and then writing out the corresponding replacements.</p>
<p>For a given image, the <strong>DATA segment may contain two sections that are relevant for dynamic symbol bindings: </strong>nl_symbol_ptr and <strong>la_symbol_ptr. </strong>nl_symbol_ptr is an array of pointers to non-lazily bound data (these are bound at the time a library is loaded) and <strong>la_symbol_ptr is an array of pointers to imported functions that is generally filled by a routine called dyld_stub_binder during the first call to that symbol (it’s also possible to tell dyld to bind these at launch). In order to find the name of the symbol that corresponds to a particular location in one of these sections, we have to jump through several layers of indirection. For the two relevant sections, the section headers (struct sections from &lt;mach-o/loader.h&gt;) provide an offset (in the reserved1 field) into what is known as the indirect symbol table. The indirect symbol table, which is located in the </strong>LINKEDIT segment of the binary, is just an array of indexes into the symbol table (also in <strong>LINKEDIT) whose order is identical to that of the pointers in the non-lazy and lazy symbol sections. So, given struct section nl_symbol_ptr, the corresponding index in the symbol table of the first address in that section is indirect_symbol_table[nl_symbol_ptr-&gt;reserved1]. The symbol table itself is an array of struct nlists (see &lt;mach-o/nlist.h&gt;), and each nlist contains an index into the string table in </strong>LINKEDIT which where the actual symbol names are stored. So, for each pointer <strong>nl_symbol_ptr and </strong>la_symbol_ptr, we are able to find the corresponding symbol and then the corresponding string to compare against the requested symbol names, and if there is a match, we replace the pointer in the section with the replacement.</p>
<p>The process of looking up the name of a given entry in the lazy or non-lazy pointer tables looks like this: Visual explanation</p>
<p><img src="https://camo.githubusercontent.com/18243516844d12b1bd158ce3687635d6e48d2e2e/687474703a2f2f692e696d6775722e636f6d2f4856587148437a2e706e67" alt="image"></p>
<h4 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h4><ul>
<li><p>h 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * A structure representing a particular intended rebinding from a symbol</span><br><span class="line"> * name to its replacement</span><br><span class="line"> */</span><br><span class="line">struct rebinding &#123;</span><br><span class="line">  const char *name; // 函数名</span><br><span class="line">  void *replacement; // hook之后用于替换的函数</span><br><span class="line">  void **replaced; // 用于保存原来的函数地址，这里传递一个函数指针变量的地址进去</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * For each rebinding in rebindings, rebinds references to external, indirect</span><br><span class="line"> * symbols with the specified name to instead point at replacement for each</span><br><span class="line"> * image in the calling process as well as for all future images that are loaded</span><br><span class="line"> * by the process. If rebind_functions is called more than once, the symbols to</span><br><span class="line"> * rebind are added to the existing list of rebindings, and if a given symbol</span><br><span class="line"> * is rebound more than once, the later rebinding will take precedence.</span><br><span class="line"> */</span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Rebinds as above, but only in the specified image. The header should point</span><br><span class="line"> * to the mach-o header, the slide should be the slide offset. Others as above.</span><br><span class="line"> */</span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line">int rebind_symbols_image(void *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         struct rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel);</span><br></pre></td></tr></table></figure>
</li>
<li><p>c 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;fishhook.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;mach/mach.h&gt;</span><br><span class="line">#include &lt;mach/vm_map.h&gt;</span><br><span class="line">#include &lt;mach/vm_region.h&gt;</span><br><span class="line">#include &lt;mach-o/dyld.h&gt;</span><br><span class="line">#include &lt;mach-o/loader.h&gt;</span><br><span class="line">#include &lt;mach-o/nlist.h&gt;</span><br><span class="line"></span><br><span class="line">#ifdef __LP64__</span><br><span class="line">typedef struct mach_header_64 mach_header_t;</span><br><span class="line">typedef struct segment_command_64 segment_command_t;</span><br><span class="line">typedef struct section_64 section_t;</span><br><span class="line">typedef struct nlist_64 nlist_t;</span><br><span class="line">#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span><br><span class="line">#else</span><br><span class="line">typedef struct mach_header mach_header_t;</span><br><span class="line">typedef struct segment_command segment_command_t;</span><br><span class="line">typedef struct section section_t;</span><br><span class="line">typedef struct nlist nlist_t;</span><br><span class="line">#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef SEG_DATA_CONST</span><br><span class="line">#define SEG_DATA_CONST  &quot;__DATA_CONST&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct rebindings_entry &#123;</span><br><span class="line">  struct rebinding *rebindings;</span><br><span class="line">  size_t rebindings_nel;</span><br><span class="line">  struct rebindings_entry *next;// 下一个指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 链表表头</span><br><span class="line">static struct rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123;</span><br><span class="line">  int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  if (retval &lt; 0) &#123;</span><br><span class="line">    return retval;</span><br><span class="line">  &#125;</span><br><span class="line">  // If this was the first call, register callback for image additions (which is also invoked for</span><br><span class="line">  // existing images, otherwise, just run on existing images</span><br><span class="line">  if (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    // 这里只是注册了一个func，并没有调用所以不用考虑参数</span><br><span class="line">      /*</span><br><span class="line">      * The following functions allow you to install callbacks which will be called</span><br><span class="line">      * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line">      * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line">      * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line">      * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line">      * and before the image is un-memory-mapped.</span><br><span class="line">      */</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 这里才是真正的调用</span><br><span class="line">    uint32_t c = _dyld_image_count();</span><br><span class="line">    for (uint32_t i = 0; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int prepend_rebindings(struct rebindings_entry **rebindings_head,</span><br><span class="line">                              struct rebinding rebindings[],</span><br><span class="line">                              size_t nel) &#123;</span><br><span class="line">  // 开辟新内存，C语言的标准写法</span><br><span class="line">  struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));</span><br><span class="line">  // C语言开辟内存之后，必须校验是否开辟成功</span><br><span class="line">  if (!new_entry) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">    // C中数组的指针就是数组里第一个元素的指针</span><br><span class="line">  new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel);</span><br><span class="line">  if (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    // malloc 内存不够需手动调整大小，内存释放需free，且free之后最好设为null</span><br><span class="line">    free(new_entry);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">    // 拷贝</span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    第一次时 _rebindings_head 为null，即new_entry-&gt;next为null</span><br><span class="line">    然后将_rebindings_head 指向 当前的new_entry</span><br><span class="line">    第二次再来会新开辟内存生成new_entry2，注意由于_rebindings_head是static变量</span><br><span class="line">    _rebindings_head保留的是上次的new_entry，此时new_entry2-&gt;next即指向new_entry</span><br><span class="line">    */</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 函数指针 void (*funcp)(); 函数的指针</span><br><span class="line">// 指针函数 int * GetDate(int wk,int dy); 返回值是指针</span><br><span class="line">static void _rebind_symbols_for_image(const struct mach_header *header,</span><br><span class="line">                                      intptr_t slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,</span><br><span class="line">                                     const struct mach_header *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">    // 地址符号信息</span><br><span class="line">  Dl_info info;</span><br><span class="line">    // dladdr 获取某个地址的符号信息</span><br><span class="line">  if (dladdr(header, &amp;info) == 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">    // 因64位和32位的结构稍有不同，需要自定义</span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  segment_command_t *linkedit_segment = NULL;</span><br><span class="line">  struct symtab_command* symtab_cmd = NULL; // 符号表</span><br><span class="line">  struct dysymtab_command* dysymtab_cmd = NULL; // 间接符号表</span><br><span class="line"></span><br><span class="line">    // 指向load Command的起始地址(uintptr_t)header。header是指针，</span><br><span class="line">    // header内存里存储的就是mach_header结构体的内存位置, 固强转long即可</span><br><span class="line">  uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">    // 遍历load command中所有的segment_command</span><br><span class="line">  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    </span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">        /*</span><br><span class="line">         int strcmp(const char *str1, const char *str2)</span><br><span class="line">         如果返回值 &lt; 0，则表示 str1 小于 str2。</span><br><span class="line">         如果返回值 &gt; 0，则表示 str2 小于 str1。</span><br><span class="line">         如果返回值 = 0，则表示 str1 等于 str2。</span><br><span class="line">         */</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Find base symbol/string table addresses</span><br><span class="line">    //slide是ASLR的随机偏移，linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff是mach-o在文件中的基地址，两者相加就是ASLR后的mach-o加载进内存的基地址</span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">    // Format of a symbol table entry of a Mach-O file</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">    // String Table的起始地址</span><br><span class="line">  char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  // Get indirect symbol table (array of uint32_t indices into symbol table)</span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  // 虽然上面所有的segment_command已经遍历完了，但header并没变，所以是第二次遍历load command</span><br><span class="line">  cur = (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">// #define    LC_SEGMENT    0x1    /* segment of this file to be mapped */</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">    // 遍历__DATA段的sections</span><br><span class="line">      for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">          // cur指向segment_command的起始地址需要偏移过去找到seciton的位置</span><br><span class="line">          // 不过 + j这个操作还是j惊艳到我了，毕竟是指针而不是section_t数组</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + sizeof(segment_command_t)) + j;</span><br><span class="line">          // 绑定懒加载 __la_symbol_ptr</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">          // 绑定非懒加载 __nl_symbol_ptr</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static vm_prot_t get_protection(void *sectionStart) &#123;</span><br><span class="line">  mach_port_t task = mach_task_self();</span><br><span class="line">  vm_size_t size = 0;</span><br><span class="line">  vm_address_t address = (vm_address_t)sectionStart;</span><br><span class="line">  memory_object_name_t object;</span><br><span class="line">#if __LP64__</span><br><span class="line">  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">  vm_region_basic_info_data_64_t info;</span><br><span class="line">  kern_return_t info_ret = vm_region_64(</span><br><span class="line">      task, &amp;address, &amp;size, VM_REGION_BASIC_INFO_64, (vm_region_info_64_t)&amp;info, &amp;count, &amp;object);</span><br><span class="line">#else</span><br><span class="line">  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT;</span><br><span class="line">  vm_region_basic_info_data_t info;</span><br><span class="line">  kern_return_t info_ret = vm_region(task, &amp;address, &amp;size, VM_REGION_BASIC_INFO, (vm_region_info_t)&amp;info, &amp;count, &amp;object);</span><br><span class="line">#endif</span><br><span class="line">  if (info_ret == KERN_SUCCESS) &#123;</span><br><span class="line">    return info.protection;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return VM_PROT_READ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section, // 节点</span><br><span class="line">                                           intptr_t slide, // ASLR的偏移量</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           char *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab) &#123;</span><br><span class="line">    </span><br><span class="line">  const bool isDataConst = strcmp(section-&gt;segname, &quot;__DATA_CONST&quot;) == 0;</span><br><span class="line">    // indirect Symbols中包含了各个section中符号在Symbol Table的index，</span><br><span class="line">    // 这里是直接定位到对应__DATA,__la_symbol_ptr所在的index数组</span><br><span class="line">  uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">    // void** ？？？void * 为 “无类型指针”，即可以指向任何类型</span><br><span class="line">  void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);</span><br><span class="line">    </span><br><span class="line">    /* read permission */</span><br><span class="line">  vm_prot_t oldProtection = VM_PROT_READ;</span><br><span class="line">    </span><br><span class="line">    // 常量</span><br><span class="line">  if (isDataConst) &#123;</span><br><span class="line">    oldProtection = get_protection(rebindings);</span><br><span class="line">      // mprotect()函数可以用来修改一段指定内存区域的保护属性。</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, PROT_READ | PROT_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line">  for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123;</span><br><span class="line">      </span><br><span class="line">    uint32_t symtab_index = indirect_symbol_indices[i];</span><br><span class="line">      </span><br><span class="line">      /*</span><br><span class="line">      * An indirect symbol table entry is simply a 32bit index into the symbol table</span><br><span class="line">      * to the symbol that the pointer or stub is refering to.  Unless it is for a</span><br><span class="line">      * non-lazy symbol pointer section for a defined symbol which strip(1) as</span><br><span class="line">      * removed.  In which case it has the value INDIRECT_SYMBOL_LOCAL.  If the</span><br><span class="line">      * symbol was also absolute INDIRECT_SYMBOL_ABS is or&apos;ed with that.</span><br><span class="line">      */</span><br><span class="line">    if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      // index into the string table, String Table中的偏移量</span><br><span class="line">    uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">      // 起始地址 + 偏移量 = 符号名</span><br><span class="line">    char *symbol_name = strtab + strtab_offset;</span><br><span class="line">      // symbol_name[0]一般是 _ 下划线, symbol_name[1] 是函数名</span><br><span class="line">    bool symbol_name_longer_than_1 = symbol_name[0] &amp;&amp; symbol_name[1];</span><br><span class="line">      </span><br><span class="line">    struct rebindings_entry *cur = rebindings;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">        // 遍历需要绑定的函数</span><br><span class="line">      for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">       //编译的时候会将符号转成带下划线的，比如printf会转成_printf,所以从下划线后面的字符开始比较</span><br><span class="line">        if (symbol_name_longer_than_1 &amp;&amp;</span><br><span class="line">            strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123;</span><br><span class="line">          if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">              // 保存原来的函数地址</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">            // 替换成新的函数实现</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">            // 退出遍历，即针对同一符号多次调用fishhook重绑定，只有会对最后一次调用的生效</span><br><span class="line">          goto symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">  if (isDataConst) &#123;</span><br><span class="line">    int protection = 0;</span><br><span class="line">    if (oldProtection &amp; VM_PROT_READ) &#123;</span><br><span class="line">      protection |= PROT_READ;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldProtection &amp; VM_PROT_WRITE) &#123;</span><br><span class="line">      protection |= PROT_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldProtection &amp; VM_PROT_EXECUTE) &#123;</span><br><span class="line">      protection |= PROT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, protection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int rebind_symbols_image(void *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         struct rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel) &#123;</span><br><span class="line">    struct rebindings_entry *rebindings_head = NULL;</span><br><span class="line">    int retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, (const struct mach_header *) header, slide);</span><br><span class="line">    if (rebindings_head) &#123;</span><br><span class="line">      free(rebindings_head-&gt;rebindings);</span><br><span class="line">    &#125;</span><br><span class="line">    free(rebindings_head);</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CoreText练习</title>
    <url>/2016/07/26/CoreText%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;前两天看到一篇文章<a href="http://www.cocoachina.com/articles/17050" target="_blank" rel="noopener">基于 CoreText 实现的高性能 UITableView</a>，思路比较清奇！以前水过NSAttributedString的使用，一般的文字排版已经能满足需求。但更复杂的文字排版就用到了CoreText，正好这块也不是很熟悉，正好学习一下</p>
<h3 id="1-CoreText简介"><a href="#1-CoreText简介" class="headerlink" title="1 CoreText简介"></a>1 CoreText简介</h3><p>&emsp;&emsp;CoreText是用于处理文字和字体的底层技术。工作在Core Graphics之上。Quartz能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此CoreText具有更高效的排版功能。详细内容参考<a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533-CH1-SW1" target="_blank" rel="noopener">About Core Text</a></p>
<p>&emsp;&emsp;CoreText和UIWebview两种排版方案对比</p>
<ol>
<li>CoreText占用内存更少，渲染速度更快，UIWebView占用内存多，渲染速度慢。</li>
<li>CoreText在渲染界面前就可以精确地获得显示内容的高度（只要有了CTFrame即可），而UIWebView只有渲染出内容后，才能获得内容的高度（而且还需要通过JavaScript代码来获取）。</li>
<li>CoreText的CTFrame可以在后台线程渲染，UIWebView的内容只能在主线程（UI线程）渲染。</li>
<li>CoreText只支持渲染不支持长按复制，UIWebview可以支持</li>
</ol>
<h3 id="2-文字排版的基础概念"><a href="#2-文字排版的基础概念" class="headerlink" title="2 文字排版的基础概念"></a>2 文字排版的基础概念</h3><p>&emsp;&emsp;盗图<a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/FontHandling/FontHandling.html#//apple_ref/doc/uid/TP40009459-CH5-SW1" target="_blank" rel="noopener">官网</a><br><img src="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyph_metrics_2x.png" alt="image"></p>
<ul>
<li>字体(Font)：需要注意的是粗体、斜体等都是不同字体，这也解释了为啥UI自定义字体时要给好几套，粗体斜体都有对应的字体文件</li>
<li>字体集(Font family):是一组相关字体</li>
<li>字符(Character)和字形(Glyphs)：字符就是字面意一般就是指某种编码，如Unicode编码，而字形则是这些编码对应的图片</li>
<li>边框(Bounding Box)：一个假想的边框，尽可能地容纳整个字形。</li>
<li>磅值(Weight):用于描述字体粗度</li>
<li>基线(Baseline)：一条假想的参照线，以此为基础进行字形的渲染。一般来说是一条横线。</li>
<li>基础原点(Origin)：基线上最左侧的点。</li>
<li>上行高度(Ascent)和下行高度(Decent)：一个字形最高点和最低点到基线的距离，前者为正数，而后者为负数。lineHeight = Ascent + |Decent| + Leading。</li>
<li>x高度(X height):指小写字母的平均高度(以x为基准)。磅值相同的两字母,x高度越大的字母看起来比x高度小的字母要大</li>
<li>Cap高度(Cap height):与x高度相似。指大写字母的平均高度(以C为基准)</li>
<li>描边(Stroke):组成字符的线或曲线。可以加粗或改变字符形状</li>
<li>行间距(Leading)：行与行之间的间距。</li>
<li>字间距(Kerning)：字与字之间的距离，为了排版的美观，并不是所有的字形之间的距离都是一致的，但是这个基本步影响到我们的文字排版。</li>
</ul>
<h3 id="3-CoreText中常用类"><a href="#3-CoreText中常用类" class="headerlink" title="3 CoreText中常用类"></a>3 CoreText中常用类</h3><ul>
<li><a href="https://developer.apple.com/documentation/coretext/ctfont?language=objc" target="_blank" rel="noopener">CTFont</a> | Core Text字体对象。字体对象表示应用程序的字体，提供对字体特征的访问，例如磅值，变换矩阵和其他属性</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctframe?language=objc" target="_blank" rel="noopener">CTFrame</a> | 想象成画布，可包含多行文本</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctframesetter?language=objc" target="_blank" rel="noopener">CTFramesetter</a> | CTFrame的一个Factory，通过传入CGPath生成相应的CTFrame并使用它进行渲染</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctline?language=objc" target="_blank" rel="noopener">CTLine</a> | 表示一行文本。</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctparagraphstyle?language=objc" target="_blank" rel="noopener">CTParagraphStyle</a> | 段落属性</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctrun?language=objc" target="_blank" rel="noopener">CTRun</a> | 绘制的最小单元，<a href="https://developer.apple.com/documentation/coretext/ctrundelegate?language=objc" target="_blank" rel="noopener">CTRunDelegate</a>实现图文混排的原理：用一个空白字符作为图片的占位符，设好Delegate，占好位置，然后用CoreGraphics进行图片的绘制</li>
</ul>
<p>&emsp;&emsp;一个CTFrame是由一行一行的CLine组成，每个CTLine又会包含若干个CTRun(既字形绘制的最小单元)，通过相应的方法可以获取到不同位置的CTRun和CTLine，以实现对不同位置touch事件的响应。注意：你不需要自己创建CTRun，CoreText将根据NSAttributedString的属性来自动创建CTRun。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Art/core_text_arch_2x.png" alt="image"></p>
<h3 id="4-绘制"><a href="#4-绘制" class="headerlink" title="4 绘制"></a>4 绘制</h3><h4 id="4-1-常用文本绘制"><a href="#4-1-常用文本绘制" class="headerlink" title="4.1 常用文本绘制"></a>4.1 常用文本绘制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetTextMatrix(context , CGAffineTransformIdentity);</span><br><span class="line">CGContextTranslateCTM(context , 0 ,self.bounds.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0 ,-1.0);</span><br><span class="line"></span><br><span class="line">NSString *str = @&quot;core text dome string. 富文本测试&quot;;</span><br><span class="line">NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:str];</span><br><span class="line"></span><br><span class="line">[mabstring beginEditing];</span><br><span class="line">/*</span><br><span class="line">kCTCharacterShapeAttributeName;//字体形状属性  必须是CFNumberRef对象默认为0，非0则对应相应的字符形状定义，如1表示传统字符形状</span><br><span class="line">kCTFontAttributeName;//字体属性   必须是CTFont对象</span><br><span class="line">kCTKernAttributeName;//字符间隔属性 必须是CFNumberRef对象</span><br><span class="line">kCTForegroundColorAttributeName; //字体颜色属性  必须是CGColor对象，默认为black</span><br><span class="line">kCTForegroundColorFromContextAttributeName //上下文的字体颜色属性 必须为CFBooleanRef 默认为False,</span><br><span class="line">kCTParagraphStyleAttributeName //段落样式属性 必须是CTParagraphStyle对象 默认为NIL</span><br><span class="line">kCTStrokeWidthAttributeName //笔画线条宽度 必须是CFNumberRef对象，默为0.0f，标准为3.0f</span><br><span class="line">kCTStrokeColorAttributeName //笔画的颜色属性 必须是CGColorRef 对象，默认为前景色</span><br><span class="line">kCTSuperscriptAttributeName //设置字体的上下标属性 必须是CFNumberRef对象 默认为0,可为-1为下标,1为上标，需要字体支持才行。如排列组合的样式Cn1</span><br><span class="line">kCTUnderlineColorAttributeName //字体下划线颜色属性 必须是CGColorRef对象，默认为前景色</span><br><span class="line">kCTUnderlineStyleAttributeName //字体下划线样式属性 必须是CFNumberRef对象,默为kCTUnderlineStyleNone 可以通过CTUnderlineStypleModifiers 进行修改下划线风格</span><br><span class="line">kCTVerticalFormsAttributeName//文字的字形方向属性 必须是CFBooleanRef 默认为false，false表示水平方向，true表示竖直方向</span><br><span class="line">kCTGlyphInfoAttributeName //字体信息属性 必须是CTGlyphInfo对象</span><br><span class="line">kCTRunDelegateAttributeName //CTRun 委托属性 必须是CTRunDelegate对象</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithObject:(id)[UIColor redColor].CGColor forKey:(id)kCTForegroundColorAttributeName];</span><br><span class="line">CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:40].fontName, 40, NULL);</span><br><span class="line">[attributes setObject:(__bridge id)font forKey:(id)kCTFontAttributeName];</span><br><span class="line">[attributes setObject:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] forKey:(id)kCTUnderlineStyleAttributeName];</span><br><span class="line">[mabstring addAttributes:attributes range:NSMakeRange(0, 4)];</span><br><span class="line"></span><br><span class="line">[mabstring endEditing];</span><br><span class="line"></span><br><span class="line">CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring);</span><br><span class="line">CGMutablePathRef Path = CGPathCreateMutable();</span><br><span class="line">CGPathAddRect(Path, NULL ,CGRectMake(0 , 0 ,self.bounds.size.width , self.bounds.size.height));</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL);</span><br><span class="line">CGContextSaveGState(context);</span><br><span class="line">CTFrameDraw(frame,context);</span><br><span class="line"></span><br><span class="line">CGPathRelease(Path);</span><br><span class="line">CFRelease(framesetter);</span><br><span class="line">UIGraphicsPushContext(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-图文混排"><a href="#4-2-图文混排" class="headerlink" title="4.2 图文混排"></a>4.2 图文混排</h4><p>&emsp;&emsp;以下代码摘自<a href="https://www.jianshu.com/p/6db3289fb05d" target="_blank" rel="noopener">CoreText实现图文混排</a>！直接看代码吧不难，核心：用一个空白字符作为图片的占位符，设好Delegate，占好位置，然后用CoreGraphics进行图片的绘制。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">[super drawRect:rect];</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;\n这里在测试图文混排，\n我是一个富文本&quot;];</span><br><span class="line">CTRunDelegateCallbacks callBacks;</span><br><span class="line">callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">callBacks.getAscent = ascentCallBacks;</span><br><span class="line">callBacks.getDescent = descentCallBacks;</span><br><span class="line">callBacks.getWidth = widthCallBacks;</span><br><span class="line">NSDictionary * dicPic = @&#123;@&quot;height&quot;:@129,@&quot;width&quot;:@400&#125;;</span><br><span class="line">CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</span><br><span class="line">unichar placeHolder = 0xFFFC;</span><br><span class="line">NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">CFRelease(delegate);</span><br><span class="line">[attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];</span><br><span class="line">CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">NSInteger length = attributeStr.length;</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</span><br><span class="line">CTFrameDraw(frame, context);</span><br><span class="line"></span><br><span class="line">UIImage * image = [UIImage imageNamed:@&quot;bd_logo1&quot;];</span><br><span class="line">CGRect imgFrm = [self calculateImageRectWithFrame:frame];</span><br><span class="line">CGContextDrawImage(context,imgFrm, image.CGImage);</span><br><span class="line">CFRelease(frame);</span><br><span class="line">CFRelease(path);</span><br><span class="line">//    CFRelease(frameSetter);</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat ascentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat descentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat widthCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</span><br><span class="line">&#123;</span><br><span class="line">NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</span><br><span class="line">NSInteger count = [arrLines count];</span><br><span class="line">CGPoint points[count];</span><br><span class="line">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</span><br><span class="line">for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">CTLineRef line = (__bridge CTLineRef)arrLines[i];</span><br><span class="line">NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</span><br><span class="line">for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</span><br><span class="line">CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</span><br><span class="line">NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</span><br><span class="line">CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">if (delegate == nil) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">CGPoint point = points[i];</span><br><span class="line">CGFloat ascent;</span><br><span class="line">CGFloat descent;</span><br><span class="line">CGRect boundsRun;</span><br><span class="line">boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">boundsRun.size.height = ascent + descent;</span><br><span class="line">CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">boundsRun.origin.x = point.x + xOffset;</span><br><span class="line">boundsRun.origin.y = point.y - descent;</span><br><span class="line">CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">CGRect colRect = CGPathGetBoundingBox(path);</span><br><span class="line">CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</span><br><span class="line">return imageBounds;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return CGRectZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/6db3289fb05d" target="_blank" rel="noopener">CoreText实现图文混排</a></li>
<li><a href="http://www.cocoachina.com/articles/17050" target="_blank" rel="noopener">基于 CoreText 实现的高性能 UITableView</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter入门学习步骤</title>
    <url>/2019/01/01/Flutter%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>&emsp;&emsp;新年新气象，但…我却不知道水啥！Flutter上次看到还是0.3这次再看已经1.0了，必须的拿出时间好好学习学习，但现在也仅仅是刚靠近Flutter门槛，远远没达到入门的标准：知识要形成体系！构建简单页面这种也没啥可水的，毕竟<a href="https://flutterchina.club/upgrading/" target="_blank" rel="noopener">Flutter中文网</a>上讲的非常详细, <a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">github</a>也有大量的问题解决方案。于是就把前段时间的学习步骤发出来吧</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><p>&emsp;&emsp;按<a href="https://flutterchina.club/upgrading/" target="_blank" rel="noopener">Flutter中文网</a> 安装环境，可能遇到问题下面列举</p>
<ol>
<li>安装过程中如果需要关闭SIP，如果电脑启用了SIP（System Integrity Protection），增加了rootless机制</li>
</ol>
<ul>
<li>1.1，重启，过程中按住 command+R，进入保护模式</li>
<li>1.2，打开terminal终端，输入 csrutil disable</li>
<li>1.3，再次重启，即可对 usr/bin 目录下文件进行修改</li>
<li>1.4，如果要恢复保护机制，重新进入保护模式，输入 csrutil enable</li>
</ul>
<ol start="2">
<li>Android studio 找不到 Flutter</li>
</ol>
<p>&emsp;&emsp;Android studio -&gt; Preferences -&gt; System Setting -&gt; updates -&gt; 去掉 use secure connection</p>
<ol start="3">
<li>PATH环境未生效</li>
</ol>
<p>&emsp;&emsp;user目录 -&gt; command+shift+.  打开隐藏文件 -&gt;  打开 .bash_profile 文件，添加相应PATH -&gt; 保存 -&gt; 重启</p>
<ol start="4">
<li>运行flutter就卡死</li>
</ol>
<p>&emsp;&emsp;偶然发现其实根本原因是mac限制了单进程最大线程个数为64，超过64就卡死了！验证方法：活动监视器 -&gt; 双击android studio -&gt; 取样 -&gt; 查看卡死信息！</p>
<p>&emsp;&emsp;几经周折找到<a href="https://www.cnblogs.com/augus007/articles/9088519.html" target="_blank" rel="noopener">修改内核的方法</a>：vim  /etc/sysctl.conf 添加如下代码 kern.wq_max_constrained_threads=128 修改保存后调用 sysctl -p 加载新配置，将单个进程最大线程数提升至128个。</p>
<p>&emsp;&emsp;PS:kern.wq_max_constrained_threads这个参数是通过全局搜64搜出来的然后慢慢试出来的，同志们修改前记得备份</p>
<ol start="5">
<li><a href="https://stackoverflow.com/questions/48650831/dart-sdk-is-not-configured" target="_blank" rel="noopener">Dart SDK is not configured</a>, android Studio -&gt; perference -&gt; framewoek -&gt; flutter</li>
</ol>
<h3 id="2-Flutter的State类"><a href="#2-Flutter的State类" class="headerlink" title="2 Flutter的State类"></a>2 Flutter的State类</h3><p>&emsp;&emsp;重点，响应式编程核心。先记住如下两张图，<a href="http://wiki.baidu.com/pages/viewpage.action?spaceKey=fmp&amp;title=Flutter" target="_blank" rel="noopener">参考</a></p>
<p>&emsp;&emsp;State 生命周期</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[开始]--&gt;B[构造函数]</span><br><span class="line">subgraph 构建</span><br><span class="line">B--&gt;C[initState]</span><br><span class="line">C--&gt;D[didChangeDependencies]</span><br><span class="line">D--&gt;E[build]</span><br><span class="line">end</span><br><span class="line">E--&gt;F&#123;显示在RenderTree&#125;</span><br><span class="line">subgraph 改变</span><br><span class="line">F--&gt;G[组件状态改变]</span><br><span class="line">G--&gt;H[didUpdateWidget]</span><br><span class="line">H--&gt;I[build]</span><br><span class="line">I--&gt;F</span><br><span class="line">end</span><br><span class="line">subgraph 销毁</span><br><span class="line">F--&gt;J[移除掉]</span><br><span class="line">J--&gt;K[deactivate]</span><br><span class="line">K--&gt;L[dispose]</span><br><span class="line">L--&gt;M[结束]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Stateless VS Stateful<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph StatelessWidgets</span><br><span class="line">A[constructor func]--&gt;B[build]</span><br><span class="line">end</span><br><span class="line">subgraph StatefulWidgets</span><br><span class="line">C[constructor func]--&gt;D[initState]</span><br><span class="line">D--&gt;F[build]</span><br><span class="line">F--&gt;E[setState]</span><br><span class="line">E--&gt;G[didUpdateWidget]</span><br><span class="line">G--&gt;H[build]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="3-Dart语法预览"><a href="#3-Dart语法预览" class="headerlink" title="3 Dart语法预览"></a>3 Dart语法预览</h3><p>&emsp;&emsp;<a href="http://dart.goodev.org" target="_blank" rel="noopener">Dart 语法</a>对学过swift或者学过JS的同学，我建议<em>直接速读</em><a href="http://dart.goodev.org/guides/language/language-tour" target="_blank" rel="noopener">Dart 语法预览</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Spacecraft &#123;</span><br><span class="line">String name;</span><br><span class="line">DateTime launchDate;</span><br><span class="line">int launchYear;</span><br><span class="line"></span><br><span class="line">// Constructor, including syntactic sugar for assignment to members.</span><br><span class="line">Spacecraft(this.name, this.launchDate) &#123;</span><br><span class="line">// Pretend the following is something you&apos;d actually want to run in</span><br><span class="line">// a constructor.</span><br><span class="line">launchYear = launchDate?.year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Named constructor that forwards to the default one.</span><br><span class="line">Spacecraft.unlaunched(String name) : this(name, null);</span><br><span class="line"></span><br><span class="line">// Method.</span><br><span class="line">void describe() &#123;</span><br><span class="line">print(&apos;Spacecraft: $name&apos;);</span><br><span class="line">if (launchDate != null) &#123;</span><br><span class="line">int years = new DateTime.now().difference(launchDate).inDays ~/ 365;</span><br><span class="line">print(&apos;Launched: $launchYear ($years years ago)&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">print(&apos;Unlaunched&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-Flutter中文网"><a href="#4-Flutter中文网" class="headerlink" title="4 Flutter中文网"></a>4 Flutter中文网</h3><ul>
<li><a href="https://flutterchina.club/get-started/codelab/" target="_blank" rel="noopener">编写第一个Flutter应用</a></li>
<li><a href="https://flutterchina.club/get-started/learn-more/" target="_blank" rel="noopener">了解更多</a></li>
</ul>
<h3 id="5-先抄几个demo"><a href="#5-先抄几个demo" class="headerlink" title="5 先抄几个demo"></a>5 先抄几个demo</h3><ul>
<li>自带示例 flutter/examples </li>
<li>其它dome <a href="https://github.com/iampawan/FlutterExampleApps" target="_blank" rel="noopener">https://github.com/iampawan/FlutterExampleApps</a></li>
<li>资料汇总 <a href="https://github.com/Solido/awesome-flutter" target="_blank" rel="noopener">https://github.com/Solido/awesome-flutter</a></li>
</ul>
<h3 id="6-按部就班"><a href="#6-按部就班" class="headerlink" title="6 按部就班"></a>6 按部就班</h3><p>&emsp;&emsp;按中文网目录往下琢磨就好了</p>
<h3 id="7-了解更好"><a href="#7-了解更好" class="headerlink" title="7 了解更好"></a>7 了解更好</h3><ul>
<li><a href="https://flutterchina.club/flutter-for-ios/" target="_blank" rel="noopener">Flutter for iOS 开发</a>  速读即可</li>
<li><a href="https://flutterchina.club/faq/" target="_blank" rel="noopener">Flutter中文网-常见问题</a></li>
<li>Flutter右上角的《Flutter实战》快速浏览即可。附上我画的思维导图 链接:<a href="https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg</a> 提取码: 9w7a </li>
</ul>
<h3 id="8-Hot-reload-（热重载）Not-Hot-fix-（热修复）"><a href="#8-Hot-reload-（热重载）Not-Hot-fix-（热修复）" class="headerlink" title="8 Hot reload （热重载）Not Hot fix （热修复）"></a>8 Hot reload （热重载）Not Hot fix （热修复）</h3><h3 id="9-add-flutter-to-App"><a href="#9-add-flutter-to-App" class="headerlink" title="9 add flutter to App"></a>9 add flutter to App</h3><ul>
<li>官网 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps</a></li>
<li>官方dome（不能用） <a href="https://github.com/flutter/ios_add2app" target="_blank" rel="noopener">https://github.com/flutter/ios_add2app</a> ，稍微改了改 链接:<a href="https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg</a> 提取码: 9w7a</li>
</ul>
<h3 id="10-我遇到的小问题"><a href="#10-我遇到的小问题" class="headerlink" title="10 我遇到的小问题"></a>10 我遇到的小问题</h3><ul>
<li><a href="https://www.cnblogs.com/mmcc/p/5133645.html" target="_blank" rel="noopener">android studio 断点调试和高级调试</a></li>
<li><a href="https://juejin.im/post/5b2b21bc51882574b629f8a0" target="_blank" rel="noopener">Flutter视图基础简介–Widget、Element、RenderObject</a> Widget是类定义，Element是实例对象，rednerObject负责实例对象的布局</li>
<li><a href="https://stackoverflow.com/questions/51061147/what-is-the-difference-between-material-and-materialapp-in-flutter" target="_blank" rel="noopener">What is the difference between Material and MaterialApp in Flutter?</a> MaterialApp定义包含appbar之类的app，Scaffold帮助构建对应的appbar</li>
<li><a href="https://stackoverflow.com/questions/46717971/can-somebody-explain-this-dart-syntax?rq=1" target="_blank" rel="noopener">TapboxA({Key key}) : super(key: key); 是什么意思</a></li>
<li><a href="https://yq.aliyun.com/articles/604054" target="_blank" rel="noopener">Flutter Engine线程管理与Dart Isolate机制</a></li>
<li><a href="https://blog.csdn.net/w411207/article/details/80026649" target="_blank" rel="noopener">Dart - Isolate 并发</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1200792" target="_blank" rel="noopener">Flutter常用widget “Expanded”，“Flexible”</a></li>
<li><a href="https://blog.csdn.net/chenlove1/article/details/83032767" target="_blank" rel="noopener">Flutter Container 参数详解</a></li>
<li><a href="https://blog.csdn.net/lyh1299259684/article/details/80565419" target="_blank" rel="noopener">Dart学习之方法函数</a></li>
<li><a href="https://stackoverflow.com/questions/27683924/how-do-getters-and-setters-change-properties-in-dart" target="_blank" rel="noopener">How do getters and setters change properties in Dart?</a></li>
<li>Dart循环引用？Java的垃圾回收可采用引用计数和寻根两种算法，即java虚拟机循环引用不用管！Dart也是垃圾回收，应该也不用管，没找到关于Dart循环引用的资料</li>
<li><a href="https://www.jianshu.com/p/720b968f4e2c" target="_blank" rel="noopener">Dart中实现单例模式</a></li>
<li>rerturn (); 用分号，其它的情况用 , 逗号</li>
<li>Dart：并不支持函数的重载</li>
<li><a href="https://news.dartlang.org/2012/06/const-static-final-oh-my.html" target="_blank" rel="noopener">“static”, “final”, and “const” in Dart</a></li>
<li>lutter的ValueChanged 如果有多个不同的值都需要监听怎么办？</li>
<li>Category ？</li>
<li>runtime ？</li>
</ul>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作</title>
    <url>/2017/03/02/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>&emsp;&emsp;说来也奇葩，工作了好几年一直用的svn，Git只是听说过没有过！来了度厂发现都是用的Git（甚至码神训练营还专门讲Git的使用）慢慢的才发现Git真好用！这不又不知道水什么了，拿Git充数吧</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统！Linus（创建Linux的大牛）花了两周时间用C语言写了Git！而我花了两周都没学会怎么用！！！</p>
<p>&emsp;&emsp;Mac上安装Git最简单的方式：安装XCode，运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<p>&emsp;&emsp;推荐使用SourceTree管理Git，简单、强大又免费！会用SourceTree的可以不用看了！</p>
<h4 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h4><p>&emsp;&emsp;安利一个命令行工具：iTerm，感觉比自带的好</p>
<ul>
<li><p>初始化一个Git仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 切换到一个目录，创建目录同名仓库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加文件到Git仓库，分两步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 放到暂存区</span><br><span class="line">git add &lt;file&gt; 添加，可一次添加多个文件，也可添加多次</span><br><span class="line">git add . 添加所有修改文件</span><br><span class="line"></span><br><span class="line">// 提交到分支</span><br><span class="line">git commit -m &lt;message&gt; 提交，message为备注</span><br><span class="line">// 合并上次和这一次修改后的，一起提交</span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line">// 把本地库的内容推送到远程</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>
</li>
<li><p>状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 仓库当前的状态</span><br><span class="line">git status</span><br><span class="line">// 查看文件修改内容</span><br><span class="line">git diff &lt;file&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看历史记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log</span><br><span class="line">// 简化输出信息</span><br><span class="line">git log --pretty=oneline</span><br><span class="line"></span><br><span class="line">// 查询结果如下</span><br><span class="line">// HEAD表示当前版本  xxxxx和yyyy是刚才commit的message</span><br><span class="line">9e5d99cf787fe37967247e67afce4e4686a3eeab (HEAD -&gt; Test1.4.2, origin/Test1.4.2) Motify xxxxxxxxx</span><br><span class="line">ccacbbdd367438350515c55e26563b5f47a59e1f modify  yyyyyyyy</span><br><span class="line"></span><br><span class="line">查询自己用过的命令不是提交记录（不要用上下键啦）</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制版本回滚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard ccacbbdd367438350</span><br></pre></td></tr></table></figure>
</li>
<li><p>一键还原</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 只回滚工作区</span><br><span class="line">// 如果暂存区有东西（即add过）回滚到暂存区状态；如果暂存区没东西，回滚线上状态</span><br><span class="line">git checkout -- &lt;file&gt;  // 两个横线</span><br><span class="line"></span><br><span class="line">// 一键还原工作区和暂存区文件</span><br><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件（其实我一直都是直接add来操作的）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用命令git rm删掉，并且git commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 查看本地分支</span><br><span class="line">git branch</span><br><span class="line">// 查看本地和远程所有分支</span><br><span class="line">git branch -a</span><br><span class="line">// 创建并切换到本地分支dev</span><br><span class="line">git checkout -b dev // 注意一个横线</span><br><span class="line">// 切换回master分支</span><br><span class="line">// 一般应保证master是非常稳定的,干活都在dev分支上，dev分支是不稳定的</span><br><span class="line">// Git工作区未提交代码，切换分支时，能提交的话就add并commit一起先提交了，不提交的就stash保存一下，就可以切换了</span><br><span class="line">git checkout master</span><br><span class="line">// 合并指定分支到当前分支，不能看出来</span><br><span class="line">git merge dev</span><br><span class="line">// 合并分支，能看出来！推荐</span><br><span class="line">git merge --no-ff </span><br><span class="line">// 有冲突 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 必须首先解决冲突，再提交，合并完成。</span><br><span class="line">// 查看分支合并图</span><br><span class="line">git log --graph</span><br><span class="line">// 删除分支</span><br><span class="line">git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂存工作区修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 暂存</span><br><span class="line">git stash</span><br><span class="line">// 查看所有暂存</span><br><span class="line">git stash list</span><br><span class="line">// 从暂存中恢复</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git pull</span><br><span class="line">// 如果git pull提示no trackinginformation，则说明本地分支和远程分支的链接关系没有创建，用命令</span><br><span class="line">git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 新建标签，用-a指定标签名，-m指定说明文字</span><br><span class="line">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br><span class="line">// 查看所有标签</span><br><span class="line">git tag</span><br><span class="line">// 删除标签</span><br><span class="line">git tag -d v0.1</span><br><span class="line">// 推送某个标签到远程</span><br><span class="line">git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>看某个具体的 commit 的改动内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git show commitId</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程 廖雪峰</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM入门</title>
    <url>/2017/08/20/LLVM%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>&emsp;&emsp;LLVM是一个好用、好玩，而且超前的系统语言（比如C和C++语言）编译器。LLVM的<a href="http://llvm.org" target="_blank" rel="noopener">官网</a> 和 <a href="https://www.bookstack.cn/read/clang-llvm/README.md" target="_blank" rel="noopener">中文版</a>，此外初学入门可参考<a href="https://blog.csdn.net/snsn1984/column/info/llvm" target="_blank" rel="noopener">LLVM零基础学习</a>的学习思路</p>
<p>&emsp;&emsp;LLVM强大的原因：1. LLVM的“中间表示”（IR）是一项大创新。2. 模块化</p>
<p>&emsp;&emsp;Everything is a lib. Everything is a value.</p>
<p>&emsp;&emsp;LLVM的组成部分：<br><img src="http://www.aosabook.org/images/llvm/SimpleCompiler.png" alt="image"></p>
<ul>
<li>前端，获取你的源代码然后将它转变为某种中间表示。Clang其实就是前端</li>
<li>流程（Pass），将程序在中间表示之间互相变换。一般情况下，流程也用来优化代码：流程输出的（中间表示）程序和它输入的（中间表示）程序相比在功能上完全相同，只是在性能上得到改进。</li>
<li>后端，可以生成实际运行的机器码。</li>
</ul>
<p>&emsp;&emsp;LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 The Architecture of Open Source Applications 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于：<a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="noopener">LLVM 架构</a></p>
<p><img src="http://www.aosabook.org/images/llvm/RetargetableCompiler.png" alt="image"></p>
<h4 id="1-1-重要文档"><a href="#1-1-重要文档" class="headerlink" title="1.1 重要文档"></a>1.1 重要文档</h4><ul>
<li><a href="http://llvm.org/doxygen/" target="_blank" rel="noopener">自动生成的Doxygen文档页</a>非常重要。</li>
<li><a href="http://llvm.org/docs/index.html" target="_blank" rel="noopener">LLVM的文档</a>的<a href="https://blog.csdn.net/snsn1984/article/details/8165529" target="_blank" rel="noopener">分类简介</a>，其中<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">语言参考手册</a>也非常有用</li>
<li><a href="http://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">开发者手册</a>描述了一些LLVM特有的数据结构的工具，<a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">编写LLVM流程</a></li>
<li>不过在在线浏览LLVM代码时，这个<a href="https://github.com/llvm-mirror/llvm" target="_blank" rel="noopener">GitHub镜像</a>有时会更方便。</li>
<li>推荐的入门书：《Getting Started with LLVM Core Libraries》</li>
</ul>
<h4 id="1-2-LLVM的IR"><a href="#1-2-LLVM的IR" class="headerlink" title="1.2 LLVM的IR"></a>1.2 LLVM的IR</h4><p>&emsp;&emsp;<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM IR的介绍</a>，LLVM的IR是中间文件，是通用的，便于前后端扩展。LLVM的IR主要有三种格式：一种是在内存中的编译中间语言；一种是硬盘上存储的二进制中间语言（以.bc结尾），最后一种是可读的中间格式（以.ll结尾）。这三种中间格式是完全相等的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello.c文件</span><br><span class="line"></span><br><span class="line">//得到二进制的.bc文件</span><br><span class="line">clang -emit-llvm -c hello.c -o hello.bc </span><br><span class="line"></span><br><span class="line">// 得到对应的hello.ll文件</span><br><span class="line">llvm-dis hello.bc</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>TODO: LLVM IR的语法简介</strong></p>
<h4 id="1-3-LLVM-的Pass"><a href="#1-3-LLVM-的Pass" class="headerlink" title="1.3 LLVM 的Pass"></a>1.3 LLVM 的Pass</h4><p>&emsp;&emsp;在LLVM中优化以pass形式实现,每一个pass代表一种优化,可以把每个Pass看成一个小模块，可单独使用也可组合使用。所有的Pass都是继承自Pass类的, 基本上分为两类, 一类是分析analysis pass (存放在lib/Analysis下), 负责收集信息共其它pass使用, 辅助调试或使程序可视化; 另一类是变换transform pass (存放在lib/Transforms下), 改变程序的dataflow / controlflow. LLVM中实现了几十种优化pass, 其中许多pass运行不止一次</p>
<p>&emsp;&emsp;在文档 <a href="http://llvm.org/docs/Passes.html" target="_blank" rel="noopener">http://llvm.org/docs/Passes.html</a> 中，列出了所有的PASS的命令行参数以及这个PASS主要是做什么用的，<a href="http://llvm.org/docs/doxygen/html/classllvm_1_1Pass.html" target="_blank" rel="noopener">思维导图版</a></p>
<h4 id="1-4-LLVM的源码结构"><a href="#1-4-LLVM的源码结构" class="headerlink" title="1.4 LLVM的源码结构"></a>1.4 LLVM的源码结构</h4><p>&emsp;&emsp;参考：<a href="https://blog.csdn.net/snsn1984/article/details/8170575" target="_blank" rel="noopener">https://blog.csdn.net/snsn1984/article/details/8170575</a></p>
<ul>
<li>llvm/examples 这个目录主要是一些简单例子，演示如何使用LLVM IR 和 JIT。还有建立一个简单的编译器的例子的代码。</li>
<li>llvm/include  这个目录主要包含LLVM library的公共头文件。</li>
<li>llvm/lib      这个目录包含了大部分的LLVM的源码。在LLVM中大部分的源码都是以库的形式存在的，这样不同的工具之前就很容易共用代码。</li>
<li>llvm/projects 这个目录包含着一些依赖LLVM的工程，这些工程严格来说又不算LLVM一部分。</li>
<li>llvm/runtimes 这个目录包含了一些库，这些库会编译成LLVM的bitcode，然后当clang linking 程序的时候使用。</li>
<li>llvm/test     这个目录是LLVM的测试套件，包含了很多测试用例，这些测试用例是测试LLVM的所有基本功能的。</li>
<li>llvm/tools    这个目录理是各个工具的源码，这些工具都是建立在刚才上面的那些库的基础之上的。也是主要的用户接口</li>
<li>llvm/utils    这个目录包含了一些和LLVM源码一起工作的应用。有些应用在LLVM的编译过程中是不可或缺的。</li>
</ul>
<h3 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令</h3><h4 id="3-1-基本命令"><a href="#3-1-基本命令" class="headerlink" title="3.1 基本命令"></a>3.1 基本命令</h4><ul>
<li>llvm-as 解释 LLVM assembler 汇编器</li>
<li>llvm-dis 解释 LLVM disassembler 反汇编器</li>
<li>opt 解释 LLVM optimizer 优化器</li>
<li>llc 解释 LLVM static compiler 静态编译器</li>
<li>lli 解释 directly execute programs from LLVM bitcode 直接执行LLVM 字节码</li>
<li>llvm-link 解释 LLVM bitcode linker 字节码连接器</li>
<li>llvm-ar 解释 LLVM archiver 归档器</li>
<li>llvm-nm -list LLVM bitcode and object file’s symbol table 列出LLVM字节码和目标文件中的符号表</li>
<li>llvm-config 解释 Print LLVM compilation options 打印LLVM编译选项</li>
<li>llvm-diff 解释 LLVM structual ‘diff’ LLVM结构上的diff</li>
<li>llvm-cov 解释 emit coverage information 省略覆盖信息</li>
<li>llvm-stress 解释 generate random .ll files 生成随机的.ll文件</li>
<li>llvm-symbolizer 解释 convert addresses into source code locations 把地址值转换成源代码位置</li>
</ul>
<h4 id="3-2-调试工具"><a href="#3-2-调试工具" class="headerlink" title="3.2 调试工具"></a>3.2 调试工具</h4><ul>
<li>bugpoint 解释 automatic test case reduction tool 自动测试用例下降工具</li>
<li>llvm-extract 解释 extract a function from an LLVM module 从LLVM模块中抽取一个函数</li>
<li>llvm-bcanalyzer 解释 LLVM bitcode analyzer LLVM字节码分析器</li>
</ul>
<h4 id="3-3-开发者工具"><a href="#3-3-开发者工具" class="headerlink" title="3.3 开发者工具"></a>3.3 开发者工具</h4><ul>
<li>FileCheck 解释 Flexible pattern matching file verifier 弹性模式匹配的文件验证器</li>
<li>tblgen 解释 Target Description To C++ Code Generator 目标描述到C++代码生成器</li>
<li>lit 解释 LLVM Integrated Tester LLVM集成的测试器</li>
<li>llvm-build 解释 LLVM Project Build Utility LLVM项目生成工具</li>
<li>llvm-readobj 解释 LLVM Object Reader LLVM目标文件阅读器</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://llvm.org" target="_blank" rel="noopener">官网</a> 和 <a href="https://www.bookstack.cn/read/clang-llvm/README.md" target="_blank" rel="noopener">中文版</a></li>
<li><a href="https://objccn.io/issue-6-2/" target="_blank" rel="noopener">objc中国：编译器</a></li>
<li><a href="https://blog.csdn.net/snsn1984/column/info/llvm" target="_blank" rel="noopener">LLVM零基础学习</a></li>
<li><a href="https://blog.csdn.net/snsn1984/column/info/llvm-study/3" target="_blank" rel="noopener">LLVM每日谈</a></li>
<li><a href="http://llvmweekly.org" target="_blank" rel="noopener">LLVM Weekly</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQwNDYyMg==&amp;mid=2247486617&amp;idx=2&amp;sn=646f0600f2713eab67a25adacbdbbe5c&amp;source=41#wechat_redirect" target="_blank" rel="noopener">为什么人人都该懂点LLVM</a></li>
<li><a href="https://lowlevelbits.org/getting-started-with-llvm/clang-on-os-x/" target="_blank" rel="noopener">GETTING STARTED WITH LLVM/CLANG ON OS X</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>MJRefresh或SVPullToRefresh 都干了什么？</title>
    <url>/2017/09/28/MJRefresh%E6%88%96SVPullToRefresh%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h3 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h3><p>MJRefresh的prepare和placeSubView巧妙的利用self特征，即self表示的是当前的实例对象，重写父类方法，再调用的时候就会调用到对应子类的实际placeSubview方法，即重载；第二个有意思的地方是 属性的setter实例化view就直接加上了；第三监听contentoffset的偏移量来设置state</p>
<ol>
<li><p>基类，注意scrollView的声明方式 weak以及readonly的写法;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 刷新控件的基类 */</span><br><span class="line">@interface MJRefreshComponent : UIView</span><br><span class="line">&#123;</span><br><span class="line">    /** 记录scrollView刚开始的inset */</span><br><span class="line">    UIEdgeInsets _scrollViewOriginalInset;</span><br><span class="line">    /** 父控件 */</span><br><span class="line">    __weak UIScrollView *_scrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 交给子类去访问</span><br><span class="line">/** 记录scrollView刚开始的inset */</span><br><span class="line">@property (assign, nonatomic, readonly) UIEdgeInsets scrollViewOriginalInset;</span><br><span class="line">/** 父控件 */</span><br><span class="line">@property (weak, nonatomic, readonly) UIScrollView *scrollView;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子view初始化在哪里？注意强制子类调用父类方法；因为如果使用init初始化下拉刷新这是的frame是cgrectzero，没法布局；还有一个因素下面讲</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 初始化 */</span><br><span class="line">- (void)prepare NS_REQUIRES_SUPER;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        // 准备工作</span><br><span class="line">        [self prepare];</span><br><span class="line">        </span><br><span class="line">        // 默认是普通状态</span><br><span class="line">        self.state = MJRefreshStateIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prepare</span><br><span class="line">&#123;</span><br><span class="line">    // 基本属性</span><br><span class="line">    self.autoresizingMask = UIViewAutoresizingFlexibleWidth;</span><br><span class="line">    self.backgroundColor = [UIColor clearColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子view的布局在哪里？注意强制子类调用父类方法；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** 摆放子控件frame */</span><br><span class="line">- (void)placeSubviews NS_REQUIRES_SUPER;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [self placeSubviews];</span><br><span class="line">    </span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeSubviews&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子view的加载方式:weak、懒加载、另外懒加载时就直接addsubview了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (weak, nonatomic) UIActivityIndicatorView *loadingView;</span><br><span class="line"></span><br><span class="line">#pragma mark - 懒加载子控件</span><br><span class="line">- (UIActivityIndicatorView *)loadingView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_loadingView) &#123;</span><br><span class="line">        UIActivityIndicatorView *loadingView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:self.activityIndicatorViewStyle];</span><br><span class="line">        loadingView.hidesWhenStopped = YES;</span><br><span class="line">        [self addSubview:_loadingView = loadingView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _loadingView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>巧妙地关联对象; 这样就不需要专门的addSubView时机了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setMj_header:(MJRefreshHeader *)mj_header</span><br><span class="line">&#123;</span><br><span class="line">    if (mj_header != self.mj_header) &#123;</span><br><span class="line">        // 删除旧的，添加新的</span><br><span class="line">        [self.mj_header removeFromSuperview];</span><br><span class="line">        // 插到tablview的最顶层</span><br><span class="line">        [self insertSubview:mj_header atIndex:0];</span><br><span class="line">        </span><br><span class="line">        // 存储新的</span><br><span class="line">        objc_setAssociatedObject(self, &amp;MJRefreshHeaderKey,</span><br><span class="line">                                 mj_header, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MJRefreshHeader *)mj_header</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;MJRefreshHeaderKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置tableView.mj_header 出发 [self insertSubview:mj_header atIndex:0]; 然后就触发了willMoveToSuperview</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</span><br><span class="line">&#123;</span><br><span class="line">    [super willMoveToSuperview:newSuperview];</span><br><span class="line">    </span><br><span class="line">    // 如果不是UIScrollView，不做任何事情</span><br><span class="line">    if (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[UIScrollView class]]) return;</span><br><span class="line">    </span><br><span class="line">    // 旧的父控件移除监听</span><br><span class="line">    [self removeObservers];</span><br><span class="line">    </span><br><span class="line">    if (newSuperview) &#123; // 新的父控件</span><br><span class="line">        // 设置宽度</span><br><span class="line">        self.mj_w = newSuperview.mj_w;</span><br><span class="line">        // 设置位置</span><br><span class="line">        self.mj_x = -_scrollView.mj_insetL;</span><br><span class="line">        </span><br><span class="line">        // 记录UIScrollView</span><br><span class="line">        _scrollView = (UIScrollView *)newSuperview;</span><br><span class="line">        // 设置永远支持垂直弹簧效果</span><br><span class="line">        _scrollView.alwaysBounceVertical = YES;</span><br><span class="line">        // 记录UIScrollView最开始的contentInset</span><br><span class="line">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class="line">        </span><br><span class="line">        // 添加监听</span><br><span class="line">        [self addObservers];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听ContentOffset，ContentSize和手势，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addObservers</span><br><span class="line">&#123;</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil];</span><br><span class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil];</span><br><span class="line">    self.pan = self.scrollView.panGestureRecognizer;</span><br><span class="line">    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>state状态改变则需要刷新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    _state = state;</span><br><span class="line">    </span><br><span class="line">    // 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue([self setNeedsLayout];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意VC切换问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)beginRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">        self.alpha = 1.0;</span><br><span class="line">    &#125;];</span><br><span class="line">    self.pullingPercent = 1.0;</span><br><span class="line">    // 只要正在刷新，就完全显示</span><br><span class="line">    if (self.window) &#123;</span><br><span class="line">        self.state = MJRefreshStateRefreshing;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 预防正在刷新中时，调用本方法使得header inset回置失败</span><br><span class="line">        if (self.state != MJRefreshStateRefreshing) &#123;</span><br><span class="line">            self.state = MJRefreshStateWillRefresh;</span><br><span class="line">            // 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span><br><span class="line">            [self setNeedsDisplay];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示之前</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    </span><br><span class="line">    if (self.state == MJRefreshStateWillRefresh) &#123;</span><br><span class="line">        // 预防view还没显示出来就调用了beginRefreshing</span><br><span class="line">        self.state = MJRefreshStateRefreshing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>endRefreshing, state状态驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark 结束刷新状态</span><br><span class="line">- (void)endRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue(self.state = MJRefreshStateIdle;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="SVPullToRefresh"><a href="#SVPullToRefresh" class="headerlink" title="SVPullToRefresh"></a>SVPullToRefresh</h3><ol>
<li><p>手动调用KVO</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setPullToRefreshView:(SVPullToRefreshView *)pullToRefreshView &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;SVPullToRefreshView&quot;];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;UIScrollViewPullToRefreshView,</span><br><span class="line">                             pullToRefreshView,</span><br><span class="line">                             OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    [self didChangeValueForKey:@&quot;SVPullToRefreshView&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SVPullToRefreshView *)pullToRefreshView &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;UIScrollViewPullToRefreshView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一如既往的弱引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, weak) UIScrollView *scrollView;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一定要计算inset，实际上上面MJ也保存了inset，思路是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.originalTopInset = self.contentInset.top;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多监听了一个frame</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self addObserver:self.pullToRefreshView forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">[self addObserver:self.pullToRefreshView forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">[self addObserver:self.pullToRefreshView forKeyPath:@&quot;frame&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听contentOffset然后手动调scrollViewDidScroll，总感觉怪怪的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if([keyPath isEqualToString:@&quot;contentOffset&quot;])</span><br><span class="line">        [self scrollViewDidScroll:[[change valueForKey:NSKeyValueChangeNewKey] CGPointValue]];</span><br><span class="line">    else if([keyPath isEqualToString:@&quot;contentSize&quot;]) &#123;</span><br><span class="line">        [self layoutSubviews];</span><br><span class="line">        </span><br><span class="line">        CGFloat yOrigin;</span><br><span class="line">        switch (self.position) &#123;</span><br><span class="line">            case SVPullToRefreshPositionTop:</span><br><span class="line">                yOrigin = -SVPullToRefreshViewHeight;</span><br><span class="line">                break;</span><br><span class="line">            case SVPullToRefreshPositionBottom:</span><br><span class="line">                yOrigin = MAX(self.scrollView.contentSize.height, self.scrollView.bounds.size.height);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        self.frame = CGRectMake(0, yOrigin, self.bounds.size.width, SVPullToRefreshViewHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    else if([keyPath isEqualToString:@&quot;frame&quot;])</span><br><span class="line">        [self layoutSubviews];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)scrollViewDidScroll:(CGPoint)contentOffset &#123;</span><br><span class="line">    if(self.state != SVPullToRefreshStateLoading) &#123;</span><br><span class="line">        CGFloat scrollOffsetThreshold = 0;</span><br><span class="line">        switch (self.position) &#123;</span><br><span class="line">            case SVPullToRefreshPositionTop:</span><br><span class="line">                scrollOffsetThreshold = self.frame.origin.y - self.originalTopInset;</span><br><span class="line">                break;</span><br><span class="line">            case SVPullToRefreshPositionBottom:</span><br><span class="line">                scrollOffsetThreshold = MAX(self.scrollView.contentSize.height - self.scrollView.bounds.size.height, 0.0f) + self.bounds.size.height + self.originalBottomInset;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(!self.scrollView.isDragging &amp;&amp; self.state == SVPullToRefreshStateTriggered)</span><br><span class="line">            self.state = SVPullToRefreshStateLoading;</span><br><span class="line">        else if(contentOffset.y &lt; scrollOffsetThreshold &amp;&amp; self.scrollView.isDragging &amp;&amp; self.state == SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionTop)</span><br><span class="line">            self.state = SVPullToRefreshStateTriggered;</span><br><span class="line">        else if(contentOffset.y &gt;= scrollOffsetThreshold &amp;&amp; self.state != SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionTop)</span><br><span class="line">            self.state = SVPullToRefreshStateStopped;</span><br><span class="line">        else if(contentOffset.y &gt; scrollOffsetThreshold &amp;&amp; self.scrollView.isDragging &amp;&amp; self.state == SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionBottom)</span><br><span class="line">            self.state = SVPullToRefreshStateTriggered;</span><br><span class="line">        else if(contentOffset.y &lt;= scrollOffsetThreshold &amp;&amp; self.state != SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionBottom)</span><br><span class="line">            self.state = SVPullToRefreshStateStopped;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CGFloat offset;</span><br><span class="line">        UIEdgeInsets contentInset;</span><br><span class="line">        switch (self.position) &#123;</span><br><span class="line">            case SVPullToRefreshPositionTop:</span><br><span class="line">                offset = MAX(self.scrollView.contentOffset.y * -1, 0.0f);</span><br><span class="line">                offset = MIN(offset, self.originalTopInset + self.bounds.size.height);</span><br><span class="line">                contentInset = self.scrollView.contentInset;</span><br><span class="line">                self.scrollView.contentInset = UIEdgeInsetsMake(offset, contentInset.left, contentInset.bottom, contentInset.right);</span><br><span class="line">                break;</span><br><span class="line">            case SVPullToRefreshPositionBottom:</span><br><span class="line">                if (self.scrollView.contentSize.height &gt;= self.scrollView.bounds.size.height) &#123;</span><br><span class="line">                    offset = MAX(self.scrollView.contentSize.height - self.scrollView.bounds.size.height + self.bounds.size.height, 0.0f);</span><br><span class="line">                    offset = MIN(offset, self.originalBottomInset + self.bounds.size.height);</span><br><span class="line">                    contentInset = self.scrollView.contentInset;</span><br><span class="line">                    self.scrollView.contentInset = UIEdgeInsetsMake(contentInset.top, contentInset.left, offset, contentInset.right);</span><br><span class="line">                &#125; else if (self.wasTriggeredByUser) &#123;</span><br><span class="line">                    offset = MIN(self.bounds.size.height, self.originalBottomInset + self.bounds.size.height);</span><br><span class="line">                    contentInset = self.scrollView.contentInset;</span><br><span class="line">                    self.scrollView.contentInset = UIEdgeInsetsMake(-offset, contentInset.left, contentInset.bottom, contentInset.right);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>subView的加载倒是出奇的一致！唯一区别是MJ用weak修饰，其实我也觉得应该用weak</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong, readwrite) UILabel *titleLabel;</span><br><span class="line"></span><br><span class="line">- (UILabel *)titleLabel &#123;</span><br><span class="line">    if(!_titleLabel) &#123;</span><br><span class="line">        _titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 210, 20)];</span><br><span class="line">        _titleLabel.text = NSLocalizedString(@&quot;Pull to refresh...&quot;,);</span><br><span class="line">        _titleLabel.font = [UIFont boldSystemFontOfSize:14];</span><br><span class="line">        _titleLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">        _titleLabel.textColor = textColor;</span><br><span class="line">        [self addSubview:_titleLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return _titleLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>都是通过state状态驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setState:(SVPullToRefreshState)newState &#123;</span><br><span class="line">    </span><br><span class="line">    if(_state == newState)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    SVPullToRefreshState previousState = _state;</span><br><span class="line">    _state = newState;</span><br><span class="line">    </span><br><span class="line">    [self setNeedsLayout];</span><br><span class="line">    [self layoutIfNeeded];</span><br><span class="line">    </span><br><span class="line">    switch (newState) &#123;</span><br><span class="line">        case SVPullToRefreshStateAll:</span><br><span class="line">        case SVPullToRefreshStateStopped:</span><br><span class="line">            [self resetScrollViewContentInset];</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case SVPullToRefreshStateTriggered:</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case SVPullToRefreshStateLoading:</span><br><span class="line">            [self setScrollViewContentInsetForLoading];</span><br><span class="line">            </span><br><span class="line">            if(previousState == SVPullToRefreshStateTriggered &amp;&amp; pullToRefreshActionHandler)</span><br><span class="line">                pullToRefreshActionHandler();</span><br><span class="line">            </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O文件</title>
    <url>/2017/09/29/Mach-O%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;大家都知道iOS编译到最后是Mach-O文件，其实就是iOS或OS X的可执行文件！</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>&emsp;&emsp;最后给大家安利两个工具：1、<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView:mach-o文件解析器</a>可直接查看mach-o文件；2、OSX系统自带的otool可以分析Mach-O可执行文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/852671-9fde036a1ce9d902.jpg?imageMogr2/auto-orient/" alt="image"></p>
<h4 id="1-Header"><a href="#1-Header" class="headerlink" title="1 Header"></a>1 Header</h4><p>&emsp;&emsp;下载<a href="https://opensource.apple.com/tarballs/xnu/" target="_blank" rel="noopener">源码</a> -&gt; EXTERNAL_HEADERS -&gt; mach-o文件夹 -&gt; loader.h 查看相关源码，32位和64位区别不大，这里只贴了64位的结构<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line">* 64-bit architectures.</span><br><span class="line">*/</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">uint32_t    filetype;    /* type of file */</span><br><span class="line">uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">uint32_t    flags;        /* flags */</span><br><span class="line">uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span><br><span class="line">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span><br><span class="line">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;简单解释</p>
<ul>
<li>magic 用于判断程序的平台版本</li>
<li>cputype 和 cpusubtype 用于判断cpu型号和cpu子型号</li>
<li><p>filetype 文件类型,决定了文件布局方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Constants for the filetype field of the mach_header</span><br><span class="line">*/</span><br><span class="line">#define    MH_OBJECT    0x1        /* relocatable object file */</span><br><span class="line">#define    MH_EXECUTE    0x2        /* demand paged executable file */</span><br><span class="line">#define    MH_FVMLIB    0x3        /* fixed VM shared library file */</span><br><span class="line"></span><br><span class="line">等...</span><br></pre></td></tr></table></figure>
</li>
<li><p>ncmds代表Load Command的个数</p>
</li>
<li>sizeofcmds代表ncmds段Load Command的总字节数</li>
<li><p>flags表示dyld加载标志位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Constants for the flags field of the mach_header */</span><br><span class="line">#define    MH_NOUNDEFS    0x1        /* the object file has no undefined</span><br><span class="line">references */</span><br><span class="line">#define    MH_INCRLINK    0x2        /* the object file is the output of an</span><br><span class="line"></span><br><span class="line">等...</span><br></pre></td></tr></table></figure>
</li>
<li><p>reserved是x64的保留位</p>
</li>
</ul>
<h3 id="2-Load-Command"><a href="#2-Load-Command" class="headerlink" title="2 Load Command"></a>2 Load Command</h3><p>&emsp;&emsp;先看源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">uint32_t cmd;</span><br><span class="line">uint32_t cmdsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;每一个command前两个字段必须是CMD和CMDSIZE，且每一个都是一个特殊的结构体，所以除了cmd之外还需要cmdsize<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Constants for the cmd field of all load commands, the type */</span><br><span class="line">#define    LC_SEGMENT    0x1    /* segment of this file to be mapped */</span><br><span class="line">#define    LC_SYMTAB    0x2    /* link-edit stab symbol table info */</span><br><span class="line"></span><br><span class="line">等...</span><br></pre></td></tr></table></figure></p>
<h3 id="3-segment-command"><a href="#3-segment-command" class="headerlink" title="3 segment_command"></a>3 segment_command</h3><p>&emsp;&emsp;直接使用LC_xxx搜索就能搜到相应的cmd数据结构，直接搜索LC_SEGMENT ，查看segment的结构<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">* The 64-bit segment load command indicates that a part of this file is to be</span><br><span class="line">* mapped into a 64-bit task&apos;s address space.  If the 64-bit segment has</span><br><span class="line">* sections then section_64 structures directly follow the 64-bit segment</span><br><span class="line">* command and their size is reflected in cmdsize.</span><br><span class="line">*/</span><br><span class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</span><br><span class="line">uint32_t    cmd;        /* LC_SEGMENT_64 */</span><br><span class="line">uint32_t    cmdsize;    /* includes sizeof section_64 structs */</span><br><span class="line">char        segname[16];    /* segment name */</span><br><span class="line">uint64_t    vmaddr;        /* memory address of this segment */</span><br><span class="line">uint64_t    vmsize;        /* memory size of this segment */</span><br><span class="line">uint64_t    fileoff;    /* file offset of this segment */</span><br><span class="line">uint64_t    filesize;    /* amount to map from the file */</span><br><span class="line">vm_prot_t    maxprot;    /* maximum VM protection */</span><br><span class="line">vm_prot_t    initprot;    /* initial VM protection */</span><br><span class="line">uint32_t    nsects;        /* number of sections in segment */</span><br><span class="line">uint32_t    flags;        /* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意问题（大小写敏感）</p>
<ul>
<li>__TEXT segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</li>
<li>__DATA segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</li>
</ul>
<h3 id="4-section"><a href="#4-section" class="headerlink" title="4 section"></a>4 section</h3><p>&emsp;&emsp;源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">char        sectname[16];    /* name of this section */</span><br><span class="line">char        segname[16];    /* segment this section goes in */</span><br><span class="line">uint64_t    addr;        /* memory address of this section */</span><br><span class="line">uint64_t    size;        /* size in bytes of this section */</span><br><span class="line">uint32_t    offset;        /* file offset of this section */</span><br><span class="line">uint32_t    align;        /* section alignment (power of 2) */</span><br><span class="line">uint32_t    reloff;        /* file offset of relocation entries */</span><br><span class="line">uint32_t    nreloc;        /* number of relocation entries */</span><br><span class="line">uint32_t    flags;        /* flags (section type and attributes)*/</span><br><span class="line">uint32_t    reserved1;    /* reserved (for offset or index) */</span><br><span class="line">uint32_t    reserved2;    /* reserved (for count or sizeof) */</span><br><span class="line">uint32_t    reserved3;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;常见的Section，<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/" target="_blank" rel="noopener">更多</a></p>
<table>
<thead>
<tr>
<th>Section</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TEXT.</strong>text</td>
<td>主程序代码</td>
</tr>
<tr>
<td><strong>TEXT.</strong>cstring</td>
<td>C 语言字符串</td>
</tr>
<tr>
<td><strong>TEXT.</strong>const</td>
<td>const 关键字修饰的常量</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs</td>
<td>用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs_helper</td>
<td>当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_methname</td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_methtype</td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_classname</td>
<td>Objective-C 类名称</td>
</tr>
<tr>
<td><strong>DATA.</strong>data</td>
<td>初始化过的可变数据</td>
</tr>
<tr>
<td><strong>DATA.</strong>la_symbol_ptr</td>
<td>lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td>__DATA.nl_symbol_ptr</td>
<td>非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td><strong>DATA.</strong>const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td><strong>DATA.</strong>cfstring</td>
<td>程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td><strong>DATA.</strong>bss</td>
<td>BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td><strong>DATA.</strong>common</td>
<td>没有初始化过的符号声明</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_classlist</td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_protolist</td>
<td>Objective-C 原型</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_imginfo</td>
<td>Objective-C 镜像信息</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_selfrefs</td>
<td>Objective-C self 引用</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_protorefs</td>
<td>Objective-C 原型引用</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_superrefs</td>
<td>Objective-C 超类引用</td>
</tr>
</tbody>
</table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://objccn.io/issue-6-3/" target="_blank" rel="noopener">objc中国 Mach-O 可执行文件</a></li>
<li><a href="https://www.jianshu.com/p/54d842db3f69" target="_blank" rel="noopener">趣探 Mach-O：文件格式分析</a></li>
<li><a href="https://www.jianshu.com/p/8498cec10a41" target="_blank" rel="noopener">趣探 Mach-O：加载过程</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>MRC和ARC混编</title>
    <url>/2014/10/19/MRC%E5%92%8CARC%E6%B7%B7%E7%BC%96/</url>
    <content><![CDATA[<p>&emsp;&emsp; OC中提供了两种内存管理机制MRC（MannulReference Counting）手动引用计数；ARC （Automatic Reference Counting）自动引用计数。<br></p>
<p>&emsp;&emsp; Xcode4.1及其以前版本只有MRC，我们必须手动管理内存，比如要手动retain、release、autorelease等<br></p>
<p>&emsp;&emsp; Xcode4.1后的版本可以使用ARC，让系统自己管理内存。</p>
<p>&emsp;&emsp; ARC 和MRC 混编怎么处理？</p>
<ul>
<li>如果你的工程使用的MRC 模式，则为 ARC 模式的代码文件加入 -fobjc-arc 标签。</li>
<li>如果你的工程使用的是 ARC 模式，则为MRC 模式的代码文件加入 -fno-objc-arc 标签。</li>
</ul>
<p>&emsp;&emsp; 位置：打开工程找到target -&gt; Build Phases -&gt; Compile Sources -&gt; 对应的 .m -&gt; 双击CompliperFlags 添加 -fobjc-arc （ARC模式） -fno-objc-arc（MRC模式）-&gt; 保存</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Masonry都干了什么？</title>
    <url>/2017/10/12/Masonry%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<ol>
<li><p>不需要weak strong因为没引用self</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;</span><br><span class="line">    self.translatesAutoresizingMaskIntoConstraints = NO;</span><br><span class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];</span><br><span class="line">    block(constraintMaker);</span><br><span class="line">    return [constraintMaker install];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>make.left.equalTo(@0).offset(1);的解读：.left直接返回self，equalTo是一个block，调用的时候需要也一个参数@0，block返回self。这样又可以调offset</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MASConstraint : NSObject</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)left &#123;</span><br><span class="line">    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">- (MASConstraint * (^)(id attr))equalTo;</span><br><span class="line">- (MASConstraint * (^)(id))equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(CGFloat offset))offset;</span><br><span class="line">- (MASConstraint * (^)(CGFloat))offset &#123;</span><br><span class="line">    return ^id(CGFloat offset)&#123;</span><br><span class="line">        self.offset = offset;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>.left 只是将约束放到了self.constraints</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];</span><br><span class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line">    if ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">        //replace with composite constraint</span><br><span class="line">        NSArray *children = @[constraint, newConstraint];</span><br><span class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">        compositeConstraint.delegate = self;</span><br><span class="line">        [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">        return compositeConstraint;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!constraint) &#123;</span><br><span class="line">        newConstraint.delegate = self;</span><br><span class="line">        [self.constraints addObject:newConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    return newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>equalTo 实际调用的是MASConstraint的equalToWithRelation方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(id))equalTo &#123;</span><br><span class="line">    return ^id(id attribute) &#123;</span><br><span class="line">        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation &#123;</span><br><span class="line">    return ^id(id attribute, NSLayoutRelation relation) &#123;</span><br><span class="line">        if ([attribute isKindOfClass:NSArray.class]) &#123;</span><br><span class="line">            NSAssert(!self.hasLayoutRelation, @&quot;Redefinition of constraint relation&quot;);</span><br><span class="line">            NSMutableArray *children = NSMutableArray.new;</span><br><span class="line">            for (id attr in attribute) &#123;</span><br><span class="line">                MASViewConstraint *viewConstraint = [self copy];</span><br><span class="line">                viewConstraint.layoutRelation = relation;</span><br><span class="line">                viewConstraint.secondViewAttribute = attr;</span><br><span class="line">                [children addObject:viewConstraint];</span><br><span class="line">            &#125;</span><br><span class="line">            MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">            compositeConstraint.delegate = self.delegate;</span><br><span class="line">            [self.delegate constraint:self shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">            return compositeConstraint;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:NSValue.class], @&quot;Redefinition of constraint relation&quot;);</span><br><span class="line">            self.layoutRelation = relation;</span><br><span class="line">            self.secondViewAttribute = attribute;</span><br><span class="line">            return self;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>offset要干的就是保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (MASConstraint * (^)(CGFloat))offset &#123;</span><br><span class="line">    return ^id(CGFloat offset)&#123;</span><br><span class="line">        self.offset = offset;</span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来最主要的方法install,实际调用的是MASViewConstraint的install</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSArray *)install &#123;</span><br><span class="line">    // update或remove需要用到</span><br><span class="line">    if (self.removeExisting) &#123;</span><br><span class="line">        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];</span><br><span class="line">        for (MASConstraint *constraint in installedConstraints) &#123;</span><br><span class="line">            [constraint uninstall];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray *constraints = self.constraints.copy;</span><br><span class="line">    for (MASConstraint *constraint in constraints) &#123;</span><br><span class="line">        constraint.updateExisting = self.updateExisting;</span><br><span class="line">        [constraint install];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.constraints removeAllObjects];</span><br><span class="line">    return constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>MASViewConstraint的install来设置系统约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)install &#123;</span><br><span class="line">    if (self.hasBeenInstalled) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 设置left时设置了firstViewAttribute</span><br><span class="line">    if ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) &#123;</span><br><span class="line">        self.layoutConstraint.active = YES;</span><br><span class="line">        [self.firstViewAttribute.view.mas_installedConstraints addObject:self];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // equalto时设置了secondViewAttribute</span><br><span class="line">    MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item;</span><br><span class="line">    NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute;</span><br><span class="line">    MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item;</span><br><span class="line">    NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute;</span><br><span class="line"></span><br><span class="line">    // alignment attributes must have a secondViewAttribute</span><br><span class="line">    // therefore we assume that is refering to superview</span><br><span class="line">    // eg make.left.equalTo(@10)</span><br><span class="line">    if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) &#123;</span><br><span class="line">        secondLayoutItem = self.firstViewAttribute.view.superview;</span><br><span class="line">        secondLayoutAttribute = firstLayoutAttribute;</span><br><span class="line">    &#125;</span><br><span class="line">    // self.layoutConstant 就是offset(1)</span><br><span class="line">    MASLayoutConstraint *layoutConstraint</span><br><span class="line">        = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line">                                        attribute:firstLayoutAttribute</span><br><span class="line">                                        relatedBy:self.layoutRelation</span><br><span class="line">                                           toItem:secondLayoutItem</span><br><span class="line">                                        attribute:secondLayoutAttribute</span><br><span class="line">                                       multiplier:self.layoutMultiplier</span><br><span class="line">                                         constant:self.layoutConstant];</span><br><span class="line">    </span><br><span class="line">    layoutConstraint.priority = self.layoutPriority;</span><br><span class="line">    layoutConstraint.mas_key = self.mas_key;</span><br><span class="line">    </span><br><span class="line">    if (self.secondViewAttribute.view) &#123;</span><br><span class="line">        MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view];</span><br><span class="line">        NSAssert(closestCommonSuperview,</span><br><span class="line">                 @&quot;couldn&apos;t find a common superview for %@ and %@&quot;,</span><br><span class="line">                 self.firstViewAttribute.view, self.secondViewAttribute.view);</span><br><span class="line">        self.installedView = closestCommonSuperview;</span><br><span class="line">    &#125; else if (self.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line">        self.installedView = self.firstViewAttribute.view;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        self.installedView = self.firstViewAttribute.view.superview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    MASLayoutConstraint *existingConstraint = nil;</span><br><span class="line">    if (self.updateExisting) &#123;</span><br><span class="line">        existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line">    &#125;</span><br><span class="line">    if (existingConstraint) &#123;</span><br><span class="line">        // just update the constant</span><br><span class="line">        existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line">        self.layoutConstraint = existingConstraint;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [self.installedView addConstraint:layoutConstraint];</span><br><span class="line">        self.layoutConstraint = layoutConstraint;</span><br><span class="line">        [firstLayoutItem.mas_installedConstraints addObject:self];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>NS_ENUM&amp;NSOption</title>
    <url>/2015/04/26/NS-ENUM-NSOption/</url>
    <content><![CDATA[<h5 id="为啥要用枚举"><a href="#为啥要用枚举" class="headerlink" title="为啥要用枚举?"></a>为啥要用枚举?</h5><ol>
<li>把别人看不懂的整数起一个别人看起来明白点的名字;</li>
<li>限制整数使用范围</li>
</ol>
<ul>
<li><p>C的枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ZKSwithType &#123;</span><br><span class="line">ZKSwithTypeOn,</span><br><span class="line">ZKSwithTypeOff</span><br><span class="line">&#125;;</span><br><span class="line">// 使用方式</span><br><span class="line">enum ZKSwithType swithType = ZKSwithTypeOn;</span><br></pre></td></tr></table></figure>
</li>
<li><p>iOS推荐写法, 使用更简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, ZKSwithType) &#123;</span><br><span class="line">ZKSwithTypeOn,</span><br><span class="line">ZKSwithTypeOff</span><br><span class="line">&#125;;</span><br><span class="line">// 使用方式</span><br><span class="line">ZKSwithType swithType = ZKSwithTypeOn;</span><br><span class="line">// iOS推荐写法等同于</span><br><span class="line">enum ZKSwithType &#123;</span><br><span class="line">ZKSwithTypeOn,</span><br><span class="line">ZKSwithTypeOff</span><br><span class="line">&#125;;</span><br><span class="line">typedef ZKSwithType ZKSwithType;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NS_OPTIONS是啥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, ZKPosition) &#123;</span><br><span class="line">ZKPositionNone      = 0,</span><br><span class="line">ZKPositionLeft      = 1 &lt;&lt; 0,</span><br><span class="line">ZKPositionTop       = 1 &lt;&lt; 1,</span><br><span class="line">ZKPositionRight     = 1 &lt;&lt; 2,</span><br><span class="line">ZKPositionBottom    = 1 &lt;&lt; 4,</span><br><span class="line">&#125;;</span><br><span class="line">// 等同于，只不过推荐写法更不容易出错</span><br><span class="line">typedef enum : NSUInteger &#123;</span><br><span class="line">ZKPositionNone    = 0,</span><br><span class="line">ZKPositionLeft    = 1,</span><br><span class="line">ZKPositionTop     = 2,</span><br><span class="line">ZKPositionRight   = 4,</span><br><span class="line">ZKPositionBottom  = 8</span><br><span class="line">&#125; ZKPosition;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Method Swizzling</title>
    <url>/2015/08/17/Method-Swizzling/</url>
    <content><![CDATA[<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><ul>
<li>参考：</li>
<li><a href="https://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">https://blog.csdn.net/yiyaaixuexi/article/details/9374411</a></li>
<li><a href="https://nshipster.com/method-swizzling/" target="_blank" rel="noopener">https://nshipster.com/method-swizzling/</a></li>
<li><a href="https://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="noopener">https://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling</a></li>
<li>建议阅读：<a href="https://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c</a></li>
</ul>
<ul>
<li><p>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void SwizzleMethod(Class cls, SEL ori, SEL rep) &#123;</span><br><span class="line">Method oriMethod = class_getInstanceMethod(cls, ori);</span><br><span class="line">Method repMethod = class_getInstanceMethod(cls, rep);</span><br><span class="line"></span><br><span class="line">BOOL flag = class_addMethod(cls, ori, method_getImplementation(repMethod), method_getTypeEncoding(repMethod));</span><br><span class="line"></span><br><span class="line">if (flag) &#123;</span><br><span class="line">class_replaceMethod(cls, rep, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">method_exchangeImplementations(oriMethod, repMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试用例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">+ (void)sleep;</span><br><span class="line">- (void)walk;</span><br><span class="line">@end</span><br><span class="line">@implementation Person</span><br><span class="line">+ (void)sleep &#123;</span><br><span class="line">NSLog(@&quot;睡觉&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)walk &#123;</span><br><span class="line">NSLog(@&quot;去哪里？&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// hook</span><br><span class="line">@interface Person (china)</span><br><span class="line">@end</span><br><span class="line">@implementation Person (china)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">// hook实例方法</span><br><span class="line">SwizzleMethod([self class], @selector(jzk_walk), @selector(walk));</span><br><span class="line">// hook类方法</span><br><span class="line">SwizzleMethod(object_getClass([self class]), @selector(sleep), @selector(jzk_sleep));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)jzk_walk &#123;</span><br><span class="line">[self jzk_walk];</span><br><span class="line">NSLog(@&quot;当然是学校&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)jzk_sleep &#123;</span><br><span class="line">NSLog(@&quot;起来嗨&quot;);</span><br><span class="line">// 注意hook类方法直接用self就好</span><br><span class="line">[self jzk_sleep];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">起来嗨</span><br><span class="line">睡觉</span><br><span class="line">去哪里？</span><br><span class="line">当然是学校</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown语法</title>
    <url>/2014/12/26/MarkDown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li><strong>2018修改支持有道云笔记格式</strong></li>
<li><em>斜体</em></li>
<li><del>删除线</del></li>
<li>++下划线++</li>
<li>==黄色高亮==<h1 id="1级标题"><a href="#1级标题" class="headerlink" title="1级标题"></a>1级标题</h1><h2 id="2级标题"><a href="#2级标题" class="headerlink" title="2级标题"></a>2级标题</h2><h3 id="3级标题"><a href="#3级标题" class="headerlink" title="3级标题"></a>3级标题</h3><h4 id="4级标题"><a href="#4级标题" class="headerlink" title="4级标题"></a>4级标题</h4><h5 id="5级标题"><a href="#5级标题" class="headerlink" title="5级标题"></a>5级标题</h5><h6 id="6级标题"><a href="#6级标题" class="headerlink" title="6级标题"></a>6级标题</h6></li>
</ul>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线 "></a>分割线 </h2><p>引用</p>
<blockquote>
<p>真理就是民兵站在白杨树下迎面吹来一阵东风</p>
</blockquote>
<ul>
<li>分类</li>
<li>二级分类</li>
<li>三级分类</li>
<li>第二分类</li>
</ul>
<ol>
<li>第一</li>
<li>第二</li>
</ol>
<ul>
<li style="list-style: none"><input type="checkbox"> 待办事项</li>
<li style="list-style: none"><input type="checkbox" checked> 已完成</li>
</ul>
<p>html标签</p>
<html><br>&emsp;&emsp;<b>直接兼容html标签</b><br><br></html>


<p>超链接<br><a href="https://mermaidjs.github.io" target="_blank" rel="noopener">流程图、时序图和甘特图  mermaid参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 直接写代码</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图片<br><img src="https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=0fc9b8c7261f95cab2f89ae4a87e145b/1c950a7b02087bf49212ea50f1d3572c10dfcf89.jpg" alt="这里是图片"></p>
<p>表格<br>header 1 | header 2<br>—|—<br>row 1 col 1 | row 1 col 2<br>row 2 col 1 | row 2 col 2</p>
<p>数学公式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E = mc^2</span><br></pre></td></tr></table></figure></p>
<p>流程图，练手各种图形和线 TB - top bottom（自上而下）,LR - left right（从左到右）<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">idA(开始) --描述--&gt; idD&#123;判断&#125;</span><br><span class="line">idD --YES--&gt;idE[过程2]</span><br><span class="line">idD --NO--&gt;idF[异常]</span><br><span class="line">idF --&gt; idZ(结束)</span><br><span class="line">idE --&gt; idZ</span><br><span class="line">idF -.虚线辅助.-&gt; idC((没用节点))</span><br><span class="line"></span><br><span class="line">subgraph 子流程名</span><br><span class="line">idC ==&gt; idG[do something]</span><br><span class="line">idG ==啥意思==&gt; idM&gt;这是啥图]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>时序图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: How about Baidu??</span><br><span class="line">B--&gt;&gt;A: baidu is Great!</span><br><span class="line">note left of B: B左边的注释</span><br><span class="line">note right of A: A右边的注释</span><br><span class="line">participant C</span><br><span class="line">loop ask myself</span><br><span class="line">C-&gt;&gt;C: is baidu good？ </span><br><span class="line">end</span><br><span class="line">note over C:I am alone</span><br></pre></td></tr></table></figure>
<p>甘特图<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">section 设计</span><br><span class="line">已完成:done,id1, 2014-01-01, 5d</span><br><span class="line">正执行:active, idUI,after id1, 2d</span><br><span class="line">section 开发</span><br><span class="line">待修正:crit, 2014-01-07, 9d</span><br><span class="line">section 测试</span><br><span class="line">原计划: 2014-01-02, 9d</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>NSAttributedString</title>
    <url>/2015/04/18/NSAttributedString/</url>
    <content><![CDATA[<h3 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h3><ul>
<li>NSAttributedString 用于实现富文本效果，可在同一字符串实现不同字体颜色大小等定制化</li>
<li>NSAttributedString继承自NSObject， 和NSString没有任何关系！！！</li>
<li>NSAttributedString 采用Key-Value方式设置富文本属性</li>
<li>NSMutableAttributedString是 NSAttributedString 的子类，可以通过insertAttributedString、appendAttributedString等方法拼接字符串</li>
<li>NSRange使用时必须注意注意再注意，很容易crash！PS:汉字和英文字母等都算1个</li>
</ul>
<h3 id="NSAttributedString的使用"><a href="#NSAttributedString的使用" class="headerlink" title="NSAttributedString的使用"></a>NSAttributedString的使用</h3><h4 id="NSAttributedStringKey"><a href="#NSAttributedStringKey" class="headerlink" title="NSAttributedStringKey"></a>NSAttributedStringKey</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//字体，value是UIFont对象</span><br><span class="line">NSFontAttributeName </span><br><span class="line">//设置文本段落排版格式，value是NSParagraphStyle 对象</span><br><span class="line">NSParagraphStyleAttributeName</span><br><span class="line">//设置字体颜色，value是UIColor对象，默认值为黑色</span><br><span class="line">NSForegroundColorAttributeName </span><br><span class="line">//设置字体所在区域背景颜色，value是UIColor对象，默认值为nil, 透明色</span><br><span class="line">NSBackgroundColorAttributeName </span><br><span class="line">//字符连体，value是NSNumber 对象，0 表示没有连体字符，1 表示使用默认的连体字符</span><br><span class="line">NSLigatureAttributeName </span><br><span class="line">//设置字符间距，value是NSNumber ，正值间距加宽，负值间距变窄</span><br><span class="line">NSKernAttributeName </span><br><span class="line">//删除线，value是NSNumber，@(NSUnderlineStyle)</span><br><span class="line">NSStrikethroughStyleAttributeName </span><br><span class="line">//下划线，value是NSNumber，@(NSUnderlineStyle)</span><br><span class="line">NSUnderlineStyleAttributeName </span><br><span class="line">//描绘边颜色，value是UIColor,默认值为nil</span><br><span class="line">NSStrokeColorAttributeName  </span><br><span class="line">//设置笔画宽度(粗细)，value是NSNumber 对象，负值填充效果，正值中空效果</span><br><span class="line">NSStrokeWidthAttributeName </span><br><span class="line">//设置阴影属性，value是NSShadow 对象 默认值为nil</span><br><span class="line">NSShadowAttributeName </span><br><span class="line">//设置文本附件,value是NSTextAttachment对象,常用于文字图片混排,如果附件文档数据指定nil, 那么系统将会默认指定为image对象作为值</span><br><span class="line">NSAttachmentAttributeName </span><br><span class="line">//链接，value是NSURL or NSString,UILabel不能用，可以用UITextView</span><br><span class="line">NSLinkAttributeName </span><br><span class="line">//设置基线偏移值，value是NSNumber,正值上偏，负值下偏, 默认值是0</span><br><span class="line">NSBaselineOffsetAttributeName </span><br><span class="line">//下划线颜色，value是UIColor对象,默认值为nil</span><br><span class="line">NSUnderlineColorAttributeName </span><br><span class="line">//删除线颜色，value是UIColor，默认值为黑色</span><br><span class="line">NSStrikethroughColorAttributeName </span><br><span class="line">//设置字形倾斜度，value是NSNumber,正值右倾，负值左倾, 默认值是0</span><br><span class="line">NSObliquenessAttributeName </span><br><span class="line">//设置文本横向拉伸属性， value是NSNumber,正值横向拉伸文本，负值横向压缩文本</span><br><span class="line">NSExpansionAttributeName </span><br><span class="line">//设置文字排版方向，value是NSNumber，0 表示横排文本，1 表示竖排文本 在iOS中, 总是以横向排版</span><br><span class="line">NSVerticalGlyphFormAttributeName </span><br><span class="line">//设置文字书写方向，从左向右书写或者从右向左书写</span><br><span class="line">NSWritingDirectionAttributeName</span><br></pre></td></tr></table></figure>
<h4 id="设置属性方式"><a href="#设置属性方式" class="headerlink" title="设置属性方式"></a>设置属性方式</h4><ol>
<li><p>整段文字设置属性 initWithString: attributes:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary *attDic = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:30], NSForegroundColorAttributeName:[UIColor redColor]&#125;;</span><br><span class="line">NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@&quot;hello, world&quot; attributes:attDic];</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSMutableAttributedString分块设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];</span><br><span class="line">NSRange range = NSMakeRange(0, 5);</span><br><span class="line">[mAttStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:range];</span><br><span class="line">[mAttStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:range];</span><br></pre></td></tr></table></figure>
</li>
<li><p>先用NSAttributedString，再用NSMutableAttributedString去添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 减少了NSRange计算带来的问题</span><br><span class="line">NSAttributedString *helloAttStr = [[NSAttributedString alloc] initWithString:@&quot;hello&quot; attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:30], NSForegroundColorAttributeName:[UIColor redColor]&#125;];</span><br><span class="line">NSAttributedString *worldAttStr = [[NSAttributedString alloc] initWithString:@&quot;, world&quot; attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20], NSForegroundColorAttributeName:[UIColor blackColor]&#125;];</span><br><span class="line">NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] init];</span><br><span class="line">[mAttStr appendAttributedString:helloAttStr];</span><br><span class="line">[mAttStr appendAttributedString:worldAttStr];</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="几个特殊的设置"><a href="#几个特殊的设置" class="headerlink" title="几个特殊的设置"></a>几个特殊的设置</h3><ul>
<li><p>段落设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">NSParagraphStyle的属性介绍</span><br><span class="line">alignment //对齐方式</span><br><span class="line">firstLineHeadIndent //首行缩进</span><br><span class="line">headIndent //缩进</span><br><span class="line">tailIndent //尾部缩进</span><br><span class="line">lineBreakMode //断行方式</span><br><span class="line">maximumLineHeight //最大行高</span><br><span class="line">minimumLineHeight //最低行高</span><br><span class="line">lineSpacing //行距</span><br><span class="line">paragraphSpacing //段距</span><br><span class="line">paragraphSpacingBefore //段首空间</span><br><span class="line">baseWritingDirection //句子方向</span><br><span class="line">lineHeightMultiple //可变行高,乘因数。</span><br><span class="line">hyphenationFactor //连字符属性</span><br><span class="line">*/</span><br><span class="line">NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];</span><br><span class="line">style.firstLineHeadIndent = 10;</span><br><span class="line">style.lineSpacing = 10;</span><br><span class="line"></span><br><span class="line">NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@&quot;hello, world&quot; attributes:@&#123;NSParagraphStyleAttributeName:style&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>下划线或删除线</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 值为整型NSNumber，可取值为 NSUnderlineStyle</span><br><span class="line">NSUnderlineStyleNone // 无</span><br><span class="line">NSUnderlineStyleSingle //单条细线</span><br><span class="line">NSUnderlineStyleThick  //单条粗线</span><br><span class="line">NSUnderlineStyleDouble //双条条细线</span><br><span class="line">NSUnderlinePatternSolid // 连续的实线</span><br><span class="line">NSUnderlinePatternDot // 虚线 例 －－－－－－</span><br><span class="line">NSUnderlinePatternDash // 破折号，比如这样：—— —— ——</span><br><span class="line">NSUnderlinePatternDashDot // 连续的破折号和点，比如这样：——.——.——</span><br><span class="line">NSUnderlinePatternDashDotDot // 连续的破折号、点、点，比如：——..——..——..</span><br><span class="line">NSUnderlineByWord // 字有线，空格没线</span><br><span class="line">*/</span><br><span class="line">NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];</span><br><span class="line">// 删除线和下滑显示设置方法一样</span><br><span class="line">[mAttStr addAttribute:NSStrikethroughStyleAttributeName value:@(NSUnderlineStyleSingle) range:NSMakeRange(0, 5)];</span><br><span class="line">// iOS10.3之后需加上以下代码</span><br><span class="line">[mAttStr addAttribute:NSBaselineOffsetAttributeName value:@0 range:NSMakeRange(0, 5)];</span><br></pre></td></tr></table></figure>
</li>
<li><p>阴影</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];</span><br><span class="line">NSShadow *shadow = [[NSShadow alloc]init];</span><br><span class="line">shadow.shadowOffset = CGSizeMake(10, 10);</span><br><span class="line">shadow.shadowColor = [UIColor redColor];</span><br><span class="line">[mAttStr addAttribute:NSShadowAttributeName value:shadow range:NSMakeRange(0, 5)];</span><br></pre></td></tr></table></figure>
</li>
<li><p>超链接,不能用于UILabel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(50, 50, 50, 50)];</span><br><span class="line">[self.view addSubview:textView];</span><br><span class="line"></span><br><span class="line">textView.backgroundColor  = [UIColor redColor];</span><br><span class="line">NSString *strLink = @&quot;百度一下&quot;;</span><br><span class="line">NSAttributedString *attStr  = [[NSAttributedString alloc] initWithString:strLink attributes:@&#123;NSLinkAttributeName: [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]&#125;];</span><br><span class="line">textView.editable = NO;</span><br><span class="line">/* 签订协议, 指定代理人之后. 但点击链接时, 会回调协议方法 (- textView:shouldInteractWithURL:inRange:) */</span><br><span class="line">textView.delegate = self;</span><br><span class="line">textView.attributedText = attStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange &#123;</span><br><span class="line">NSLog(@&quot;url: %@&quot;, URL);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>附件(图文混排)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 下面实现在百度两个汉字之间插入一个照片 */</span><br><span class="line">NSString *str = @&quot;百度&quot;;</span><br><span class="line">/**</span><br><span class="line">* 关于NSTextAttachment类的简单说明</span><br><span class="line">*</span><br><span class="line">* NSTextAttachment 类有一个指定的初始化方法(- initWithData:ofType:), 需要指定附件文档的数据和附件文件的类型. 如果附件文档数据指定nil, 那么系统将会默认指定为image对象作为值. 因此, 也可以通过这个特性实现图文混排.</span><br><span class="line">* 下面就以附件为image对象来说明NSAttachmentAttributeName的使用.</span><br><span class="line">*</span><br><span class="line">*/</span><br><span class="line">NSTextAttachment *attach = [[NSTextAttachment alloc] initWithData:nil ofType:nil];</span><br><span class="line">attach.bounds = CGRectMake(0, 0, 50, 50);</span><br><span class="line">attach.image = [UIImage imageNamed:@&quot;logo&quot;];</span><br><span class="line"></span><br><span class="line">NSAttributedString *strAtt = [NSAttributedString attributedStringWithAttachment:attach];</span><br><span class="line">NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:str];</span><br><span class="line">[mAttStr insertAttributedString:strAtt atIndex:1];</span><br></pre></td></tr></table></figure>
</li>
<li><p>文字书写方向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];</span><br><span class="line">//    //取值为包含NSNumber对象的数组. 从左向右书写或者从右向左书写.</span><br><span class="line">//    // NSArray of NSNumbers representing the nested levels of writing direction overrides as</span><br><span class="line">//    defined by Unicode LRE, RLE, LRO, and RLO characters.  The control characters can be</span><br><span class="line">//    obtained by masking NSWritingDirection and NSTextWritingDirection values.  LRE:</span><br><span class="line">//    NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE:</span><br><span class="line">//    NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO:</span><br><span class="line">//    NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO:</span><br><span class="line">//    NSWritingDirectionRightToLeft|NSWritingDirectionOverride,</span><br><span class="line">[mAttStr addAttribute:NSWritingDirectionAttributeName value:@[@2] range:NSMakeRange(0, 11)];</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>NSDate使用</title>
    <url>/2016/02/25/NSDate%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天开发时遇到需要获取当前是星期几的需求！虽然NSDate经常在用，但这个需求确实不知道，百度了一下，其实挺简单！顺便总结一下NSDate的使用，于是乎又水了一篇</p>
<h3 id="1-概念理解"><a href="#1-概念理解" class="headerlink" title="1 概念理解"></a>1 概念理解</h3><ul>
<li>NSDate获取的都是当前机器的时间，用户是可以改的！NSDate所获取到的时间, 都是相对于GMT的, 即格林威治标准时间</li>
</ul>
<h4 id="1-1-时区问题"><a href="#1-1-时区问题" class="headerlink" title="1.1 时区问题"></a>1.1 时区问题</h4><ul>
<li><p>当前时区的时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 零时区时间</span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">// 如果没有指定NSDateFormatter的时区，NSDateFormatter默认是当前时区的时间</span><br><span class="line">NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSString *time = [dateFormat stringFromDate:date];</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSLog(@&quot;系统时区：%@&quot;, [NSTimeZone systemTimeZone]);</span><br><span class="line">dateFormat.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;];</span><br><span class="line">// 还可用GMT+0800 加8小时, GMT-0800减8小时来表示</span><br><span class="line">//    dateFormat.timeZone =  [NSTimeZone timeZoneWithName:@&quot;GMT+0800&quot;];</span><br><span class="line">// 相对0时区的 秒 数</span><br><span class="line">//    dateFormat.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:28800];</span><br><span class="line">NSString *time = [dateFormat stringFromDate:date];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-2-时间比较"><a href="#1-2-时间比较" class="headerlink" title="1.2 时间比较"></a>1.2 时间比较</h4><ul>
<li>唯一需要注意的：需要转化为同一时区，不同时区时间比价没有意义<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSDate *)earlierDate:(NSDate *)anotherDate;</span><br><span class="line">- (NSDate *)laterDate:(NSDate *)anotherDate;</span><br><span class="line">- (NSComparisonResult)compare:(NSDate *)other;</span><br><span class="line">- (BOOL)isEqualToDate:(NSDate *)otherDate;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-timeIntervalSinceXXX"><a href="#1-3-timeIntervalSinceXXX" class="headerlink" title="1.3 timeIntervalSinceXXX"></a>1.3 timeIntervalSinceXXX</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 以下三个方法默认都是0时区时间，中国要 + 8个小时</span><br><span class="line">// 自2001年1月1日晚上12点</span><br><span class="line">NSDate *date1 = [NSDate dateWithTimeIntervalSinceReferenceDate:0];</span><br><span class="line">// 自19070年1月1日晚上12点</span><br><span class="line">NSDate *date2 = [NSDate dateWithTimeIntervalSince1970:0];</span><br><span class="line">// now</span><br><span class="line">NSDate *date3 = [NSDate dateWithTimeIntervalSinceNow:0];</span><br></pre></td></tr></table></figure>
<h3 id="2常见用法"><a href="#2常见用法" class="headerlink" title="2常见用法"></a>2常见用法</h3><h4 id="2-1-NSDate与NSString转化"><a href="#2-1-NSDate与NSString转化" class="headerlink" title="2.1 NSDate与NSString转化"></a>2.1 NSDate与NSString转化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// NSDateFormatter是线程安全的，而且使用起来开销非常大，故可以只初始化一次即可</span><br><span class="line">static NSDateFormatter *dateFormatter = nil;</span><br><span class="line">NSDateFormatter *shareDateFormatter() &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return dateFormatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSDate (String)</span><br><span class="line"></span><br><span class="line">- (NSString *)dateStringWithFormat:(NSString *)format &#123;</span><br><span class="line">[shareDateFormatter() setDateFormat:format];</span><br><span class="line">return [shareDateFormatter() stringFromDate:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSString (Date)</span><br><span class="line"></span><br><span class="line">- (NSDate *)dateWithFormat:(NSString *)format &#123;</span><br><span class="line">[getDateFormatter() setDateFormat:format];</span><br><span class="line">return [getDateFormatter() dateFromString:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://stackoverflow.com/questions/24777496/how-can-i-convert-string-date-to-nsdate?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/24777496/how-can-i-convert-string-date-to-nsdate?r=SearchResults</a></li>
</ul>
<h4 id="2-2-现在是星期几"><a href="#2-2-现在是星期几" class="headerlink" title="2.2 现在是星期几"></a>2.2 现在是星期几</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSDateComponents *)dateComponentsFromDate:(NSDate* )date&#123;</span><br><span class="line">NSDateComponents *components = [[NSDateComponents alloc] init];</span><br><span class="line">// 可获得很多信息，自己看吧</span><br><span class="line">NSInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay |  NSCalendarUnitWeekday | NSCalendarUnitWeekOfMonth | NSCalendarUnitWeekOfYear;</span><br><span class="line">NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">calendar.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];</span><br><span class="line">components = [calendar components:unitFlags fromDate:date];</span><br><span class="line">return components;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意在西方周日是第一天</span><br><span class="line">+ (NSString *)getWeekDayFromDateComponents:(NSDateComponents *) comps&#123;</span><br><span class="line">NSString *weekDayStr = @&quot;&quot;;</span><br><span class="line">switch ([comps weekday]) &#123;</span><br><span class="line">case 1:</span><br><span class="line">weekDayStr = @&quot;周日&quot;;</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">weekDayStr = @&quot;周一&quot;;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">weekDayStr = @&quot;周二&quot;;</span><br><span class="line">break;</span><br><span class="line">case 4:</span><br><span class="line">weekDayStr = @&quot;周三&quot;;</span><br><span class="line">break;</span><br><span class="line">case 5:</span><br><span class="line">weekDayStr = @&quot;周四&quot;;</span><br><span class="line">break;</span><br><span class="line">case 6:</span><br><span class="line">weekDayStr = @&quot;周五&quot;;</span><br><span class="line">break;</span><br><span class="line">case 7:</span><br><span class="line">weekDayStr = @&quot;周六&quot;;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return weekDayStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://stackoverflow.com/questions/3694867/nsdate-get-year-month-day?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/3694867/nsdate-get-year-month-day?r=SearchResults</a></li>
</ul>
<h4 id="2-3-获取当前时间若干年、月、日之后的时间"><a href="#2-3-获取当前时间若干年、月、日之后的时间" class="headerlink" title="2.3  获取当前时间若干年、月、日之后的时间"></a>2.3  获取当前时间若干年、月、日之后的时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSDate *)dateWithFromDate:(NSDate *)date years:(NSInteger)years months:(NSInteger)months days:(NSInteger)days&#123;</span><br><span class="line">NSDate  * latterDate;</span><br><span class="line">if (date) &#123;</span><br><span class="line">latterDate = date;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">latterDate = [NSDate date];</span><br><span class="line">&#125;</span><br><span class="line">NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">NSDateComponents *comps = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute</span><br><span class="line">fromDate:latterDate];</span><br><span class="line"></span><br><span class="line">[comps setYear:years];</span><br><span class="line">[comps setMonth:months];</span><br><span class="line">[comps setDay:days];</span><br><span class="line"></span><br><span class="line">return [calendar dateByAddingComponents:comps toDate:latterDate options:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://stackoverflow.com/questions/5067785/how-do-i-add-1-day-to-an-nsdate?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/5067785/how-do-i-add-1-day-to-an-nsdate?r=SearchResults</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html" target="_blank" rel="noopener">https://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html</a></li>
<li><a href="https://stackoverflow.com/questions/5965044/how-to-compare-two-nsdates-which-is-more-recent/5965106?r=SearchResults#5965106" target="_blank" rel="noopener">https://stackoverflow.com/questions/5965044/how-to-compare-two-nsdates-which-is-more-recent/5965106?r=SearchResults#5965106</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>NSException介绍</title>
    <url>/2017/06/17/NSException%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><ul>
<li>name :  唯一标识符</li>
<li>reason: 异常原因，最重要的属性！找问题就靠它了</li>
<li>userInfo：当异常被抛出时，返回原因等的一个字典<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">// 如果这里面的代码执行后会导致程序崩溃，就会跳到@catch这个方法中</span><br><span class="line">// @throw someException</span><br><span class="line">&#125; @catch(NSException *exception) &#123;</span><br><span class="line">// 处理异常</span><br><span class="line">&#125;@finally&#123;</span><br><span class="line">// 这里的代码是一定执行的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2 常见异常"></a>2 常见异常</h3><h4 id="2-1-NSGenericException"><a href="#2-1-NSGenericException" class="headerlink" title="2.1 NSGenericException"></a>2.1 NSGenericException</h4><ul>
<li>通用异常？我也翻译不准还要看reason，不能一概而论，不过个人理解就跟枚举的第一个default一样</li>
<li>我只见一次NSGenericException，对数组进行删除操作时见到的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *muArr = @[@1, @2, @3].mutableCopy;</span><br><span class="line">for (id elem in muArr) &#123;</span><br><span class="line">[muArr removeObject:elem];</span><br><span class="line">&#125;</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSGenericException&apos;, reason: &apos;*** Collection &lt;__NSArrayM: 0x600002052310&gt; was mutated while being enumerated.&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-NSRangeException越界"><a href="#2-2-NSRangeException越界" class="headerlink" title="2.2 NSRangeException越界"></a>2.2 NSRangeException越界</h4><ul>
<li>一般是数组越界，字符创越界两种！Debug下打开全局断点基本都是定位到，release下分析崩溃行上下文基本也能处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 空数组</span><br><span class="line">NSMutableArray *photos  = [NSMutableArray array];</span><br><span class="line">NSLog(@&quot;--- %@&quot;,photos[0]);</span><br><span class="line"></span><br><span class="line">// Crash</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 0 beyond bounds for empty array&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-NSInvalidArgumentException-非法入参"><a href="#2-3-NSInvalidArgumentException-非法入参" class="headerlink" title="2.3 NSInvalidArgumentException 非法入参"></a>2.3 NSInvalidArgumentException 非法入参</h4><ul>
<li>开发阶段可用NSAssert代替，但使用NSInvalidArgumentException可以保证在release阶段也不会出现入参问题的crash<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *muArr = [[NSMutableArray alloc] init];</span><br><span class="line">NSString *str = nil;</span><br><span class="line">[muArr addObject:str];</span><br><span class="line">// erminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-4-NSInternalInconsistencyException"><a href="#2-4-NSInternalInconsistencyException" class="headerlink" title="2.4 NSInternalInconsistencyException"></a>2.4 NSInternalInconsistencyException</h4><ul>
<li>内部矛盾异常，主要在断言失败时自动调用！</li>
<li>出现这个异常，一般都是类型问题，xib连线问题，约束问题等<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSAssert(NO, @&quot;this will call NSInternalInconsistencyException&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-5-NSMallocException-内存不足"><a href="#2-5-NSMallocException-内存不足" class="headerlink" title="2.5 NSMallocException 内存不足"></a>2.5 NSMallocException 内存不足</h4><ul>
<li>内存不足的问题，无法分配足够的内存空间,比如需要分配的内存大小是一个不正常的值，比较巨大或者设备的内存空间不足以及耗尽</li>
</ul>
<h3 id="3-小技巧"><a href="#3-小技巧" class="headerlink" title="3 小技巧"></a>3 小技巧</h3><h4 id="3-1-throw的妙用"><a href="#3-1-throw的妙用" class="headerlink" title="3.1 @throw的妙用"></a>3.1 @throw的妙用</h4><ul>
<li><p>限制某方式使用，特别是废弃的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 强制使用initWithPath作为初始化，也可以直接用NSAssert(NO, @&quot;原因&quot;);</span><br><span class="line">@throw [NSException exceptionWithName:NSGenericException</span><br><span class="line">reason:@&quot;`-init` unavailable. Use `-initWithReachability:` instead&quot;</span><br><span class="line">userInfo:nil];</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制子类实现某个方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 如果所有子类都必须实现某个方法，怎么做才好？</span><br><span class="line">// 第一种方法声明协议，父类遵守，子类实现；但协议只能产生警告，不够强硬！而且一旦父类实现了该方法，子类实现不实现根本就无所谓！</span><br><span class="line">// 第二种方法，父类实现该方法并添加@throw强制实现子类去自己重载</span><br><span class="line">- (void)changeActivityState:(BOOL)active &#123;</span><br><span class="line">@throw [NSException exceptionWithName:NSInternalInconsistencyException</span><br><span class="line">reason:[NSString stringWithFormat:@&quot;You must override %@ in %@&quot;, NSStringFromSelector(_cmd), self.class]</span><br><span class="line">userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-自己捕获异常"><a href="#3-2-自己捕获异常" class="headerlink" title="3.2 自己捕获异常"></a>3.2 自己捕获异常</h4><ul>
<li>注意，很多三方SDK也用到了自定义异常处理，咱们捕获了要转发出去<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static NSUncaughtExceptionHandler *_previousHandler;</span><br><span class="line">// 在程序开始运行就监控异常</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">// 保存第三方处理异常的 handler</span><br><span class="line">_previousHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">// 将下面C函数的函数地址当做参数</span><br><span class="line">NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">// 设置一个C函数，用来接收崩溃信息</span><br><span class="line">void UncaughtExceptionHandler(NSException *exception)&#123;</span><br><span class="line">// 崩溃栈</span><br><span class="line">NSArray *symbols = [exception callStackSymbols];</span><br><span class="line">NSString *reason = [exception reason];</span><br><span class="line">NSString *name = [exception name];</span><br><span class="line">// 本地记录并上传</span><br><span class="line"></span><br><span class="line">// 转发为三方</span><br><span class="line">_previousHandler(exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB</a></li>
</ul>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><ul>
<li>NSException 异常，非正常，想不到的是异常</li>
<li>NSError 错误，流程的一部分，有正确就有错误</li>
<li>NSAssert 断言，保证正确（或错误），就是程序员确定这个是正确的（或错误的），常用测试和参数校验</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>NSUserDefault</title>
    <url>/2015/11/08/NSUserDefault/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天打算水一水最基础的NSUserDefault，因为太常用了都没啥可写的！但后来发现可以APP间共享数据！嗯，正好最近也不知道水什么，就水它了！</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>轻量级数据持久化工具类</li>
<li>存储方式key-value，key要实现NSCoding协议，注意使用对应方法value才可以是值类型</li>
<li>文件格式：plist，保存位置：/Library/preferences/ Bound ID.plist</li>
<li>NSUserDefault中5个域的检索顺序：NSArgumentDomain-&gt;Application-&gt;NSGlobalDomain-&gt;Languages-&gt;NSRegistrationDomain</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>简单，一个单例走天下，跟NSDictionary用法差不多</li>
<li>提供了大量的快捷方法，例arrayForKey: setBool: forKey:</li>
<li>线程安全,不管存的啥，取出来的都是<strong>不可变类型</strong></li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>非实时写入硬盘，而是先写入内存，系统再定时写入硬盘。想要实时写入硬盘调用synchronize方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 非实时写入，最可能问题是程序突然中断，虽然调用了setObject forkey，但再次启动时读取的仍是上个数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>不适合写入大量数据</p>
</li>
<li>频繁的读写会导致性能问题</li>
<li>单例写法很独特 [NSUserDefaults standardUserDefaults]</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h4><ul>
<li><p>存取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设值set方法和取值forKey方法都一样，唯一区别就是参数类型</span><br><span class="line">// 注意所有object都必须实现NSCoding协议</span><br><span class="line">NSUserDefaults *userDefault =  [NSUserDefaults standardUserDefaults];</span><br><span class="line">NSMutableArray *muArr = [[NSMutableArray alloc] initWithObjects:@1,@2, nil];</span><br><span class="line">[userDefault setObject:muArr forKey:@&quot;key&quot;];</span><br><span class="line">[userDefault synchronize];</span><br><span class="line">NSArray *arr = [userDefault objectForKey:@&quot;key&quot;];// 取出来是不可变类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSUserDefaults *userDefault =  [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userDefault setObject:nil forKey:@&quot;key&quot;];// 不建议</span><br><span class="line">[userDefault removeObjectForKey:@&quot;key&quot;];// 建议</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">NSDictionary *defaultSet = @&#123;@&quot;name&quot;:@&quot;JZK&quot;, @&quot;sex&quot;:@&quot;man&quot;&#125;;</span><br><span class="line">// 注册默认值，主要用于通用配制的初次载入！取值的时候节省了if判断和测试</span><br><span class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:defaultSet];</span><br><span class="line">// Override point for customization after application launch.</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h4><ul>
<li><p>APP间数据共享</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 开启App Groups，共享的App都需要加入同一个Group，@&quot;com.yourcompany.appsShare&quot;</span><br><span class="line">// appA中</span><br><span class="line">NSUserDefaults *shareDefaultA = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];</span><br><span class="line">[shareDefaultA setObject:@&quot;appA&quot; forKey:@&quot;shareKey&quot;];</span><br><span class="line">// appB中</span><br><span class="line">NSUserDefaults *shareDefaultB = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];</span><br><span class="line">NSString *value = [shareDefaultB objectForKey:@&quot;shareKey&quot;];</span><br><span class="line"></span><br><span class="line">// 域名管理，几乎用不到</span><br><span class="line">// 将指定的域名插入到接收方的搜索列表中</span><br><span class="line">// - (void)addSuiteNamed:(NSString*)suiteName;</span><br><span class="line">// 从接收器的搜索列表中移除指定的域名</span><br><span class="line">// - (void)removeSuiteNamed:(NSString*)suiteName;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 当前域名下所有的key value</span><br><span class="line">NSUserDefaults *userDefault = [[NSUserDefaults standardUserDefaults];</span><br><span class="line">// NSUserDefaults *userDefault = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];</span><br><span class="line">NSDictionary* dic = [userDefault dictionaryRepresentation];</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>OC怎么实现多参数</title>
    <url>/2015/09/17/OC%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天被一个问题难到了，OC怎么实现多参数？</p>
<p>&emsp;&emsp;其实我们经常用的NSArray里就有多参数的实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么我们怎么自己定义多参数函数呢？几经周折找到了<a href="https://developer.apple.com/library/archive/qa/qa1405/_index.html" target="_blank" rel="noopener">官方源码</a>如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSMutableArray (variadicMethodExample)</span><br><span class="line"></span><br><span class="line">- (void) appendObjects:(id) firstObject, ...; // This method takes a nil-terminated list of objects.</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSMutableArray (variadicMethodExample)</span><br><span class="line"></span><br><span class="line">- (void) appendObjects:(id) firstObject, ...</span><br><span class="line">&#123;</span><br><span class="line">id eachObject;</span><br><span class="line">va_list argumentList;</span><br><span class="line">if (firstObject) // The first argument isn&apos;t part of the varargs list,</span><br><span class="line">&#123;                                   // so we&apos;ll handle it separately.</span><br><span class="line">[self addObject: firstObject];</span><br><span class="line">va_start(argumentList, firstObject); // Start scanning for arguments after firstObject.</span><br><span class="line">while (eachObject = va_arg(argumentList, id)) // As many times as we can get an argument of type &quot;id&quot;</span><br><span class="line">[self addObject: eachObject]; // that isn&apos;t nil, add it to self&apos;s contents.</span><br><span class="line">va_end(argumentList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;要不要加NS_REQUIRES_NIL_TERMINATION ？ 我认为要加，这个宏表示最后需要一个nil，就是为了多参数准备的</p>
<p>&emsp;&emsp;stackoverflow上有个问题，也可以参考一下（其实就是省略函数名）：<a href="https://stackoverflow.com/questions/722651/how-do-i-pass-multiple-parameters-in-objective-c?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/722651/how-do-i-pass-multiple-parameters-in-objective-c?r=SearchResults</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Property关键字</title>
    <url>/2014/08/17/Property%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h3 id="property是什么"><a href="#property是什么" class="headerlink" title="@property是什么"></a>@property是什么</h3><ul>
<li><p>@property声明的属性，默认会自动创建该属性的getter/setter方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *propertyName;</span><br><span class="line">// 自动生成如下方法</span><br><span class="line">// 注意自动生成setter方法的属性名首字母大写</span><br><span class="line">- (void)setPropertyName:(NSString *)propertyName;</span><br><span class="line">// 注意自动生成getter方法没有get</span><br><span class="line">- (NSString *)propertyName;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不想让系统生成getter和setter方法，要用@dynamic</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不要系统生成的getter和setter，例如CoreData</span><br><span class="line">@dynamic propertyName;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property声明的属性，会自动生成带下划线的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 相当于系统帮你写了</span><br><span class="line">@synthesize propertyName = _propertyName;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="property的关键字"><a href="#property的关键字" class="headerlink" title="property的关键字"></a>property的关键字</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul>
<li>atomic:原子性，耗性能而且不保证一定是安全的，所以iOS里不会用！Mac OS倒可以用</li>
<li>nonatomic:非原子性，和atomic含义是相反的，iOS一直用这个</li>
</ul>
<h4 id="存取控制"><a href="#存取控制" class="headerlink" title="存取控制"></a>存取控制</h4><ul>
<li>readwrite：可读可写，默认值。同时拥有getter和setter方法</li>
<li>readonly：可读不可写，只有getter没有setter方法</li>
<li>setter = xxx， 通过xxx来访问setter方法，属性必须是readwrite</li>
<li>getter = xxx， 通过xxx来访问getter方法，经常和readonly配合使用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy, getter=pName, setter=setPName) NSString *name;</span><br><span class="line">- (void)setPName:(NSString *)name &#123;&#125;</span><br><span class="line">- (NSString *)pName &#123;&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, readonly, assign, getter=isShowed) BOOL showed;</span><br><span class="line">- (BOOL)isShowed&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>strong | weak | unsafe_unretained | assign | retain | copy</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>assign:用于修饰值类型（基本数据类型），如：int，float，double，CGFloat，NSInteger等。assign修饰的属性不牵涉内存管理，不会被引用计数器管理</li>
<li>retain:表示实例变量对传入的对象要有所有权关系，也就是强引用</li>
<li>strong:强引用, ARC后用于取代retain的，作用等同于retain</li>
<li>weak:弱引用。当传入的对象被释放后，用weak声明的属性会指向nil</li>
<li>unsafe_unretained:跟assign相似，不同的是可以修饰类，不安全！慎用</li>
<li>copy: 深拷贝，内存拷贝！常用于修饰 NSString，NSArray,NSDictionary等有可变子类型的数据</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="unsafe-unretained、weak、assign-的区别？"><a href="#unsafe-unretained、weak、assign-的区别？" class="headerlink" title="unsafe_unretained、weak、assign 的区别？"></a>unsafe_unretained、weak、assign 的区别？</h4><ul>
<li>三者都不会对引用计数器进行操作，属性和实例对象都没有“强”关系</li>
<li>assign 只能修饰值类型，其它两个可以修饰类</li>
<li>weak属性当实例对象销毁时会自动置为nil不会产生野指针，而assign和unsafe_unretained当实例对象销毁时不做任何操作，可能存在野指针，甚至造成Crash</li>
<li>weak是ARC才有的，其它两个一直都有</li>
</ul>
<h4 id="delegate使用assign还是weak，为什么？"><a href="#delegate使用assign还是weak，为什么？" class="headerlink" title="delegate使用assign还是weak，为什么？"></a>delegate使用assign还是weak，为什么？</h4><p>理论上来说，两者都是可以使用的，其一，都不会操作delegate的引用计数器，不是强引用对象。其二，在实际开发中，几乎所有场景下，delegate所指向的对象A的生存期都会被delegate变量B自身的生存期覆盖，也就是说A在使用B的过程中，B都是存在的，因此使用assign也不会有问题。但是，由于assign不会处理delegate被释放后的情况，上述的也只是大部分情况，不排除可能会出现delegate被释放了而A还在使用，产生野指针错误，而weak正好会处理这个情况，因此我们一般使用weak来修饰delegate，会更加安全</p>
<h4 id="self对象是被strong，weak还是其他关键字修饰的？"><a href="#self对象是被strong，weak还是其他关键字修饰的？" class="headerlink" title="self对象是被strong，weak还是其他关键字修饰的？"></a>self对象是被strong，weak还是其他关键字修饰的？</h4><p>通过 查阅clang文档，我们发现了关于self的解释：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object.</span><br><span class="line">To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method.</span><br><span class="line">Rationale</span><br><span class="line">The cost of retaining self in all methods was found to be prohibitive, as it tends to be live across calls, preventing the optimizer from proving that the retain and release are unnecessary — for good reason, as it’s quite possible in theory to cause an object to be deallocated during its execution without this retain and release. Since it’s extremely uncommon to actually do so, even unintentionally, and since there’s no natural way for the programmer to remove this retain/release pair otherwise (as there is for other parameters by, say, making the variable __unsafe_unretained), we chose to make this optimizing assumption and shift some amount of risk to the user.</span><br></pre></td></tr></table></figure></p>
<p>上述，self既不是strong也不是weak，而是被unsafe_unretained修饰的，因此要求我们调用的时候保证self是存在的，否则可能会引起无法预料的crash。这样设计的原因是因为在对象方法调用时，我们一定是会把self传递进去，并且在绝大部分情况下做为调用方，我们不会把self释放掉，如果为了处理不到1%情况下的异常而在方法执行时增加retain和release进行保护的话，会对性能有重大影响，因此ARC设计也就没有帮我们处理，需要调用方自行保证self的存在。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>RN分享之后</title>
    <url>/2017/03/11/RN%E5%88%86%E4%BA%AB%E4%B9%8B%E5%90%8E/</url>
    <content><![CDATA[<p>&emsp;&emsp;RN出来之后，我自己学过，当时为了学RN，还专门复习了早就忘记的JavaScript，但一直没有正式用到项目上，仅限于自己学习！来度厂之后正好组内还没人分享过RN的使用，就借这个机会对RN进行简单的介绍！预计分享时间一个小时，主要听众是iOS童鞋、安卓童鞋以及部分FE童鞋！但整个分享过后，应者寥寥，甚至出现了短时间的沉默，不得不提前几分钟左右终止了分享！当然引入RN这件事也随之化为泡影！虽然会后领导还是对我的分享表示了赞扬，但作为试用期的第一次“露脸”还是比较尴尬的！</p>
<p>&emsp;&emsp;会后我对分享内容进行了反思：首先我分享的是RN入门级知识，并没有介绍JavaScript语言细节，也没有深入去探讨RN的高级用法，对于有两三年开发经验的RD应该不存在“鸿沟”；其次我主要介绍RN的使用以及优势、劣势和引入成本，优势劣势引入成本这些东西都不涉及到具体代码都是理论上的东西，大多数人都应该能听懂；最后我的分享范围很小，仅限于大前端组内童鞋的十几个人！而且在整个分享过程中我认为我把我罗列的提纲，基本上都说完了；</p>
<p>&emsp;&emsp;再后来与同事闲聊时发现，最大的问题在于，iOS、安卓和FE童鞋，三个端的同学都只看明白一部分：iOS和安卓童鞋大概看明白界面展示，但对于javascript则一知半解；FE童鞋正好相反；如果要引入RN，iOS和安卓同学需要学习javaScript, 而FE童鞋则可能需要了解iOS和安卓知识；其实只是学习新语言对程序猿而言并不是什么大事，程序猿每天都在学习新东西！麻烦的是使用和学习RN，很可能要对Javascript、iOS和安卓都有所涉猎才行，强类型与弱类型之争、各种版本的iOS安卓系统的坑，困难的调试等问题已足以让团队成员放弃RN，更何况还有一条十万分之二的crash红线…</p>
<p>&emsp;&emsp;说到底这次分享冷场还是自己的问题：选题不太好、问题考虑的不太充分、没有正确认清产品现状</p>
<p>&emsp;&emsp;PS: 其实这次我本来打算水一水RN的基本使用，但经历了失败的分享，标题也从RN入门变成了RN分享之后，但不管怎样！也算水了一篇吧</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>Runloop</title>
    <url>/2016/09/11/Runloop/</url>
    <content><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><h4 id="1-Runloop"><a href="#1-Runloop" class="headerlink" title="1 Runloop"></a>1 Runloop</h4><p>&emsp;&emsp;Runloop是用于线程调度的，让线程有“事”干活，没“事”休息！方式就是执行一个while循环 “接受消息-&gt;等待-&gt;处理”，直到这个循环结束（比如传入quit的消息），函数返回。CFRunLoopRef是开源的，可以在 <a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/CF/</a> 下载到整个 CoreFoundation 的源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">//程序一直运行状态</span><br><span class="line">while (AppIsRunning) &#123;</span><br><span class="line">//睡眠状态，等待唤醒事件</span><br><span class="line">id whoWakesMe = SleepForWakingUp();</span><br><span class="line">//得到唤醒事件</span><br><span class="line">id event = GetEvent(whoWakesMe);</span><br><span class="line">//开始处理事件</span><br><span class="line">HandleEvent(event);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-Runloop与线程"><a href="#2-Runloop与线程" class="headerlink" title="2 Runloop与线程"></a>2 Runloop与线程</h4><p>&emsp;&emsp;线程和RunLoop之间是一一对应的，除主线程外（主线程默认开启runloop）其它线程需要手动开启runloop，即需要手动获取一下runloop，系统会自己开启runloop<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取主线程runloop</span><br><span class="line">[NSRunLoop mainRunLoop];</span><br><span class="line"></span><br><span class="line">// 1、开辟新线程</span><br><span class="line">// 2、获取新线程的runloop</span><br><span class="line">[NSRunLoop currentRunLoop];</span><br></pre></td></tr></table></figure></p>
<h4 id="3-Runloop组成"><a href="#3-Runloop组成" class="headerlink" title="3 Runloop组成"></a>3 Runloop组成</h4><p>&emsp;&emsp;在 CoreFoundation 里面关于 RunLoop 有5个类:CFRunLoopRef、CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef、CFRunLoopObserverRef，参考：<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">盗的大神的图</a><br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="image"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct __CFRunLoop * CFRunLoopRef;</span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">// 其它变量.....</span><br><span class="line">pthread_t _pthread;  // 线程和RunLoop之间是一一对应的</span><br><span class="line">uint32_t _winthread;</span><br><span class="line">CFMutableSetRef _commonModes;      // Set &lt;ModeName&gt;</span><br><span class="line">CFMutableSetRef _commonModeItems;  // Set &lt;Source/Observer/Timer&gt;</span><br><span class="line">CFRunLoopModeRef _currentMode;     // Current Runloop Mode</span><br><span class="line">// 其它变量.....</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">// 其它变量.....</span><br><span class="line">CFMutableSetRef _sources0; // 处理如UIEvent，CFSocket这样的事件</span><br><span class="line">CFMutableSetRef _sources1; // Mach port驱动，CFMachport，CFMessagePort</span><br><span class="line">CFMutableArrayRef _observers; // typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;</span><br><span class="line">CFMutableArrayRef _timers;    // typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;</span><br><span class="line">// 其它变量.....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-1-CFRunLoopModeRef"><a href="#3-1-CFRunLoopModeRef" class="headerlink" title="3.1 CFRunLoopModeRef"></a>3.1 CFRunLoopModeRef</h5><p>&emsp;&emsp;CFRunLoopModeRef只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<ul>
<li>NSDefaultRunLoopMode：默认，空闲状态</li>
<li>UITrackingRunLoopMode：ScrollView滑动时</li>
<li>UIInitializationRunLoopMode：启动时</li>
<li>NSRunLoopCommonModes：Mode集合Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes来解决</li>
</ul>
<h5 id="3-2-CFRunLoopSourceRef"><a href="#3-2-CFRunLoopSourceRef" class="headerlink" title="3.2  CFRunLoopSourceRef"></a>3.2  CFRunLoopSourceRef</h5><ul>
<li>_sources0; // 处理如UIEvent，CFSocket这样的事件</li>
<li>_sources1; // Mach port驱动，CFMachport，CFMessagePort</li>
</ul>
<h5 id="3-3-CFRunLoopObserverRef"><a href="#3-3-CFRunLoopObserverRef" class="headerlink" title="3.3  CFRunLoopObserverRef"></a>3.3  CFRunLoopObserverRef</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Run Loop Observer Activities */</span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">kCFRunLoopEntry = (1UL &lt;&lt; 0),        // 即将进入loop</span><br><span class="line">kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">kCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 Source</span><br><span class="line">kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠</span><br><span class="line">kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">kCFRunLoopExit = (1UL &lt;&lt; 7),         // 即将退出Loop</span><br><span class="line">kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-CFRunLoopTimerRef"><a href="#3-4-CFRunLoopTimerRef" class="headerlink" title="3.4  CFRunLoopTimerRef"></a>3.4  CFRunLoopTimerRef</h5><p>&emsp;&emsp; 和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<h3 id="2-RunLoop使用"><a href="#2-RunLoop使用" class="headerlink" title="2 RunLoop使用"></a>2 RunLoop使用</h3><h4 id="1-示例"><a href="#1-示例" class="headerlink" title="1 示例"></a>1 示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int test() &#123;</span><br><span class="line">pthread_t t;</span><br><span class="line">pthread_create(&amp;t, NULL, &amp;runLoopStart, NULL);</span><br><span class="line">pthread_join(t, NULL);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">static void *runLoopStart() &#123;</span><br><span class="line">CFRunLoopRef runLoop = CFRunLoopGetCurrent();</span><br><span class="line">CFRunLoopSourceContext *context = malloc(sizeof(CFRunLoopSourceContext));</span><br><span class="line">CFRunLoopSourceContext contextTemplate = &#123;</span><br><span class="line">0,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">NULL,</span><br><span class="line">RunloopSourceSchedule,</span><br><span class="line">RunloopSourceCancel,</span><br><span class="line">RunloopSourcePerform</span><br><span class="line">&#125;;</span><br><span class="line">memcpy(context, &amp;contextTemplate, sizeof(CFRunLoopSourceContext));</span><br><span class="line">CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, context);</span><br><span class="line">CFRunLoopAddSource(runLoop, source, kCFRunLoopDefaultMode);</span><br><span class="line">CFRunLoopSourceSignal(source);</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">switch (activity) &#123;</span><br><span class="line">case kCFRunLoopEntry:</span><br><span class="line">NSLog(@&quot;observer: loop entry&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeTimers:</span><br><span class="line">NSLog(@&quot;observer: before timers&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeSources:</span><br><span class="line">NSLog(@&quot;observer: before sources&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopBeforeWaiting:</span><br><span class="line">NSLog(@&quot;observer: before waiting&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopAfterWaiting:</span><br><span class="line">NSLog(@&quot;observer: after waiting&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopExit:</span><br><span class="line">NSLog(@&quot;observer: exit&quot;);</span><br><span class="line">break;</span><br><span class="line">case kCFRunLoopAllActivities:</span><br><span class="line">NSLog(@&quot;observer: all activities&quot;);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">CFRunLoopAddObserver(runLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line"></span><br><span class="line">CFRunLoopWakeUp(runLoop);</span><br><span class="line">NSTimeInterval theFuture = [NSDate timeIntervalSinceReferenceDate] + 4.0;</span><br><span class="line">while ([NSDate timeIntervalSinceReferenceDate] &lt; theFuture) &#123;</span><br><span class="line">CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.0, YES);</span><br><span class="line">sleep(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CFRunLoopRemoveSource(runLoop, source, kCFRunLoopDefaultMode);</span><br><span class="line">CFRunLoopRemoveObserver(runLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">free(context);</span><br><span class="line">CFRelease(source);</span><br><span class="line">CFRelease(observer);</span><br><span class="line"></span><br><span class="line">return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RunloopSourceSchedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode) &#123;</span><br><span class="line">NSLog(@&quot;Schedule routine: source is added to runloop&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RunloopSourceCancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode) &#123;</span><br><span class="line">NSLog(@&quot;Cancel Routine: source removed from runloop&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void RunloopSourcePerform(void *info) &#123;</span><br><span class="line">NSLog(@&quot;Perform Routine: source has fired&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-大神总结的问题，摘录在此"><a href="#2-大神总结的问题，摘录在此" class="headerlink" title="2 大神总结的问题，摘录在此"></a>2 大神总结的问题，摘录在此</h4><ul>
<li>AutoreleasePool什么时候释放？ kCFRunLoopEntry、kCFRunLoopBeforeWaiting和kCFRunLoopExit时会自动释放AutoreleasePool</li>
<li>事件响应跟runloop关系？苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()，进行事件的包装处理和分发</li>
<li>手势识别，苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()</li>
<li>界面更新，苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</li>
<li>定时器，一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件</li>
<li>PerformSelecter，当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</li>
</ul>
<h3 id="3-RunLoop内部逻辑"><a href="#3-RunLoop内部逻辑" class="headerlink" title="3 RunLoop内部逻辑"></a>3 RunLoop内部逻辑</h3><p>&emsp;&emsp;先把大神的结论放出来:<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">盗的大神的图</a><br><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt="image"></p>
<p>源码里核心方法是 __CFRunLoopRun，说实话不参照大神给的代码注解，真心不好看懂此函数有<strong>300多行</strong>，我就不显丑了，感兴趣的自己去研究源码吧!抄录大神的注解<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">/// 首先根据modeName找到对应mode</span><br><span class="line">CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">/// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">/// 内部函数，进入loop</span><br><span class="line">__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">Boolean sourceHandledThisLoop = NO;</span><br><span class="line">int retVal = 0;</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">/// 执行被加入的block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">/// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">/// 执行被加入的block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">if (hasMsg) goto handle_msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">if (!sourceHandledThisLoop) &#123;</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">/// • 一个基于 port 的Source 的事件。</span><br><span class="line">/// • 一个 Timer 到时间了</span><br><span class="line">/// • RunLoop 自身的超时时间到了</span><br><span class="line">/// • 被其他什么调用者手动唤醒</span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">/// 收到消息，处理消息。</span><br><span class="line">handle_msg:</span><br><span class="line"></span><br><span class="line">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">if (msg_is_timer) &#123;</span><br><span class="line">__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">else if (msg_is_dispatch) &#123;</span><br><span class="line">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">else &#123;</span><br><span class="line">CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">if (sourceHandledThisLoop) &#123;</span><br><span class="line">mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 执行加入到Loop的block</span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">/// 进入loop时参数说处理完事件就返回。</span><br><span class="line">retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; else if (timeout) &#123;</span><br><span class="line">/// 超出传入参数标记的超时时间了</span><br><span class="line">retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">/// 被外部调用者强制停止了</span><br><span class="line">retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">/// source/timer/observer一个都没有了</span><br><span class="line">retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">&#125; while (retVal == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;: 好玩的CFRuntimeBase是啥？是所有CF “instances”的“根类”<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* All CF &quot;instances&quot; start with this structure.  Never refer to</span><br><span class="line">* these fields directly -- they are for CF&apos;s use and may be added</span><br><span class="line">* to or removed or change format without warning.  Binary</span><br><span class="line">* compatibility for uses of this struct is not guaranteed from</span><br><span class="line">* release to release.</span><br><span class="line">*/</span><br><span class="line">typedef struct __CFRuntimeBase &#123;</span><br><span class="line">uintptr_t _cfisa;</span><br><span class="line">uint8_t _cfinfo[4];</span><br><span class="line">#if __LP64__</span><br><span class="line">uint32_t _rc;</span><br><span class="line">#endif</span><br><span class="line">&#125; CFRuntimeBase;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">https://blog.ibireme.com/2015/05/18/runloop/</a></li>
<li><a href="https://github.com/ming1016/study/wiki/CFRunLoop" target="_blank" rel="noopener">https://github.com/ming1016/study/wiki/CFRunLoop</a></li>
</ul>
<h4 id="其它优质博客"><a href="#其它优质博客" class="headerlink" title="其它优质博客"></a>其它优质博客</h4><ul>
<li><a href="http://mrpeak.cn/blog/ios-runloop/" target="_blank" rel="noopener">http://mrpeak.cn/blog/ios-runloop/</a></li>
<li><a href="https://juejin.im/post/5afcf305f265da0b8e7f9b74#comment" target="_blank" rel="noopener">https://juejin.im/post/5afcf305f265da0b8e7f9b74#comment</a></li>
<li><a href="https://juejin.im/post/5a951cb26fb9a0633229d4ec#comment" target="_blank" rel="noopener">https://juejin.im/post/5a951cb26fb9a0633229d4ec#comment</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>SDWebImage都干了什么？</title>
    <url>/2017/10/04/SDWebImage%E9%83%BD%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>High Level Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="image"></p>
<p>Overall Class Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageClassDiagram.png" alt="image"></p>
<p>Top Level API Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageTopLevelClassDiagram.png" alt="image"></p>
<p>Main Sequence Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageSequenceDiagram.png" alt="image"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><ol>
<li><p>为啥不用NSThread</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>SD里大量用到了 @synchronized(self)，另外正在下载中取消了怎么办？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // Cancel in progress downloader from queue</span><br><span class="line">        SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">        // 这个协议好，将抽象和实现分离！其实这就是最好的分层解耦</span><br><span class="line">        id&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123;</span><br><span class="line">                // 是不是抽象的非常好，下载、解码、还是存储根本就不用关心</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>学艺不精：怎么设置view的center</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.center = CGPointMake(CGRectGetMidX(self.bounds), CGRectGetMidY(self.bounds));</span><br></pre></td></tr></table></figure>
</li>
<li><p>和2毕竟相似，最基础的解耦思想：协议+抽象。 注意协议的定义以及requair的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)sd_startImageIndicator &#123;</span><br><span class="line">    id&lt;SDWebImageIndicator&gt; imageIndicator = self.sd_imageIndicator;</span><br><span class="line">    if (!imageIndicator) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        // SDWebImageActivityIndicator、SDWebImageProgressIndicator等等</span><br><span class="line">        [imageIndicator startAnimatingIndicator];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 再看协议是怎么定义的</span><br><span class="line">/**</span><br><span class="line"> A protocol to custom the indicator during the image loading.</span><br><span class="line"> All of these methods are called from main queue.</span><br><span class="line"> */</span><br><span class="line">@protocol SDWebImageIndicator &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/**</span><br><span class="line"> The view associate to the indicator.</span><br><span class="line"></span><br><span class="line"> @return The indicator view</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) UIView *indicatorView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Start the animating for indicator.</span><br><span class="line"> */</span><br><span class="line">- (void)startAnimatingIndicator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Stop the animating for indicator.</span><br><span class="line"> */</span><br><span class="line">- (void)stopAnimatingIndicator;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">/**</span><br><span class="line"> Update the loading progress (0-1.0) for indicator. Optional</span><br><span class="line"> </span><br><span class="line"> @param progress The progress, value between 0 and 1.0</span><br><span class="line"> */</span><br><span class="line">- (void)updateIndicatorProgress:(double)progress;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property 的属性class，表示给类增加一个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, class, nullable) id&lt;SDImageCache&gt; defaultImageCache;</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">static id&lt;SDImageCache&gt; _defaultImageCache;</span><br><span class="line"></span><br><span class="line">+ (id&lt;SDImageCache&gt;)defaultImageCache &#123;</span><br><span class="line">    return _defaultImageCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setDefaultImageCache:(id&lt;SDImageCache&gt;)defaultImageCache &#123;</span><br><span class="line">    if (defaultImageCache &amp;&amp; ![defaultImageCache conformsToProtocol:@protocol(SDImageCache)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _defaultImageCache = defaultImageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>io队列是串行队列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承 NSCache的正确方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; &lt;SDMemoryCache&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>像不像手动实现MVVM？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void * SDMemoryCacheContext = &amp;SDMemoryCacheContext;</span><br><span class="line"></span><br><span class="line">- (void)commonInit &#123;</span><br><span class="line">    SDImageCacheConfig *config = self.config;</span><br><span class="line">    self.totalCostLimit = config.maxMemoryCost;</span><br><span class="line">    self.countLimit = config.maxMemoryCount;</span><br><span class="line">    </span><br><span class="line">    [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCost)) options:0 context:SDMemoryCacheContext];</span><br><span class="line">    [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCount)) options:0 context:SDMemoryCacheContext];</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if (context == SDMemoryCacheContext) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(maxMemoryCost))]) &#123;</span><br><span class="line">            self.totalCostLimit = self.config.maxMemoryCost;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(maxMemoryCount))]) &#123;</span><br><span class="line">            self.countLimit = self.config.maxMemoryCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strong weak Cache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</span><br><span class="line"></span><br><span class="line">self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line"></span><br><span class="line">// NSMapTable线程不安全，用锁</span><br><span class="line">#ifndef SD_LOCK</span><br><span class="line">#define SD_LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef SD_UNLOCK</span><br><span class="line">#define SD_UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件按MD5存的，注意文件名是有长度限制的，超长就不加扩展名了！注意检查的时候也要检查扩展名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SD_MAX_FILE_EXTENSION_LENGTH (NAME_MAX - CC_MD5_DIGEST_LENGTH * 2 - 1)</span><br><span class="line"></span><br><span class="line">static inline NSString * _Nonnull SDDiskCacheFileNameForKey(NSString * _Nullable key) &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    // File system has file name length limit, we need to check if ext is too long, we don&apos;t add it to the filename</span><br><span class="line">    if (ext.length &gt; SD_MAX_FILE_EXTENSION_LENGTH) &#123;</span><br><span class="line">        ext = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)containsDataForKey:(NSString *)key &#123;</span><br><span class="line">    NSParameterAssert(key);</span><br><span class="line">    NSString *filePath = [self cachePathForKey:key];</span><br><span class="line">    BOOL exists = [self.fileManager fileExistsAtPath:filePath];</span><br><span class="line">    </span><br><span class="line">    // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</span><br><span class="line">    // checking the key with and without the extension</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        exists = [self.fileManager fileExistsAtPath:filePath.stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>wirteToUrl,苹果推荐使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// get cache Path for image key</span><br><span class="line">NSString *cachePathForKey = [self cachePathForKey:key];</span><br><span class="line">// transform to NSUrl</span><br><span class="line">NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">[data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line"></span><br><span class="line">// disable iCloud backup</span><br><span class="line">if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">    // ignore iCloud backup resource value error</span><br><span class="line">    [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optionsProcessor是strong</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> The options processor is used, to have a global control for all the image request options and context option for current manager.</span><br><span class="line"> @note If you use `transformer`, `cacheKeyFilter` or `cacheSerializer` property of manager, the input context option already apply those properties before passed. This options processor is a better replacement for those property in common usage.</span><br><span class="line"> For example, you can control the global options, based on the URL or original context option like the below code.</span><br><span class="line"> </span><br><span class="line"> @code</span><br><span class="line"> SDWebImageManager.sharedManager.optionsProcessor = [SDWebImageOptionsProcessor optionsProcessorWithBlock:^SDWebImageOptionsResult * _Nullable(NSURL * _Nullable url, SDWebImageOptions options, SDWebImageContext * _Nullable context) &#123;</span><br><span class="line">     // Only do animation on `SDAnimatedImageView`</span><br><span class="line">     if (!context[SDWebImageContextAnimatedImageClass]) &#123;</span><br><span class="line">        options |= SDWebImageDecodeFirstFrameOnly;</span><br><span class="line">     &#125;</span><br><span class="line">     // Do not force decode for png url</span><br><span class="line">     if ([url.lastPathComponent isEqualToString:@&quot;png&quot;]) &#123;</span><br><span class="line">        options |= SDWebImageAvoidDecodeImage;</span><br><span class="line">     &#125;</span><br><span class="line">     // Always use screen scale factor</span><br><span class="line">     SDWebImageMutableContext *mutableContext = [NSDictionary dictionaryWithDictionary:context];</span><br><span class="line">     mutableContext[SDWebImageContextImageScaleFactor] = @(UIScreen.mainScreen.scale);</span><br><span class="line">     context = [mutableContext copy];</span><br><span class="line"> </span><br><span class="line">     return [[SDWebImageOptionsResult alloc] initWithOptions:options context:context];</span><br><span class="line"> &#125;];</span><br><span class="line"> @endcode</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) id&lt;SDWebImageOptionsProcessor&gt; optionsProcessor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SD是怎么限制字典配制项的？比钱包强了不止一个档次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NSString * SDWebImageContextOption NS_EXTENSIBLE_STRING_ENUM;</span><br><span class="line">typedef NSDictionary&lt;SDWebImageContextOption, id&gt; SDWebImageContext;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A String to be used as the operation key for view category to store the image load operation. This is used for view instance which supports different image loading process. If nil, will use the class name as operation key. (NSString *)</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT SDWebImageContextOption _Nonnull const SDWebImageContextSetImageOperationKey;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A SDWebImageManager instance to control the image download and cache process using in UIImageView+WebCache category and likes. If not provided, use the shared manager (SDWebImageManager *)</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT SDWebImageContextOption _Nonnull const SDWebImageContextCustomManager;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@weakify(operation); 和 @strongify(operation); <a href="https://blog.csdn.net/ryansuan/article/details/51941702" target="_blank" rel="noopener">https://blog.csdn.net/ryansuan/article/details/51941702</a>  和  <a href="https://www.cnblogs.com/fengmin/p/5870554.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengmin/p/5870554.html</a></p>
</li>
</ol>
<ol start="15">
<li><p>大量IO操作应该放到@autoreleasepool里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载状态和锁，分细一点还是有好处的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载通过栈排序还是堆排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (self.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        // Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation</span><br><span class="line">        // This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations</span><br><span class="line">        // Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder</span><br><span class="line">        for (NSOperation *pendingOperation in self.downloadQueue.operations) &#123;</span><br><span class="line">            [pendingOperation addDependency:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载会不会死锁？哪里用到锁？加到队列后自动调用start开始下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SD_LOCK(self.operationsLock);</span><br><span class="line">    id downloadOperationCancelToken;</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    // There is a case that the operation may be marked as finished or cancelled, but not been removed from `self.URLOperations`.</span><br><span class="line">    if (!operation || operation.isFinished || operation.isCancelled) &#123;</span><br><span class="line">        operation = [self createDownloaderOperationWithUrl:url options:options context:context];</span><br><span class="line">        if (!operation) &#123;</span><br><span class="line">            SD_UNLOCK(self.operationsLock);</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadOperation userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloader operation is nil&quot;&#125;];</span><br><span class="line">                completedBlock(nil, nil, error, YES);</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        @weakify(self);</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            if (!self) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            SD_LOCK(self.operationsLock);</span><br><span class="line">            [self.URLOperations removeObjectForKey:url];</span><br><span class="line">            SD_UNLOCK(self.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        self.URLOperations[url] = operation;</span><br><span class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</span><br><span class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">        downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // When we reuse the download operation to attach more callbacks, there may be thread safe issue because the getter of callbacks may in another queue (decoding queue or delegate queue)</span><br><span class="line">        // So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.</span><br><span class="line">        @synchronized (operation) &#123;</span><br><span class="line">            downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        if (!operation.isExecuting) &#123;</span><br><span class="line">            if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">            &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityNormal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD_UNLOCK(self.operationsLock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么在自己的类里开始后台下载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    __weak typeof(self) wself = self;</span><br><span class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        [wself cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不设NSURLSession的delegateQueue竟然默认串行队列回调! 注意这里回调会通过操作转给内部的task从而实现解码缓存啥的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">        NSURLSession *session = self.unownedSession;</span><br><span class="line">        if (!session) &#123;</span><br><span class="line">            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             *  Create the session for this task</span><br><span class="line">             *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span><br><span class="line">             *  method calls and completion handler calls.</span><br><span class="line">             */</span><br><span class="line">            session = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:self</span><br><span class="line">                                               delegateQueue:nil];</span><br><span class="line">            self.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当网络请求成功或失败需要调用 done表示此操作已完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// make sure to call `[self done]` to mark operation as finished</span><br><span class="line">if (error) &#123;</span><br><span class="line">    // custom error instead of URLSession error</span><br><span class="line">    if (self.responseError) &#123;</span><br><span class="line">        error = self.responseError;</span><br><span class="line">    &#125;</span><br><span class="line">    [self callCompletionBlocksWithError:error];</span><br><span class="line">    [self done];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两个Data是否相等，用什么？既不用 == ，也不用isEqualTo，而是isEqualToData</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.cachedData isEqualToData:imageData]</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的总长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line">    NSInteger expected = (NSInteger)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; 0 ? expected : 0;</span><br><span class="line">    self.expectedSize = expected;</span><br><span class="line">    self.response = response;</span><br><span class="line">    NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200;</span><br><span class="line">    BOOL valid = statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400;</span><br><span class="line">    if (!valid) &#123;</span><br><span class="line">        self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadStatusCode userInfo:@&#123;SDWebImageErrorDownloadStatusCodeKey : @(statusCode)&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    //&apos;304 Not Modified&apos; is an exceptional one</span><br><span class="line">    //URLSession current behavior will return 200 status code when the server respond 304 and URLCache hit. But this is not a standard behavior and we just add a check</span><br><span class="line">    if (statusCode == 304 &amp;&amp; !self.cachedData) &#123;</span><br><span class="line">        valid = NO;</span><br><span class="line">        self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCacheNotModified userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, expected, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Status code invalid and marked as cancelled. Do not call `[self.dataTask cancel]` which may mass up URLSession life cycle</span><br><span class="line">        disposition = NSURLSessionResponseCancel;</span><br><span class="line">    &#125;</span><br><span class="line">    __block typeof(self) strongSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已经下载的长度，注意解码问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    if (!self.imageData) &#123;</span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">    </span><br><span class="line">    self.receivedSize = self.imageData.length;</span><br><span class="line">    if (self.expectedSize == 0) &#123;</span><br><span class="line">        // Unknown expectedSize, immediately call progressBlock and return</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(self.receivedSize, self.expectedSize, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get the finish status</span><br><span class="line">    BOOL finished = (self.receivedSize &gt;= self.expectedSize);</span><br><span class="line">    // Get the current progress</span><br><span class="line">    double currentProgress = (double)self.receivedSize / (double)self.expectedSize;</span><br><span class="line">    double previousProgress = self.previousProgress;</span><br><span class="line">    double progressInterval = currentProgress - previousProgress;</span><br><span class="line">    // Check if we need callback progress</span><br><span class="line">    if (!finished &amp;&amp; (progressInterval &lt; self.minimumProgressInterval)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.previousProgress = currentProgress;</span><br><span class="line"></span><br><span class="line">    if (self.options &amp; SDWebImageDownloaderProgressiveLoad) &#123;</span><br><span class="line">        // Get the image data</span><br><span class="line">        NSData *imageData = [self.imageData copy];</span><br><span class="line">        </span><br><span class="line">        // progressive decode the image in coder queue</span><br><span class="line">        dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                UIImage *image = SDImageLoaderDecodeProgressiveImageData(imageData, self.request.URL, finished, self, [[self class] imageOptionsFromDownloaderOptions:self.options], self.context);</span><br><span class="line">                if (image) &#123;</span><br><span class="line">                    // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</span><br><span class="line">                    </span><br><span class="line">                    [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(self.receivedSize, self.expectedSize, self.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>token的多继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface SDWebImageDownloadToken : NSObject &lt;SDWebImageOperation&gt;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift开发者必备Tips</title>
    <url>/2018/04/10/Swift%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87Tips/</url>
    <content><![CDATA[<ol>
<li><p>柯里化: 通过模板来批量生成方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;</span><br><span class="line">return &#123; $0 &gt; comparer&#125;</span><br><span class="line">&#125;</span><br><span class="line">let greaterThan10 = greaterThan(10)</span><br><span class="line">greaterThan10(13) // true</span><br><span class="line">greaterThan10(0) // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>将protocol的方法声明为mutating：mutating关键字是为了能在该方法里修改struct或enum变量，另外使用class实现protocol时，可以不用加mutating，因class可随意改变量，mutating对于class时完全透明的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">protocol Vehicle &#123;</span><br><span class="line">var color: UIColor &#123;get set&#125;</span><br><span class="line">mutating func changeColor()</span><br><span class="line">&#125;</span><br><span class="line">struct MyCar: Vehicle &#123;</span><br><span class="line">var color = UIColor.blue</span><br><span class="line">mutating func changeColor() &#123;</span><br><span class="line">color = .red</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环可用于实现了Sequence的类型上，要实现Sequence需要先实现IteratorProtocol协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ReverseIterator&lt;T&gt;: IteratorProtocol &#123;</span><br><span class="line">typealias Element = T</span><br><span class="line">var array:[Element]</span><br><span class="line">var currentIndex = 0</span><br><span class="line">init(array:[Element]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">currentIndex = array.count - 1</span><br><span class="line">&#125;</span><br><span class="line">func next() -&gt; Element? &#123;</span><br><span class="line">if currentIndex &lt; 0 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;else &#123;</span><br><span class="line">let element = array[currentIndex]</span><br><span class="line">currentIndex -= 1</span><br><span class="line">return element</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct ReverseSequence&lt;T&gt;: Sequence &#123;</span><br><span class="line">var array:[T]</span><br><span class="line">init(array:[T]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">&#125;</span><br><span class="line">typealias Iterator = ReverseIterator&lt;T&gt;</span><br><span class="line">func makeIterator() -&gt; ReverseIterator&lt;T&gt; &#123;</span><br><span class="line">return ReverseIterator(array: self.array)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [2,3,4,5,7,6]</span><br><span class="line">for (index, value) in ReverseSequence(array: arr).enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(value)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多元组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func swap&lt;T&gt;(a: inout T, b: inout T) &#123;</span><br><span class="line">(a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2</span><br><span class="line">var b = 3</span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">print(&quot;a is \(a) b is \(b)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@autoclosure 是把形如 ()-&gt;T 的一句表达式（无参数，就一句）自动封装成闭包，var c = a ?? b,表示a非nil时c=a，nil时c=b，其实跟连着写的?: 是一样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func logIfTure(_ predicate: ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure (&#123; () -&gt; Bool in</span><br><span class="line">return 2 &gt; 1</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure (&#123;</span><br><span class="line">return 3 &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123; 4 &gt; 3 &#125;)</span><br><span class="line">logIfTure &#123; 5 &gt; 4 &#125;</span><br><span class="line"></span><br><span class="line">func logIfTureAutoclosure(_ predicate:@autoclosure ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意是小括号</span><br><span class="line">logIfTureAutoclosure(6&gt;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@escaping逃逸闭包，异步回调那种函数执行完了闭包还需要执行，注意循环引用使用weak self unowned self；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 逃逸闭包</span><br><span class="line">func testEscapingFunc(printNum: @escaping (_ num: Int) -&gt; ())&#123;</span><br><span class="line">print(&quot;testEscapingFunc begin&quot;)</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">printNum(66)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;testEscapingFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testEscapingFunc &#123; (num) in</span><br><span class="line">print(&quot;Escaping colsure begin&quot;)</span><br><span class="line">print(&quot;Escaping num is \(num)&quot;)</span><br><span class="line">print(&quot;Escaping colsure end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 非逃逸闭包</span><br><span class="line">func testNoescapeFunc(printNum: (_ num: Int) -&gt; ()) &#123;</span><br><span class="line">print(&quot;testNoescapeFunc begin&quot;)</span><br><span class="line">printNum(77)</span><br><span class="line">print(&quot;testNoescapeFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testNoescapeFunc &#123; (num) in</span><br><span class="line">print(&quot;Noescape colsure begin&quot;)</span><br><span class="line">print(&quot;Noescape num is \(num)&quot;)</span><br><span class="line">print(&quot;Noescape colsure end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional chaining ，返回的都是最后一个的可选类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Pet &#123;</span><br><span class="line">let name: String</span><br><span class="line">init(name: String) &#123;</span><br><span class="line">self.name = name</span><br><span class="line">&#125;</span><br><span class="line">func play() -&gt; (String) &#123;</span><br><span class="line">return &quot;playing&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child &#123;</span><br><span class="line">var pet: Pet?</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = Child()</span><br><span class="line">xiaoming.pet = Pet(name: &quot;dog&quot;)</span><br><span class="line">if let petName = xiaoming.pet?.name &#123;</span><br><span class="line">print(&quot;xiaoming pet name is \(petName)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if let p = xiaoming.pet?.play() &#123;</span><br><span class="line">print(&quot;xiaoming pet is \(p)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载操作符，慎用避免冲突，应该是公开的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">var x = 0</span><br><span class="line">var y = 0</span><br><span class="line">&#125;</span><br><span class="line">func +(left:Vector2D, right:Vector2D) -&gt; Vector2D&#123;</span><br><span class="line">return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">&#125;</span><br><span class="line">let v1 = Vector2D(x: 1, y: 2)</span><br><span class="line">let v2 = Vector2D(x: 3, y: 4)</span><br><span class="line">let v3 = v1 + v2</span><br><span class="line">print(&quot;v3 is \(v3)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>func的参数修饰，默认参数都是copy的，inout关键字可以直接修改参数值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func incrementor1(x: Int) -&gt; Int &#123;</span><br><span class="line">x + 1</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;参数不可变 \(incrementor1(x: 1))&quot;)</span><br><span class="line">func incrementor2(x: inout Int) &#123;</span><br><span class="line">x = x + 1</span><br><span class="line">&#125;</span><br><span class="line">var x = 1</span><br><span class="line">incrementor2(x: &amp;x)</span><br><span class="line">print(&quot;参数可变 \(x)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字面量表达式，实现类似ExpressibleByBooleanLiteral的协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 以下就是字面量表达式，思考为啥写个true编译器就知道是BOOL类型的</span><br><span class="line">var aBool = true</span><br><span class="line">var aString = &quot;this is a string&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下标，数组下标注意越界，字典下标返回可选类型。可以重写数组或字典下标，也可以自定义下标,实现subscript方法，延伸阅读<a href="https://www.cnblogs.com/ludashi/p/5179275.html" target="_blank" rel="noopener">窥探Swift之数组安全索引与数组切片</a></p>
</li>
<li><p>方法嵌套，更清晰不用在别的地方调用一堆小方法了都在函数里面呢，访问权限更易管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func makeIncrementer(add: Int) -&gt; (inout Int) -&gt; Void &#123;</span><br><span class="line">func incrementer(x : inout Int) -&gt; Void &#123;</span><br><span class="line">x = x + add</span><br><span class="line">&#125;</span><br><span class="line">return incrementer;</span><br><span class="line">&#125;</span><br><span class="line">let incrementer2 = makeIncrementer(add: 2)</span><br><span class="line">var y = 3</span><br><span class="line">incrementer2(&amp;y)</span><br><span class="line">print(&quot;\(y)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空间。基于module的而不是直接再代码中显示指明的，进行app开发时，默认添加app的主target里的内容都在同一命名空间里，即同一target里名称不能相同。</p>
</li>
<li><p>typealias，指定类型重命名。当实现多个协议时，也可以用 &amp; 连接多协议，用typealias重命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol Dog &#123;</span><br><span class="line">func watch() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">protocol Cat &#123;</span><br><span class="line">func sleep() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">typealias Pet = Dog &amp; Cat</span><br></pre></td></tr></table></figure>
</li>
<li><p>associatedtype 如果有多个协议，它们的方法和属性都一样，只有协议中用到的类型不同，则可合并为一个使用关联类型(associatedtype)进行区分。实现时自定义typealias相应类型即可。延伸阅读<a href="https://www.cnblogs.com/muzijie/p/6596164.html" target="_blank" rel="noopener">Swift—–协议Protocol</a></p>
</li>
<li>可变参数<br><a href="https://www.jianshu.com/p/5a1178f3c36f" target="_blank" rel="noopener">OC的可变参数</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 注意可变参数必须是最后一个参数，且name后面有一个英文逗号</span><br><span class="line">- (void)testMultiplePramar:(NSString *)name, ... &#123;</span><br><span class="line">// 一个字符类型的指针，指针指向当前的参数，需要通过这个指针取参数。</span><br><span class="line">va_list arg_list;</span><br><span class="line">// 初始化字符指针的函数，将把arg_list指针指向name这个可变形参的第一个位置</span><br><span class="line">va_start(arg_list, name);</span><br><span class="line">NSLog(@&quot;第一个 ： %@&quot;, name);</span><br><span class="line">while(YES)&#123;</span><br><span class="line">// 这是一个取参数的函数，这个函数需要两个参数，第一个参数是字符指针va_list，第二个参数是我们需要取的可变参数的数据类型</span><br><span class="line">// 这个函数需要做两件事：1：取到指定数据类型的参数。2：将指针ap指向下一个可变参数的地址。</span><br><span class="line">NSString * obj=va_arg(arg_list,NSString *);</span><br><span class="line">// 取完所有参数之后，跳出循环</span><br><span class="line">if(obj==nil)break;</span><br><span class="line">NSLog(@&quot;--- %@&quot;,obj);</span><br><span class="line">&#125;</span><br><span class="line">// 最后要将指针ap指向NULL。避免野指针。和va_start成对使用。</span><br><span class="line">va_end(arg_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Swift版可变参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 只能有一个可变参数，位置不限类型相同</span><br><span class="line">func myFunc(numbers:Int..., str: String) &#123;</span><br><span class="line">numbers.forEach &#123; (i) in</span><br><span class="line">print(&quot;\(str)，第\(i)个&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunc(numbers: 1,2,3,4,5, str: &quot;hello&quot;)</span><br><span class="line">Swift版的stringformat方法 init(format:NSString, _ args: CVarArgType...)</span><br></pre></td></tr></table></figure></p>
<ol start="17">
<li><p>初始化方法顺序<br>明确一个问题<a href="https://stackoverflow.com/questions/8056188/should-i-refer-to-self-property-in-the-init-method-with-arc" target="_blank" rel="noopener">不要在init初始化方法里使用self.property</a> <br><br>A，OC是先初始化父类在初始化子类成员变量<br><br>B，1，先初始化子类成员变量，<br><br>2调用父类初始化，（若没第3步，可不写编译器自己加）<br><br>3对父类中需要改变的成员进行设定<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">// Designated 指定的 init初始化方法</span><br><span class="line">// 也可以加上required关键字以确保子类对其实现</span><br><span class="line">init(num: Int) &#123;</span><br><span class="line">numA = num; //可对let的实例常量赋值</span><br><span class="line">&#125;</span><br><span class="line">// 所有的便利构造器都必须调同一类中Designated初始化完成设置，且不能被子类重写或从子类中以super的方式调用</span><br><span class="line">convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 1000 : 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassB: ClassA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">override init(num: Int) &#123;</span><br><span class="line">numB = num + 2</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let bObj = ClassB(bigNum: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化返回nil<br>OC初始化失败可以返回nil，但swift没有return，因此swif中用 init? 表示返回可选值，即可能失败</p>
</li>
<li><a href="https://www.jianshu.com/p/c2c95c1c593d" target="_blank" rel="noopener">static 和 class</a>， 注意cpoy on write</li>
<li>容器(Array, Dictionary, Set)只能放同一类型元素，如果想放不同类型怎么办？<br><br>A。类型转换，信息损失十分危险，最好不要用！<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">let mixed: [Any] = [1, &quot;Two&quot;,3]; // Any类型可以隐式转换</span><br><span class="line">// 转换为[NSObject]</span><br><span class="line">let objectArray = [1 as NSObject, &quot;two&quot; as NSObject, 3 as NSObject]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>B。如果有共同特征，可以添加实现同一协议的类型的对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">let mixed2 : [CustomStringConvertible] = [1, &quot;two&quot;, 3]</span><br><span class="line">for obj in mixed2 &#123;</span><br><span class="line">print(obj.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C。将类型信息封装到enum中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">enum IntOrString &#123;</span><br><span class="line">case IntValue(Int)</span><br><span class="line">case StringValue(String)</span><br><span class="line">&#125;</span><br><span class="line">let mixed = [IntOrString.IntValue(1), IntOrString.StringValue(&quot;two&quot;), IntOrString.IntValue(3)]</span><br><span class="line">for value in mixed &#123;</span><br><span class="line">switch value &#123;</span><br><span class="line">case let .IntValue(i):</span><br><span class="line">print(i)</span><br><span class="line">case let .StringValue(str):</span><br><span class="line">print(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="21">
<li><p>default参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hello(name:String = &quot;JZK&quot;, str:String)&#123;</span><br><span class="line">print(name+&quot; &quot;+str)</span><br><span class="line">&#125;</span><br><span class="line">hello(str: &quot;hello world&quot;)</span><br><span class="line">hello(name: &quot;dxm&quot;, str: &quot;hello world&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式。自定义符号还是麻烦，其实用OC的是最省事的，<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a>，<a href="https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149" target="_blank" rel="noopener">8个常用正则</a></p>
</li>
<li><p>模式匹配,没看懂好像就是switch的使用而已呀，重载~/ 跟switch有啥子关系。。。</p>
</li>
<li><p>… 和 ..&lt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 包含3，即输出0 1 2 3</span><br><span class="line">for i in 0...3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 小于3（不含3），即输出0 1 2</span><br><span class="line">for i in 0..&lt;3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 还可以通过 ... 或 ..&lt; 来连接两个字符串</span><br><span class="line">// 但经过试验发现很难用，例&quot;0&quot;...&quot;10&quot; 包含&quot;1&quot;但不包含&quot;2&quot;, 还有校验ASCII码 \0...~ 确实正确的</span><br></pre></td></tr></table></figure>
</li>
<li><p>AnyClass, 元类型和 .self</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// swift中能够表示“任意”这个概念的除了 Any 和 AnyObject 外，还有AnyClass , AnyClass = AnyObject.Type</span><br><span class="line">// .Type 表示的是某个类型的元类型。.Protocol表示某个协议的元类型</span><br><span class="line">// 类型.self 表示获得该类型Class， 实例.self表示获得该实例对象</span><br><span class="line">import UIKit</span><br><span class="line">class AVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">class BVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 强转成AnyClass，类似工厂方法</span><br><span class="line">let VCTypes : [AnyClass] = [AVC.self, BVC.self]</span><br><span class="line">for type in VCTypes &#123;</span><br><span class="line">if type is UIViewController.Type &#123;</span><br><span class="line">// 想想为什么可以调init 类方法？</span><br><span class="line">let vc = (type as! UIViewController.Type).init()</span><br><span class="line">print(&quot;vc实例类型为：\(vc)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议和类方法中的Self</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 协议没自己的上下文信息，也不知道谁实现。当我们希望在协议中使用的就是实现这个协议本身的类型的话，就需要使用Self（注意首字母大写）进行指代，此时Self不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态类型和多方法<br><a href="https://www.jianshu.com/p/7eb4053d339e" target="_blank" rel="noopener">dynamicType废除，用type(of:)代替</a></p>
</li>
<li>属性观察<br>存储型属性 willSet 和 didSet 方法中newValue表示将要设定的，oldValue表示已经设定的。注意初始化时不会调属性观察。计算形型属性只有get和set方法</li>
<li>final 表示不允许继承或重写。</li>
<li><p>lazy修饰符和lazy方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">// class或struct 的变量属性，且需指明类型</span><br><span class="line">lazy var str : String = &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">// lazy 也能修饰方法,对于可能提前退出情况，性能优化明显</span><br><span class="line">let arr = 1...3</span><br><span class="line">let result = arr.lazy.map &#123; (i: Int) -&gt; Int in</span><br><span class="line">print(&quot;map \(i)&quot;)</span><br><span class="line">return i * 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;begin&quot;)</span><br><span class="line">for i in result &#123;</span><br><span class="line">print(&quot;result \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>refection 和 mirror , 知道有反射就行了，最好不用</p>
</li>
<li>强制解包，少用才好，多用可选链！</li>
<li><p>多重optional</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aNil : String? = nil</span><br><span class="line">var anotherNil : String?? = aNil</span><br><span class="line">var literalNil : String?? = nil</span><br><span class="line">if anotherNil != nil &#123;</span><br><span class="line">print(&quot;anotherNil&quot;) // 输出</span><br><span class="line">&#125;</span><br><span class="line">if literalNil != nil &#123;</span><br><span class="line">print(&quot;literalNil&quot;) //</span><br><span class="line">&#125;</span><br><span class="line">// 但用po输出时，anotherNil和literalNil 都是nil，因lldb已经将optional展开了</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional map ，没啥用</p>
</li>
<li><p>协议扩展 protocol extension， 可以为协议中定义的方法提供一个默认的实现</p>
</li>
<li><p>where 和模式匹配</p>
</li>
<li>indirect 和嵌套enum</li>
<li>swift的#selector 和OC的@selector一样，swift4中默认所有的swift方法在OC中都不可见，所以需要在方法前加上@objc 关键字。使用#selector时，swift的同名方法需要强制转化</li>
<li><p>实例方法动态调用，挺好玩的，虽然我也没想到有什么用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">func method(num: Int) -&gt; Int &#123;</span><br><span class="line">return num + 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化MyClass对象，再调用method方法就限定死了类型</span><br><span class="line">// 但swift中可直接用 Type.instanceMethod的语法生成一个可以柯里化的方法，只适用于实例方法，对getter或setter无效,同名方法需对 f 加上类型加以区别</span><br><span class="line">let f = MyClass.method</span><br><span class="line">let object = MyClass()</span><br><span class="line">let result = f(object)(1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设置init方法为private来覆盖默认public的方法，保证其他地方不能init实例</span><br><span class="line">//方法一</span><br><span class="line">class AppShared &#123;</span><br><span class="line">private static let _sharedInstance = AppShared()</span><br><span class="line">class func sharedInstance() -&gt;AppShared&#123;</span><br><span class="line">return _sharedInstance</span><br><span class="line">&#125;</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方法二</span><br><span class="line">class AppShared2 &#123;</span><br><span class="line">static let sharedInstance = AppShared2()</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// swift中没有宏，实质上是一些全局常量和函数</span><br><span class="line">//#if condition //注意condition大小写敏感</span><br><span class="line">//#endif</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>延伸阅读<a href="https://www.cnblogs.com/Bob-wei/p/5237761.html" target="_blank" rel="noopener">Swift中如何使用 #if DEBUG</a><br>condition  | 可选参数<br>—|—<br>os() | macOS,iOS,tvOS,watchOS,Linux<br>arch() | x86_64, arm, arm64, i386<br>swift() | &gt;= 某个版本</p>
<ol start="42">
<li>编译标记OC的#param，在swift中用 // MARK:- 代替（注意大写），此外还有// TODO: 和 // FIXME: , 但没有#warning的替代品</li>
<li>@UIApplicationMain， 和OC的main函数是一样的，如果我们想使用UIApplicaiton的子类(例如监听所有的点击事件)，就可以创建main.swift</li>
<li>@objc 和 dynamic，swift写的类继承自NSObject的话，swift会自动为所有非private的类和成员加上@objc，但@objc并不意味着会变成动态派发，动态派发需用dynamic关键字。延伸阅读<a href="https://www.jianshu.com/p/37f720df43ac" target="_blank" rel="noopener">iOS OC与Swift混编</a>，注意和OC的@dynamic没任何关系，@dynamic表示不用编译器自动生成getter和setter方法</li>
<li>可选协议和协议扩展</li>
<li>内存管理，weak和unowned，如果再在访问时不会被释放的话，尽量用unowned，如果存在被释放的课鞥呢，那就用weak</li>
<li>@autoreleasepool在swift中已经没有了, swift提倡用初始化方法而不是用类方法来生成对象</li>
<li>值类型和引用类型，swift中所有的内建类型都是值类型，甚至String，array以及Dictionary都是值类型，值类型复制值发生在内容发生改变时</li>
<li>String 还是 NSString？能用String尽量用String，但使用Range时还是NSString更好用</li>
<li><p>UnsafePointer, 用于对C语言的指针进行转换，C中的基本类型在swift中对应的类型都有统一的命名规则：前面加上 C 且首字母大写，例如int 对应的类型为 CInt，int的指针转换到swift中对应的就是UnsafePointer<cint>, C的指针不可变用UnsafePointer,可变指针用UnsafeMutablePointer</cint></p>
</li>
<li><p>C指针的内存管理，无法使用ARC，deallocate与deinitialize应该要和allocate与initialize成对出现。malloc和calloc要与free匹配</p>
</li>
<li>C中指向函数的指针可转为闭包，不过需要加上@convention标注</li>
<li>GCD和延时调用, <a href="https://www.jianshu.com/p/51fd1362249e" target="_blank" rel="noopener">OC多线程</a> 和 <a href="https://www.cnblogs.com/csdnIOS/p/6874839.html" target="_blank" rel="noopener">swift的GCD</a></li>
<li>获取对象类型 type(of:)</li>
<li>OC的 isKindOfClass 和 isMemberOfClass 在swift中继承自NSObject的依然可以使用，swift还有 is 关键字等同于isKindOfClass，但也可以用于struct或enum进行类型判断。as 关键字向上转型；as！向下转型；as？向下转型，如果失败返回nil</li>
<li><p>swift中的KVO实现, 延伸：可用属性观察自己实现，也可<a href="http://chris.eidhof.nl/post/references/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">// 继承自NSObject</span><br><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">// 要检测的属性必须标注 @objc dynamic</span><br><span class="line">@objc dynamic var date = Date()</span><br><span class="line">&#125;</span><br><span class="line">class KvoClass: NSObject &#123;</span><br><span class="line">var myObject : MyClass!</span><br><span class="line">var observation: NSKeyValueObservation?</span><br><span class="line">override init() &#123;</span><br><span class="line">myObject = MyClass()</span><br><span class="line">print(&quot;初始化时间：\(Date())&quot;)</span><br><span class="line">observation = myObject.observe(\MyClass.date, options: [.new], changeHandler: &#123; (_, change) in</span><br><span class="line">if let newDate = change.newValue &#123;</span><br><span class="line">print(&quot;变化时间：\(Date())&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var kvoObject = KvoClass()</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123;</span><br><span class="line">kvoObject.myObject.date = Date()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部scope，隔离代码的好方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OC中使用方法</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// 局部scope</span><br><span class="line">&#123;</span><br><span class="line">UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 100, 44)];</span><br><span class="line">label1.text = @&quot;first label&quot;;</span><br><span class="line">[self.view addSubview:label1];</span><br><span class="line">&#125;</span><br><span class="line">// GNU C的声明扩展</span><br><span class="line">UILabel *label2 = (&#123;</span><br><span class="line">UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 200, 100, 44)];</span><br><span class="line">tempLabel.text = @&quot;second label&quot;;</span><br><span class="line">tempLabel; // 注意没有return</span><br><span class="line">&#125;);</span><br><span class="line">[self.view addSubview:label2];</span><br><span class="line">&#125;</span><br><span class="line">// swift不允许直接使用大括号，和闭包冲突。而且没有GNU C的声明扩展</span><br><span class="line">// 但可以使用匿名闭包</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">let titleLabel : UILabel = &#123;</span><br><span class="line">let label = UILabel(frame: CGRect(x: 0, y: 100, width: 100, height: 44))</span><br><span class="line">label.text = &quot;匿名闭包&quot;</span><br><span class="line">return label</span><br><span class="line">&#125;()</span><br><span class="line">self.view.addSubview(titleLabel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中==表示判断两个对象是否指向同一块内存，在swift中对应为 === ，而swift中的 == 是一个操作符声明，在 Equatable 协议里声明，可重载，没重载的话就是 isEqual </p>
</li>
<li>哈希</li>
<li>类簇，swift中使用工厂方法模式来实现，因swift中初始化方法只能得到完成所有配置的当前类实例，即不可能在公共类中返回子类信息</li>
<li>swift中直接使用C代码或库是不可能的，因此使用C库最好的办法是使用OC文件封装，通过 工程名-Bridging-Header.h 桥接文件来调OC的代码</li>
<li><p>输出格式化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">var b = 1.234567890</span><br><span class="line">print(&quot;b is \(b)&quot;)</span><br><span class="line">let formatB = String(format: &quot;%.2f&quot;, b)</span><br><span class="line">print(&quot;保留两位小数 b is \(formatB)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NS_ENUM对应swift的enum，OC的NS_OPTIONS被映射为满足OptionSet协议的struct类型，以及一组静态的get属性，对不需要选项的可以用[]空集合表示，可以参照 AnimationOptions </p>
</li>
<li><p>数组的enumerated</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (index, item) in [2,4,1,4,5].enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(item)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中可以通过@encode来获取类型编码，swift中可以通过转换为NSValue类型，使用objCType获取类型编码。类型编码这个运行时还是比较有用的</p>
</li>
<li>@asmname可直接将C函数映射为swift函数，但可能会有命名冲突，慎用</li>
<li><p>swift的protocol可以被class，struct，enum等类型遵守。而想要在swift中声明weak delegate，就最要将protocol限制在class内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将protocol限制在class内</span><br><span class="line">// 1,在protocol声明前加上@objc</span><br><span class="line">@objc protocol MyClassDelegate &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br><span class="line">// 更好的办法</span><br><span class="line">// 2，在protocol声明后加上class</span><br><span class="line">protocol ClassDelegate : class &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>associated object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private var key : Void?</span><br><span class="line">extension AppDelegate &#123;&apos;</span><br><span class="line">var associatedObject: String? &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return objc_getAssociatedObject(self, &amp;key) as? String</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_COPY)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中没有 @synchronized ，但可以自己实现一个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OC的@synchronized，也是调objc_sync_enter和objc_sync_exit，外加异常判断</span><br><span class="line">func syncchronized(_ lock: AnyObject, closure:()-&gt;())&#123;</span><br><span class="line">objc_sync_enter(lock) </span><br><span class="line">closure()</span><br><span class="line">objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC与CoreFoundation的转化规则：<strong>bridge转换OC和CF，不涉及内存；</strong>bridge_retained或CFBridgingRetain 将OC转换到CF，需要手动调用CFRelease来释放对象内存；__bridge_transfer或CFBridgingRelease将CF转化为OC，ARC负责释放对象。对于CF系API，如果API名字中含有Create，Copy或Retain的话，使用完成后要手动调CFRelease来释放内存。但在swift中，与CF的转化可以省掉了，也不用调CFRelease释放内存了，一个字：爽</p>
</li>
<li>swift命令号工具</li>
<li><p>随机数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// let num = Int(arc4random()) % 5 + 1 ;  iphone4，5上可能crash</span><br><span class="line">// 因swift的Int和CPU架构有关，在32位CPU上是Int32，64位CPU上是Int64，而arc4random不论什么平台上都是UInt32，故可能越界crash</span><br><span class="line">// 可用arc4random_uniform 实现相同效果</span><br><span class="line">let num = Int(arc4random_uniform()) % 5 + 1 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CustomStringConvertible 和 CustomDebugStringConvertible 协议可以格式化print样式</p>
</li>
<li><p>要throws另一个throws时，应将前者改为rethrows。<a href="https://www.cnblogs.com/junhuawang/p/6231084.html" target="_blank" rel="noopener">Swift异常处理</a> 和 <a href="https://www.jianshu.com/p/a71d87d92459" target="_blank" rel="noopener">swift的defer</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">//try? 抛出异常则返回nil,没抛出正常返回；try！肯定不会抛异常。但抛出异常就crash，慎用 </span><br><span class="line">//try somthing</span><br><span class="line">//try somthing</span><br><span class="line">&#125; catch let err as NSError &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NSAssert宏 在swift中对应为assert函数</p>
</li>
<li>fatalError可以在release和debug下终止程序，类似于Debug下NSAssert(NO, @”说明”);的作用</li>
<li>代码组织和Framework</li>
<li><p>安全的资源组织方式，OC时经常将资源名称定义为宏，这样可相对集中的管理和修改。swift可以用enum和extension来处理资源，原理如下。<a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener">SwiftGen</a> 和 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 可扫描文件自动生成对应的enum或struct文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum ImageName: String &#123;</span><br><span class="line">case myImage = &quot;my_image&quot;</span><br><span class="line">&#125;</span><br><span class="line">extension UIImage &#123;</span><br><span class="line">convenience init?(imageName: ImageName)&#123;</span><br><span class="line">self.init(named: imageName.rawValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let image = UIImage(imageName: .myImage)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Playground延时运行有问题，需要引入PlaygroundSupport框架</p>
</li>
<li>Playground与项目协作</li>
<li>Playground的可视化开发</li>
<li>NaN 是not a number的意思，很特殊，但好像没啥用！ isNaN 判断是否是NaN</li>
<li>swift4以后可以用Codable协议进行json解析，序列化和反序列化操作</li>
<li>swift中NSNull会默认通过可选链转化为nil</li>
<li>在方法或属性上面使用快捷键（ alt+cmd+/ ）快速生成注释。也可使用<a href="https://github.com/realm/jazzy" target="_blank" rel="noopener">jazzy</a></li>
<li>swift由于类型安全，性能比较高！</li>
<li><p>log输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// #file 文件路径，#line 行号，#function 方法名</span><br><span class="line">func Log&lt;T&gt;(_ message: T, file: String = #file, method:String = #function, line:Int = #line)&#123;</span><br><span class="line">print(&quot;\((file as NSString).lastPathComponent)[\(line)],\(method): \(message)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中可以通过 &amp;+，&amp;-，&amp;*，&amp;/, &amp;% 来忽略溢出的错误</p>
</li>
<li>swift中没有宏定义，使用let 或 get属性来替代宏定义</li>
<li>属性访问控制：open (跨模块) &gt; public（本模块） &gt; interal（本模块内部用） &gt; fileprivate（本文件可用） &gt; private（本类可用）</li>
<li>swift中的测试</li>
<li>swift的CoreData使用</li>
<li>闭包很好用，最好写全了，别用乱七八糟的简写</li>
</ol>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>UIBezierPath详解</title>
    <url>/2016/07/10/UIBezierPath%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><p>&emsp;&emsp;iOS里涉及到“路径”绕不开UIBezierPath，UIBezierPath已经满足了绝大部分的开发需求，建议大家自己动手去实验一下，看看到底什么效果！</p>
<p>&emsp;&emsp;一般自定义试图的都需要重写drawRect方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">// Drawing code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)bezierPath;</span><br><span class="line"></span><br><span class="line">// 初始化一个矩形</span><br><span class="line">+ (instancetype)bezierPathWithRect:(CGRect)rect;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">初始化一个椭圆</span><br><span class="line">rect的width和height分别表示椭圆的长轴和短轴，当然宽高相等意味着圆形</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">初始化一个所有角都是圆角的矩形</span><br><span class="line">cornerRadius表示圆角半径</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // rounds all corners with the same horizontal and vertical radius</span><br><span class="line">/*</span><br><span class="line">初始化一个指定角（一个或多个）是圆角的矩形，</span><br><span class="line">corners是圆角的位置，</span><br><span class="line">cornerRadius表示圆角半径</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">指定中心化画圆弧</span><br><span class="line">center 圆心</span><br><span class="line">radius 圆的半径</span><br><span class="line">startAngle 和 endAngle 开始和结束的弧度，一般都用 M_PI 即180度来计算！水平向右是0度，水平向左就是180度即M_PI</span><br><span class="line">clockwise clock时钟，clockwise用于表示顺时针方向还是逆时针方向绘制</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;</span><br><span class="line"></span><br><span class="line">+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-构造path"><a href="#1-2-构造path" class="headerlink" title="1.2 构造path"></a>1.2 构造path</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">当前有正在绘制的子路径, 该方法则会隐式的结束当前路径，并将当前点设置为终点</span><br><span class="line">当上一条子路径被终止, 该方法并不会去闭合上一条子路径，即子路径起点终点没连接</span><br><span class="line">大部分情况下绘制直线或曲线之前, 需要先调用这个方法.</span><br><span class="line">*/ </span><br><span class="line">- (void)moveToPoint:(CGPoint)point;</span><br><span class="line"></span><br><span class="line">// 添加一条直线，唯一需要注意的是起点是上文提供的，上文的终点即此次的起点</span><br><span class="line">- (void)addLineToPoint:(CGPoint)point;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">以下两个方法是用于绘制贝塞尔曲线！</span><br><span class="line">说实话，网上其他的介绍都是盗图直接上，谈不上理解！而我高数早就还给老师了，不献丑了</span><br><span class="line">但分享一个css的调试网站：https://cubic-bezier.com/#.17,.67,.83,.67</span><br><span class="line">*/ </span><br><span class="line">- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;</span><br><span class="line">- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">添加一段圆弧</span><br><span class="line">center 圆心</span><br><span class="line">radius 圆的半径</span><br><span class="line">startAngle 和 endAngle 开始和结束的弧度，一般都用 M_PI 即180度来计算！水平向右是0度，水平向左就是180度即M_PI</span><br><span class="line">clockwise clock时钟，clockwise用于表示顺时针方向还是逆时针方向绘制</span><br><span class="line">*/ </span><br><span class="line">- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);</span><br><span class="line"></span><br><span class="line">// 闭合路径，终点和起点连一条直线</span><br><span class="line">- (void)closePath;</span><br><span class="line"></span><br><span class="line">// 移除所有的控制点，也就是删除了所有的子路径</span><br><span class="line">- (void)removeAllPoints;</span><br><span class="line"></span><br><span class="line">// 添加另一个路径。很重要的方法</span><br><span class="line">- (void)appendPath:(UIBezierPath *)bezierPath;</span><br><span class="line"></span><br><span class="line">// 反转路径：形状一样，绘制方向相反</span><br><span class="line">- (UIBezierPath *)bezierPathByReversingPath NS_AVAILABLE_IOS(6_0);</span><br><span class="line"></span><br><span class="line">// 用指定的仿射变换矩阵变换路径的所有点</span><br><span class="line">- (void)applyTransform:(CGAffineTransform)transform;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-Path-info"><a href="#1-3-Path-info" class="headerlink" title="1.3 Path info"></a>1.3 Path info</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Returns an immutable CGPathRef which is only valid until the UIBezierPath is further mutated.</span><br><span class="line">// Setting the path will create an immutable copy of the provided CGPathRef, so any further mutations on a provided CGMutablePathRef will be ignored.</span><br><span class="line">/*</span><br><span class="line">官方解释很清楚了</span><br><span class="line">1、CGPath的getter其实是当前这一刻的路径信息</span><br><span class="line">2、CGPath可理解为copy修饰的不可变对象</span><br><span class="line">*/</span><br><span class="line">@property(nonatomic) CGPathRef CGPath;</span><br><span class="line">- (CGPathRef)CGPath NS_RETURNS_INNER_POINTER CF_RETURNS_NOT_RETAINED;</span><br><span class="line"></span><br><span class="line">// 路径是否为空。需要注意的是就算只调用了 moveToPoint 方法当前路径也不为空.</span><br><span class="line">@property(readonly,getter=isEmpty) BOOL empty;</span><br><span class="line"></span><br><span class="line">// 一个能覆盖所有控制点的最小矩形，包括贝塞尔曲线的控制点1、2</span><br><span class="line">@property(nonatomic,readonly) CGRect bounds;</span><br><span class="line"></span><br><span class="line">// 当前点，用笔画画，当前笔尖的位置！每次move、add和append等都会更新currentPoint</span><br><span class="line">@property(nonatomic,readonly) CGPoint currentPoint;</span><br><span class="line"></span><br><span class="line">// 闭合路径是否包含（边框和内部）某个点，开放路径只检测是否在边框上</span><br><span class="line">- (BOOL)containsPoint:(CGPoint)point;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-Drawing-properties"><a href="#1-4-Drawing-properties" class="headerlink" title="1.4 Drawing properties"></a>1.4 Drawing properties</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 线宽</span><br><span class="line">@property(nonatomic) CGFloat lineWidth;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">线头样式</span><br><span class="line">kCGLineCapButt,  // 默认</span><br><span class="line">kCGLineCapRound, // 圆角</span><br><span class="line">kCGLineCapSquare // 正方形</span><br><span class="line">*/</span><br><span class="line">@property(nonatomic) CGLineCap lineCapStyle;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">线连接处样式</span><br><span class="line">kCGLineJoinMiter, // 默认</span><br><span class="line">kCGLineJoinRound, // 圆润</span><br><span class="line">kCGLineJoinBevel  // 斜角</span><br><span class="line">*/</span><br><span class="line">@property(nonatomic) CGLineJoin lineJoinStyle;</span><br><span class="line">// 最大斜接长度 只在lineJoinStyle 是 kCGLineJoinMiter时使用</span><br><span class="line">@property(nonatomic) CGFloat miterLimit; </span><br><span class="line"></span><br><span class="line">// 弯曲路径的渲染精度，默认为0.6，越小精度越高，相应的更加消耗性能。</span><br><span class="line">@property(nonatomic) CGFloat flatness;</span><br><span class="line"></span><br><span class="line">// 单双数圈规则是否用于绘制路径，默认是NO</span><br><span class="line">@property(nonatomic) BOOL usesEvenOddFillRule; // Default is NO. When YES, the even-odd fill rule is used for drawing, clipping, and hit testing.</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">设置虚线</span><br><span class="line">pattern C语言类型的数组</span><br><span class="line">count pattern数组的个数</span><br><span class="line">phase 起始位置</span><br><span class="line">*/</span><br><span class="line">- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;</span><br><span class="line">// 检索线段类型</span><br><span class="line">- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-其他"><a href="#1-5-其他" class="headerlink" title="1.5 其他"></a>1.5 其他</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 填充颜色</span><br><span class="line">- (void)fill;</span><br><span class="line"></span><br><span class="line">// 路径绘制</span><br><span class="line">- (void)stroke;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// These methods do not affect the blend mode or alpha of the current graphics context</span><br><span class="line">// 用指定的混合模式和透明度值来描绘受接收路径所包围的区域</span><br><span class="line">- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;</span><br><span class="line">// 使用指定的混合模式和透明度值沿着接收器路径。绘制一行</span><br><span class="line">- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;</span><br><span class="line"></span><br><span class="line">// 剪切被接收者路径包围的区域该路径是带有剪切路径的当前绘图上下文。使得其成为我们当前的剪切路径</span><br><span class="line">- (void)addClip;</span><br></pre></td></tr></table></figure>
<h3 id="CGPath"><a href="#CGPath" class="headerlink" title="CGPath"></a>CGPath</h3><p>&emsp;&emsp;CGPath的大部分用法和UIBezierPath差不多，感兴趣的童鞋可以自己去看看！一眼就能看懂，个别需要注意的：1、由于CG没有ARC，需要手动释放CGRelease；2、CGMutablePathRef才能进行move、add等操作；</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>UIImage技巧</title>
    <url>/2014/11/28/UIImage%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="PNG-amp-JPEG"><a href="#PNG-amp-JPEG" class="headerlink" title="PNG &amp; JPEG"></a>PNG &amp; JPEG</h3><ul>
<li>JPEG可以非常好的压缩图片，但是JPEG是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像gzip这样压缩算法的限制，但是压缩算法也更复杂。相对来说，JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间。</li>
<li>对于PNG来说它的压缩是无损的，所以图片相对JPEG来说也大很多，加载时间会比JPEG更长，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li><p>imageNamed 第一次加载慢点，有缓存，缓存什么时候清除由系统决定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;logo&quot;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>imageWithContentsOfFile 用于一次性的本地图片，无缓存，加载快点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *filePath = [NSString stringWithFormat:@&quot;%@/%@.png&quot;, [[NSBundle mainBundle] resourcePath], @&quot;logo&quot;];</span><br><span class="line">UIImage *image = [UIImage imageWithContentsOfFile:filePath];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="内存消耗计算"><a href="#内存消耗计算" class="headerlink" title="内存消耗计算"></a>内存消耗计算</h3><ul>
<li>与分辨率无关，和宽高有关<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Width x Height x 4 / 1024 / 1024 （M）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="contentMode理解"><a href="#contentMode理解" class="headerlink" title="contentMode理解"></a>contentMode理解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">UIViewContentModeScaleToFill, //图片根据imageView的大小显示，图片会变形</span><br><span class="line">UIViewContentModeScaleAspectFit, // 按比例压缩，图片大边缩小策略即图片总能完全显示，空白部分透明</span><br><span class="line">UIViewContentModeScaleAspectFill, // 按比例压缩，图片小边放大策略即图片总是显示不完全，图片居中</span><br><span class="line">//下面的属性都是不会拉伸图片的</span><br><span class="line">UIViewContentModeRedraw, //调用setNeedsDisplay 方法时,就会重新渲染图片</span><br><span class="line">UIViewContentModeCenter,//显示图片中间</span><br><span class="line">UIViewContentModeTop, //显示图片顶部</span><br><span class="line">UIViewContentModeBottom, //显示图片底部</span><br><span class="line">UIViewContentModeLeft, //显示图片左边</span><br><span class="line">UIViewContentModeRight, //显示图片右边</span><br><span class="line">UIViewContentModeTopLeft, //显示图片左上</span><br><span class="line">UIViewContentModeTopRight, //显示图片右上</span><br><span class="line">UIViewContentModeBottomLeft, //显示图片左下</span><br><span class="line">UIViewContentModeBottomRight, //显示图片右下</span><br><span class="line">*/</span><br><span class="line">imageView.contentMode = UIViewContentModeScaleAspectFit;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>UIScrollView瀑布流</title>
    <url>/2015/09/26/UIScrollView%E7%80%91%E5%B8%83%E6%B5%81/</url>
    <content><![CDATA[<ul>
<li>原理：先计算出所有cell的位置，然后根据offset判断屏幕内的进行加载</li>
<li><p>JZKWaterFallView.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@class JZKWaterFallView;</span><br><span class="line">@protocol JZKWaterFallViewDelegate &lt;NSObject&gt;</span><br><span class="line">// 多少列</span><br><span class="line">- (NSInteger)numberOfCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">// 一共多少个cell</span><br><span class="line">- (NSInteger)numberOfCellsInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">// 定制cell类型</span><br><span class="line">- (UIView *)waterFallView:(JZKWaterFallView *)waterFallView cellForRowAtIndex:(NSInteger )index;</span><br><span class="line">// cell高度,可以用NSIndexPath，但我懒得整了</span><br><span class="line">- (CGFloat)waterFallView:(JZKWaterFallView *)tableView heightForRowAtIndex:(NSInteger )index;</span><br><span class="line">// 点击事件自己写吧，懒得判断UIView具体类型了</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">// 列间距</span><br><span class="line">- (CGFloat )offsetXBetweenCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">// 行间距</span><br><span class="line">- (CGFloat )offsetYBetweenLinesInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JZKWaterFallView : UIView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) id&lt;JZKWaterFallViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (UIView *)dequeueReusableCell;</span><br><span class="line">- (void)reloadData;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>JZKWaterFallView.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;JZKWaterFallView.h&quot;</span><br><span class="line"></span><br><span class="line">#define kItemViewTag 6848</span><br><span class="line"></span><br><span class="line">@interface JZKWaterFallView ()&lt;UIScrollViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIScrollView *scrollView;</span><br><span class="line">@property (nonatomic, strong) UIView *contentView;</span><br><span class="line">// 各个cell的位置</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *cellFrames;</span><br><span class="line">// cell 缓冲池</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *cellCachePool;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JZKWaterFallView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">self = [super initWithFrame:frame];</span><br><span class="line">if (self) &#123;</span><br><span class="line">[self setUpWithFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUpWithFrame:(CGRect)frame &#123;</span><br><span class="line">CGFloat width = frame.size.width;</span><br><span class="line">CGFloat height = frame.size.height;</span><br><span class="line">_scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, width, height)];</span><br><span class="line">_scrollView.delegate = self;</span><br><span class="line">[self addSubview:_scrollView];</span><br><span class="line">_cellCachePool = [[NSMutableArray alloc] init];</span><br><span class="line">_cellFrames = [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)reloadData &#123;</span><br><span class="line">[self clear];</span><br><span class="line">if ([self numberOfCulumns] &gt; 0 &amp;&amp; [self numberOfCells] &gt; 0) &#123;</span><br><span class="line">[self reloadScrollView];</span><br><span class="line">CGFloat offsetY = _scrollView.contentOffset.y;</span><br><span class="line">[self refreshItemViewWithOffsetY:offsetY];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clear &#123;</span><br><span class="line">[_contentView removeFromSuperview];</span><br><span class="line">_contentView = nil;</span><br><span class="line">[_cellFrames removeAllObjects];</span><br><span class="line">[_cellCachePool removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)reloadScrollView &#123;</span><br><span class="line">CGFloat scrollViewWidth = _scrollView.frame.size.width;</span><br><span class="line">_contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, scrollViewWidth, 200)];</span><br><span class="line">[_scrollView addSubview:_contentView];</span><br><span class="line"></span><br><span class="line">NSInteger culumnsCount = [self numberOfCulumns];</span><br><span class="line">NSInteger cellCount = [self numberOfCells];</span><br><span class="line">CGFloat offsetX = [self offsetXBetweenCulumns];</span><br><span class="line">CGFloat offsetY = [self offsetYBetweenLines];</span><br><span class="line">CGFloat cellWidth = (scrollViewWidth - (culumnsCount * offsetX))/ culumnsCount;</span><br><span class="line">CGFloat maxHeight = [self cellHeightAtIndex:0] + offsetY;</span><br><span class="line">NSMutableArray *culumnsHeight = [[NSMutableArray alloc] init];</span><br><span class="line">NSInteger targetCulumn = 0;</span><br><span class="line">for (int index = 0; index &lt; cellCount; index++) &#123;</span><br><span class="line">CGFloat cellHeight = [self cellHeightAtIndex:index];</span><br><span class="line">CGFloat originX = 0;</span><br><span class="line">CGFloat originY = 0;</span><br><span class="line">// 第一排c特殊处理</span><br><span class="line">if (index &lt; culumnsCount) &#123;</span><br><span class="line">originY = 0;</span><br><span class="line">originX = index*(cellWidth + offsetX);</span><br><span class="line">[culumnsHeight addObject:@(cellHeight + offsetY)];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">// 找到所有列中最矮的</span><br><span class="line">CGFloat minHeight = MAXFLOAT;</span><br><span class="line">for (int j = 0 ; j &lt; culumnsHeight.count; j++) &#123;</span><br><span class="line">CGFloat height = [[culumnsHeight objectAtIndex:j] floatValue];</span><br><span class="line">if (minHeight &gt; height) &#123;</span><br><span class="line">minHeight = height;</span><br><span class="line">targetCulumn = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">originY = minHeight;</span><br><span class="line">originX = targetCulumn * (cellWidth + offsetX);</span><br><span class="line">// 替换</span><br><span class="line">[culumnsHeight replaceObjectAtIndex:targetCulumn withObject:@(originY+cellHeight + offsetY)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGRect frame = CGRectMake(originX, originY, cellWidth, cellHeight);</span><br><span class="line">NSValue *value = [NSValue valueWithCGRect:frame];</span><br><span class="line">[_cellFrames addObject:value];</span><br><span class="line"></span><br><span class="line">if (maxHeight &lt; originY + cellHeight +offsetY) &#123;</span><br><span class="line">maxHeight = originY + cellHeight +offsetY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_contentView.frame = CGRectMake(0, 0, scrollViewWidth, maxHeight);</span><br><span class="line">_scrollView.contentSize = CGSizeMake(scrollViewWidth, maxHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)refreshItemViewWithOffsetY:(CGFloat )offsetY &#123;</span><br><span class="line">for (int index = 0; index &lt; [self numberOfCells]; index++) &#123;</span><br><span class="line">NSValue *value = [_cellFrames objectAtIndex:index];</span><br><span class="line">CGRect frame = [value CGRectValue];</span><br><span class="line">// 判断是否在屏幕内</span><br><span class="line">NSInteger tag = kItemViewTag + index;</span><br><span class="line">if (frame.origin.y + frame.size.height &gt; offsetY &amp;&amp; frame.origin.y + frame.size.height &lt; offsetY + _scrollView.frame.size.height) &#123;</span><br><span class="line">if (![_contentView viewWithTag:tag]) &#123;</span><br><span class="line">UIView *view = [self cellViewForIndex:index];</span><br><span class="line">view.frame = frame;</span><br><span class="line">[_contentView addSubview:view];</span><br><span class="line">[view setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if ([_contentView viewWithTag:tag]) &#123;</span><br><span class="line">UIView *view = [_contentView viewWithTag:tag];</span><br><span class="line">[_cellCachePool addObject:view];</span><br><span class="line">[view removeFromSuperview];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)dequeueReusableCell &#123;</span><br><span class="line">if (_cellCachePool.count &gt; 0) &#123;</span><br><span class="line">UIView *view = [_cellCachePool firstObject];</span><br><span class="line">[_cellCachePool removeObjectAtIndex:0];</span><br><span class="line">return view;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark scrollDelegate</span><br><span class="line"></span><br><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">CGFloat offsetY = scrollView.contentOffset.y;</span><br><span class="line">[self refreshItemViewWithOffsetY:offsetY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark getter</span><br><span class="line">- (NSInteger )numberOfCulumns &#123;</span><br><span class="line">return [self.delegate numberOfCulumnsInWaterFallView:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger )numberOfCells &#123;</span><br><span class="line">return [self.delegate numberOfCellsInWaterFallView:self];</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat )offsetXBetweenCulumns &#123;</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(offsetXBetweenCulumnsInWaterFallView:)]) &#123;</span><br><span class="line">return [self.delegate offsetXBetweenCulumnsInWaterFallView:self];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat )offsetYBetweenLines &#123;</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(offsetYBetweenLinesInWaterFallView:)]) &#123;</span><br><span class="line">return [self.delegate offsetYBetweenLinesInWaterFallView:self];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat )cellHeightAtIndex:(NSInteger)index &#123;</span><br><span class="line">return [self.delegate waterFallView:self heightForRowAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)cellViewForIndex:(NSInteger )index &#123;</span><br><span class="line">return [self.delegate waterFallView:self cellForRowAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController ()&lt;JZKWaterFallViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableArray *heights;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">JZKWaterFallView *waterFallView = [[JZKWaterFallView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, 300)];</span><br><span class="line">waterFallView.delegate = self;</span><br><span class="line">[self.view addSubview:waterFallView];</span><br><span class="line">_heights = [[NSMutableArray alloc] init];</span><br><span class="line">for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">CGFloat height = (arc4random() % 9)*11;</span><br><span class="line">[_heights addObject:@(height)];</span><br><span class="line">&#125;</span><br><span class="line">[waterFallView reloadData];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfCellsInWaterFallView:(JZKWaterFallView *)waterFallView &#123;</span><br><span class="line">return _heights.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)waterFallView:(JZKWaterFallView *)waterFallView cellForRowAtIndex:(NSInteger)index &#123;</span><br><span class="line">UILabel *label = (UILabel *)[waterFallView dequeueReusableCell];</span><br><span class="line">if (label == nil) &#123;</span><br><span class="line">label = [[UILabel alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">label.text = [NSString stringWithFormat:@&quot;第%li个&quot;,(long)index];</span><br><span class="line">if (index % 2 == 0) &#123;</span><br><span class="line">label.backgroundColor = [UIColor blueColor];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">label.backgroundColor = [UIColor yellowColor];</span><br><span class="line">&#125;</span><br><span class="line">return label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)waterFallView:(JZKWaterFallView *)tableView heightForRowAtIndex:(NSInteger)index &#123;</span><br><span class="line">return [[_heights objectAtIndex:index] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>UIEvent简介</title>
    <url>/2015/05/30/UIEvent%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>&emsp;&emsp;UIEvent是代表iOS系统中的一个事件,一个事件包含一个或多个的UITouch；</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p>@property(nonatomic,readonly) UIEventType     type NS_AVAILABLE_IOS(3_0);//事件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventType) &#123;</span><br><span class="line">UIEventTypeTouches,//触摸事件类型 iOS3.0之后可以用</span><br><span class="line">UIEventTypeMotion,//摇晃事件类型 iOS3.0之后可以用</span><br><span class="line">UIEventTypeRemoteControl,//遥控事件类型 iOS4.0之后可以用</span><br><span class="line">UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0),//物理按钮事件类型 iOS9.0之后可以用</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property(nonatomic,readonly) UIEventSubtype  subtype NS_AVAILABLE_IOS(3_0);//子事件类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIEventSubtype) &#123;</span><br><span class="line">//事件没有子类型 iOS3.0之后可以用</span><br><span class="line">UIEventSubtypeNone                              = 0,</span><br><span class="line"></span><br><span class="line">//iOS3.0之后可以用</span><br><span class="line">UIEventSubtypeMotionShake                       = 1, // 摇晃事件</span><br><span class="line"></span><br><span class="line">//遥控的事件子类型 iOS4.0之后可以用</span><br><span class="line">UIEventSubtypeRemoteControlPlay                 = 100,//播放</span><br><span class="line">UIEventSubtypeRemoteControlPause                = 101,//暂停</span><br><span class="line">UIEventSubtypeRemoteControlStop                 = 102,//停止</span><br><span class="line">UIEventSubtypeRemoteControlTogglePlayPause      = 103,//播放或暂停</span><br><span class="line">UIEventSubtypeRemoteControlNextTrack            = 104,//下一曲</span><br><span class="line">UIEventSubtypeRemoteControlPreviousTrack        = 105,//上一曲</span><br><span class="line">UIEventSubtypeRemoteControlBeginSeekingBackward = 106,//开始快退</span><br><span class="line">UIEventSubtypeRemoteControlEndSeekingBackward   = 107,//快退结束</span><br><span class="line">UIEventSubtypeRemoteControlBeginSeekingForward  = 108,//开始快进</span><br><span class="line">UIEventSubtypeRemoteControlEndSeekingForward    = 109,//快进结束</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property(nonatomic,readonly) NSTimeInterval  timestamp;//事件发生时间</p>
</li>
<li>@property(nonatomic, readonly, nullable) NSSet <uitouch *> *allTouches;//所有触摸对象。</uitouch></li>
</ul>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;//没用，都是main window才响应</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;//返回属于一个给定View的触摸对象。</span><br><span class="line">- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);//返回指定的手势触摸对象集合</span><br><span class="line"></span><br><span class="line">//会将丢失的触摸放到一个新的 UIEvent 数组中，你可以用 coalescedTouchesForTouch(_:) 方法来访问</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)coalescedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);</span><br><span class="line"></span><br><span class="line">//辅助UITouch的触摸，预测发生了一系列主要的触摸事件。这些预测可能不完全匹配的触摸的真正的行为，因为它的移动，所以他们应该被解释为一个估计。</span><br><span class="line">- (nullable NSArray &lt;UITouch *&gt; *)predictedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);</span><br></pre></td></tr></table></figure>
<ul>
<li>参考 <a href="https://developer.apple.com/documentation/uikit/uievent" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uievent</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>UIScrollView轮播图</title>
    <url>/2015/07/01/UIScrollView%E8%BD%AE%E6%92%AD%E5%9B%BE/</url>
    <content><![CDATA[<ul>
<li>原理: 使用左中右三个imageview，每次循环完就强制滚到中间ImageView，同时刷新左中右三个imageview；代码如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ZKAutoScrollPicture.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ZKAutoScrollPicture ()&lt;UIScrollViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, retain) UIScrollView *scrollView;</span><br><span class="line">@property (nonatomic, retain) UIImageView *leftImageView;</span><br><span class="line">@property (nonatomic, retain) UIImageView *centerImageView;</span><br><span class="line">@property (nonatomic, retain) UIImageView *rightImageView;</span><br><span class="line">@property (nonatomic, retain) UIPageControl *pageControl;</span><br><span class="line">@property (nonatomic, copy) NSArray&lt;UIImage *&gt; *images;</span><br><span class="line">@property (nonatomic, assign) NSUInteger currentImageIndex;//当前图片索引</span><br><span class="line">@property (nonatomic, retain) NSTimer *timer;</span><br><span class="line">@property (nonatomic, assign) NSTimeInterval timeInterval;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ZKAutoScrollPicture</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">timeInterval:(NSTimeInterval)interval</span><br><span class="line">images:(NSArray&lt;UIImage *&gt; *)images&#123;</span><br><span class="line">self = [super initWithFrame:frame];</span><br><span class="line">if (self) &#123;</span><br><span class="line">self.images = images;</span><br><span class="line">self.timeInterval = interval;</span><br><span class="line">[self startTimer];</span><br><span class="line">[self setupWithFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setImages:(NSArray&lt;UIImage *&gt; *)images &#123;</span><br><span class="line">_images = images;</span><br><span class="line">if (images.count == 0) &#123;</span><br><span class="line">[self stopTimer];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setTimeInterval:(NSTimeInterval)timeInterval &#123;</span><br><span class="line">if (timeInterval &lt;= 0) &#123;</span><br><span class="line">[self stopTimer];</span><br><span class="line">_timeInterval = 0;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">_timeInterval = timeInterval;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setupWithFrame:(CGRect)frame &#123;</span><br><span class="line">CGFloat imageWidth = frame.size.width;</span><br><span class="line">CGFloat imageHeight = frame.size.height;</span><br><span class="line"></span><br><span class="line">_currentImageIndex = 0;</span><br><span class="line">// pageControl</span><br><span class="line">_pageControl=[[UIPageControl alloc]init];</span><br><span class="line">CGSize size= [_pageControl sizeForNumberOfPages:_images.count];</span><br><span class="line">_pageControl.bounds=CGRectMake(0, 0, size.width, size.height);</span><br><span class="line">_pageControl.center=CGPointMake(imageWidth / 2, imageHeight - 10);</span><br><span class="line">_pageControl.pageIndicatorTintColor=[UIColor blackColor];</span><br><span class="line">_pageControl.currentPageIndicatorTintColor=[UIColor redColor];</span><br><span class="line">_pageControl.numberOfPages = _images.count;</span><br><span class="line"></span><br><span class="line">// 初始化左中右三个imageview</span><br><span class="line">_leftImageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, imageWidth, imageHeight)];</span><br><span class="line">_centerImageView=[[UIImageView alloc]initWithFrame:CGRectMake(imageWidth, 0, imageWidth, imageHeight)];</span><br><span class="line">_rightImageView=[[UIImageView alloc]initWithFrame:CGRectMake(2*imageWidth, 0, imageWidth, imageHeight)];</span><br><span class="line">// scrollview</span><br><span class="line">_scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, imageWidth, imageHeight)];</span><br><span class="line">_scrollView.delegate = self;</span><br><span class="line">_scrollView.showsVerticalScrollIndicator = NO;</span><br><span class="line">_scrollView.showsHorizontalScrollIndicator = NO;</span><br><span class="line">_scrollView.pagingEnabled = YES;</span><br><span class="line">//</span><br><span class="line">[_scrollView addSubview:_leftImageView];</span><br><span class="line">[_scrollView addSubview:_centerImageView];</span><br><span class="line">[_scrollView addSubview:_rightImageView];</span><br><span class="line">_scrollView.contentSize = CGSizeMake(3*imageWidth, imageHeight);</span><br><span class="line"></span><br><span class="line">[self addSubview:_scrollView];</span><br><span class="line">[self addSubview:_pageControl];</span><br><span class="line"></span><br><span class="line">// 设置默认显示中间的</span><br><span class="line">[self resetScrollViewContentOffset];</span><br><span class="line">[self refreshImageByOffsetX:imageWidth];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123;</span><br><span class="line">//重新加载图片</span><br><span class="line">[self refreshImageByOffsetX:scrollView.contentOffset.x];</span><br><span class="line">[self resetScrollViewContentOffset];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;scrollViewDidEndDecelerating offsetX:%f&quot;,_scrollView.contentOffset.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resetScrollViewContentOffset &#123;</span><br><span class="line">//永远移动到centerImageView</span><br><span class="line">[_scrollView setContentOffset:CGPointMake(self.frame.size.width, 0) animated:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 重新加载图片</span><br><span class="line">-(void)refreshImageByOffsetX:(CGFloat)offsetX &#123;</span><br><span class="line">CGFloat width = self.frame.size.width;</span><br><span class="line">NSUInteger totalCount = _images.count;</span><br><span class="line">if (offsetX &gt; width) &#123; //向右滑动</span><br><span class="line">_currentImageIndex = (_currentImageIndex + 1) % totalCount;</span><br><span class="line">&#125;else if(offsetX &lt; width)&#123; //向左滑动</span><br><span class="line">_currentImageIndex = (_currentImageIndex + totalCount - 1) % totalCount;</span><br><span class="line">&#125;</span><br><span class="line">[self refreshImageAndPage];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)refreshImageAndPage &#123;</span><br><span class="line">NSUInteger totalCount = _images.count;</span><br><span class="line">_centerImageView.image = _images[_currentImageIndex];</span><br><span class="line">//重新设置左右图片</span><br><span class="line">NSUInteger leftIndex = (_currentImageIndex + totalCount - 1) % totalCount;</span><br><span class="line">NSUInteger rightIndex = (_currentImageIndex + 1) % totalCount;</span><br><span class="line">_leftImageView.image = _images[leftIndex];</span><br><span class="line">_rightImageView.image = _images[rightIndex];</span><br><span class="line">//设置分页</span><br><span class="line">_pageControl.currentPage = _currentImageIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//开始拖拽</span><br><span class="line">-(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123;</span><br><span class="line">[self stopTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123;</span><br><span class="line">[self startTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startTimer &#123;</span><br><span class="line">[self stopTimer];</span><br><span class="line">_timer = [NSTimer timerWithTimeInterval:_timeInterval target:self selector:@selector(autoScrollToNext) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopTimer &#123;</span><br><span class="line">[_timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)autoScrollToNext &#123;</span><br><span class="line">[UIView animateWithDuration:0.25 animations:^&#123;</span><br><span class="line">// 小坑，设置动画YES，下面reset是又设置NO,动画就不执行了</span><br><span class="line">[self.scrollView setContentOffset:CGPointMake(self.frame.size.width*2, 0) animated:NO];</span><br><span class="line">&#125; completion:^(BOOL finished) &#123;</span><br><span class="line">self.currentImageIndex++;</span><br><span class="line">if (self.currentImageIndex &gt;= self.images.count) &#123;</span><br><span class="line">self.currentImageIndex = 0;</span><br><span class="line">&#125;</span><br><span class="line">[self refreshImageAndPage];</span><br><span class="line">[self resetScrollViewContentOffset];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>UITableView使用</title>
    <url>/2014/07/22/UITableView%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>1.UITableView的datasource实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//回调获取每个section中的cell的行数</span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调获取每个uitableviewcell，只有当需要显示的cell在table的可视区域内才被回调</span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调获取table的section数量</span><br><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView</span><br><span class="line"></span><br><span class="line">//回调获取table的每个section的header标题</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调获取table的每个section的footer标题</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调判断指定的cell是否能有编辑状态</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调判断指定的cell能否被移动当进入编辑模式的时候</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调获取table右边的索引栏内容</span><br><span class="line">- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView</span><br><span class="line"></span><br><span class="line">//当点击右边索引栏时执行的回调，可以根据点击的title值返回应该跳到第几个section</span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index</span><br><span class="line"></span><br><span class="line">//当所有相关编辑模式的回调，只实现该回调时默认能滑动cell出现删除按钮。当和其他相关的编辑模式回调混合使用分别有移动，插入，删除等功能</span><br><span class="line">- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//当进入的是移动的编辑模式时，实现该回调进行移动cell和数据的更新</span><br><span class="line">- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath</span><br></pre></td></tr></table></figure></p>
<p>2.UITableView的delegate实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//每个cell将要呈现时回调</span><br><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//每个section的header将要呈现时回调</span><br><span class="line">- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//每个section的footer将要呈现时回调</span><br><span class="line">- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//每个cell呈现完毕后回调</span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//每个section的header呈现完毕后回调</span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//每个section的footer呈现完毕后回调</span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//回调设置每行的高度，如果要自适应调整cell的高度，则必须要实现该回调，返回调整后的cell高度</span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调设置每个section的header高度，如果要自适应调整header的高度，则必须要实现该回调，返回调整后的header高度</span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调设置每个section的footer高度，如果要自适应调整footer的高度，则必须要实现该回调，返回调整后的footer高度</span><br><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调设置每个section的header自定义view</span><br><span class="line">- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调设置每个section的footer自定义view</span><br><span class="line">- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section</span><br><span class="line"></span><br><span class="line">//回调设置每行最右边的辅助按钮的样式</span><br><span class="line">/*</span><br><span class="line">typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123;</span><br><span class="line">UITableViewCellAccessoryNone,                   // don&apos;t show any accessory view</span><br><span class="line">UITableViewCellAccessoryDisclosureIndicator,    // regular chevron. doesn&apos;t track</span><br><span class="line">UITableViewCellAccessoryDetailDisclosureButton, // blue button w/ chevron. tracks</span><br><span class="line">UITableViewCellAccessoryCheckmark               // checkmark. doesn&apos;t track</span><br><span class="line">&#125;;</span><br><span class="line">*/</span><br><span class="line">- (UITableViewCellAccessoryType)tableView:(UITableView *)tableView accessoryTypeForRowWithIndexPath:(NSIndexPath *)indexPath NS_DEPRECATED_IOS(2_0, 3_0)</span><br><span class="line"></span><br><span class="line">//回调设置辅助按钮被点击后的事件</span><br><span class="line">- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调设置某行是否当被点击后处于高亮状态</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//回调当某行处于高亮状态时的行为</span><br><span class="line">- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//回调当某行失去高亮状态时的行为</span><br><span class="line">- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0)</span><br><span class="line"></span><br><span class="line">//回调某行将要被选中的行为</span><br><span class="line">- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调某行将要被取消选中的行为</span><br><span class="line">- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0)</span><br><span class="line"></span><br><span class="line">//回调某行已经被选中点击的行为</span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调某行已经取消选中的行为</span><br><span class="line">- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0)</span><br><span class="line"></span><br><span class="line">//回调设置某行进入了哪种编辑模式</span><br><span class="line">- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调设置某行进入删除模式的删除按钮名字</span><br><span class="line">- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0)</span><br><span class="line"></span><br><span class="line">//回调设置进入编辑模式的行能否缩进</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调将要进入编辑模式的行为</span><br><span class="line">- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调完成编辑模式的行为</span><br><span class="line">- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调设置某行的缩进级别</span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line"></span><br><span class="line">//回调设置某行被长按是否出现菜单栏</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(5_0)</span><br><span class="line"></span><br><span class="line">//回调设置菜单栏是否显示哪些菜单栏选项</span><br><span class="line">- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender NS_AVAILABLE_IOS(5_0)</span><br><span class="line"></span><br><span class="line">//回调点击菜单栏选项触发的事件</span><br><span class="line">- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender NS_AVAILABLE_IOS(5_0)</span><br></pre></td></tr></table></figure></p>
<p>3.UITableView常用成员方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//通过indexpath获取指定行的uitableviewcell</span><br><span class="line">[_table cellForRowAtIndexPath:indexPath];</span><br><span class="line">//删除某行并带上动画</span><br><span class="line">[_table deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];</span><br><span class="line">//删除某个section并带上动画</span><br><span class="line">[_table deleteSections:[NSIndexSet indexSetWithIndex:1] withRowAnimation:UITableViewRowAnimationMiddle];</span><br><span class="line">//取消被选中的某行</span><br><span class="line">[_table deselectRowAtIndexPath:indexPath animated:YES];</span><br><span class="line">//返回某个section的header自定义view</span><br><span class="line">[_table headerViewForSection:indexPath.row];</span><br><span class="line">//返回某个section的footer自定义view</span><br><span class="line">[_table footerViewForSection:indexPath.row];</span><br><span class="line">//通过指定的cell获取cell所在的行数</span><br><span class="line">[_table indexPathForCell:cell];</span><br><span class="line">//通过在table的位置坐标返回该坐标所在的cell的行数</span><br><span class="line">[_table indexPathForRowAtPoint:CGPointMake(0, 0)];</span><br><span class="line">//返回被选中的cell的行数</span><br><span class="line">[_table indexPathForSelectedRow];</span><br><span class="line">//返回table中一个范围区域的cell的行数</span><br><span class="line">[_table indexPathsForRowsInRect:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">//返回table视觉区域内的cell的行数</span><br><span class="line">[_table indexPathsForVisibleRows];</span><br><span class="line">//以动画方式在指定的位置插入cell</span><br><span class="line">[_table insertRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationLeft];</span><br><span class="line">//以动画方式在指定位置插入section</span><br><span class="line">[_table insertSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationRight];</span><br><span class="line">//返回指定位置的cell的rect属性</span><br><span class="line">[_table rectForRowAtIndexPath:indexPath];</span><br><span class="line">//重新加载table，重新执行所有回调方法</span><br><span class="line">[_table reloadData];</span><br><span class="line">//指定重新加载table的某些行，并以动画方式</span><br><span class="line">[_table reloadRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationTop];</span><br><span class="line">//重新加载索引栏</span><br><span class="line">[_table reloadSectionIndexTitles];</span><br><span class="line">//指定重新加载table的section，并以动画方式</span><br><span class="line">[_table reloadSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationFade];</span><br><span class="line">//滑动table到顶部</span><br><span class="line">[_table scrollsToTop];</span><br><span class="line">//带动画方式滑动table到指定区间</span><br><span class="line">[_table scrollRectToVisible:CGRectMake(0, 0, 100, 100) animated:YES];</span><br><span class="line">//带动画方式滑动table到指定位置附近</span><br><span class="line">[_table scrollToNearestSelectedRowAtScrollPosition:UITableViewScrollPositionBottom animated:YES];</span><br><span class="line">//以动画方式从table的哪个指定位置滑动到指定的行</span><br><span class="line">[_table scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES];</span><br><span class="line">//返回table可视区域内所有的cell</span><br><span class="line">[_table visibleCells];</span><br><span class="line"></span><br><span class="line">//beginupdates和endupdates要成对出现，对于同时操作多个insert，delete，selection的动画操作需要把它们放在beginupdates和endupdates中间执行，这样可以把多个动画合成一个动画来处理，实现原子性，降低出错的机率</span><br><span class="line">[_table beginUpdates];</span><br><span class="line"></span><br><span class="line">[_table endUpdates];</span><br></pre></td></tr></table></figure>
<p>转载自：<a href="https://blog.csdn.net/kingsley_cxz/article/details/9123959" target="_blank" rel="noopener">https://blog.csdn.net/kingsley_cxz/article/details/9123959</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>UITouch简介</title>
    <url>/2015/05/24/UITouch%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h4 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h4><ul>
<li><p>常见属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 触摸发生或最后修改的时间</span><br><span class="line">@property(nonatomic,readonly) NSTimeInterval      timestamp;</span><br><span class="line">// 触摸次数</span><br><span class="line">@property(nonatomic,readonly) NSUInteger          tapCount;   // touch down within a certain point within a certain amount of time</span><br><span class="line">// 触摸发生的window，一般是main window</span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIWindow *window;</span><br><span class="line">// 触摸的view</span><br><span class="line">@property(nullable,nonatomic,readonly,strong) UIView *view;</span><br><span class="line">// 数组? 试验结果包含系统手势，同一个手势的不同状态等，总之此属性不靠谱</span><br><span class="line">@property(nullable,nonatomic,readonly,copy)   NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UITouchPhase) &#123;</span><br><span class="line">UITouchPhaseBegan,             // 手指接触屏幕</span><br><span class="line">UITouchPhaseMoved,             // 手指在屏幕上移动</span><br><span class="line">UITouchPhaseStationary,        // 中间态，手指保持接触但没移动</span><br><span class="line">UITouchPhaseEnded,             // 手指离开屏幕</span><br><span class="line">UITouchPhaseCancelled,         // 触摸没结束，但需要强制停止追踪触摸事件</span><br><span class="line">&#125;;</span><br><span class="line">@property(nonatomic,readonly) UITouchPhase        phase;</span><br><span class="line">typedef NS_ENUM(NSInteger, UITouchType) &#123;</span><br><span class="line">UITouchTypeDirect, // 直接触摸屏幕</span><br><span class="line">UITouchTypeIndirect, // 间接触摸，遥控器</span><br><span class="line">UITouchTypePencil NS_AVAILABLE_IOS(9_1), // 触控笔</span><br><span class="line">UITouchTypeStylus NS_AVAILABLE_IOS(9_1) = UITouchTypePencil, </span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(9_0);</span><br><span class="line">@property(nonatomic,readonly) UITouchType         type NS_AVAILABLE_IOS(9_0);</span><br><span class="line"></span><br><span class="line">// 唯一索引，让你把一个更新的触摸与原来的触摸联系起来。</span><br><span class="line">@property(nonatomic,readonly) NSNumber * _Nullable estimationUpdateIndex NS_AVAILABLE_IOS(9_1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>触摸半径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// majorRadius and majorRadiusTolerance are in points</span><br><span class="line">// The majorRadius will be accurate +/- the majorRadiusTolerance</span><br><span class="line">// 触摸半径</span><br><span class="line">@property(nonatomic,readonly) CGFloat majorRadius NS_AVAILABLE_IOS(8_0);</span><br><span class="line">// 触摸半径偏移量</span><br><span class="line">@property(nonatomic,readonly) CGFloat majorRadiusTolerance NS_AVAILABLE_IOS(8_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3Dtouch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 触摸力度，均值为1，系统预设</span><br><span class="line">@property(nonatomic,readonly) CGFloat force NS_AVAILABLE_IOS(9_0);</span><br><span class="line">// 最大触摸力度</span><br><span class="line">@property(nonatomic,readonly) CGFloat maximumPossibleForce NS_AVAILABLE_IOS(9_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>API</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 返回值表示触摸在view上的位置， 传入nil就是相对UIWindow的位置</span><br><span class="line">- (CGPoint)locationInView:(nullable UIView *)view;</span><br><span class="line">// 该方法记录了前一个触摸点的位置</span><br><span class="line">- (CGPoint)previousLocationInView:(nullable UIView *)view;</span><br><span class="line"></span><br><span class="line">//触摸可用时，返回触摸的精确位置</span><br><span class="line">- (CGPoint)preciseLocationInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1);</span><br><span class="line">//触摸可用时，返回触控的精确先前位置</span><br><span class="line">- (CGPoint)precisePreviousLocationInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1);</span><br></pre></td></tr></table></figure>
</li>
<li><p>触笔相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 触笔弧度，0弧度表示触笔与表面平行。当触笔垂直于表面时，此属性的值为pi/2。</span><br><span class="line">@property(nonatomic,readonly) CGFloat altitudeAngle NS_AVAILABLE_IOS(9_1);</span><br><span class="line">// 返回手触笔的方位角（弧度）</span><br><span class="line">- (CGFloat)azimuthAngleInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1);</span><br><span class="line">// 返回指向指针的方位角的单位向量</span><br><span class="line">- (CGVector)azimuthUnitVectorInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://developer.apple.com/documentation/uikit/uitouch" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uitouch</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>UIViewController的生命周期</title>
    <url>/2015/02/22/UIViewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>init—&gt;loadView—&gt;viewDidLoad—&gt;viewWillApper—&gt;viewDidApper—&gt;viewWillDisapper—&gt;viewDidDisapper—&gt;—&gt;dealloc</p>
<h3 id="VC的生命周期"><a href="#VC的生命周期" class="headerlink" title="VC的生命周期"></a>VC的生命周期</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 非storyBoard(xib或非xib)都走这个方法,一般用不着，不要初始化view</span><br><span class="line">- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;</span><br><span class="line">if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">// storyBoard走这个方法，不要初始化view</span><br><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;</span><br><span class="line">if (self = [super initWithCoder:aDecoder]) &#123;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">// xib 加载完成，可以直接用xib的连线view了</span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">[super awakeFromNib];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 加载视图，不应该直接被调用，在UIViewController对象的view被访问且为空的时候由系统调用</span><br><span class="line">- (void)loadView &#123;</span><br><span class="line">// 没有调用super</span><br><span class="line">self.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];</span><br><span class="line">self.view.backgroundColor = [UIColor redColor];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 视图控制器中的视图加载完成，只调用一次</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">// 可用 isViewLoaded 判断某个VC是否调用了viewdidload方法</span><br><span class="line">&#125;</span><br><span class="line">// VC即将可见，不稳定状态，不要做复杂或耗时操作</span><br><span class="line">- (void)viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">[super viewWillAppear:animated];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// VC的view调layoutSubviews之前</span><br><span class="line">- (void)viewWillLayoutSubviews &#123;</span><br><span class="line">[super viewWillLayoutSubviews];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// VC的view调layoutSubviews之后</span><br><span class="line">- (void)viewDidLayoutSubviews &#123;</span><br><span class="line">[super viewDidLayoutSubviews];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// VC已经全部展示在屏幕上</span><br><span class="line">- (void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 视图将要消失 dismissed, covered or otherwise hidden</span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">[super viewWillDisappear:animated];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 视图已经消失 dismissed, covered or otherwise hidden</span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">[super viewDidDisappear:animated];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 出现内存警告 </span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">[super didReceiveMemoryWarning];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 视图被销毁</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line">// 注意：viewWillUnload和viewDidUnload 已经被废弃掉了</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/documentation/uikit/uiviewcontroller?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uiviewcontroller?language=objc</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>addChildViewController</title>
    <url>/2016/12/08/addChildViewController/</url>
    <content><![CDATA[<p>&emsp;&emsp;apple推荐的MVC是一个view对应一个Controller，但实际项目开发中几乎都是一堆view对应一个VC，这几天正尝试重构部分页面时，因为辑实在是比较乱，view层级只能用乱七八糟来形容！就尝试了一下使用addChildViewController将一个VC拆分成多个VC，也发现了几个坑！总的来说，addChildViewController方式各有利弊，如果页面很复杂还是值得拆分出来的！</p>
<h4 id="1-API介绍"><a href="#1-API介绍" class="headerlink" title="1 API介绍"></a>1 API介绍</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加childVC（如果已被加在别的VC上了先移除再添加）</span><br><span class="line">- (void)addChildViewController:(UIViewController *)childController NS_AVAILABLE_IOS(5_0);</span><br><span class="line"></span><br><span class="line">// self从父VC中移除，注意iOS7中会崩溃，ios7中最好让父类去移除</span><br><span class="line">- (void)removeFromParentViewController NS_AVAILABLE_IOS(5_0);</span><br><span class="line"></span><br><span class="line">// 父VC切换两个子ChildVC,fromViewController.view removeFromeSuperView；self.view addSubview:toViewController.view。</span><br><span class="line">- (void)transitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(5_0);</span><br></pre></td></tr></table></figure>
<ul>
<li>关于willMoveToParentViewController方法和didMoveToParentViewController方法的使用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)willMoveToParentViewController:(nullable UIViewController *)parent NS_AVAILABLE_IOS(5_0);</span><br><span class="line">- (void)didMoveToParentViewController:(nullable UIViewController *)parent NS_AVAILABLE_IOS(5_0);</span><br><span class="line">/*</span><br><span class="line">1.这两个方法用在子试图控制器交换的时候调用！即调用transitionFromViewController 方法时，调用。</span><br><span class="line">*/ </span><br><span class="line"></span><br><span class="line">/*2.当调用willMoveToParentViewController方法或didMoveToParentViewController方法时，要注意他们的参数使用：</span><br><span class="line">当某个子视图控制器将从父视图控制器中删除时，parent参数为nil。</span><br><span class="line">即：[将被删除的子试图控制器 willMoveToParentViewController:nil];</span><br><span class="line">当某个子试图控制器将加入到父视图控制器时，parent参数为父视图控制器。</span><br><span class="line">即：[将被加入的子视图控制器 didMoveToParentViewController:父视图控制器];</span><br><span class="line">*/ </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">3.无需调用[子视图控制器 willMoveToParentViewController:父视图控制器]方法。因为我们调用[父视图控制器 addChildViewController:子视图控制器]时，已经默认调用了。</span><br><span class="line">只需要在transitionFromViewController方法后，调用[子视图控制器didMoveToParentViewController:父视图控制器];</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">4.无需调用[子视图控制器 didMoveToParentViewController:父视图控制器]方法。因为我们调用</span><br><span class="line">[子视图控制器 removeFromParentViewController]时，已经默认调用了。</span><br><span class="line">只需要在transitionFromViewController方法之前调用：[子视图控制器 willMoveToParentViewController:nil]。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-子VC的生命周期"><a href="#2-子VC的生命周期" class="headerlink" title="2 子VC的生命周期"></a>2 子VC的生命周期</h4><ul>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JZKChildViewController *childVC1 = [[JZKChildViewController alloc] init];</span><br><span class="line">childVC1.view.backgroundColor = [UIColor yellowColor];</span><br><span class="line">childVC1.view.frame = CGRectMake(0, 100, 300, 300);</span><br><span class="line">// step 1</span><br><span class="line">[self addChildViewController:childVC1];</span><br><span class="line">// step 2</span><br><span class="line">[self.view addSubview:childVC1.view];</span><br><span class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">// step 3</span><br><span class="line">[childVC1.view removeFromSuperview];</span><br><span class="line">// step 4</span><br><span class="line">[childVC1 removeFromParentViewController];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 1 时childVC1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[JZKChildViewController initWithNibName:bundle:]</span><br><span class="line">[JZKChildViewController loadView]</span><br><span class="line">[JZKChildViewController viewDidLoad]</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 2 时childVC1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[JZKChildViewController viewWillAppear:]</span><br><span class="line">[JZKChildViewController viewWillLayoutSubviews]</span><br><span class="line">[JZKChildViewController viewDidLayoutSubviews]</span><br><span class="line">[JZKChildViewController viewWillLayoutSubviews]</span><br><span class="line">[JZKChildViewController viewDidLayoutSubviews]</span><br><span class="line">[JZKChildViewController viewDidAppear:]</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 3 时childVC1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[JZKChildViewController viewWillDisappear:]</span><br><span class="line">[JZKChildViewController viewDidDisappear:]</span><br></pre></td></tr></table></figure>
</li>
<li><p>step 4 时childVC1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[JZKChildViewController dealloc]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3 问题"></a>3 问题</h3><h4 id="ddChildViewController-VS-addSubview"><a href="#ddChildViewController-VS-addSubview" class="headerlink" title="ddChildViewController VS addSubview"></a>ddChildViewController VS addSubview</h4><ul>
<li>很简单的直接用addsubview，比较复杂而且可单独封装的用ddChildViewController</li>
<li><a href="https://stackoverflow.com/questions/30438847/difference-between-addchildviewcontroller-and-addsubview/30459226#30459226?newreg=9ba3a040f661419e9f9b7f861d696e47" target="_blank" rel="noopener">Difference between addChildViewController and addSubview?</a></li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li><p><a href="https://stackoverflow.com/questions/17192005/what-does-addchildviewcontroller-actually-do?r=SearchResults" target="_blank" rel="noopener">What does addChildViewController actually do?</a></p>
</li>
<li><p><a href="https://stackoverflow.com/questions/8084050/when-to-use-addchildviewcontroller-vs-pushviewcontroller" target="_blank" rel="noopener">When to use addChildViewController vs pushViewController</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>atomic和nonatomic区别</title>
    <url>/2014/10/03/atomic%E5%92%8Cnonatomic%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><table>
<thead>
<tr>
<th>atomic</th>
<th>nonatomic</th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的</td>
<td>非默认，需手写</td>
</tr>
<tr>
<td>速度慢，耗性能</td>
<td>速度快，不太耗性能</td>
</tr>
<tr>
<td>线程不安全</td>
<td>线程不安全</td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp; atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。如果你自己写 getter/setter，那 atomic/nonatomic/retain/assign/copy 这些关键字只起提示作用，写不写都一样。<br><br>&emsp;&emsp;对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。<br><br>&emsp;&emsp;而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。<br></p>
<h4 id="为什么atomic线程不安全"><a href="#为什么atomic线程不安全" class="headerlink" title="为什么atomic线程不安全"></a>为什么atomic线程不安全</h4><p>&emsp;&emsp;假设有一个 atomic 的属性 “name”，如果线程 A 调[self setName:@”A”]，线程 B 调[self setName:@”B”]，线程 C 调[self name]，那么所有这些不同线程上的操作都将依次顺序执行——也就是说，如果一个线程正在执行 getter/setter，其他线程就得等待。因此，属性 name 是读/写安全的。<br>但是，如果有另一个线程 D 同时在调[name release]，那可能就会crash，因为 release 不受 getter/setter 操作的限制。也就是说，<strong>atomic属性只能说是读/写安全的，但并不是线程安全的</strong>，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。<br>如果 name 属性是 nonatomic 的，那么上面例子里的所有线程 A、B、C、D 都可以同时执行，可能导致无法预料的结果。如果是 atomic 的，那么 A、B、C 会串行，而 D 还是并行的。</p>
<h4 id="更新一篇详解"><a href="#更新一篇详解" class="headerlink" title="更新一篇详解"></a>更新一篇详解</h4><ul>
<li><a href="http://mrpeak.cn/blog/ios-thread-safety/" target="_blank" rel="noopener">http://mrpeak.cn/blog/ios-thread-safety/</a></li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Chapters/ocProperties.html" target="_blank" rel="noopener">官方文档</a></li>
<li><a href="https://stackoverflow.com/questions/588866/whats-the-difference-between-the-atomic-and-nonatomic-attributes/589392#589392" target="_blank" rel="noopener">What’s the difference between the atomic and nonatomic attributes?</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>__attribute__笔记</title>
    <url>/2017/03/21/attribute-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="1-format"><a href="#1-format" class="headerlink" title="1 format"></a>1 format</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</span><br><span class="line"></span><br><span class="line">// “archetype”指定是哪种风格,这里是NSString；</span><br><span class="line">// “string-index”指定传入函数的第几个参数是格式化字符串；</span><br><span class="line">// “first-to-check”指定第一个可变参数所在的索引.</span><br><span class="line">format (archetype, string-index, first-to-check)</span><br></pre></td></tr></table></figure>
<h4 id="2-availability"><a href="#2-availability" class="headerlink" title="2 availability"></a>2 availability</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NS_DEPRECATED_IOS(2_0, 7_0, &quot;Use -sizeWithAttributes:&quot;)</span><br><span class="line">// 宏展开以后如下</span><br><span class="line">__attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;&quot;__VA_ARGS__)));</span><br><span class="line">// 例</span><br><span class="line">- (void)oldMethod:(NSString *)string __attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;用 -newMethod: 这个方法替代 &quot;)));</span><br></pre></td></tr></table></figure>
<h4 id="3-unavailable-amp-deprecated"><a href="#3-unavailable-amp-deprecated" class="headerlink" title="3 unavailable &amp; deprecated"></a>3 unavailable &amp; deprecated</h4><p>&emsp;&emsp;unavailable告诉编译器该方法不可用，如果强行调用编译器会提示错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)method1 NS_UNAVAILABLE;</span><br><span class="line">- (void)method2 __attribute__((unavailable(&quot;不能用了，&quot;)));</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;deprecated告诉用户方法被废弃，强行用提示警告<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)method1 DEPRECATED_ATTRIBUTE; </span><br><span class="line">- (void)method2:( NSString *)string __attribute__((deprecated(&quot;警告不要用了，可用xxx&quot;)));</span><br></pre></td></tr></table></figure></p>
<h4 id="4-nonnull-amp-nullable"><a href="#4-nonnull-amp-nullable" class="headerlink" title="4 nonnull &amp; nullable"></a>4 nonnull &amp; nullable</h4><p>&emsp;&emsp;<a href="https://kangzubin.com/nullability-and-objective-c/" target="_blank" rel="noopener">参考</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 对于属性、方法返回值、方法参数的修饰，使用：nonnull/nullable；</span><br><span class="line">@property(nonatomic, copy, nullable) NSString *str;</span><br><span class="line">- (nullable NSString*)method;</span><br><span class="line">- (void)formatString:(nullable NSString *)str;</span><br><span class="line"></span><br><span class="line">// 对于 C 函数的参数、Block 的参数、Block 返回值的修饰，使用：_Nonnull/_Nullable</span><br><span class="line">- (void)methodWithBlock:(id _Nonnull (^ _Nullable)(id _Nullable params))block;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-always-inline-强制内联，好像没啥用"><a href="#5-always-inline-强制内联，好像没啥用" class="headerlink" title="5 always_inline 强制内联，好像没啥用"></a>5 always_inline 强制内联，好像没啥用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">内联函数不是在调用时发生控制转移(没有寻址、压栈入栈等操作)，而是在编译时将函数体嵌入在每一个调用处</span><br><span class="line">好处是:快代码的执行，减少系统开销.适用场景:A 这个函数更小;B这个函数不被经常调用</span><br><span class="line">*/ </span><br><span class="line">// 内联函数的一般写法</span><br><span class="line">static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-objc-requires-super"><a href="#6-objc-requires-super" class="headerlink" title="6 objc_requires_super"></a>6 objc_requires_super</h4><p>&emsp;&emsp;子类复写父类方法时必须调用父类方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Father : NSObject</span><br><span class="line">- (void)hailHydra __attribute__((objc_requires_super));</span><br><span class="line">@end</span><br><span class="line">@implementation Father</span><br><span class="line">- (void)hailHydra &#123;</span><br><span class="line">NSLog(@&quot;hail hydra!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">@interface Son : Father</span><br><span class="line">@end</span><br><span class="line">@implementation Son</span><br><span class="line">- (void)hailHydra &#123;</span><br><span class="line">&#125; // &lt;--- Warning missing [super hailHydra]</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<h4 id="7-cleanup"><a href="#7-cleanup" class="headerlink" title="7 cleanup"></a>7 cleanup</h4><p>&emsp;&emsp;声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)test&#123;</span><br><span class="line">int a __attribute__((cleanup(intCleanup))) = 10;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">注意点:</span><br><span class="line"></span><br><span class="line">指定的函数传递的参数是变量的地址</span><br><span class="line">作用域的结束包括:大括号结束、return、goto、break、exception等情况</span><br><span class="line">当作用域内有多个cleanup的变量时,遵守 先入后出 的栈式结构.</span><br><span class="line">*/</span><br><span class="line">//这里传递的参数是变量的地址</span><br><span class="line">void intCleanup(int *num)&#123;</span><br><span class="line">NSLog(@&quot;cleanup------%d&quot;,*num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;,cleanup先于对象的dealloc执行。更多可看<a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="noopener">黑魔法attribute((cleanup))</a></p>
<h4 id="8-objc-subclassing-restricted"><a href="#8-objc-subclassing-restricted" class="headerlink" title="8 objc_subclassing_restricted"></a>8 objc_subclassing_restricted</h4><p>&esmp;&emsp;使用这个属性可以定义一个 Final Class，也就是说，一个不可被继承的类<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__((objc_subclassing_restricted))</span><br><span class="line">@interface Eunuch : NSObject</span><br><span class="line">@end</span><br><span class="line">// 现在没人能继承Eunuch</span><br></pre></td></tr></table></figure></p>
<h4 id="9-enable-if"><a href="#9-enable-if" class="headerlink" title="9 enable_if"></a>9 enable_if</h4><p>&esmp;&emsp;参数静态检查，只能用在C函数上<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void printValidAge(int age)</span><br><span class="line">__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你丫火星人？&quot;))) &#123;</span><br><span class="line">printf(&quot;%d&quot;, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="10-overloadable"><a href="#10-overloadable" class="headerlink" title="10 overloadable"></a>10 overloadable</h4><p>&esmp;&emsp;C函数实现类似java的重载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__attribute__((overloadable)) void print(NSString *string)&#123;</span><br><span class="line">NSLog(@&quot;%@&quot;,string);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((overloadable)) void print(int num)&#123;</span><br><span class="line">NSLog(@&quot;%d&quot;,num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">Clang Attributes 黑魔法小记</a></li>
<li><a href="https://www.jianshu.com/p/29eb7b5c8b2d" target="_blank" rel="noopener"><strong>attribute</strong> 总结</a></li>
<li><a href="https://kangzubin.com/nullability-and-objective-c/" target="_blank" rel="noopener">Objective-C 中 nullable、__nullable、_Nullable 的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>__block</title>
    <url>/2017/04/02/block/</url>
    <content><![CDATA[<p>&emsp;&emsp;水一水block到底怎么回事吧！</p>
<p>&emsp;&emsp;待测试方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">__block int age = 10;</span><br><span class="line">void (^myblock)(void) =  ^&#123;</span><br><span class="line">NSLog(@&quot;%d&quot;,age);</span><br><span class="line">&#125;;</span><br><span class="line">age  = 20;</span><br><span class="line">myblock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;clang编译成C++,<a href="https://stackoverflow.com/questions/33950466/how-to-translate-objective-c-code-to-c-with-arc-enabling?r=SearchResults" target="_blank" rel="noopener">参考：How to translate Objective-C code to C++ with ARC enabling</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;打开mian.cpp文件拉到最后发现如下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">void *__isa;</span><br><span class="line">__Block_byref_age_0 *__forwarding;</span><br><span class="line">int __flags;</span><br><span class="line">int __size;</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">__Block_byref_age_0 *age; // by ref</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">__Block_byref_age_0 *age = __cself-&gt;age; // bound by ref</span><br><span class="line"></span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_main_8a7d1e_mi_0,(age-&gt;__forwarding-&gt;age));</span><br><span class="line">&#125;</span><br><span class="line">static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;age, (void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;</span><br><span class="line"></span><br><span class="line">static struct __main_block_desc_0 &#123;</span><br><span class="line">size_t reserved;</span><br><span class="line">size_t Block_size;</span><br><span class="line">void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">void (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">__attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;</span><br><span class="line">void (*myblock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, 570425344));</span><br><span class="line">(age.__forwarding-&gt;age) = 20;</span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);</span><br><span class="line">&#125;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;直接看main函数，可知使用 <strong>block后编译器将age包装成 </strong>Block_byref_age_0对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Block_byref_age_0 &#123;</span><br><span class="line">void *__isa;                     // age类型</span><br><span class="line">__Block_byref_age_0 *__forwarding; // 重定位用</span><br><span class="line">int __flags;</span><br><span class="line">int __size;                       // 内存大小</span><br><span class="line">int age;                          // 实际上的age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再看myblock的构成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void (*myblock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, 570425344));</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;核心是__main_block_impl_0<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __main_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;     </span><br><span class="line">struct __main_block_desc_0* Desc;</span><br><span class="line">__Block_byref_age_0 *age; // by ref</span><br><span class="line">__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;__block_impl是block的具体类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __block_impl &#123;</span><br><span class="line">void *isa; // block类型，分为3类：__NSGlobalBlock__全局区；__NSStackBlock__ 栈区；__NSMallocBlock__ 堆区</span><br><span class="line">int Flags; // 标志位</span><br><span class="line">int Reserved; // 这里为void</span><br><span class="line">void *FuncPtr; // block块里具体执行代码的匿名函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>main_block_func_0是具体实现的匿名函数；</strong>main_block_desc_0_DATA表示对block内部参数变量等的引用计数管理(可随便加个变量检验例如 __block int age = 10; )</p>
<p>&emsp;&emsp;综上<strong>main_block_impl_0存储了block捕获的外部变量age并包装了下！这也解释了为什么用block修饰的变量可以在block内部修改！Block只有的是</strong>Block_byref_age_0对象，此对象不可变；但<strong>Block_byref_age_0通过(age.</strong>forwarding-&gt;age) = 20;的方式可以操纵__Block_byref_age_0对象内部的age对象的数值</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>dyld笔记</title>
    <url>/2017/09/23/dyld%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;前一段时间整理了下iOS的编译过程，对整体流程有了个大概印象！但在<a href="https://www.jianshu.com/p/d5cf01424e92" target="_blank" rel="noopener">点击 Run 之后发生了什么？</a>里提到了APP启动中dyld的作用，对此了解不是很多，只是知道dyld是用来加载的，正好看到大神的相关文章，这次就水一水dyld笔记吧</p>
<p>&emsp;&emsp;先下载<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">dyld源码</a></p>
<h3 id="1-dyld-start"><a href="#1-dyld-start" class="headerlink" title="1 __dyld_start"></a>1 __dyld_start</h3><p>&emsp;&emsp;load方法打个断点，调用栈第一个就是我们要观察的__dyld_start的方法。汇编看不懂(虽然LLVM -dis可以反汇编，但IR文件更不好理解，而且没必要)，但有注释呀<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"># call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">...</span><br><span class="line"># clean up stack and jump to &quot;start&quot; in main executable</span><br><span class="line">...</span><br><span class="line"># LC_MAIN case, set up stack for call to main()</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;扩展：执行__dyld_start之前执行了什么？参考:<a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/" target="_blank" rel="noopener">_dyld_start之前</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">▼ execve       // 用户点击了app, 用户态会发送一个系统调用 execve 到内核</span><br><span class="line">▼ __mac_execve  // 创建线程</span><br><span class="line">▼ exec_activate_image // 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法</span><br><span class="line">▼ exec_mach_imgact</span><br><span class="line">▼ load_machfile</span><br><span class="line">▶︎ parse_machfile  //解析主二进制macho</span><br><span class="line">▼ load_dylinker // 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld</span><br><span class="line">▼ parse_machfile // 解析 dyld 这个mach-o文件，这个过程中会解析出entry_point</span><br><span class="line">▼ activate_exec_state</span><br><span class="line">▶︎ thread_setentrypoint // 设置entry_point。</span><br></pre></td></tr></table></figure></p>
<h3 id="2-dyldbootstrap-start-方法"><a href="#2-dyldbootstrap-start-方法" class="headerlink" title="2 dyldbootstrap::start 方法"></a>2 dyldbootstrap::start 方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt. // 就是启动dyld的</span><br><span class="line">//  In dyld we have to do this manually.</span><br><span class="line">//</span><br><span class="line">uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader,uintptr_t* startGlue) &#123;</span><br><span class="line"></span><br><span class="line">// 中间主要是重绑定判断、参数转化等</span><br><span class="line"></span><br><span class="line">// 最后调用</span><br><span class="line">return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-dyld-main"><a href="#3-dyld-main" class="headerlink" title="3 dyld::_main"></a>3 dyld::_main</h3><p>&emsp;&emsp;有将近500行代码,说实话没太看懂，还是直接贴大神的总结吧！另外写一点我感兴趣的函数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 设置运行环境，环境变量</span><br><span class="line">2. 加载共享缓存</span><br><span class="line">3. 实例化Image</span><br><span class="line">4. 动态库的版本化重载</span><br><span class="line">5. 加载插入的动态库</span><br><span class="line">6. link主程序</span><br><span class="line">7. link插入的动态库</span><br><span class="line">8. weakBind</span><br><span class="line">9. initialize</span><br><span class="line">10.main</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-加载dyld-image-和-main-image，"><a href="#3-1-加载dyld-image-和-main-image，" class="headerlink" title="3.1 加载dyld image 和 main image，"></a>3.1 加载dyld image 和 main image，</h4><p>&emsp;&emsp;不看代码我一直以为dyldbootstrap::start阶段就已经加载dyld image<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Trace dyld&apos;s load</span><br><span class="line">notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, &quot;dyld_file&quot;));</span><br><span class="line">#if !TARGET_IPHONE_SIMULATOR</span><br><span class="line">// Trace the main executable&apos;s load</span><br><span class="line">notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &quot;executable_file&quot;));</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-奇怪的注释"><a href="#3-2-奇怪的注释" class="headerlink" title="3.2 奇怪的注释"></a>3.2 奇怪的注释</h4><p>&emsp;&emsp; 突然间出现 // could not use closure info, launch old way  注释，也没找到return或else处理，这个注释是啥意思？怎么launch old way？<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// load shared cache</span><br><span class="line">checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">// 接下来校验closure是否需要支持，以及一些措施</span><br><span class="line"></span><br><span class="line">// 问题在这，</span><br><span class="line">// could not use closure info, launch old way</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-instantiateFromLoadedImage"><a href="#3-3-instantiateFromLoadedImage" class="headerlink" title="3.3 instantiateFromLoadedImage"></a>3.3 instantiateFromLoadedImage</h4><p>&emsp;&emsp; isCompatibleMachO 是检查mach-o的subtype是否是当前cpu可以支持； <em> instantiateMainExecutable 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； </em> addImage 添加到 allImages中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</span><br><span class="line">&#123;</span><br><span class="line">// try mach-o loader</span><br><span class="line">if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span><br><span class="line">ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">addImage(image);</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">throw &quot;main executable not a known format&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-load-libraries"><a href="#3-4-load-libraries" class="headerlink" title="3.4 load libraries"></a>3.4 load libraries</h4><p>&emsp;&emsp; inserted 环境 libraries, then main, then others.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// load any inserted libraries</span><br><span class="line">if    ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</span><br><span class="line">for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </span><br><span class="line">loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br><span class="line">// record count of inserted libraries so that a flat search will look at </span><br><span class="line">// inserted libraries, then main, then others.</span><br><span class="line">sInsertedDylibCount = sAllImages.size()-1;</span><br><span class="line"></span><br><span class="line">// link main executable</span><br><span class="line">gLinkContext.linkingMainExecutable = true;</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">if ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">// previous link() on main executable has already adjusted its internal pointers for ASLR</span><br><span class="line">// work around that by rebasing by inverse amount</span><br><span class="line">sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = true;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// link any inserted libraries</span><br><span class="line">// do this after linking main executable so that any dylibs pulled in by inserted </span><br><span class="line">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span><br><span class="line">if ( sInsertedDylibCount &gt; 0 ) &#123;</span><br><span class="line">for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+1];</span><br><span class="line">link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">image-&gt;setNeverUnloadRecursive();</span><br><span class="line">&#125;</span><br><span class="line">// only INSERTED libraries can interpose</span><br><span class="line">// register interposing info after all inserted libraries are bound so chaining works</span><br><span class="line">for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+1];</span><br><span class="line">image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-weakBind"><a href="#3-5-weakBind" class="headerlink" title="3.5 weakBind"></a>3.5 weakBind</h4><p>&emsp;&emsp; 强符号：函数和已经初始化的全局变量;弱符号：未初始化的全局变量！弱符号对于库来说十分有用，我们在开发库时，可以将某些符号定义为弱符号，这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，增加了很大的灵活性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sMainExecutable-&gt;weakBind(gLinkContext);</span><br></pre></td></tr></table></figure></p>
<h4 id="总结：dyld-作用顺序的概括"><a href="#总结：dyld-作用顺序的概括" class="headerlink" title="总结：dyld 作用顺序的概括"></a>总结：dyld 作用顺序的概括</h4><ul>
<li>从 kernel 留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制</li>
<li>non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li>
<li>Runs static initializers for the executable</li>
<li>找到可执行文件的 main 函数，准备参数并调用</li>
<li>程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li>
<li>程序main函数 return 后执行 static terminator</li>
<li>某些场景下 main 函数结束后调 libSystem 的 _exit 函数</li>
</ul>
<h3 id="其它：-objc的启动"><a href="#其它：-objc的启动" class="headerlink" title="其它： objc的启动"></a>其它： objc的启动</h3><p>&emsp;&emsp; _objc_init源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">static bool initialized = false;</span><br><span class="line">if (initialized) return;</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line">// 各种初始化</span><br><span class="line">environ_init();</span><br><span class="line">tls_init();</span><br><span class="line">static_init();</span><br><span class="line">lock_init();</span><br><span class="line">// 看了一下exception_init是空实现！！就是说objc的异常是完全采用c++那一套的。</span><br><span class="line">exception_init();</span><br><span class="line">// 注册dyld事件的监听</span><br><span class="line">_dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>dyld 开始将程序二进制文件初始化</li>
<li>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号</li>
<li>再由libsystem 中的一个initialize方法 libsystem_initializer中初始化了 libdispatch</li>
<li>然后libdispatch调用了_os_object_int, 最终调用了 _objc_init，并绑定runtime回调</li>
<li>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理</li>
<li>runtime 接手后调用 map_images 做解析和处理，接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">iOS 程序 main 函数之前发生了什么</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/" target="_blank" rel="noopener">dyld与ObjC</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/" target="_blank" rel="noopener">Dyld系列之一：_dyld_start之前</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/" target="_blank" rel="noopener">Dyld之二: 动态链接过程</a></li>
<li><a href="https://segmentfault.com/a/1190000007769327" target="_blank" rel="noopener">dyld 加载 Mach-O</a></li>
<li><a href="https://blog.csdn.net/gaoyuqiang30/article/details/52536168" target="_blank" rel="noopener">iOS中的dyld缓存是什么？</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS内核推荐博文</title>
    <url>/2018/01/23/iOS%E5%86%85%E6%A0%B8%E6%8E%A8%E8%8D%90%E5%8D%9A%E6%96%87/</url>
    <content><![CDATA[<h3 id="1-Mac-OS-X-和-iOS架构"><a href="#1-Mac-OS-X-和-iOS架构" class="headerlink" title="1 Mac OS X 和 iOS架构"></a>1 Mac OS X 和 iOS架构</h3><ol>
<li>用户体验层：主要有SpringBoard、Spotlight、Accessibility选项等等</li>
<li>应用框架层：主要有 Cocoa Touch、Java</li>
<li>核心框架层：主要有 OpenGL、Quartz等图形、多媒体组件</li>
<li>Darwin：操作系统核心，包括XNU内核(kernel)和UNIX shell</li>
</ol>
<h4 id="1-1-iOS-和-OS-X的不同点："><a href="#1-1-iOS-和-OS-X的不同点：" class="headerlink" title="1.1 iOS 和 OS X的不同点："></a>1.1 iOS 和 OS X的不同点：</h4><ul>
<li>iOS 内核和二进制文件编译的目标架构是ARM架构， OS X基于Intel i386 和 x86_64。</li>
<li>iOS 的内核闭源，OS X内核是开源的</li>
<li>iOS 的内存管理要紧凑的多。 iOS系统不支持虚拟内存，OS X通过内存映射获得额外的内存，几乎有无穷的交换空间可以使用。</li>
<li>iOS app不允许访问底层的Darwin，也没有root访问权限，并且只能访问自己目录内的数据。</li>
</ul>
<h3 id="2-Darwin架构"><a href="#2-Darwin架构" class="headerlink" title="2 Darwin架构"></a>2 Darwin架构</h3><p>&emsp;&emsp;盗图<a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/Architecture/Architecture.html#//apple_ref/doc/uid/TP30000905-CH1g-TPXREF101" target="_blank" rel="noopener">OS X Darwin</a>，iOS和OS X的Darwin架构差不多，我觉的这个更清晰易懂一些</p>
<p><img src="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/art/osxarchitecture.gif" alt="image"></p>
<p>&emsp;&emsp;Darwin的内核是XNU，XNU is Not Unix的缩写。XNU是由Mach微内核和BSD（伯克利软件套件）组合而成。</p>
<h4 id="2-1-Mach微内核"><a href="#2-1-Mach微内核" class="headerlink" title="2.1 Mach微内核"></a>2.1 Mach微内核</h4><p>&emsp;&emsp;Mach是一个微内核轻量级操作系统，仅处理最核心的任务，</p>
<ul>
<li>进程和线程</li>
<li>虚拟内存管理</li>
<li>任务调度</li>
<li>进程通信</li>
</ul>
<h4 id="2-2-BSD"><a href="#2-2-BSD" class="headerlink" title="2.2 BSD"></a>2.2 BSD</h4><p>&emsp;&emsp;BSD层在Mach之上，提供了更高层次的功能，包括：</p>
<ul>
<li>文件系统</li>
<li>网络（硬件设备级别除外）</li>
<li>UNIX安全模型</li>
<li>syscall 支持</li>
<li>BSD过程模型，包括过程ID和信号</li>
<li>FreeBSD内核API</li>
<li>许多POSIX API</li>
<li>内核支持pthreads（POSIX线程）</li>
</ul>
<h4 id="2-3-File-Systems"><a href="#2-3-File-Systems" class="headerlink" title="2.3 File Systems"></a>2.3 File Systems</h4><p>&emsp;&emsp;iOS 的文件系统和 OS X 非常类似，但是有以下区别：</p>
<ul>
<li>iOS文件系统（HFSX）是大小写敏感的, OS X 的 HFS+是不敏感</li>
<li>iOS文件系统是部分加密的。</li>
<li>没有/Users 目录，只有一个/User 目录</li>
<li>没有/Volumes目录, 没有必要进行磁盘仲裁</li>
</ul>
<h4 id="2-4-I-O-Kit"><a href="#2-4-I-O-Kit" class="headerlink" title="2.4 I/O Kit"></a>2.4 I/O Kit</h4><p>&emsp;&emsp;开发者可以使用C ++快速创建设备驱动程序。但内核是C语言或汇编写的，因此需要libKern库支持C ++运行时并提供所需要的基类。I/O Kit的功能：</p>
<ul>
<li>真正的即插即用</li>
<li>动态设备管理</li>
<li>动态（“按需”）加载驱动程序</li>
<li>桌面系统和便携式设备的电源管理</li>
<li>多处理器功能</li>
</ul>
<h3 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3 系统调用"></a>3 系统调用</h3><h4 id="3-1-POSIX系统调用"><a href="#3-1-POSIX系统调用" class="headerlink" title="3.1 POSIX系统调用"></a>3.1 POSIX系统调用</h4><p>&emsp;&emsp;POSIX 兼容性是由XNU中BSD层提供的。所有的POSIX 系统调用不论底层实现如何都有相同的原型，也就是说具有相同的参数和返回值。<br>&emsp;&emsp;系统调用编号：除了固定的原型之外，POSIX还完整定义了系统调用的编号。</p>
<h4 id="3-2-Mach-系统调用"><a href="#3-2-Mach-系统调用" class="headerlink" title="3.2 Mach 系统调用"></a>3.2 Mach 系统调用</h4><p>&emsp;&emsp;BSD层是对Mach内核的包装，但是Mach系统调用仍然可以在用户态访问。需要借助mach trap实现用户态到内核态的转换。<br>&emsp;&emsp;在32位系统上，Mach系统调用的编号都为负数，POSIX调用编号为非负。<br>&emsp;&emsp;在64位系统上，Mach系统调用为正数，但是以0x2000000开头，而POSIX调用编号以0x1000000开头。</p>
<h3 id="博文推荐："><a href="#博文推荐：" class="headerlink" title="博文推荐："></a>博文推荐：</h3><p>&emsp;&emsp;最近在啃《深入解析Mac OS X &amp; iOS 操作系统》啃了一个多星期，我自以为我现在已经比上学的时候好多了，能看点书了！但还是啃不动了：太厚了造成我比较烦躁、没有试验机会、过时（市面上已经绝版了）！熬了一个多星期实在熬不住了！给大家推荐一个系列博客吧，博主应该是上学时啃的（估计工作也没时间）：<a href="https://www.jianshu.com/p/95acba84bfef" target="_blank" rel="noopener">https://www.jianshu.com/p/95acba84bfef</a></p>
<p>&emsp;&emsp;其实我觉得如果不考虑细微差别直接看OS X的官方文档反而是最舒服的 <a href="https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS编译过程</title>
    <url>/2017/09/16/iOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1-编译简介"><a href="#1-编译简介" class="headerlink" title="1 编译简介"></a>1 编译简介</h3><h4 id="1-1-编译"><a href="#1-1-编译" class="headerlink" title="1.1 编译"></a>1.1 编译</h4><p>&emsp;&emsp;把高级语言翻译成机器语言或汇编语言，叫编译！</p>
<p>&emsp;&emsp;语言翻译的两种基本形态: 编译器与解释器</p>
<ul>
<li>编译器采用先翻译后执行. 例如C语言 .c -&gt; .o -&gt; 再运行！特点：工作效率高,可移植性差，时间换空间</li>
<li>解释器采用边翻译边执行. 例如shell 边写边执行！特点：工作效率低,可移植性好，空间换时间</li>
</ul>
<p>&emsp;&emsp;一般编译器有以下工作步骤：</p>
<ol>
<li>词法分析（lexical analysis）：此阶段的任务是从左到右一个字符一个字符地读入源程序，使用词法分析器（扫描器）对构成源程序的字符流进行扫描然后根据语言的词法规则识别单词（Token），至少分以下几类：关键字(保留字)、标识符、字面量、特殊符号</li>
</ol>
<ul>
<li>1.1 识别记号并交给语法分析器(根据模式识别记号)</li>
<li>1.2 滤掉源程序中的无用成分,如注释、空格和回车等</li>
<li>1.3 处理与具体平台有关的输入(如文件结束符的不同表示等)</li>
</ul>
<ol start="2">
<li>语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser）</li>
<li>语义分析（Syntax analysis）：根据语义规则对语法树中的语法单元进行静态语义检查,如类型检查和转换等,目的是保证语法和语义都正确，因为一个语法上正确的句子，它所代表的意义并不一定正确.</li>
<li>中间码生成（可选）：生成一种既接近目标语言,又与具体机器无关的表示,便于代码优化与代码生成.好处是前后分离，便于扩展</li>
<li>中间代码优化(可选)：优化后功能相同，但在占用的空间上和程序执行的时间上都更省、更有效</li>
<li>目标代码生成：一般分为三种形式目标代码，A 汇编；B 可重定位二进制；C 内存形式</li>
<li>目标代码</li>
</ol>
<p>&emsp;&emsp;编译过程 1 至 6 阶段，都会管理符号表，便于各个阶段的查找\填写等工作；另外各个阶段都会有出错处理</p>
<p>&emsp;&emsp;编译器和解释器的区别往往是在第4步(中间代码)之后开始的.编译型语言的可执行程序产生的是直接执行机器指令，而解释型语言的每一句源代码都要经过解释器解释为可以执行的机器指令</p>
<p>&emsp;&emsp;最后，编译器完成编译后，由链接器（Linker）将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。</p>
<h4 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2 链接"></a>1.2 链接</h4><p>&emsp;&emsp;静态链接：在编译链接期间发挥作用，把目标文件和静态库一起链接形成可执行文件</p>
<p>&emsp;&emsp;链接器需要对源代码进行的处理：</p>
<ol>
<li>对各个目标文件中没有定义的变量，在其他目标文件中寻找到相关的定义。</li>
<li>把不同目标文件中生成的同类型的段进行合并。</li>
<li>对不同目标文件中的变量进行地址重定位。</li>
</ol>
<h4 id="1-3-装载"><a href="#1-3-装载" class="headerlink" title="1.3 装载"></a>1.3 装载</h4><p>&emsp;&emsp;动态链接库需要编译器做的最基本的事情：</p>
<ol>
<li>链接库在将目标文件链接成可执行文件的时候如果发现某一个变量或者函数在目标文件中找不到，会按预定义的动态库寻找路径寻找动态库中定义的变量或者函数。</li>
<li>如果链接库在某一个动态链接库中找到了该变量或者函数定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理 symbol.</li>
<li>在_GLOBAL_OFFSET_TABLE_代码中生成真正的动态跳转指令，并且在库函数（比如strncpy,printf）代理symbol中跳转到_GLOBAL_OFFSET_TABLE_中相应的偏移位置。</li>
</ol>
<h3 id="2-iOS编译"><a href="#2-iOS编译" class="headerlink" title="2 iOS编译"></a>2 iOS编译</h3><p>&emsp;&emsp;iOS的编译工具是LLVM, Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，可用如下命令查看编译源文件有几个阶段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-预编译"><a href="#2-1-预编译" class="headerlink" title="2.1 预编译"></a>2.1 预编译</h4><p>&emsp;&emsp;主要用来处理那些源文件中以#开头的预编译命令，比如宏、#include等<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -E main.m</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-词法分析"><a href="#2-2-词法分析" class="headerlink" title="2.2 词法分析"></a>2.2 词法分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure>
<h4 id="2-3-语法分析"><a href="#2-3-语法分析" class="headerlink" title="2.3 语法分析"></a>2.3 语法分析</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure>
<h4 id="2-4-语义分析"><a href="#2-4-语义分析" class="headerlink" title="2.4 语义分析"></a>2.4 语义分析</h4><h4 id="2-5-生成中间代码-LLVM-IR"><a href="#2-5-生成中间代码-LLVM-IR" class="headerlink" title="2.5 生成中间代码 LLVM IR"></a>2.5 生成中间代码 LLVM IR</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>
<h4 id="2-6-中间代码优化-可选"><a href="#2-6-中间代码优化-可选" class="headerlink" title="2.6 中间代码优化(可选)"></a>2.6 中间代码优化(可选)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s</span><br><span class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>
<h4 id="2-7-目标代码生成-汇编代码"><a href="#2-7-目标代码生成-汇编代码" class="headerlink" title="2.7 目标代码生成 汇编代码"></a>2.7 目标代码生成 汇编代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure>
<h4 id="2-8-目标代码"><a href="#2-8-目标代码" class="headerlink" title="2.8 目标代码"></a>2.8 目标代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure>
<h4 id="2-9-汇编器"><a href="#2-9-汇编器" class="headerlink" title="2.9 汇编器"></a>2.9 汇编器</h4><p>&emsp;&emsp;汇编器把汇编代码转换为机器代码，但<a href="https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM" target="_blank" rel="noopener">大神</a>说iOS没用汇编器</p>
<h4 id="2-9-链接"><a href="#2-9-链接" class="headerlink" title="2.9 链接"></a>2.9 链接</h4><p>&emsp;&emsp;连接器把编译产生的.o文件合并成一个mach-o文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果</span><br></pre></td></tr></table></figure></p>
<h4 id="2-10-签名"><a href="#2-10-签名" class="headerlink" title="2.10 签名"></a>2.10 签名</h4><p>&emsp;&emsp;程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名</p>
<h4 id="总结完整步骤："><a href="#总结完整步骤：" class="headerlink" title="总结完整步骤："></a>总结完整步骤：</h4><ol>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework 例如Foundation.framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ol>
<p>&emsp;&emsp;最后安利一本书<a href="https://item.jd.com/10067200.html" target="_blank" rel="noopener">程序员的自我修养：链接、装载与库</a></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://objccn.io/issue-6-2/" target="_blank" rel="noopener">objc中国：编译器</a></li>
<li><a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/iOS编译过程的原理和应用.md" target="_blank" rel="noopener">iOS编译过程的原理和应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/D5IqhiDfe2gGb1Hkm2uS2w?" target="_blank" rel="noopener">编译原理之词法分析简介</a></li>
<li><a href="https://tech.meituan.com/2015/01/22/linker.html" target="_blank" rel="noopener">高级语言的编译：链接及装载过程介绍</a></li>
<li><a href="https://www.jianshu.com/p/d5cf01424e92" target="_blank" rel="noopener">点击 Run 之后发生了什么？</a></li>
<li><a href="https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM" target="_blank" rel="noopener">深入剖析 iOS 编译 Clang LLVM</a></li>
</ul>
<h4 id="更新一篇比较好的文章"><a href="#更新一篇比较好的文章" class="headerlink" title="更新一篇比较好的文章"></a>更新一篇比较好的文章</h4><ul>
<li><a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147" target="_blank" rel="noopener">深入浅出iOS编译</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS锁相关</title>
    <url>/2016/09/18/iOS%E9%94%81%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天偶然看到<a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>，里面介绍了9种锁，而我自己知道的只要三个：NSLock，dispatch_semaphore和@synchronized，今天抽时间查了下相关锁的使用，记录如下</p>
<h3 id="1-锁的种类"><a href="#1-锁的种类" class="headerlink" title="1 锁的种类"></a>1 锁的种类</h3><ul>
<li>临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。</li>
<li>自旋锁：反复检查(while(1)循环)锁变量是否可用。忙等虽然占用CPU，但避免了上下文切换的开销，所以只适用于阻塞时间很短的任务</li>
<li>互斥锁（Mutex）：当一个线程无法获得互斥量时直接挂起，当互斥量可用时系统在激活该线程</li>
<li>递归锁：可重复加锁并记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。所以这个锁可以被同一线程多次请求，而不会引起死锁</li>
<li>读写锁：多读者-单写者锁，读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。</li>
<li>信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。</li>
<li>条件锁：顾名思义，不符合条件：锁住，符合条件：开锁，继续运行</li>
<li>死锁：由于竞争资源相互阻塞，谁也动不了就是死锁</li>
</ul>
<h3 id="2-互斥锁"><a href="#2-互斥锁" class="headerlink" title="2 互斥锁"></a>2 互斥锁</h3><ul>
<li><p>2.1 NSlock 放心用AFN就在用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// NSLock的lock和unlock需要在同一个线程下</span><br><span class="line">// NSLock内部封装了一个 pthread_mutex，因此比较慢</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, strong) NSLock *lock;</span><br><span class="line">// 初始化</span><br><span class="line">self.lock = [[NSLock alloc] init];</span><br><span class="line">self.lock.name = @&quot;com.compony.xxx.lock&quot;;</span><br><span class="line">// 使用</span><br><span class="line">[self.lock lock];</span><br><span class="line">// do something</span><br><span class="line">[self.lock unlock];</span><br><span class="line"></span><br><span class="line">// 试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程，相反，它只是返回NO</span><br><span class="line">[self.lock tryLock];</span><br><span class="line">// 尝试在给定时间内获得锁</span><br><span class="line">[self.lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:100]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.2 pthread_mutex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// C 语言下多线程加互斥锁的方式</span><br><span class="line"></span><br><span class="line">@interface JZKManager ()&#123;</span><br><span class="line">pthread_mutex_t _pLock;</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">pthread_mutex_init(&amp;_pLock, NULL);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">pthread_mutex_lock(&amp;_pLock);</span><br><span class="line">// do something</span><br><span class="line">pthread_mutex_unlock(&amp;_pLock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">pthread_mutex_destroy(&amp;_pLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.3 @synchronized 慎用,更多内容：<a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// obj为该锁的唯一标识,只有当标识相同时，才满足互斥</span><br><span class="line">@synchronized (obj) &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-递归锁"><a href="#3-递归锁" class="headerlink" title="3 递归锁"></a>3 递归锁</h3><ul>
<li><p>3.1 NSRecursiveLock</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// NSRecursiveLock与NSLock使用方式一样，区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE</span><br><span class="line">NSRecursiveLock *lock = [[NSRecursiveLock alloc] init];</span><br><span class="line">[lock lock];</span><br><span class="line">// dosomething      </span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.2 pthread_mutex(recursive)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">PTHREAD_MUTEX_NORMAL 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。</span><br><span class="line"></span><br><span class="line">PTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。</span><br><span class="line"></span><br><span class="line">PTHREAD_MUTEX_RECURSIVE 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。</span><br><span class="line"></span><br><span class="line">PTHREAD_MUTEX_DEFAULT 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列</span><br><span class="line">*/</span><br><span class="line">@interface JZKManager ()&#123;</span><br><span class="line">pthread_mutex_t _pLock;</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init (&amp;attr);</span><br><span class="line">pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">pthread_mutex_init (&amp;_lock, &amp;attr);</span><br><span class="line">pthread_mutexattr_destroy (&amp;attr);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)test &#123;</span><br><span class="line">pthread_mutex_lock(&amp;_lock);</span><br><span class="line">// do something</span><br><span class="line">pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">pthread_mutex_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4 信号量"></a>4 信号量</h3><ul>
<li>4.1 dispatch_semaphore  放心用SD就在用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 常用宏定义,SD源码</span><br><span class="line">#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#define UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line">// 使用</span><br><span class="line">@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe</span><br><span class="line">// call At self init</span><br><span class="line">self.weakCacheLock = dispatch_semaphore_create(1);</span><br><span class="line">// use</span><br><span class="line">LOCK(self.weakCacheLock);</span><br><span class="line">// do something</span><br><span class="line">UNLOCK(self.weakCacheLock);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-读写锁"><a href="#5-读写锁" class="headerlink" title="5 读写锁"></a>5 读写锁</h3><ul>
<li><p>5.1 pthread_rwlock</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 跟pthread_mutex类似，唯一区别是上锁时分为读锁还是写锁</span><br><span class="line"></span><br><span class="line">@interface JZKManager ()&#123;</span><br><span class="line">pthread_rwlock_t _rwlock;</span><br><span class="line">&#125;</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">pthread_rwlock_init(&amp;_rwlock, NULL);</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)read &#123;</span><br><span class="line">pthread_rwlock_rdlock(&amp;_rwlock);</span><br><span class="line">// do something</span><br><span class="line">pthread_rwlock_unlock(&amp;_rwlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)write &#123;</span><br><span class="line">pthread_rwlock_wrlock(&amp;_rwlock);</span><br><span class="line">// do something</span><br><span class="line">pthread_rwlock_unlock(&amp;_rwlock);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">pthread_rwlock_destroy(&amp;_rwlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.2 另类思路：dispatch_barrier_async / dispatch_barrier_sync</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/ 主要用于解决多线程并发读写同一个资源发生死锁</span><br><span class="line">// dispatchbarrier\(a)sync只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。</span><br><span class="line"></span><br><span class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.MyQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">// 其它异步操作a b c</span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">// 唯我独尊，这个时间段队列只运行这个block</span><br><span class="line">&#125;);</span><br><span class="line">// 其它异步操作 e f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-条件锁"><a href="#6-条件锁" class="headerlink" title="6 条件锁"></a>6 条件锁</h3><ul>
<li>NSConditionLock<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];</span><br><span class="line">if([cLock tryLockWhenCondition:0])&#123;</span><br><span class="line">[cLock unlockWithCondition:1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="7-自旋锁"><a href="#7-自旋锁" class="headerlink" title="7 自旋锁"></a>7 自旋锁</h3><ul>
<li>OSSpinLock 已废弃</li>
</ul>
<h3 id="参考或其他优秀博客"><a href="#参考或其他优秀博客" class="headerlink" title="参考或其他优秀博客"></a>参考或其他优秀博客</h3><ul>
<li><a href="http://yulingtianxia.com/blog/2015/11/01/More-than-you-want-to-know-about-synchronized/" target="_blank" rel="noopener">关于 @synchronized，这儿比你想知道的还要多</a></li>
<li><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a></li>
<li><a href="https://www.cnblogs.com/huangjianwu/p/4575763.html" target="_blank" rel="noopener">实现锁的多种方式和锁的高级用法</a></li>
<li><a href="https://stackoverflow.com/questions/2065747/pthreads-mutex-vs-semaphore" target="_blank" rel="noopener">https://stackoverflow.com/questions/2065747/pthreads-mutex-vs-semaphore</a></li>
<li><a href="http://mrpeak.cn/blog/synchronized/" target="_blank" rel="noopener">正确使用多线程同步锁@synchronized</a></li>
<li><a href="https://juejin.im/post/5a0a92996fb9a0451f307479?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io#heading-20" target="_blank" rel="noopener">谈谈iOS多线程的锁</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489265&amp;idx=1&amp;sn=2de47017e2862817456c48df211787fa&amp;source=41#wechat_redirect" target="_blank" rel="noopener">白夜追凶，揭开iOS锁的秘密</a></li>
<li><a href="http://satanwoo.github.io/2019/01/01/Synchronized/" target="_blank" rel="noopener">抛开性能，谈谈不该用@Synchronized的原因</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>idea训练套路</title>
    <url>/2014/09/10/idea%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>PS：很多年前copy的，不记得从哪整的了！如果侵犯版权请告诉我</p>
<ol>
<li>把它颠倒过来</li>
<li>把它摆平</li>
<li>把缩小</li>
<li>把颜色变换一下</li>
<li>把它变为圆形</li>
<li>使它更大</li>
<li>把它变为正方形</li>
<li>使它更小</li>
<li>使它更长</li>
<li>使它闪动</li>
<li>使它更短</li>
<li>使它发出火花</li>
<li>使它可以看到</li>
<li>点燃它</li>
<li>使它逾起一般情况</li>
<li>使它发萤光</li>
<li>把它放进文字里</li>
<li>使它沉重</li>
<li>把它插进音乐里</li>
<li>使它成为引火物</li>
<li>结合文字和音乐</li>
<li>使它成为引火物</li>
<li>结合文字. 音乐和图画</li>
<li>参加竞赛</li>
<li>结合音乐和图画删除文字</li>
<li>参加打赌</li>
<li>不要图画</li>
<li>使它成为年轻型的</li>
<li>不要文字</li>
<li>使它成为壮年型的</li>
<li>沉默无声</li>
<li>把它分割开</li>
<li>使它重复</li>
<li>保守地说</li>
<li>使它变成立体</li>
<li>夸张地说</li>
<li>使它变成平面</li>
<li>当替代品卖</li>
<li>变换它的形态</li>
<li>发现新用途</li>
<li>只变更一部分</li>
<li>减掉它</li>
<li>使它成为一组</li>
<li>撕开它</li>
<li>为捐献或义卖而销售</li>
<li>使它化合</li>
<li>鼓励它</li>
<li>用显而易见的</li>
<li>机动化</li>
<li>把要素重新配置</li>
<li>电气代</li>
<li>降低调子</li>
<li>使它活动</li>
<li>提高调子</li>
<li>使它相反</li>
<li>割开它</li>
<li>它像是某种东西的代替品</li>
<li>混合在一起</li>
<li>使它罗曼蒂克</li>
<li>改用另一种形式表现</li>
<li>增添怀旧的诉求</li>
<li>使它的速度加快</li>
<li>使它看起来流行</li>
<li>使它缓慢下来</li>
<li>使它看起来像未来派</li>
<li>使它飞行</li>
<li>使它成为某种物品的部分代替</li>
<li>使它浮起</li>
<li>使它更强壮</li>
<li>使它滚转</li>
<li>使它更耐久</li>
<li>把它切成片状</li>
<li>运用象征</li>
<li>使它成为粉状</li>
<li>它是写实派</li>
<li>以性欲作诉求</li>
<li>运用新艺术形式</li>
<li>使它凝缩</li>
<li>变为摄影技巧</li>
<li>使它弯曲</li>
<li>变换为图解方式</li>
<li>使它成对</li>
<li>使它变更形式</li>
<li>使它倾斜</li>
<li>用图画说明你的故事</li>
<li>使它悬浮半空中</li>
<li>使用新广告媒体</li>
<li>使它垂直站立</li>
<li>创造新广告媒体</li>
<li>把它由里向外翻转</li>
<li>使它更强烈</li>
<li>把它向旁边转</li>
<li>使它更冷</li>
<li>摇动它</li>
<li>增加香味</li>
<li>把它遮蔽起来</li>
<li>变换气味</li>
<li>使它不对称</li>
<li>把它除臭</li>
<li>使它不对称</li>
<li>将它向儿童诉求</li>
<li>反它隔开</li>
<li>将它向男士诉求</li>
<li>使它与其他相敌对</li>
<li>将它向妇女诉求</li>
<li>使它锐利</li>
<li>价钱更低</li>
<li>变更它的外形</li>
<li>抬高价格</li>
<li>要它绕一周</li>
<li>变更成份</li>
<li>把它框起来</li>
<li>增加新成份</li>
<li>把它卷成一圈</li>
<li>拧搓它</li>
<li>把它填满</li>
<li>使它透明</li>
<li>把它弄成空的</li>
<li>使它不透明</li>
<li>把它打开</li>
<li>用不同背景</li>
<li>把拼错</li>
<li>用不同环境</li>
<li>给它起我上绰号</li>
<li>使它富有魅力</li>
<li>把它封印起来</li>
<li>使用视觉效果</li>
<li>把它移转过来</li>
<li>使用另外的物料</li>
<li>把它捆包起来</li>
<li>增加人的趣味</li>
<li>把它集中起来</li>
<li>变更密度</li>
<li>把它推开</li>
<li>置于不同的货柜</li>
<li>使它成为交替的</li>
<li>变换包装</li>
<li>使它凝固起来</li>
<li>使密度增加</li>
<li>使它溶化</li>
<li>小型化</li>
<li>使成凝胶状</li>
<li>增加至最大限</li>
<li>使它软化</li>
<li>把它除掉</li>
<li>使它硬化</li>
<li>使它轻便</li>
<li>使蒸发变为汽化</li>
<li>使它可以折叠</li>
<li>加上抑扬顿挫</li>
<li>趋向偏激</li>
<li>使它更狭窄</li>
<li>如夏天炎热</li>
<li>使它更宽广</li>
<li>如冬天寒冷</li>
<li>使它更滑稽</li>
<li>使拟人化</li>
<li>使它成为被讽刺的</li>
<li>使它更暗</li>
<li>用简短的文案</li>
<li>使它发光</li>
<li>用冗长的文案</li>
<li>使它灼</li>
<li>发现第二种用途</li>
<li>使它更有营养</li>
<li>使它合成在一起</li>
<li>把它倒进瓶中</li>
<li>把它当作用具来卖</li>
<li>把它倒进罐中</li>
<li>使它清净</li>
<li>把它放进盒中</li>
<li>把它倒进壶中</li>
<li>把它倒进缸中</li>
<li>把它弄直</li>
<li>把它褶曲</li>
<li>把它缠起来</li>
<li>提升声誉</li>
<li>免费提供</li>
<li>以成本价出售</li>
<li>提供特价</li>
<li>增加慰藉的诉求</li>
<li>提供维护服务</li>
<li>运用不同的织法</li>
<li>使它变成香郁宜人</li>
<li>使它变成酸的</li>
<li>使它濡湿</li>
<li>使它脱水</li>
<li>使它干燥</li>
<li>把它冻起来</li>
<li>把它抛出去</li>
<li>使它无刺激性的</li>
<li>使它单纯化</li>
<li>使它具有刺激性的</li>
<li>把以上各项任意组合</li>
</ol>
<p>其实这些对那些从事平面设计和影视广告设计的技术人员是有很大的帮助的。<br><br>我有时候就有这种感觉—-思路被困看看这些就会有新的想法。<br><br>等时间长了以后就不用常看这些了。<br></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>index 2 beyond bounds [0 .. 0]</title>
    <url>/2015/01/12/index-2-beyond-bounds-0-0/</url>
    <content><![CDATA[<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>空数组就提示empty array</li>
<li>[x .. y] x 表示起始索引都是0，y 表示终止索引即count-1</li>
<li>例如 [0 .. 0] 代表数组的起始和终止索引都是0，即一个元素； [0 .. 1]代表数组包含两个元素；[0 .. 2]代表数组包含三个元素</li>
</ul>
<h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>&emsp;&emsp;release包突然有个偶现的crash，查看crash日志发现index 2 beyond bounds [0 .. 0]，想当然的以为 空数组 数组越界，然后就费心心思的排查什么情况下会出现空数组！然而折腾半天也没发现会出现空数组的情况，假数据，打log都试了一遍，最少也包含一个对象！最后还是归根到Crash日志上仔细排查，经过试验才发现对 [0 .. 0]理解错了！学艺不精，害人不浅呀！特此记录</p>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><ul>
<li><p>空数组, 注意提示的 empty array</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 空数组</span><br><span class="line">NSMutableArray *photos  = [NSMutableArray array];</span><br><span class="line">NSLog(@&quot;--- %@&quot;,photos[0]);</span><br><span class="line"></span><br><span class="line">// Crash</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 0 beyond bounds for empty array&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组只有一个对象，注意提示 [0 .. 0]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数组，包含一个对象</span><br><span class="line">NSMutableArray *photos  = [NSMutableArray array];</span><br><span class="line">[photos addObject:@0];</span><br><span class="line">NSLog(@&quot;--- %@&quot;,photos[1]);</span><br><span class="line"></span><br><span class="line">// Crash</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 1 beyond bounds [0 .. 0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组只有两个对象，注意提示 [0 .. 1]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数组，包含两个对象</span><br><span class="line">NSMutableArray *photos  = [NSMutableArray array];</span><br><span class="line">[photos addObject:@0];</span><br><span class="line">[photos addObject:@1];</span><br><span class="line">NSLog(@&quot;--- %@&quot;,photos[2]);</span><br><span class="line"></span><br><span class="line">// Crash</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 2 beyond bounds [0 .. 1]</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组只有三个对象，注意提示 [0 .. 2]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数组，包含三个对象</span><br><span class="line">NSMutableArray *photos  = [NSMutableArray array];</span><br><span class="line">[photos addObject:@0];</span><br><span class="line">[photos addObject:@1];</span><br><span class="line">[photos addObject:@2];</span><br><span class="line">NSLog(@&quot;--- %@&quot;,photos[4]);</span><br><span class="line"></span><br><span class="line">// Crash</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 4 beyond bounds [0 .. 2]</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>nil&amp;id&amp;NSObject</title>
    <url>/2015/03/17/nil-id-NSObject/</url>
    <content><![CDATA[<ul>
<li><p>nil：空对象,发送消息安全</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 没有内存地址</span><br><span class="line">NSString *str = nil;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSNull：值为 空 的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 内存地址为 Ox101zce9ea8</span><br><span class="line">NSNull *null = [NSNull null];</span><br></pre></td></tr></table></figure>
</li>
<li><p>NULL：C的的空指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// p是空指针</span><br><span class="line">int *p = NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>id 可指向任何OC类型的指针,而 void * 表示C语言中可指向任何类型的指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// str2 内存中就是NSString类型</span><br><span class="line">id str2 = @&quot;id一个指针,可指向任何OC类型,且不用加 * 号&quot;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSObject是OC的基类,但并不是所有OC对象都继承NSObject,例如NSProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 声明一个NSObject类型的对象,内存地址为Ox600000c2</span><br><span class="line">c300</span><br><span class="line">NSObject *ob = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSOjbect还可以是协议,只不过同名罢了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id&lt;NSObject&gt; obdelegate; // 表示一个遵循NSObject协议的对象</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>otool命令</title>
    <url>/2017/10/09/otool%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>&emsp;&emsp;Otool可以提取并显示ios下目标文件的相关信息，包括头部、加载命令、各个段、共享库、动态库等。Otool拥有大量的命令选项，是一个功能强大的分析工具，也可以反汇编！常用于逆向工程，这里不写逆向工程，就写点otool命令</p>
<p>&emsp;&emsp;第一个命令永远是help，但刚开头就卡壳了！无论otool -h，还是otool -help，都会提示错误。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool: at least one file must be specified</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;我想破脑袋也没想明白怎么会这样？典型的反人类设计！不过还是可以看到相关的命令解释的！更新：otool+回车，才是正确的help命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ...</span><br><span class="line">-f print the fat headers</span><br><span class="line">-a print the archive header</span><br><span class="line">-h print the mach header</span><br><span class="line">-l print the load commands</span><br><span class="line">-L print shared libraries used</span><br><span class="line">-D print shared library id name</span><br><span class="line">-t print the text section (disassemble with -v)</span><br><span class="line">-p &lt;routine name&gt;  start dissassemble from routine name</span><br><span class="line">-s &lt;segname&gt; &lt;sectname&gt; print contents of section</span><br><span class="line">-d print the data section</span><br><span class="line">-o print the Objective-C segment</span><br><span class="line">-r print the relocation entries</span><br><span class="line">-S print the table of contents of a library (obsolete)</span><br><span class="line">-T print the table of contents of a dynamic shared library (obsolete)</span><br><span class="line">-M print the module table of a dynamic shared library (obsolete)</span><br><span class="line">-R print the reference table of a dynamic shared library (obsolete)</span><br><span class="line">-I print the indirect symbol table</span><br><span class="line">-H print the two-level hints table (obsolete)</span><br><span class="line">-G print the data in code table</span><br><span class="line">-v print verbosely (symbolically) when possible</span><br><span class="line">-V print disassembled operands symbolically</span><br><span class="line">-c print argument strings of a core file</span><br><span class="line">-X print no leading addresses or headers</span><br><span class="line">-m don&apos;t use archive(member) syntax</span><br><span class="line">-B force Thumb disassembly (ARM objects only)</span><br><span class="line">-q use llvm&apos;s disassembler (the default)</span><br><span class="line">-Q use otool(1)&apos;s disassembler</span><br><span class="line">-mcpu=arg use `arg&apos; as the cpu for disassembly</span><br><span class="line">-j print opcode bytes</span><br><span class="line">-P print the info plist section as strings</span><br><span class="line">-C print linker optimization hints</span><br><span class="line">--version print the version of /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;由上可知</p>
<ol>
<li>otool地址：/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 前往bin目录得知otool其实是llvm-otool。bin目录下还有很多工具，我似乎看到了好多水文在向我招手，嘿嘿…</li>
<li>使用方式： otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [–version] <object file> …</object></li>
</ol>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2 常用命令"></a>2 常用命令</h3><ul>
<li><p>查看Mach-O头结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -v -h a.out</span><br><span class="line">otool -h xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看load commands</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -v -l a.out</span><br><span class="line">otool -l xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看Objective-C segment</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -o xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看Section中的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 查看__TEXT segname的 __text段</span><br><span class="line">otool -s __TEXT __text a.out </span><br><span class="line">// 由于 -s __TEXT __text 很常见，otool 对其设置了一个缩写 -t</span><br><span class="line">otool -t a.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 -v 来查看反汇编代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 查看反汇编之后的__TEXT segname的 __text段</span><br><span class="line">otool -v -t xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取所有方法名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -v -s __TEXT __objc_methname xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看依赖的动态库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -L xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看支持的框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -D xxx.app/xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看该应用是否加壳</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">otool -l xxx.app/xxx | grep -B 2 crypt</span><br><span class="line">// cryptid 0（砸壳） 1（未砸壳）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-常见的Section"><a href="#3-常见的Section" class="headerlink" title="3 常见的Section"></a>3 常见的Section</h3><p>&emsp;&emsp;<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/" target="_blank" rel="noopener">更多Section介绍</a></p>
<table>
<thead>
<tr>
<th>Section</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TEXT.</strong>text</td>
<td>主程序代码</td>
</tr>
<tr>
<td><strong>TEXT.</strong>cstring</td>
<td>C 语言字符串</td>
</tr>
<tr>
<td><strong>TEXT.</strong>const</td>
<td>const 关键字修饰的常量</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs</td>
<td>用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs_helper</td>
<td>当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_methname</td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_methtype</td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_classname</td>
<td>Objective-C 类名称</td>
</tr>
<tr>
<td><strong>DATA.</strong>data</td>
<td>初始化过的可变数据</td>
</tr>
<tr>
<td><strong>DATA.</strong>la_symbol_ptr</td>
<td>lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td>__DATA.nl_symbol_ptr</td>
<td>非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td><strong>DATA.</strong>const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td><strong>DATA.</strong>cfstring</td>
<td>程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td><strong>DATA.</strong>bss</td>
<td>BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td><strong>DATA.</strong>common</td>
<td>没有初始化过的符号声明</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_classlist</td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_protolist</td>
<td>Objective-C 原型</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_imginfo</td>
<td>Objective-C 镜像信息</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_selfrefs</td>
<td>Objective-C self 引用</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_protorefs</td>
<td>Objective-C 原型引用</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_superrefs</td>
<td>Objective-C 超类引用</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>runtime的使用</title>
    <url>/2016/09/02/runtime%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。Runtime是C和汇编编写的，这里 <a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">https://opensource.apple.com/tarballs/objc4/</a> 可下载源码</p>
<h4 id="常用API介绍"><a href="#常用API介绍" class="headerlink" title="常用API介绍"></a>常用API介绍</h4><ul>
<li><p>类相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取类的类名</span><br><span class="line">const char * class_getName ( Class cls );</span><br><span class="line">// 获取类的父类，当cls为Nil或者cls为根类时，返回Nil</span><br><span class="line">Class class_getSuperclass ( Class cls );</span><br><span class="line">// 判断给定的Class是否是一个元类，如果是cls是元类，则返回YES</span><br><span class="line">BOOL class_isMetaClass ( Class cls );</span><br><span class="line"></span><br><span class="line">// 创建一个新类和元类，如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</span><br><span class="line">Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );</span><br><span class="line">// 销毁一个类及其相关联的类，如果程序运class_conformsToProtocol行中还存在类或其子类的实例，则不能调用针对类调用该方法</span><br><span class="line">void objc_disposeClassPair ( Class cls );</span><br><span class="line">// 在应用中注册由objc_allocateClassPair创建的类</span><br><span class="line">void objc_registerClassPair ( Class cls );</span><br><span class="line"></span><br><span class="line">// 获取已注册的类定义的列表</span><br><span class="line">int objc_getClassList ( Class *buffer, int bufferCount );</span><br><span class="line">// 创建并返回一个指向所有已注册类的指针列表</span><br><span class="line">Class * objc_copyClassList ( unsigned int *outCount );</span><br><span class="line">// 返回指定类的类定义，如果类在运行时未注册，则objc_lookUpClass会返回nil，</span><br><span class="line">// 而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil</span><br><span class="line">// 而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程。</span><br><span class="line">Class objc_lookUpClass ( const char *name );</span><br><span class="line">Class objc_getClass ( const char *name );</span><br><span class="line">Class objc_getRequiredClass ( const char *name );</span><br><span class="line">// 返回指定类的元类</span><br><span class="line">Class objc_getMetaClass ( const char *name );</span><br></pre></td></tr></table></figure>
</li>
<li><p>ivar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取类中指定名称实例成员变量的信息，返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</span><br><span class="line">Ivar class_getInstanceVariable ( Class cls, const char *name );</span><br><span class="line">// 获取类成员变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</span><br><span class="line">Ivar class_getClassVariable ( Class cls, const char *name );</span><br><span class="line">// 添加成员变量，只能在objc_allocateClassPair函数与objc_registerClassPair之间调用</span><br><span class="line">BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );</span><br><span class="line">// 获取整个成员变量列表，但不包含在父类中声明的变量，必须使用free()来释放。outCount指针返回数组的大小</span><br><span class="line">Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );</span><br><span class="line"></span><br><span class="line">// 获取成员变量名</span><br><span class="line">const char * ivar_getName ( Ivar v );</span><br><span class="line">// 获取成员变量类型编码</span><br><span class="line">const char * ivar_getTypeEncoding ( Ivar v );</span><br><span class="line">// 获取成员变量的偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset ( Ivar v );</span><br></pre></td></tr></table></figure>
</li>
<li><p>property</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取指定的属性</span><br><span class="line">objc_property_t class_getProperty ( Class cls, const char *name );</span><br><span class="line">// 获取属性列表</span><br><span class="line">objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );</span><br><span class="line">// 为类添加属性</span><br><span class="line">BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );</span><br><span class="line">// 替换类的属性</span><br><span class="line">void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取属性名</span><br><span class="line">const char * property_getName ( objc_property_t property );</span><br><span class="line">// 获取属性特性描述字符串</span><br><span class="line">const char * property_getAttributes ( objc_property_t property );</span><br><span class="line">// 获取属性中指定的特性，必须使用free()来释放。</span><br><span class="line">char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );</span><br><span class="line">// 获取属性的特性列表，必须使用free()来释放。</span><br><span class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加方法，如果本类中包含一个同名的实现，则函数会返回NO！</span><br><span class="line">// https://stackoverflow.com/questions/49003493/objc-class-addmethod-does-not-check-argument-type?r=SearchResults</span><br><span class="line">BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );</span><br><span class="line">// 移除方法？不能，参考：https://stackoverflow.com/questions/1315169/how-do-i-remove-instance-methods-at-runtime-in-objective-c-2-0</span><br><span class="line">// 获取实例方法，会去搜索父类的实现</span><br><span class="line">Method class_getInstanceMethod ( Class cls, SEL name );</span><br><span class="line">// 获取类方法，会去搜索父类的实现</span><br><span class="line">Method class_getClassMethod ( Class cls, SEL name );</span><br><span class="line">// 获取所有实例方法的数组，但不会去搜索父类的实现，必须使用free()来释放。outCount指针返回数组的大小</span><br><span class="line">// 获取类方法，则可以使用class_copyMethodList(object_getClass(cls), &amp;count)因为一个类的实例方法是定义在元类里面</span><br><span class="line">Method * class_copyMethodList ( Class cls, unsigned int *outCount );</span><br><span class="line">// 替代方法的实现，如果不存在同名方法则类似class_addMethod添加方法，存在则类似method_setImplementation替代原方法的实现</span><br><span class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );</span><br><span class="line">// 返回方法的具体实现，一个指向方法实现函数的指针。比method_getImplementation(class_getInstanceMethod(cls, name))更快</span><br><span class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</span><br><span class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</span><br><span class="line">// 类实例是否响应指定的selector</span><br><span class="line">BOOL class_respondsToSelector ( Class cls, SEL sel );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。</span><br><span class="line">// 工程中的所有的SEL组成一个Set集合，这也是为啥OC，不同类（无论是否继承）不能有同名方法！SEL方法签名</span><br><span class="line">// IMP实际上是一个函数指针，指向方法实现的首地址</span><br><span class="line"></span><br><span class="line">// 调用指定方法的实现</span><br><span class="line">id method_invoke ( id receiver, Method m, ... );</span><br><span class="line">// 调用返回一个数据结构的方法的实现</span><br><span class="line">void method_invoke_stret ( id receiver, Method m, ... );</span><br><span class="line">// 获取方法名</span><br><span class="line">SEL method_getName ( Method m );</span><br><span class="line">// 返回方法的实现</span><br><span class="line">IMP method_getImplementation ( Method m );</span><br><span class="line">// 获取描述方法参数和返回值类型的字符串</span><br><span class="line">const char * method_getTypeEncoding ( Method m );</span><br><span class="line">// 获取方法的返回值类型的字符串</span><br><span class="line">char * method_copyReturnType ( Method m );</span><br><span class="line">// 获取方法的指定位置参数的类型字符串</span><br><span class="line">char * method_copyArgumentType ( Method m, unsigned int index );</span><br><span class="line">// 通过引用返回方法的返回值类型字符串</span><br><span class="line">void method_getReturnType ( Method m, char *dst, size_t dst_len );</span><br><span class="line">// 返回方法的参数的个数</span><br><span class="line">unsigned int method_getNumberOfArguments ( Method m );</span><br><span class="line">// 通过引用返回方法指定位置参数的类型字符串</span><br><span class="line">void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );</span><br><span class="line">// 返回指定方法的方法描述结构体</span><br><span class="line">struct objc_method_description * method_getDescription ( Method m );</span><br><span class="line">// 设置方法的实现</span><br><span class="line">IMP method_setImplementation ( Method m, IMP imp );</span><br><span class="line">// 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations ( Method m1, Method m2 );</span><br><span class="line"></span><br><span class="line">// 返回给定选择器指定的方法的名称</span><br><span class="line">const char * sel_getName ( SEL sel );</span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span><br><span class="line">SEL sel_registerName ( const char *str );</span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法</span><br><span class="line">SEL sel_getUid ( const char *str );</span><br><span class="line">// 比较两个选择器</span><br><span class="line">BOOL sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 添加协议</span><br><span class="line">BOOL class_addProtocol ( Class cls, Protocol *protocol );</span><br><span class="line">// 返回类是否实现指定的协议, 不检测父类中实现的Protocol,而 [NSObject conformsToProtocol:] 检测所有继承类中实现的Protocol</span><br><span class="line">BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );</span><br><span class="line">// 返回类实现的协议列表，但不包含在父类的协议，必须使用free()来释放。outCount指针返回数组的大小</span><br><span class="line">Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );</span><br><span class="line"></span><br><span class="line">// 返回指定的协议,如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nil</span><br><span class="line">Protocol * objc_getProtocol ( const char *name );</span><br><span class="line">// 获取运行时所知道的所有协议的数组,，必须使用free()来释放</span><br><span class="line">Protocol ** objc_copyProtocolList ( unsigned int *outCount );</span><br><span class="line">// 创建新的协议实例，如果同名的协议已经存在，则返回nil</span><br><span class="line">Protocol * objc_allocateProtocol ( const char *name );</span><br><span class="line">// 在运行时中注册新创建的协议，协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议</span><br><span class="line">void objc_registerProtocol ( Protocol *proto );</span><br><span class="line">// 为协议添加方法</span><br><span class="line">void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );</span><br><span class="line">// 添加一个已注册的协议到协议中</span><br><span class="line">void protocol_addProtocol ( Protocol *proto, Protocol *addition );</span><br><span class="line">// 为协议添加属性</span><br><span class="line">void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line">// 返回协议名</span><br><span class="line">const char * protocol_getName ( Protocol *p );</span><br><span class="line">// 测试两个协议是否相等</span><br><span class="line">BOOL protocol_isEqual ( Protocol *proto, Protocol *other );</span><br><span class="line">// 获取协议中指定条件的方法的方法描述数组</span><br><span class="line">struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );</span><br><span class="line">// 获取协议中指定方法的方法描述</span><br><span class="line">struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );</span><br><span class="line">// 获取协议中的属性列表</span><br><span class="line">objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );</span><br><span class="line">// 获取协议的指定属性</span><br><span class="line">objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );</span><br><span class="line">// 获取协议采用的协议</span><br><span class="line">Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );</span><br><span class="line">// 查看协议是否采用了另一个协议</span><br><span class="line">BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other );</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取实例大小</span><br><span class="line">size_t class_getInstanceSize ( Class cls );</span><br><span class="line"></span><br><span class="line">// 返回给定对象的类名</span><br><span class="line">const char * object_getClassName ( id obj );</span><br><span class="line">// 返回对象的类</span><br><span class="line">Class object_getClass ( id obj );</span><br><span class="line">// 设置对象的类</span><br><span class="line">Class object_setClass ( id obj, Class cls );</span><br><span class="line"></span><br><span class="line">// 返回指定对象的一份拷贝</span><br><span class="line">id object_copy ( id obj, size_t size );</span><br><span class="line">// 释放指定对象占用的内存</span><br><span class="line">id object_dispose ( id obj );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 修改类实例的实例变量的值</span><br><span class="line">Ivar object_setInstanceVariable ( id obj, const char *name, void *value );</span><br><span class="line">// 获取对象实例变量的值</span><br><span class="line">Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );</span><br><span class="line">// 返回指向给定对象分配的任何额外字节的指针</span><br><span class="line">void * object_getIndexedIvars ( id obj );</span><br><span class="line">// 返回对象中实例变量的值</span><br><span class="line">id object_getIvar ( id obj, Ivar ivar );</span><br><span class="line">// 设置对象中实例变量的值</span><br><span class="line">void object_setIvar ( id obj, Ivar ivar, id value );</span><br></pre></td></tr></table></figure>
</li>
<li><p>关联对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设置关联对象</span><br><span class="line">void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );</span><br><span class="line">// 获取关联对象</span><br><span class="line">id objc_getAssociatedObject ( id object, const void *key );</span><br><span class="line">// 移除关联对象</span><br><span class="line">void objc_removeAssociatedObjects ( id object );</span><br></pre></td></tr></table></figure>
</li>
<li><p>编码类型,@encode返回这个类型的字符串编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起,@encode返回这个类型的字符串编码</span><br><span class="line">const char *argType = [self.methodSignature getArgumentTypeAtIndex:index];</span><br><span class="line">if (strcmp(argType, @encode(int)) == 0) &#123;</span><br><span class="line">// return value is int </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>block</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建一个指针函数的指针，该函数调用时会调用特定的block，参数block的签名必须是method_return_type ^(id self, method_args …)形式的。</span><br><span class="line">IMP imp_implementationWithBlock ( id block );</span><br><span class="line">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span><br><span class="line">id imp_getBlock ( IMP anImp );</span><br><span class="line">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span><br><span class="line">BOOL imp_removeBlock ( IMP anImp );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h4><ul>
<li><p>Method Swizzle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void SwizzleMethod(Class cls, SEL ori, SEL rep) &#123;</span><br><span class="line">Method oriMethod = class_getInstanceMethod(cls, ori);</span><br><span class="line">Method repMethod = class_getInstanceMethod(cls, rep);</span><br><span class="line"></span><br><span class="line">BOOL flag = class_addMethod(cls, ori, method_getImplementation(repMethod), method_getTypeEncoding(repMethod));</span><br><span class="line"></span><br><span class="line">if (flag) &#123;</span><br><span class="line">class_replaceMethod(cls, rep, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">method_exchangeImplementations(oriMethod, repMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印所有信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)print:(Class)cls &#123;</span><br><span class="line">unsigned int outCount = 0;</span><br><span class="line">NSLog(@&quot;===========================&quot;);</span><br><span class="line">NSLog(@&quot;----------------------&quot;);</span><br><span class="line">Class tempCls = cls;</span><br><span class="line">while (tempCls != NULL) &#123;</span><br><span class="line">NSLog(@&quot;class name: %s&quot;,class_getName(tempCls));</span><br><span class="line">// isa指针是啥？实例对象的isa指针指向类对象，类对象的isa指针指向元类对象。</span><br><span class="line">Class meta_class = objc_getMetaClass(class_getName(tempCls));</span><br><span class="line">NSLog(@&quot;%s&apos;s meta-class is %s&quot;, class_getName(tempCls), class_getName(meta_class));</span><br><span class="line">tempCls = class_getSuperclass(tempCls);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;----------------------&quot;);</span><br><span class="line">Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">for (int i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">Ivar ivar = ivars[i];</span><br><span class="line">NSLog(@&quot;ivar : %s type:%s at index: %d&quot;, ivar_getName(ivar) , ivar_getTypeEncoding(ivar), i);</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br><span class="line">Ivar shoolNum = class_getInstanceVariable(cls, &quot;_schoolNum&quot;);</span><br><span class="line">if (shoolNum != NULL) &#123;</span><br><span class="line">NSLog(@&quot;ivar _schoolNum is exist&quot;);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;----------------------&quot;);</span><br><span class="line">objc_property_t *propertys = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">for (int i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">objc_property_t p = propertys[i];</span><br><span class="line">NSLog(@&quot;property : %s attributes:%s at index: %d&quot;, property_getName(p) , property_getAttributes(p), i);</span><br><span class="line">&#125;</span><br><span class="line">free(propertys);</span><br><span class="line">objc_property_t name = class_getProperty(cls, &quot;name&quot;);</span><br><span class="line">if (name != NULL) &#123;</span><br><span class="line">NSLog(@&quot;property name is exist&quot;);</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;----------------------&quot;);</span><br><span class="line">Method *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">for (int i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">Method m = methods[i];</span><br><span class="line">NSLog(@&quot;Method : %s typeEncoding:%s&quot;,method_getName(m), method_getTypeEncoding(m));</span><br><span class="line">unsigned int argCount = method_getNumberOfArguments(m);</span><br><span class="line">for (int j = 0; j &lt; argCount; j++) &#123;</span><br><span class="line">char *argType = method_copyArgumentType(m, j);</span><br><span class="line">NSLog(@&quot;Method %s arg: %s at index: %i&quot;,method_getName(m), argType , j);</span><br><span class="line">free(argType);</span><br><span class="line">&#125;</span><br><span class="line">char *returnType = method_copyReturnType(m);</span><br><span class="line">NSLog(@&quot;Method %s return: %s&quot;,method_getName(m),returnType);</span><br><span class="line">free(returnType);</span><br><span class="line">&#125;</span><br><span class="line">free(methods);</span><br><span class="line">Method walk = class_getInstanceMethod(cls, @selector(walk));</span><br><span class="line">if (walk != NULL) &#123;</span><br><span class="line">NSLog(@&quot;method %s&quot;, method_getName(walk));</span><br><span class="line">&#125;</span><br><span class="line">Method sleep = class_getClassMethod(cls, @selector(sleep));</span><br><span class="line">if (sleep != NULL) &#123;</span><br><span class="line">NSLog(@&quot;class method : %s&quot;, method_getName(sleep));</span><br><span class="line">&#125;</span><br><span class="line">if (class_respondsToSelector(cls, @selector(eat))) &#123;</span><br><span class="line">IMP eat = class_getMethodImplementation(cls, @selector(eat));</span><br><span class="line">eat();</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;----------------------&quot;);</span><br><span class="line">Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">for (int i = 0; i &lt; outCount; i++) &#123;</span><br><span class="line">Protocol *p = protocols[i];</span><br><span class="line">NSLog(@&quot;protocol name: %s&quot;, protocol_getName(p));</span><br><span class="line">&#125;</span><br><span class="line">if (class_conformsToProtocol(cls, @protocol(UITableViewDelegate))) &#123;</span><br><span class="line">class_addProtocol(cls, @protocol(UITableViewDelegate));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加新类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addNewClass &#123;</span><br><span class="line">Class newClass = objc_allocateClassPair([Person class], &quot;XiaoHong&quot;, 0);</span><br><span class="line">/*</span><br><span class="line">Type Encodings：</span><br><span class="line">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1</span><br><span class="line">*/</span><br><span class="line">class_addIvar(newClass, &quot;_shoes&quot;, sizeof(int), rint(log2(sizeof(int))), @encode(int));</span><br><span class="line">/*</span><br><span class="line">属性的特性字符串 以 T@encode(type) 开头</span><br><span class="line">type类型分为以下几种</span><br><span class="line">1、所有类，包括NSOjbect，是什么类型就 @“类型”即可</span><br><span class="line">2、基础类型：NSInteger-&gt;q、NSUInteger-&gt;Q、int-&gt;i、float-&gt;f、double-&gt;d、BOOL-&gt;B</span><br><span class="line">3、Block -&gt; @?</span><br><span class="line">*/</span><br><span class="line">objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;q&quot;&#125;;</span><br><span class="line">/*</span><br><span class="line">中间以特性编码填充</span><br><span class="line">R-&gt;readonly、C-&gt;copy、&amp;-&gt;retain、N-&gt;nonatomic、G(name)-&gt;getter=(name)、S(name)-》setter=(name)、D-&gt;@dynamic、W-&gt;weak</span><br><span class="line">*/</span><br><span class="line">objc_property_attribute_t ownership = &#123; &quot;N&quot;, &quot;&quot; &#125;;</span><br><span class="line">//以 V实例变量名称 结尾，注无法动态注册关联对象也没必要</span><br><span class="line">objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_shoes&quot;&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line">class_addProperty(newClass, &quot;shoes&quot;, attrs, 3);</span><br><span class="line"></span><br><span class="line">// method_getTypeEncoding</span><br><span class="line">/*</span><br><span class="line">https://stackoverflow.com/questions/11491947/what-are-the-digits-in-an-objc-method-type-encoding-string</span><br><span class="line">https://stackoverflow.com/questions/43492021/runtime-what-does-this-mean-in-class-addmethod?r=SearchResults</span><br><span class="line">结论: &quot;v@:@&quot;：v：是void； @表示是id(即self) ：表示_cmd @表示：第一个参数类型（此为id），其他可参照Type Encodings，所以 &quot;v@:&quot; 即无参数</span><br><span class="line"></span><br><span class="line">https://stackoverflow.com/questions/20735814/adding-objective-c-method-to-class-at-runtime?r=SearchResults</span><br><span class="line">结论: colorWithWhite:alpha: -&gt; @@:ff</span><br><span class="line">*/  </span><br><span class="line">class_addMethod(newClass, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);</span><br><span class="line">class_replaceMethod(newClass, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">objc_registerClassPair(newClass);</span><br><span class="line"></span><br><span class="line">id instance = [[newClass alloc] init];</span><br><span class="line">[instance performSelector:@selector(submethod1)];</span><br><span class="line">[instance performSelector:@selector(method1)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加新协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addNewProtocol &#123;</span><br><span class="line">Protocol *newP = objc_allocateProtocol(&quot;MyDelete&quot;);</span><br><span class="line">protocol_addMethodDescription(newP, @selector(submethod1), &quot;v@:&quot;, NO, NO);</span><br><span class="line">objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;q&quot;&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; &quot;N&quot;, &quot;&quot; &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_shoes&quot;&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line">protocol_addProperty(newP, &quot;shoes&quot;, attrs, 3, NO, NO);</span><br><span class="line">objc_registerProtocol(newP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类到子类的强转是怎么进行的？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 把NSObject的实例（内存空间小）转为MyClass（内存空间大），即强制转换</span><br><span class="line">NSObject *a = [[NSObject alloc] init];</span><br><span class="line">id newB = object_copy(a, class_getInstanceSize(MyClass.class));</span><br><span class="line">object_setClass(newB, MyClass.class);</span><br><span class="line">object_dispose(a);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://southpeak.github.io/2014/10/25/objective-c-runtime-1/" target="_blank" rel="noopener">http://southpeak.github.io/2014/10/25/objective-c-runtime-1/</a></li>
<li><a href="http://southpeak.github.io/2014/10/30/objective-c-runtime-2/" target="_blank" rel="noopener">http://southpeak.github.io/2014/10/30/objective-c-runtime-2/</a></li>
<li><a href="http://southpeak.github.io/2014/11/03/objective-c-runtime-3/" target="_blank" rel="noopener">http://southpeak.github.io/2014/11/03/objective-c-runtime-3/</a></li>
<li><a href="http://southpeak.github.io/2014/11/06/objective-c-runtime-4/" target="_blank" rel="noopener">http://southpeak.github.io/2014/11/06/objective-c-runtime-4/</a></li>
<li><a href="http://southpeak.github.io/2014/11/08/objective-c-runtime-5/" target="_blank" rel="noopener">http://southpeak.github.io/2014/11/08/objective-c-runtime-5/</a></li>
<li><a href="http://southpeak.github.io/2014/11/09/objective-c-runtime-6/" target="_blank" rel="noopener">http://southpeak.github.io/2014/11/09/objective-c-runtime-6/</a></li>
<li><a href="https://github.com/ming1016/study/wiki/Objc-Runtime" target="_blank" rel="noopener">https://github.com/ming1016/study/wiki/Objc-Runtime</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlite常用语句</title>
    <url>/2015/04/07/sqlite%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>SQL 对大小写不敏感</p>
<ol>
<li><p>创建数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database dbname</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop database dbname</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// text 为col对应的数据类型，在iOS中建议都用text，</span><br><span class="line">// 因为第一数据量不是很多，不太影响效率；第二避免后端更改数据类型造成的越界等错误</span><br><span class="line">create table if not exists tablename(col1 text [not null] [primary key],col2 text [not null],..)</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据已有的表创建新表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不要使用as方式，as方式没索引</span><br><span class="line">create table newTable like oldTable</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除新表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table tabname</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加、修改一个列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">增加：alter table tabname add columnName columnType</span><br><span class="line">修改：alter table tabname modify columnName columnType</span><br><span class="line">删除：千万不要做，宁愿留着不用</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找select,注意iOS里value需要用‘%@’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 所有</span><br><span class="line">select * from table1</span><br><span class="line">//过滤掉someKey的重复值</span><br><span class="line">elect distinct field1 from table1 </span><br><span class="line">// 查找具体项 ,详见本文运算符</span><br><span class="line">select * from table1 where field1 = value1</span><br><span class="line">// 排序,默认asc升序，desc降序！</span><br><span class="line">select * from table1 order by field1 [desc] </span><br><span class="line">// 取到升序前5个。注意sqlite没有top语法，但可以通过 limit 5 来实现top效果</span><br><span class="line">select * from table1 order by field1 limit 5</span><br><span class="line"></span><br><span class="line">总数：select count as totalcount from table1</span><br><span class="line">求和：select sum(field1) as sumvalue from table1</span><br><span class="line">平均：select avg(field1) as avgvalue from table1</span><br><span class="line">最大：select max(field1) as maxvalue from table1</span><br><span class="line">最小：select min(field1) as minvalue from table1</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">插入：insert or replace into table1(field1,field2) values(value1,value2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from table1 where 范围</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update table1 set field1=value1 where 范围</span><br></pre></td></tr></table></figure>
</li>
<li><p>运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考：https://www.runoob.com/sqlite/sqlite-operators.html</span><br><span class="line">算数运算符 + ，- ，* ，/ , %</span><br><span class="line">比较运算符 = , &gt; , &gt;= , &lt; , &lt;= </span><br><span class="line">// and 与关系</span><br><span class="line">select * from table1 where field1 &gt;= value1 and field2 = value2 </span><br><span class="line">// or 或关系</span><br><span class="line">select * from table1 where field1 &gt;= value1 for field2 = value2 </span><br><span class="line">// [不]在value1和value2之间</span><br><span class="line">select * frome table1 where field1 [not] between value1 and value2</span><br><span class="line">// [不]是NULL的值</span><br><span class="line">select * from table1 where field1 is [not] NULL</span><br><span class="line">// like模糊匹配 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用</span><br><span class="line">select * frome table1 where field1 like &apos;_ZK%&apos;</span><br><span class="line">// [不]在给定范围内</span><br><span class="line">select * frome table1 where field1 [not] in (60, 100)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：<a href="https://www.runoob.com/sqlite/sqlite-select.html" target="_blank" rel="noopener">SQL语法</a></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>swiftUI练习</title>
    <url>/2019/06/15/swiftUI%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>&emsp;&emsp;要说这次WWDC最惊艳的是什么？绝对是swiftUI！好长时间没水点东西了（没时间也没精力整理），但这个swiftUI我确实想凑个热闹！毕竟太好玩了！官方教程：<a href="https://developer.apple.com/tutorials/swiftui/" target="_blank" rel="noopener">https://developer.apple.com/tutorials/swiftui/</a>  建议大家跟着官方教程学一遍！其实不用英语很好，直接看代码也能看懂个大概的! </p>
<p>&emsp;&emsp;由于是照超官方教程，没啥技术含量！项目不发了，也没必要！鼓励大家自己按教程敲一敲看一看！这里就贴点我觉得好玩的代码</p>
<ol>
<li><p>some 关键字是Swift 5.1 的新特性，个人理解就是一种确定类型，具体什么类型调用者自己去看函数。参考：<a href="https://stackoverflow.com/questions/56433665/what-is-the-some-keyword-in-swiftui" target="_blank" rel="noopener">https://stackoverflow.com/questions/56433665/what-is-the-some-keyword-in-swiftui</a> 和 <a href="https://juejin.im/post/5cfb1217f265da1b8a4f0f14" target="_blank" rel="noopener">https://juejin.im/post/5cfb1217f265da1b8a4f0f14</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">Text(&quot;Hello World&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用UIKit方法：新建swiftUI view用于包装UIKit，并实现UIViewRepresentable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MapView : UIViewRepresentable &#123;</span><br><span class="line"></span><br><span class="line">typealias UIViewType = MKMapView</span><br><span class="line"></span><br><span class="line">func makeUIView(context: UIViewRepresentableContext&lt;MapView&gt;) -&gt; MKMapView &#123;</span><br><span class="line">return MKMapView(frame: .zero)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateUIView(_ uiView: MKMapView, context: UIViewRepresentableContext&lt;MapView&gt;) &#123;</span><br><span class="line">let coordinate = CLLocationCoordinate2D(</span><br><span class="line">latitude: 34.011286, longitude: -116.166868)</span><br><span class="line">let span = MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)</span><br><span class="line">let region = MKCoordinateRegion(center: coordinate, span: span)</span><br><span class="line">uiView.setRegion(region, animated: true)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>list 的 identifiable 的数据，两种方法让数据变成 identifiable ：1、identified(by:) 提供一个唯一key；2、遵循 Identifiable 协议。这样比OC的dequeueReusableCellWithIdentifier强多了，虽然一般也是直接用cellClassName</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List(landmarkData, id: \.id) &#123; landmark in</span><br><span class="line">LandmarkRow(landmark: landmark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有意思的导航! NavigationView{} 表示有上面的导航条！最主要是NavigationButton，这个很有意思！一般UIKit写起来需要获取VC，现在使用seiftUI解放了这项工作，直接用一个特殊的NavigationButton就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">NavigationView &#123;</span><br><span class="line">List(landmarkData) &#123; landmark in</span><br><span class="line">NavigationButton(destination: LandmarkDetail()) &#123;</span><br><span class="line">LandmarkRow(landmark: landmark)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.navigationBarTitle(Text(&quot;Landmarks&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@state 看到state肯定是状态机，我好奇地是是不是也跟flutter一样，分为StatelessWidgets和 StatefulWidgets，几经检索找到一篇 <a href="https://mecid.github.io/2019/06/12/understanding-property-wrappers-in-swiftui/" target="_blank" rel="noopener">https://mecid.github.io/2019/06/12/understanding-property-wrappers-in-swiftui/</a>  简单总结一下：</p>
</li>
</ol>
<ul>
<li>@State 修饰的属性发生改变，通知一个view发生改变</li>
<li>@Binding 把值属性变成引用属性，使用 $ 前缀来访问一个状态变量或者它的属性的 binding</li>
<li>@ObservedObject 监听一个实现 ObservableObject 协议的对象，对象内部属性需用@Published 修饰。可通知多个view</li>
<li>@EnvironmentObject 修饰全局变量的 一般和 BindableObject协议一起用于viewModel</li>
<li>@Environment 监控系统级别object<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@State var showFavoritesOnly = false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li><p>BindableObject 一开始写dome时，我理解撑了viewModel，但现在想想理解的有点狭隘，应该是有反射机制的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class UserData: BindableObject  &#123;</span><br><span class="line">let didChange = PassthroughSubject&lt;UserData, Never&gt;()</span><br><span class="line"></span><br><span class="line">var showFavoritesOnly = false &#123;</span><br><span class="line">didSet &#123;</span><br><span class="line">didChange.send(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var landmarks = landmarkData &#123;</span><br><span class="line">didSet &#123;</span><br><span class="line">didChange.send(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式动画，直接用 .animation() 即可，确实简单多了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Button(action: &#123;</span><br><span class="line">self.showDetail.toggle()</span><br><span class="line">&#125;) &#123;</span><br><span class="line">Image(systemName: &quot;chevron.right.circle&quot;)</span><br><span class="line">.imageScale(.large)</span><br><span class="line">.rotationEffect(.degrees(showDetail ? 90 : 0))</span><br><span class="line">.scaleEffect(showDetail ? 1.5 : 1)</span><br><span class="line">.padding()</span><br><span class="line">.animation(.spring())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示动画withAnimation</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Button(action: &#123;</span><br><span class="line">withAnimation &#123;</span><br><span class="line">self.showDetail.toggle()</span><br><span class="line">&#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">Image(systemName: &quot;chevron.right.circle&quot;)</span><br><span class="line">.imageScale(.large)</span><br><span class="line">.rotationEffect(.degrees(showDetail ? 90 : 0))</span><br><span class="line">.scaleEffect(showDetail ? 1.5 : 1)</span><br><span class="line">.padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var animation: Animation &#123;</span><br><span class="line">Animation.spring(initialVelocity: 5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var body: some View &#123;</span><br><span class="line">Capsule()</span><br><span class="line">.fill(Color.gray)</span><br><span class="line">.frame(height: height * heightRatio, alignment: .bottom)</span><br><span class="line">.offset(x: 0, y: height * -offsetRatio)</span><br><span class="line">.animation(animation)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Environment 能监控哪些系统级别value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Environment(\.editMode) var mode</span><br><span class="line"></span><br><span class="line">extension EnvironmentValues &#123;</span><br><span class="line"></span><br><span class="line">@available(OSX, unavailable)</span><br><span class="line">@available(watchOS, unavailable)</span><br><span class="line">public var editMode: Binding&lt;EditMode&gt;?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等等</span><br></pre></td></tr></table></figure>
</li>
<li><p>swiftUI和UIKit的协调员</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct PageControl: UIViewRepresentable &#123;</span><br><span class="line">var numberOfPages: Int</span><br><span class="line">@Binding var currentPage: Int</span><br><span class="line"></span><br><span class="line">func makeCoordinator() -&gt; Coordinator &#123;</span><br><span class="line">Coordinator(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func makeUIView(context: Context) -&gt; UIPageControl &#123;</span><br><span class="line">let control = UIPageControl()</span><br><span class="line">control.numberOfPages = numberOfPages</span><br><span class="line">control.addTarget(</span><br><span class="line">context.coordinator,</span><br><span class="line">action: #selector(Coordinator.updateCurrentPage(sender:)),</span><br><span class="line">for: .valueChanged)</span><br><span class="line"></span><br><span class="line">return control</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateUIView(_ uiView: UIPageControl, context: Context) &#123;</span><br><span class="line">uiView.currentPage = currentPage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Coordinator: NSObject &#123;</span><br><span class="line">var control: PageControl</span><br><span class="line"></span><br><span class="line">init(_ control: PageControl) &#123;</span><br><span class="line">self.control = control</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc</span><br><span class="line">func updateCurrentPage(sender: UIPageControl) &#123;</span><br><span class="line">control.currentPage = sender.currentPage</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>tableview的坑</title>
    <url>/2015/09/12/tableview%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h3 id="header问题"><a href="#header问题" class="headerlink" title="header问题"></a>header问题</h3><ul>
<li>tableview的reloadSections刷新时，如果cell或secitonHeader中有XIB创建的subview，可能会出现frame问题,一会大一会小，但没任何地方更改frame，结论：慎用XIB</li>
<li><a href="https://blog.csdn.net/weixin_33686714/article/details/89615265" target="_blank" rel="noopener">https://blog.csdn.net/weixin_33686714/article/details/89615265</a></li>
</ul>
<h3 id="reloadSection的坑"><a href="#reloadSection的坑" class="headerlink" title="reloadSection的坑"></a>reloadSection的坑</h3><ul>
<li>现象：reloadSections后，再设置P2P或爆品抢购对应的选中tab会闪动。</li>
<li>实验结果：reloadSections时好像不会复用已展示的cell，而是cellA和cellB的循环展示，cellA的scrollViewContentOffset与cellB的scrollViewContentOffset不一致，造成闪动，且scrollViewContentOffset大小没有必然规律</li>
<li>补充：参考 <a href="https://blog.csdn.net/hherima/article/details/84573076" target="_blank" rel="noopener">https://blog.csdn.net/hherima/article/details/84573076</a></li>
</ul>
<h3 id="更新：tableView-reloadData-有跳动"><a href="#更新：tableView-reloadData-有跳动" class="headerlink" title="更新：tableView reloadData 有跳动"></a>更新：tableView reloadData 有跳动</h3><ul>
<li>在iOS 11Self-Sizing自动打开后，contentSize和contentOffset都可能发生改变。可以通过以下方式禁用</li>
<li>tableView.estimatedRowHeight = 0;</li>
<li>tableView.estimatedSectionHeaderHeight = 0;</li>
<li>tableView.estimatedSectionFooterHeight = 0;</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>weak源码</title>
    <url>/2017/04/26/weak%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>&emsp;&emsp;直接上源码吧，<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">源码地址</a>，我就写写我感兴趣的部分吧</p>
<h3 id="1-内存属性类型"><a href="#1-内存属性类型" class="headerlink" title="1 内存属性类型"></a>1 内存属性类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">&quot;Unknown&quot; includes non-object ivars and non-ARC non-__weak ivars</span><br><span class="line">&quot;Strong&quot; includes ARC __strong ivars</span><br><span class="line">&quot;Weak&quot; includes ARC and new MRC __weak ivars</span><br><span class="line">&quot;Unretained&quot; includes ARC __unsafe_unretained and old GC+MRC __weak ivars</span><br><span class="line">*/</span><br><span class="line">typedef enum &#123;</span><br><span class="line">objc_ivar_memoryUnknown,     // unknown / unknown</span><br><span class="line">objc_ivar_memoryStrong,      // direct access / objc_storeStrong</span><br><span class="line">objc_ivar_memoryWeak,        // objc_loadWeak[Retained] / objc_storeWeak</span><br><span class="line">objc_ivar_memoryUnretained   // direct access / direct access</span><br><span class="line">&#125; objc_ivar_memory_management_t;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;提问assign应该算到哪一个？答案unknown！copy呢？</p>
<h3 id="2-添加weak"><a href="#2-添加weak" class="headerlink" title="2 添加weak"></a>2 添加weak</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Update a weak variable.</span><br><span class="line">// If HaveOld is true, the variable has an existing value </span><br><span class="line">//   that needs to be cleaned up. This value might be nil.</span><br><span class="line">// If HaveNew is true, there is a new value that needs to be </span><br><span class="line">//   assigned into the variable. This value might be nil.</span><br><span class="line">// If CrashIfDeallocating is true, the process is halted if newObj is </span><br><span class="line">//   deallocating or newObj&apos;s class does not support weak references. </span><br><span class="line">//   If CrashIfDeallocating is false, nil is stored instead.</span><br><span class="line">template &lt;bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;</span><br><span class="line">static id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">assert(HaveOld  ||  HaveNew);</span><br><span class="line">if (!HaveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">Class previouslyInitializedClass = nil;</span><br><span class="line">id oldObj;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">声明新旧两个散列表，防止数据污染</span><br><span class="line">SideTable 下面有介绍</span><br><span class="line">*/</span><br><span class="line">SideTable *oldTable;</span><br><span class="line">SideTable *newTable;</span><br><span class="line"></span><br><span class="line">// Acquire locks for old and new values.</span><br><span class="line">// Order by lock address to prevent lock ordering problems. </span><br><span class="line">// Retry if the old value changes underneath us.</span><br><span class="line">retry:</span><br><span class="line">if (HaveOld) &#123;</span><br><span class="line">oldObj = *location;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">SideTables的初始化很有意思，既不是在C++ static初始化时干的，也不是全局初始化时干的</span><br><span class="line">而是在runtime第一次初始化时干的</span><br><span class="line">*/</span><br><span class="line">oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">oldTable = nil;</span><br><span class="line">&#125;</span><br><span class="line">if (HaveNew) &#123;</span><br><span class="line">newTable = &amp;SideTables()[newObj];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">newTable = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">if (HaveOld  &amp;&amp;  *location != oldObj)有两个作用：</span><br><span class="line">1，因为有goto retry重试机制，可用此if来判断是否处理过location</span><br><span class="line">2，预防多线程问题</span><br><span class="line">*/</span><br><span class="line">if (HaveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line">goto retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Prevent a deadlock between the weak reference machinery</span><br><span class="line">// and the +initialize machinery by ensuring that no </span><br><span class="line">// weakly-referenced object has an un-+initialized isa.</span><br><span class="line"></span><br><span class="line">if (HaveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">Class cls = newObj-&gt;getIsa();</span><br><span class="line">if (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">!((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">&#123;</span><br><span class="line">SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">我对上面说通过initialize来防止deadlock很感兴趣，到底怎么才会死锁？又怎么防止？</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">_class_initialize(_class_getNonMetaClass(cls, (id)newObj));</span><br><span class="line"></span><br><span class="line">// If this class is finished with +initialize then we&apos;re good.</span><br><span class="line">// If this class is still running +initialize on this thread </span><br><span class="line">// (i.e. +initialize called storeWeak on an instance of itself)</span><br><span class="line">// then we may proceed but it will appear initializing and </span><br><span class="line">// not yet initialized to the check above.</span><br><span class="line">// Instead set previouslyInitializedClass to recognize it on retry.</span><br><span class="line">previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">goto retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Clean up old value, if any.</span><br><span class="line">if (HaveOld) &#123;</span><br><span class="line">weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Assign new value, if any.</span><br><span class="line">if (HaveNew) &#123;</span><br><span class="line">newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, </span><br><span class="line">(id)newObj, location, </span><br><span class="line">CrashIfDeallocating);</span><br><span class="line">// weak_register_no_lock returns nil if weak store should be rejected</span><br><span class="line"></span><br><span class="line">// Set is-weakly-referenced bit in refcount table.</span><br><span class="line"></span><br><span class="line">// 关于TaggedPointer https://www.infoq.cn/article/deep-understanding-of-tagged-pointer</span><br><span class="line">if (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Do not set *location anywhere else. That would introduce a race.</span><br><span class="line">*location = (id)newObj;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// No new value. The storage is not changed.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">return (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="问题1-initialize-deadlock"><a href="#问题1-initialize-deadlock" class="headerlink" title="问题1 initialize deadlock"></a>问题1 initialize deadlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***********************************************************************</span><br><span class="line">*  +initialize deadlock case when a class is marked initializing while </span><br><span class="line">*  its superclass is initialized. Solved by completely initializing </span><br><span class="line">*  superclasses before beginning to initialize a class.</span><br><span class="line">*</span><br><span class="line">*  OmniWeb class hierarchy:</span><br><span class="line">*                 OBObject </span><br><span class="line">*                     |    ` OBPostLoader</span><br><span class="line">*                 OFObject</span><br><span class="line">*                 /     \</span><br><span class="line">*      OWAddressEntry  OWController</span><br><span class="line">*                        | </span><br><span class="line">*                      OWConsoleController</span><br><span class="line">*</span><br><span class="line">*  Thread 1 (evil testing thread):</span><br><span class="line">*    initialize OWAddressEntry</span><br><span class="line">*    super init OFObject</span><br><span class="line">*    super init OBObject             </span><br><span class="line">*    [OBObject initialize] runs OBPostLoader, which inits lots of classes...</span><br><span class="line">*    initialize OWConsoleController</span><br><span class="line">*    super init OWController - wait for Thread 2 to finish OWController init</span><br><span class="line">*</span><br><span class="line">*  Thread 2 (normal OmniWeb thread):</span><br><span class="line">*    initialize OWController</span><br><span class="line">*    super init OFObject - wait for Thread 1 to finish OFObject init</span><br><span class="line">*</span><br><span class="line">*  deadlock!</span><br><span class="line">*</span><br><span class="line">*  Solution: fully initialize super classes before beginning to initialize </span><br><span class="line">*  a subclass. Then the initializing+initialized part of the class hierarchy</span><br><span class="line">*  will be a contiguous subtree starting at the root, so other threads </span><br><span class="line">*  can&apos;t jump into the middle between two initializing classes, and we won&apos;t </span><br><span class="line">*  get stuck while a superclass waits for its subclass which waits for the </span><br><span class="line">*  superclass.</span><br><span class="line">**********************************************************************/</span><br></pre></td></tr></table></figure>
<h4 id="问题2-weak-register-no-lock-为啥是no-lock？"><a href="#问题2-weak-register-no-lock-为啥是no-lock？" class="headerlink" title="问题2 weak_register_no_lock 为啥是no_lock？"></a>问题2 weak_register_no_lock 为啥是no_lock？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">因为不关心！查看源码过程中，发现会有判断各种入参！</span><br></pre></td></tr></table></figure>
<h4 id="问题3-weak的引用计数？不关心，直接加到哈希表里！到时候直接清空哈希表"><a href="#问题3-weak的引用计数？不关心，直接加到哈希表里！到时候直接清空哈希表" class="headerlink" title="问题3 weak的引用计数？不关心，直接加到哈希表里！到时候直接清空哈希表"></a>问题3 weak的引用计数？不关心，直接加到哈希表里！到时候直接清空哈希表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line">* Add new_entry to the object&apos;s table of weak references.</span><br><span class="line">* Does not check whether the referent is already in the table.</span><br><span class="line">*/</span><br><span class="line">static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">weak_entry_t *weak_entries = weak_table-&gt;weak_entries;</span><br><span class="line">assert(weak_entries != nil);</span><br><span class="line"></span><br><span class="line">size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);</span><br><span class="line">size_t index = begin;</span><br><span class="line">size_t hash_displacement = 0;</span><br><span class="line">while (weak_entries[index].referent != nil) &#123;</span><br><span class="line">index = (index+1) &amp; weak_table-&gt;mask;</span><br><span class="line">if (index == begin) bad_weak_table(weak_entries);</span><br><span class="line">hash_displacement++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">weak_entries[index] = *new_entry;</span><br><span class="line">weak_table-&gt;num_entries++;</span><br><span class="line"></span><br><span class="line">if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;</span><br><span class="line">weak_table-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-移除weak"><a href="#3-移除weak" class="headerlink" title="3 移除weak"></a>3 移除weak</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// dealloc -&gt; _objc_rootDealloc</span><br><span class="line"></span><br><span class="line">static id </span><br><span class="line">_object_dispose(id anObject) </span><br><span class="line">&#123;</span><br><span class="line">if (anObject==nil) return nil;</span><br><span class="line"></span><br><span class="line">objc_destructInstance(anObject);</span><br><span class="line">// 这个有意思！将isa指向nil，防止销毁“类对象”和元类</span><br><span class="line">anObject-&gt;initIsa(_objc_getFreedObjectClass ()); </span><br><span class="line"></span><br><span class="line">free(anObject);</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// Slow path of clearDeallocating() </span><br><span class="line">// for objects with nonpointer isa</span><br><span class="line">// that were ever weakly referenced </span><br><span class="line">// or whose retain count ever overflowed to the side table.</span><br><span class="line">NEVER_INLINE void</span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">SideTable&amp; table = SideTables()[this];</span><br><span class="line">table.lock();</span><br><span class="line">if (isa.weakly_referenced) &#123;</span><br><span class="line">weak_clear_no_lock(&amp;table.weak_table, (id)this);</span><br><span class="line">&#125;</span><br><span class="line">if (isa.has_sidetable_rc) &#123;</span><br><span class="line">table.refcnts.erase(this);</span><br><span class="line">&#125;</span><br><span class="line">table.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">* Called by dealloc; nils out all weak pointers that point to the </span><br><span class="line">* provided object so that they can no longer be used.</span><br><span class="line">* </span><br><span class="line">* @param weak_table </span><br><span class="line">* @param referent The object being deallocated. </span><br><span class="line">*/</span><br><span class="line">void </span><br><span class="line">weak_clear_no_lock(weak_table_t *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>weakSelf和strongSelf</title>
    <url>/2017/04/08/weakSelf%E5%92%8CstrongSelf/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天水完了__block，这次水水weakself和strongself吧</p>
<h3 id="1-不使用weak"><a href="#1-不使用weak" class="headerlink" title="1 不使用weak"></a>1 不使用weak</h3><p>&emsp;&emsp;待测试代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (void)test &#123;</span><br><span class="line">//    __weak typeof(self) weakSelf = self;</span><br><span class="line">void (^myblock)(void) =  ^&#123;</span><br><span class="line">//        __strong typeof(weakSelf)self = weakSelf;</span><br><span class="line">NSLog(@&quot;%@&quot;,weakSelf);</span><br><span class="line">&#125;;</span><br><span class="line">myblock();</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;使用clang编译命令,<a href="https://stackoverflow.com/questions/40946716/how-to-use-weak-reference-in-clang?r=SearchResults" target="_blank" rel="noopener">参考:How to use __weak reference in clang?</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc -fobjc-arc -stdlib=libc++ -mmacosx-version-min=10.7 -fobjc-runtime=macosx-10.7 -Wno-deprecated-declarations keke.m</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;打开编译后cpp文件，找到@implementation  Person<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __Person__test_block_desc_0* Desc;</span><br><span class="line">Person *const __strong self;</span><br><span class="line">__Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *const __strong _self, int flags=0) : self(_self) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">void (*myblock)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344));</span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过编译后源码得知，不使用weak时，Block捕获self，并强持有! 这时如果self也持有Block，就会造成循环引用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person *const __strong self;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-使用weakself"><a href="#2-使用weakself" class="headerlink" title="2 使用weakself"></a>2 使用weakself</h3><p>&emsp;&emsp;删除上面weak的注释，使用clang编译</p>
<p>&emsp;&emsp;打开编译后cpp文件，找到@implementation  Person。找到weakself相关代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __Person__test_block_desc_0* Desc;</span><br><span class="line">Person *const __weak weakSelf;</span><br><span class="line">__Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">__attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class="line">void (*myblock)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, weakSelf, 570425344));</span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;objc_ownership字面意思是：对象的所有权，即Block中weakSelf的所有权为weak</p>
<h3 id="3-使用weakself，也使用strongself"><a href="#3-使用weakself，也使用strongself" class="headerlink" title="3 使用weakself，也使用strongself"></a>3 使用weakself，也使用strongself</h3><p>&emsp;&emsp;删除上面weak和strong的注释，使用clang编译</p>
<p>&emsp;&emsp;打开编译后cpp文件，找到@implementation  Person。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***********这段和2 只有weak没strong时一样************/</span><br><span class="line">struct __Person__test_block_impl_0 &#123;</span><br><span class="line">struct __block_impl impl;</span><br><span class="line">struct __Person__test_block_desc_0* Desc;</span><br><span class="line">Person *const __weak weakSelf;</span><br><span class="line">__Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;</span><br><span class="line">impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">impl.Flags = flags;</span><br><span class="line">impl.FuncPtr = fp;</span><br><span class="line">Desc = desc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">__attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;</span><br><span class="line">void (*myblock)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, weakSelf, 570425344));</span><br><span class="line">((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);</span><br><span class="line">&#125;</span><br><span class="line">/***********这段和2 只有weak没strong时一样************/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;</span><br><span class="line">Person *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy</span><br><span class="line"></span><br><span class="line">__attribute__((objc_ownership(strong))) typeof(weakSelf)self = weakSelf;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_883428_mi_0,self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;综上Block捕获self时是weak的，这样能打破循环引用，在Block函数内部又对self声明所有权为strong，此时strongself的生命周期同Block函数生命周期一直，保证了在Black函数内部self是存在的</p>
<h3 id="4-weakself是不是必须的？"><a href="#4-weakself是不是必须的？" class="headerlink" title="4 weakself是不是必须的？"></a>4 weakself是不是必须的？</h3><p>&emsp;&emsp;先献上大神的文章： <a href="https://github.com/ChenYilong/iOSBlog/issues/4" target="_blank" rel="noopener">使用 Heap-Stack Dance 替代 Weak-Strong Dance，优雅避开循环引用</a></p>
<p>&emsp;&emsp;原理：利用了“参数”的特性：参数是存放在栈中的(或寄存器中)，系统负责回收，开发者无需关心。因为解决问题的思路是：将 block 会捕获变量到堆上的问题，化解为了：变量会被分配到栈(或寄存器中)上</p>
<p>&emsp;&emsp;实现方法就是：把self当做参数手动传给block，而不是通过Block的被动去捕获self</p>
<p>&emsp;&emsp;其实我们一直在用只是没有注意到，例如FMDB里<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)inDatabase:(__attribute__((noescape)) void (^)(FMDatabase *db))block;</span><br><span class="line"></span><br><span class="line">- (void)inTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;</span><br><span class="line"></span><br><span class="line">- (void)inDeferredTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;</span><br><span class="line"></span><br><span class="line">- (void)inExclusiveTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;</span><br><span class="line"></span><br><span class="line">- (void)inImmediateTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-weakify和-strongify"><a href="#5-weakify和-strongify" class="headerlink" title="5 @weakify和@strongify"></a>5 @weakify和@strongify</h3><p>&emsp;&emsp;写到weakself就不得不提到RAC的@weakify和@strongify！说来惭愧，接触RAC很长一段时间了，源码也研究过一些！但始终也没写出点什么！整体框架太大，写不了！细节又太小，又不想写……</p>
<p>&emsp;&emsp;先看看一般情况下怎么写<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define BBWeakSelf(type)    __weak typeof(type) weak##type = type</span><br><span class="line">#define BBStrongSelf(type)  __strong typeof(type) type = weak##type</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;是不是很lou？现在打开RACEXTScope.h文件，找到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define weakify(...) \</span><br><span class="line">rac_keywordify \</span><br><span class="line">metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)</span><br><span class="line"></span><br><span class="line">#define strongify(...) \</span><br><span class="line">rac_keywordify \</span><br><span class="line">_Pragma(&quot;clang diagnostic push&quot;) \</span><br><span class="line">_Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \</span><br><span class="line">metamacro_foreach(rac_strongify_,, __VA_ARGS__) \</span><br><span class="line">_Pragma(&quot;clang diagnostic pop&quot;)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;先看rac_keywordify，作用是添加@符号，这也是比BBWeakSelf牛逼的不止一点点！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Details about the choice of backing keyword:</span><br><span class="line">//</span><br><span class="line">// The use of @try/@catch/@finally can cause the compiler to suppress</span><br><span class="line">// return-type warnings.</span><br><span class="line">// The use of @autoreleasepool &#123;&#125; is not optimized away by the compiler,</span><br><span class="line">// resulting in superfluous creation of autorelease pools.</span><br><span class="line">//</span><br><span class="line">// Since neither option is perfect, and with no other alternatives, the</span><br><span class="line">// compromise is to use @autorelease in DEBUG builds to maintain compiler</span><br><span class="line">// analysis, and to use @try/@catch otherwise to avoid insertion of unnecessary</span><br><span class="line">// autorelease pools.</span><br><span class="line">#if DEBUG</span><br><span class="line">#define rac_keywordify autoreleasepool &#123;&#125;</span><br><span class="line">#else</span><br><span class="line">#define rac_keywordify try &#123;&#125; @catch (...) &#123;&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;metamacro_foreach最后也是调的metamacro_foreach_cxt，点到最后发现是 A ## B ， ## 是宏连接符，会将 ## 左右两边连接起来，整体替换下来是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">autoreleasepool &#123;&#125;</span><br><span class="line">metamacro_foreach_cxt1(rac_weakify_,  , __weak, self)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接着看rac_weakify_是怎么回事<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define rac_weakify_(INDEX, CONTEXT, VAR) \</span><br><span class="line">CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);</span><br><span class="line"></span><br><span class="line">#define rac_strongify_(INDEX, VAR) \</span><br><span class="line">__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最终替换成如下代码，和编译后的<strong>weak和</strong>strong几乎一模一样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125; __attribute__((objc_ownership(weak))) __typeof__(self) self_weak_ = (self);</span><br><span class="line"></span><br><span class="line">@autoreleasepool &#123;&#125; __attribute__((objc_ownership(strong))) __typeof__(self) self = self_weak_;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;折腾这么一大圈的原因是@weakify(…);可以支持最多20个参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* For each consecutive variadic argument (up to twenty)</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;参考：<a href="http://www.cocoachina.com/articles/17303" target="_blank" rel="noopener">剖析RAC中的@weakify、@strongify</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>xib与代码颜色偏差问题</title>
    <url>/2017/10/20/xib%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%A2%9C%E8%89%B2%E5%81%8F%E5%B7%AE%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天视觉走查时发现一个问题，视觉给的stech文件给出了颜色值，正常流程是拿到颜色值直接扔过去就不管了！但今天踩雷了，UI的火眼金睛竟然发下颜色不一样，代码里数值明明都是一样的，但仔细观察的话，确实有一点点的区别。这是为什么？</p>
<p>&emsp;&emsp;经过仔细排查，没发现任何程序上的问题，且发现纯代码设置的颜色是正确的，只有xib/SB设置的颜色不正确，那是不是xib自己的坑？</p>
<p>&emsp;&emsp;新建一个xib，随便选个颜色，保存，右键查看xml，得到源码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view contentMode=&quot;scaleToFill&quot; id=&quot;iN0-l3-epB&quot;&gt;</span><br><span class="line">&lt;rect key=&quot;frame&quot; x=&quot;0.0&quot; y=&quot;0.0&quot; width=&quot;414&quot; height=&quot;896&quot;/&gt;</span><br><span class="line">&lt;autoresizingMask key=&quot;autoresizingMask&quot; widthSizable=&quot;YES&quot; heightSizable=&quot;YES&quot;/&gt;</span><br><span class="line">&lt;color key=&quot;backgroundColor&quot; red=&quot;0.0&quot; green=&quot;0.97680455450000003&quot; blue=&quot;0.0&quot; alpha=&quot;1&quot; colorSpace=&quot;custom&quot; customColorSpace=&quot;sRGB&quot;/&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;代码设置颜色的方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIColor *colorFromRGB(float r, float g, float b, float alpha) &#123;</span><br><span class="line">return [UIColor colorWithRed:r/255.f green:g/255.f blue:b/255.f alpha:alpha];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;对比发现xib多了一个colorSpace，即颜色空间！很有可能是这个问题，再次查阅官方文档，发现如下解释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (UIColor *)colorWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha;</span><br><span class="line"></span><br><span class="line">The color object. The color information represented by this object is in an RGB colorspace. On applications linked for iOS 10 or later, the color is specified in an extended range sRGB color space. On earlier versions of iOS, the color is specified in a device RGB colorspace.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;简单翻译就是iOS10之后使用sRGB颜色空间，iOS10之前跟随系统颜色空间设置</p>
<p>&emsp;&emsp;那iOS10之前的颜色空间是什么？查阅到<a href="https://medium.com/@ethanhuang13/ios-interface-builder指定顏色與實際有出入-19735b3f467b" target="_blank" rel="noopener">.Xcode Interface Builder 指定顏色與實際有出入  </a></p>
<ul>
<li>Xib/Storyboard默认用的是sRGB。</li>
<li>Sketch用的是sRGB。</li>
<li>PhotoShop默认用的是Generic RGB。</li>
<li>代码中的UIColor赋值，用的是Generic RGB。</li>
</ul>
<p>&emsp;&emsp;很明显了！修改方式也比较简单了，把颜色空间改成sRGB即可</p>
<p>&emsp;&emsp;本来到这为止！我已经水完了！已经完成了水一篇的任务！</p>
<p>&emsp;&emsp;但是我们的 .clr文件里有一百多个颜色值，我怎么改才行？</p>
<ul>
<li>最理想：写算法批量转化！但我不懂颜色空间的知识，而且这个是一次性操作，专门去学习成本太高！<strong>失败</strong></li>
<li>退而次之：直接在xib里修改颜色值的colorspace！不行，因为xib里直接修改颜色值，xcode为了保证颜色一致，修改了Red，Green和Blue的值，而我们的需求是Red，Green和Blue的值是正确的</li>
<li>再次之：手动输入Red，Green和Blue的值，再选择colorspace！可以做，但工作量比较大，而且步骤较多，以后新增颜色出问题的可能性比较大！.clr文件是共享的，维护成本较高</li>
</ul>
<p>&emsp;&emsp;经过数次试验发现：在xib里使用吸管来取颜色值，能够正确的取到了Red，Green和Blue的值，并正确设置colorspace！</p>
<p>&emsp;&emsp;==结论：使用吸管来吸颜色最靠谱，团队维护成本也较低==</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>为啥叫发消息</title>
    <url>/2014/10/08/%E4%B8%BA%E5%95%A5%E5%8F%AB%E5%8F%91%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p>&emsp;&emsp;从Java转到OC，遇到一个以前不太在意的问题：发消息还是函数调用？刚开始自学的时候认为 [NSObject alloc] 就是函数调用，跟int ret = max(a, b); 或者 System.out.println(“Hello World!”); 没区别，只不过是换汤不换药，换了个马甲而已！直到今天，被同事郑重其事的告诉我：不是函数调用，而是向某某发消息！<br><br>&emsp;&emsp;究其原因，可能如下：</p>
<ol>
<li><p>函数调用是编译时已经确定的，接收方肯定能做出反应；而发消息是编译时只是调用objc_msgSend方法，运行时再确定接收方是否能做出反应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// </span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用是写死的关系，而发消息时，接受者可以选择转发等操作让别人干活</p>
</li>
<li>发消息是不是等同于广播（OC的通知）? 个人认为不是，广播的接受者可以选择无视，也可以选择执行；而OC的发消息，接受者只能选择执行，交给别人执行或者Crash</li>
</ol>
<p>&emsp;&emsp; 以上就是对发消息的个人理解</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>代码规范</title>
    <url>/2017/06/30/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>转载自<a href="https://github.com/samlaudev/Objective-C-Coding-Style#error-handling" target="_blank" rel="noopener">https://github.com/samlaudev/Objective-C-Coding-Style#error-handling</a></p>
<p>其它参考：<a href="https://www.jianshu.com/p/8b76814b3663" target="_blank" rel="noopener">Objective-C编码规范(译)</a>、<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">Google代码规范</a>以及<a href="https://github.com/zh-google-styleguide/zh-google-styleguide" target="_blank" rel="noopener">中文版</a>、</p>
<p>补充更新：<a href="https://juejin.im/post/5a0921c05188252ae93a7014" target="_blank" rel="noopener">如何提高代码的可读性?</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;mid=2647761689&amp;idx=1&amp;sn=b35c6a64d39d716003502a7925cf3a7f" target="_blank" rel="noopener">何为代码质量？——用脑子写代码</a>、WordPress的<a href="https://github.com/wordpress-mobile/objective-c-style-guide" target="_blank" rel="noopener">OC规范</a>和<a href="https://github.com/wordpress-mobile/swift-style-guide" target="_blank" rel="noopener">Swift规范</a></p>
<p>&emsp;&emsp;看到一份不错的代码规范，摘录下来！PS：感觉比百度的好</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#language">语言</a></li>
<li><a href="#code-organization">代码组织</a></li>
<li><a href="#spacing">空格</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#naming">命名</a></li>
<li><a href="#underscores">下划线</a></li>
<li><a href="#methods">方法</a></li>
<li><a href="#variables">变量</a></li>
<li><a href="#property-attributes">属性特性</a></li>
<li><a href="#dot-notation-syntax">点符号语法</a></li>
<li><a href="#literals">字面值</a></li>
<li><a href="#constants">常量</a></li>
<li><a href="#enumerated-types">枚举类型</a></li>
<li><a href="#case-statements">Case语句</a></li>
<li><a href="#private-properties">私有属性</a></li>
<li><a href="#booleans">布尔值</a></li>
<li><a href="#conditionals">条件语句</a></li>
<li><a href="#ternary-operator">三元操作符</a></li>
<li><a href="#init-methods">Init方法</a></li>
<li><a href="#class-constructor-methods">类构造方法</a></li>
<li><a href="#cgrect-functions">CGRect函数</a></li>
<li><a href="#golden-path">黄金路径</a></li>
<li><a href="#error-handling">错误处理</a></li>
<li><a href="#singletons">单例模式</a></li>
<li><a href="#line-breaks">换行符</a></li>
<li><a href="#xcode-project">Xcode工程</a></li>
</ul>
<p><b id="language"></b></p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>应该使用US英语.</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColour = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure>
<p><b id="code-organization"></b></p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>在函数分组和protocol/delegate实现中使用<code>#pragma mark -</code>来分类方法，要遵循以下一般结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Lifecycle</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Custom Accessors</span></span><br><span class="line">- (<span class="keyword">void</span>)setCustomProperty:(<span class="keyword">id</span>)value &#123;&#125;</span><br><span class="line">- (<span class="keyword">id</span>)customProperty &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - IBActions/Event Response</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)submitData:(<span class="keyword">id</span>)sender &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)someButtonDidPressed:(<span class="built_in">UIButton</span>*)button</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Protocol conformance</span></span><br><span class="line"><span class="meta">#pragma mark - UITextFieldDelegate</span></span><br><span class="line"><span class="meta">#pragma mark - UITableViewDataSource</span></span><br><span class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Public</span></span><br><span class="line">- (<span class="keyword">void</span>)publicMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private</span></span><br><span class="line">- (<span class="keyword">void</span>)privateMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSObject</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><b id="spacing"></b></p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>缩进使用<strong>4</strong>个空格，确保在Xcode偏好设置来设置。(raywenderlich.com使用<strong>2</strong>个空格)</li>
<li>方法大括号和其他大括号(<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等.)总是在同一行语句打开但在新行中关闭。</li>
</ul>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line"><span class="comment">//Do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。</li>
<li>优先使用auto-synthesis。但如果有必要，<code>@synthesize</code> 和 <code>@dynamic</code>应该在实现中每个都声明新的一行。</li>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请<strong>不要</strong>这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。</li>
</ul>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">animations:^&#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line">completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><b id="comments"></b></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当需要注释时，注释应该用来解释这段特殊代码<strong>为什么</strong>要这样做。任何被使用的注释都必须保持最新或被删除。</p>
<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。<em>例外：这不应用在生成文档的注释</em></p>
<p><b id="naming"></b></p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>Apple命名规则尽可能坚持，特别是与这些相关的<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" target="_blank" rel="noopener">memory management rules</a> (<a href="http://stackoverflow.com/a/2865194/340508" target="_blank" rel="noopener">NARC</a>)。</p>
<p>长的，描述性的方法和变量命名是好的。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *settingsButton;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *setBut;</span><br></pre></td></tr></table></figure>
<p>三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。</p>
<p>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>
<p>属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@ synthesize语句，除非你有一个好的理由。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> varnm;</span><br></pre></td></tr></table></figure>
<p><b id="underscores"></b></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>当使用属性时，实例变量应该使用<code>self.</code>来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有<code>self.</code>。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<p><b id="methods"></b></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像<code>initWithWidth:height</code>以下这个例子：</p>
<p><strong>应该:</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setExampleText:(<span class="built_in">NSString</span> *)text image:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector to:(<span class="keyword">id</span>)anObject forAllCells:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line">- (<span class="keyword">id</span>)viewWithTag:(<span class="built_in">NSInteger</span>)tag;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width height:(<span class="built_in">CGFloat</span>)height;</span><br></pre></td></tr></table></figure></p>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setT:(<span class="built_in">NSString</span> *)text i:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector :(<span class="keyword">id</span>)anObject :(<span class="built_in">BOOL</span>)flag;</span><br><span class="line">- (<span class="keyword">id</span>)taggedView:(<span class="built_in">NSInteger</span>)tag;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width andHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<p><b id="variables"></b></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p>
<p>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>，除了一些特殊情况下常量。</p>
<p><a href="#private-properties">私有变量</a> 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(<code>init</code>, <code>initWithCoder:</code>, 等…)，<code>dealloc</code> 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6" target="_blank" rel="noopener">这里</a></p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTTutorial</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTTutorial</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="built_in">NSString</span> *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b id="property-attributes"></b></p>
<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><p>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>NSString应该使用<code>copy</code> 而不是 <code>strong</code>的属性特性。</p>
<p>为什么？即使你声明一个<code>NSString</code>的属性，有人可能传入一个<code>NSMutableString</code>的实例，然后在你没有注意的情况下修改它。 </p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p><b id="dot-notation-syntax"></b></p>
<h2 id="点符号语法"><a href="#点符号语法" class="headerlink" title="点符号语法"></a>点符号语法</h2><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="noopener">这里</a></p>
<p>点语法应该<strong>总是</strong>被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
<p><strong>应该:</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span>.array count];</span><br><span class="line">view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication].delegate;</span><br></pre></td></tr></table></figure></p>
<p><strong>不应该:</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span>.array.count;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</span><br></pre></td></tr></table></figure></p>
<p><b id="literals"></b></p>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code>的字面值应该在创建这些类的不可变实例时被使用。请特别注意<code>nil</code>值不能传入<code>NSArray</code>和<code>NSDictionary</code>字面值，因为这样会导致crash。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span>: <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span>: <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span>: <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>
<p><b id="constants"></b></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define CompanyName @<span class="meta-string">"RayWenderlich.com"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define thumbnailHeight 2</span></span><br></pre></td></tr></table></figure>
<p><b id="enumerated-types"></b></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>当使用<code>enum</code>时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p>
<p><strong>例如:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">RWTLeftMenuTopItemMain,</span><br><span class="line">RWTLeftMenuTopItemShows,</span><br><span class="line">RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTGlobalConstants) &#123;</span><br><span class="line">RWTPinSizeMin = <span class="number">1</span>,</span><br><span class="line">RWTPinSizeMax = <span class="number">5</span>,</span><br><span class="line">RWTPinCountMin = <span class="number">100</span>,</span><br><span class="line">RWTPinCountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旧的k-style常量定义应该<strong>避免</strong>除非编写Core Foundation C的代码。</p>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> GlobalConstants &#123;</span><br><span class="line">kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><b id="case-statements"></b></p>
<h2 id="Case语句"><a href="#Case语句" class="headerlink" title="Case语句"></a>Case语句</h2><p>大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Multi-line example using braces</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// ** fall-through! **</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">// code executed for values 1 and 2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在switch使用枚举类型时，’default’是不需要的。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line"><span class="keyword">case</span> RWTLeftMenuTopItemMain:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RWTLeftMenuTopItemShows:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RWTLeftMenuTopItemSchedule:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b id="private-properties"></b></p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如<code>RWTPrivate</code>或<code>private</code>)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p><strong>例如:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTDetailViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) GADBannerView *googleAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ADBannerView *iAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWebView</span> *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><b id="booleans"></b></p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Objective-C使用<code>YES</code>和<code>NO</code>。因为<code>true</code>和<code>false</code>应该只在CoreFoundation，C或C++代码使用。既然<code>nil</code>解析成<code>NO</code>，所以没有必要在条件语句比较。不要拿某样东西直接与<code>YES</code>比较，因为<code>YES</code>被定义为1和一个<code>BOOL</code>能被设置为8位。</p>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (![anotherObject boolValue]) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject == <span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ([anotherObject boolValue] == <span class="literal">NO</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">YES</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">true</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<p>如果<code>BOOL</code>属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure>
<p>文字和例子从这里引用<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="noopener">Cocoa Naming Guidelines</a></p>
<p><b id="conditionals"></b></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，<a href="http://programmers.stackexchange.com/a/16530" target="_blank" rel="noopener">even more dangerous defect</a>可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line"><span class="keyword">return</span> success;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error) <span class="keyword">return</span> success;</span><br></pre></td></tr></table></figure>
<p><b id="ternary-operator"></b></p>
<h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>当需要提高代码的清晰性和简洁性时，三元操作符<code>?:</code>才会使用。单个条件求值常常需要它。多个条件求值时，如果使用<code>if</code>语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line">result = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> isHorizontal = <span class="literal">YES</span>;</span><br><span class="line">result = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure>
<p><b id="init-methods"></b></p>
<h2 id="Init方法"><a href="#Init方法" class="headerlink" title="Init方法"></a>Init方法</h2><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用<code>instancetype</code>而不是<code>id</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看关于instancetype的文章<a href="#class-constructor-methods">Class Constructor Methods</a></p>
<p><b id="class-constructor-methods"></b></p>
<h2 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法"></a>类构造方法</h2><p>当类构造方法被使用时，它应该返回类型是<code>instancetype</code>而不是<code>id</code>。这样确保编译器正确地推断结果类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Airplane</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)airplaneWithType:(RWTAirplaneType)type;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>关于更多instancetype信息，请查看<a href="http://nshipster.com/instancetype/" target="_blank" rel="noopener">NSHipster.com</a></p>
<p><b id="cgrect-functions"></b></p>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><p>当访问<code>CGRect</code>里的<code>x</code>, <code>y</code>, <code>width</code>, 或 <code>height</code>时，应该使用<a href="http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html" target="_blank" rel="noopener"><code>CGGeometry</code>函数</a>而不是直接通过结构体来访问。引用Apple的<code>CGGeometry</code>:</p>
<blockquote>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
</blockquote>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = frame.origin.x;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame.origin.y;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame.size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame.size.height;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; .origin = <span class="built_in">CGPointZero</span>, .size = frame.size &#125;;</span><br></pre></td></tr></table></figure>
<p><b id="golden-path"></b></p>
<h2 id="黄金路径"><a href="#黄金路径" class="headerlink" title="黄金路径"></a>黄金路径</h2><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line"><span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line"><span class="keyword">if</span> ([someOther boolValue]) &#123;</span><br><span class="line"><span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b id="error-handling"></b></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p><strong>应该:</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> trySomethingWithError:&amp;error]) &#123;</span><br><span class="line"><span class="comment">// Handle Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>不应该:</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">[<span class="keyword">self</span> trySomethingWithError:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">// Handle Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<p><b id="singletons"></b></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例对象应该使用线程安全模式来创建共享实例。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会防止<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html" target="_blank" rel="noopener">possible and sometimes prolific crashes</a>.</p>
<p><b id="line-breaks"></b></p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] initWithProductIdentifiers:productIdentifiers];</span><br></pre></td></tr></table></figure>
<p>一行很长的代码应该分成两行代码，下一行用两个空格隔开。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] </span><br><span class="line">initWithProductIdentifiers:productIdentifiers];</span><br></pre></td></tr></table></figure>
<p><b id="xcode-project"></b></p>
<h2 id="Xcode工程"><a href="#Xcode工程" class="headerlink" title="Xcode工程"></a>Xcode工程</h2><p>物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据<strong>类型</strong>来分组，而且还可以根据<strong>功能</strong>来分组，这样代码更加清晰。</p>
<p>尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下<a href="http://boredzo.org/blog/archives/2009-11-07/warnings" target="_blank" rel="noopener">additional warnings</a>。如果你需要忽略特殊的警告，使用 <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas" target="_blank" rel="noopener">Clang’s pragma feature</a>。</p>
<h1 id="其他Objective-C编码规范"><a href="#其他Objective-C编码规范" class="headerlink" title="其他Objective-C编码规范"></a>其他Objective-C编码规范</h1><p>如果我们的编码规范不符合你的口味，可以查看其他的编码规范：</p>
<ul>
<li><a href="https://github.com/RobotsAndPencils/objective-c-style-guide" target="_blank" rel="noopener">Robots &amp; Pencils</a></li>
<li><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="noopener">New York Times</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml" target="_blank" rel="noopener">Google</a></li>
<li><a href="https://github.com/github/objective-c-conventions" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://trac.adium.im/wiki/CodingStyle" target="_blank" rel="noopener">Adium</a></li>
<li><a href="https://gist.github.com/soffes/812796" target="_blank" rel="noopener">Sam Soffes</a></li>
<li><a href="http://cocoadevcentral.com/articles/000082.php" target="_blank" rel="noopener">CocoaDevCentral</a></li>
<li><a href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html" target="_blank" rel="noopener">Luke Redpath</a></li>
<li><a href="http://www.cimgf.com/zds-code-style-guide/" target="_blank" rel="noopener">Marcus Zarra</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>whistle使用</title>
    <url>/2016/10/20/whistle%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>&emsp;&emsp;使用charles已经好几年了，一直觉得挺好用的！但入职新公司才发现，我又out了，大家都用whistle！另外由于百度不允许自己带电脑，新发的电脑里所有的环境都需要重新安装一下，charles下载了两个却都没破解</p>
<h3 id="1-Whistle安装方法"><a href="#1-Whistle安装方法" class="headerlink" title="1 Whistle安装方法"></a>1 Whistle安装方法</h3><h4 id="1-1-安装Node："><a href="#1-1-安装Node：" class="headerlink" title="1.1 安装Node："></a>1.1 安装Node：</h4><ol>
<li>Windows或Mac系统，访问<a href="https://nodejs.org/，安装LTS版本的Node，默认安装即可。" target="_blank" rel="noopener">https://nodejs.org/，安装LTS版本的Node，默认安装即可。</a></li>
<li>Linux下推荐使用源码安装: 从Node官网下载最新版的SourceCode(或者用wget命令下载)，解压文件(tar -xzvf node-vx.y.z.tar.gz)后进入解压后的根目录(node-vx.y.z)，依次执行./configure、./make和./make install。</li>
</ol>
<h4 id="1-2-安装Whistle"><a href="#1-2-安装Whistle" class="headerlink" title="1.2 安装Whistle:"></a>1.2 安装Whistle:</h4><p>&emsp;&emsp;Node安装成功后，执行如下npm命令安装whistle<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Mac或Linux的非root用户需要在命令行前面加sudo，如：sudo npm install -g whistle</span><br><span class="line">$ npm install -g whistle</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;npm默认镜像是在国外，有时候安装速度很慢或者出现安装不了的情况，如果无法安装或者安装很慢，可以使用taobao的镜像安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br><span class="line">$ cnpm install -g whistle</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;或者直接指定镜像安装：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install whistle -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;whistle安装完成后，执行命令 whistle help 或 w2 help，查看whistle的帮助信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ w2 help</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果能正常输出whistle的帮助信息，表示whistle已安装成功。</p>
<h4 id="3-启动Whistle"><a href="#3-启动Whistle" class="headerlink" title="3.启动Whistle"></a>3.启动Whistle</h4><p>&emsp;&emsp;启动whistle:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ w2 start</span><br><span class="line">// 如果要防止其他人访问配置页面，可以在启动时加上登录用户名和密码 -n yourusername -w yourpassword。</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;重启whsitle:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ w2 restart</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;停止whistle:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ w2 stop</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;调试模式启动whistle(主要用于查看whistle的异常及插件开发):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ w2 run</span><br></pre></td></tr></table></figure></p>
<h3 id="2-代理"><a href="#2-代理" class="headerlink" title="2 代理"></a>2 代理</h3><p>&emsp;&emsp;使用Chrome访问本地的8899端口，<a href="http://127.0.0.1:8899/，进入Whistle的主页！没啥可说的，就两点：1、可以自建rule保存以往的配置文件；2、点击https，下载认证证书" target="_blank" rel="noopener">http://127.0.0.1:8899/，进入Whistle的主页！没啥可说的，就两点：1、可以自建rule保存以往的配置文件；2、点击https，下载认证证书</a></p>
<p>&emsp;&emsp;重点：<a href="http://wproxy.org/whistle/rules" target="_blank" rel="noopener">http://wproxy.org/whistle/rules</a></p>
<ol>
<li><p>绑定转发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## disable,对某些域名不拦截</span><br><span class="line">## 一般放到 Default 分组</span><br><span class="line">/wx.qq.com/ disable://intercept</span><br><span class="line">## filter,在Network不会出现某些域名的请求</span><br><span class="line">/qq.com/ filter://hide</span><br><span class="line"></span><br><span class="line">## socks</span><br><span class="line">## 一般放到 Default 分组</span><br><span class="line">/facebook/ socks://127.0.0.1:1080</span><br><span class="line">/vk.com/ socks://127.0.0.1:1080</span><br><span class="line">/google/ socks://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">## 一般场景是调试内嵌APP页面，APP内有一个入口链接a，而调试的目标页面是b</span><br><span class="line">## 通过以下一行配置，页面a会自动换成页面b</span><br><span class="line">m.aliexpress.com/a.html m.aliexpress.com/b.html</span><br><span class="line"></span><br><span class="line">## 绑定</span><br><span class="line">## a.b.c.d 是某个环境的ip地址</span><br><span class="line">## 有时通过多个域名的方式来部署多套开发环境</span><br><span class="line">## 通过以下两行配置可以屏蔽开发环境域名与线上不一致的情况</span><br><span class="line">m.aliexpress.com mm.aliexpress.com</span><br><span class="line">mm.aliexpress.com a.b.c.d</span><br></pre></td></tr></table></figure>
</li>
<li><p>req</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## ua</span><br><span class="line">m.aliexpress.com ua://&#123;wp_ua&#125;</span><br><span class="line">#m.aliexpress.com ua://&#123;ali_ua&#125;</span><br><span class="line"></span><br><span class="line">## referrer</span><br><span class="line">m.aliexpress.com referer://https://vk.com/</span><br><span class="line">## referrer null</span><br><span class="line">#m.aliexpress.com referer://</span><br><span class="line"></span><br><span class="line">## reqHeaders，修改请求头</span><br><span class="line">## ua、referer协议都可以通过reqHeaders来完成</span><br><span class="line">m.aliexpress.com reqHeaders://&#123;req-headers&#125;</span><br><span class="line"></span><br><span class="line">## values</span><br><span class="line">&#123;wp_ua&#125;</span><br><span class="line">Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; RM-1113) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/13.10586</span><br><span class="line"></span><br><span class="line">&#123;req-headers&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;X-Forwarded-For&quot;:&quot; 188.146.171.71&quot;,</span><br><span class="line">&quot;X-Real-IP&quot;:&quot; 188.146.171.71&quot;,</span><br><span class="line">&quot;X-Client-Scheme&quot;:&quot;https&quot;,</span><br><span class="line">&quot;referer&quot;:&quot;https://vk.com/&quot;,</span><br><span class="line">&quot;User-Agent&quot;:&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 AliApp(H/5)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>res</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## file，本地调试是其典型的使用场景</span><br><span class="line">m.aliexpress.com/sw.js file:///path/to/your/local/sw.js</span><br><span class="line">## xfile</span><br><span class="line">#m.aliexpress.com/sw.js xfile:///path/to/your/local/sw.js</span><br><span class="line"></span><br><span class="line">## tpl，常用于mock jsonp请求</span><br><span class="line">aliexpress.com/query.jsonp tpl://&#123;res-jsonp&#125;</span><br><span class="line">## xtpl，同tpl，本地不存在时走线上</span><br><span class="line">aliexpress.com/query.jsonp xtpl://&#123;res-jsonp&#125;</span><br><span class="line"></span><br><span class="line">## resHeaders，修改响应头</span><br><span class="line">ae01.alicdn.com resHeaders://&#123;res-cors&#125;</span><br><span class="line"></span><br><span class="line">## html，往html文档(&lt;/body&gt;之前)追加html标签(script,style or normal html tag)</span><br><span class="line">m.aliexpress.com html://&#123;html-test&#125;</span><br><span class="line"></span><br><span class="line">## js，往js响应追加脚本，如果响应是html文档，则自动用`&lt;script&gt;&lt;/script&gt;`包装后插入</span><br><span class="line">m.aliexpress.com/sw.js js://&#123;js-test&#125;</span><br><span class="line"></span><br><span class="line">## css，往css响应追加样式，如果响应是html文档，则自动用`&lt;style&gt;&lt;/style&gt;`包装后插入</span><br><span class="line">## `/`可以起到仅对首页追加的效果</span><br><span class="line">m.aliexpress.com/ css://&#123;css-test&#125;</span><br><span class="line"></span><br><span class="line">## resReplace，替换响应的某些字符串</span><br><span class="line">## 一般可用来快速验证某些功能</span><br><span class="line">m.aliexpress.com resReplace://&#123;res-replace&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## values</span><br><span class="line">&#123;res-jsonp&#125;: whistle会用请求对应的callback值来替换&#123;callback&#125;</span><br><span class="line">&#123;callback&#125;(&#123;</span><br><span class="line">&quot;ec&quot;: 0,</span><br><span class="line">&quot;list&quot;:[&#123;</span><br><span class="line">&quot;id&quot;:1,</span><br><span class="line">&quot;price&quot;:&quot;US $100&quot;,</span><br><span class="line">&quot;stock&quot;:&quot;100&quot;,</span><br><span class="line">&quot;imgUrl&quot;:&quot;https://ae01.alicdn.com/kf/HTB12x0CLpXXXXajaXXX760XFXXXS.png_640x640.png&quot;</span><br><span class="line">&#125;,...</span><br><span class="line">]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#123;html-test&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">// make an error</span><br><span class="line">x.x;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&#123;js-test&#125;</span><br><span class="line">fetch(&quot;/&quot;).then(res=&gt;&#123;console.log(&quot;fetched!&quot;)&#125;);</span><br><span class="line"></span><br><span class="line">&#123;css-test&#125;</span><br><span class="line">body&#123;</span><br><span class="line">font-size:15px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;res-cors&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;access-control-allow-origin&quot;:&quot;*&quot;,</span><br><span class="line">&quot;access-control-expose-headers&quot;:&quot;Via&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;res-replace&#125;</span><br><span class="line">&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;: &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=436672029&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>debugging</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m.aliexpress.com weinre://debug</span><br><span class="line">m.aliexpress.com log://&#123;log-test&#125;</span><br><span class="line"></span><br><span class="line">## values</span><br><span class="line">&#123;log-test&#125;</span><br><span class="line">console.log(&quot;Yeah!&quot;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://github.com/avwo/whistle#whistle" target="_blank" rel="noopener">https://github.com/avwo/whistle#whistle</a><br><a href="https://avwo.github.io/whistle/install.html" target="_blank" rel="noopener">https://avwo.github.io/whistle/install.html</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>人性的弱点</title>
    <url>/2017/02/23/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9/</url>
    <content><![CDATA[<ul>
<li>人类自然的天性，是做错事只会责备别人，而绝不会责备自己</li>
<li>不要评议人，免得为人所评议</li>
<li>不要批评他们，我们在相同的情形下，也会像他们一样。</li>
<li>尖锐的批评、斥责，、永远不会有效果的。</li>
<li>成功的秘诀，是：「我不说任何人的不好！」他又这样说：「而说我所知道的每一个人的好处！」</li>
<li>不要批评，责怪或抱怨。任何一个愚蠢的人，都会批评人，斥责人，和抱怨人同时，也是绝大部份愚蠢的人才这样做的</li>
<li>我能叫你去做任何事情的唯一方法，那就是把你所需要的给你</li>
<li>人类天性中最深切的冲动，那是「成为重要人物的欲望”</li>
<li>人类天性至深的本质，就是渴求为人所重视。</li>
<li>每个人都喜欢受人恭维。</li>
<li>世界上最容易摧毁一个人志向的，那就是上司所给他的批评。我从来不批评任何人，我只给人们工作的激励。我是急于称赞，而迟于寻错，如果说我喜欢什么的话，那就是诚于嘉许，宽于称道。」</li>
<li>赞赏是出于真诚，而谄媚是虚伪的。</li>
<li>别怕攻击你的敌人，提防谄媚你的朋友</li>
<li>谄媚是明白的告诉别人，他想到他自己的种种</li>
<li>献出你真实，诚恳的赞赏</li>
<li>想想别人的优点；我们就不必措辞卑贱、虚伪，在话</li>
<li>世界上唯一能影响对方的方法，就是谈论他所要的，而且还告诉他，如何才能得到它.</li>
<li>从你来到世界上这一天开始，你所有的每一种举动，出发点都是为了你自己，都是因为你需要些什么</li>
<li>如果有一个成功秘诀的话，那就是如何得到对方立场” 的能力，由他的观点设想，正同由你的观点一样。</li>
<li>很多人，费去一生的光阴在销售工作，却不站在买主的立场论事。他并没有注意到如何帮助我，他祇是注意帮助他自己</li>
<li>你会永远站在别人立场去打算、设想，并由对方的观点，去观察事物的趋向</li>
<li>先激起对方某种迫切的需要，若能做到这点就可左右逢源，否则到处碰壁</li>
<li>表现自己，那是人性最主要的需要。</li>
<li>一种深入、前驱的学习欲望，一个增加你应付他人能力的强烈决心</li>
<li>每周反省比我所尝试的其它任何方法，都更为有益。</li>
<li>如果你时刻关心别人，对别人发生兴趣，在两个月的时间里所交的朋友，要比只想让别人关心你，对你发生兴趣，在两年的时间里所交的朋友还多</li>
<li>如果我们只是想使人注意，使人对我们发生兴趣，我们、水远不会有很多真诚的朋友……朋友，真正的朋友，不是那样造成的</li>
<li>假如我们想交朋友，应该先出来替别人做些事——需要时间、精力、公义、体恤的事</li>
<li>到了有人生日那一天，我就发给他一封贺函，或是贺电。当那人接到贺函，或是贺电时，他是多幺高兴……：．除了他的亲人以外，我是世界上唯一知道他生日的一个朋友。</li>
<li>我真实的对他，就他的问题发生了兴趣，关心他和他切身的问题</li>
<li>微笑是从内心发出的</li>
<li>若干人，开始一桩事业的时候，怀着极大的希望和兴趣，所以能在早期获得部份的成就。当他们对这项工作，感到厌烦、沉闷，失去了原有的兴趣时，他的事业也渐渐走向下坡，终至失败。</li>
<li>如果你希望别人用一副高兴、欢愉的神情来接待你，那么你自己先要用这样的神情去对别人。</li>
<li>改掉原有对人的批评，把斥责人家的话，换成赞赏和鼓励。</li>
<li>快乐是出自自己内在的心情，不需要向外界寻求的</li>
<li>微笑是、永远受人所欢迎的</li>
<li>保持一种正确的心理状态——勇敢、诚实，和乐观</li>
<li>如果你希望人们都喜欢你，第一、强迫你自己微笑，如果你单独一人的时候，吹吹口哨，唱唱歌，尽量让自己高兴起来；第二项规则是：微笑！</li>
<li>人们如果脸上没有带着笑容，千万别开店</li>
<li>一般人对自己的姓名，比杷世界上所有的姓名堆在一起的总数，还感到重要，和关心。把一个人的姓名记住，很自然的叫出口来，你已对他含有微妙的恭维、赞赏的意味</li>
<li>人们都重视自己的名字，尽量设法让自己的名字留传下去，甚至愿意付出任何的代价</li>
<li>一种最简单、最明显、而又是最重要的如何获得好感的方法，就是记住对方的姓名，使别人感到自己很重要</li>
<li>把一个恼怒的人，变成了一个满意的顾客。他是如何做的？他把这情形分成三个步骤：第一，他让我从头到尾，说出我的经过，他则静静听着，没有插进一句话来。第二，当我讲完那些话后，那两个店员又要开始与我争辩了。可是那负责人，却站在我的观点跟他们辩论；第三，他承认不知道这套衣服，会这样的差劲，而是坦直的对我锐：「你认为我该如何处理这套衣服，你尽管吩咐，我完全可以依照你的意思。』</li>
<li>最爱挑剔的人，最激烈的批评者，往往会在一个怀有忍耐、同情的静听者面前软化下来！这位静听者，必须要有过人的沉着，他必须当着寻衅者像一条大毒蛇张开嘴巴的时候– 静听</li>
<li>如果你要成为一个谈笑风生，受人欢迎的人，你需要静听别人的谈话。就像李夫人所说的：「要使别人对你感到兴趣，先要对别人感到兴趣。」问别人所喜欢回答的问题，鼓励他谈谈他自己，和他的成就。</li>
<li>做一个善于静听的人，鼓励别人多谈谈他们自己。</li>
<li>深入人们心底的最佳途径，就是对那人讲他知道得最多的事物</li>
<li>就别人的兴趣谈论。永远使别人感觉重要.</li>
<li>你希望别人怎样待你，你就该怎样去对待别人。</li>
<li>如何做?何时做？在什么地方做？这个答案是：「所有的时间，任何地点。」</li>
<li>平时客气的话，像「对不起，麻烦你，请你，你会介意吗．．谢谢你！」这些简短的话，可以减少人与人之间的纠纷，同时也自然地表现出高贵的人格来。</li>
<li>凡我所遇到的人，都有比我优越的地方，而在那些方面，我能向他学习。</li>
<li>有一条最明显的真理，就是你所遇到的任何人，几乎每个人，都觉得自己某方面比你优秀。可是有一个方法，可以深入他的心底——就是让他觉得你承认他在自己的小天地里，是高贵重要的，要真诚的承认</li>
<li>你只要对女人谈论她自己就行了。</li>
<li>使别人感觉到他的重要——必需真诚的这样做。</li>
</ul>
<hr>
<ul>
<li>第一项规则：真诚的对别人发生兴趣。</li>
<li>第二项规则：微笑。</li>
<li>第三项规则：记住你所接触中，每一个人的姓名。</li>
<li>第四项规则：做一个善于静听的人，鼓励别人多谈谈他们自己。</li>
<li>第五项规则：就别人的兴趣谈论。</li>
<li>第六项规则：使别人感觉到他的重要——必需真诚的这样做。</li>
</ul>
<hr>
<ul>
<li>你不可能在争辩中获胜</li>
<li>永远避免正面的冲突，那才是对的</li>
<li>天下只有一种方法，能得到辩论的最大胜利，那就是尽量避免辩论………避免辩论，就像避开毒蛇和地震一样。</li>
<li>你必需要知道，当人们逆着自己的意见，被人家说服时，他仍然会固执的坚持自己是对的。</li>
<li>一个真正成功的推销员，他决不会跟顾客争辩，即使轻微的争辩，也加以避免………人类的思想，不是那么容易改变的</li>
<li>如果你辩论、反驳，或许你会得到胜利，可是那胜利是短暂、空虚的………你永远得不到，对方给你的好感</li>
<li>我们要让顾客、爱人、丈夫、或者是妻子，在细小的争论上，胜过我们。</li>
<li>一个成大事的人，不能处处计较别人，消耗自己的时闲去和人家争论。无谓的争论，对自己性情上不但有所损害，且会失去自己的自制力。在尽可能的情形下，不妨对人谦让一点。与其跟一只狗子路走，不如让狗先走一步。如果给狗咬了一口，你即使把这只狗打死，也不能治好你的伤口。</li>
<li>在辩论中，获得最大利益的唯一方法，就是避免辩论。</li>
<li>你可以用神态、声调，或是手势，告诉一个人他错了，就像我们用话一样的有效……而如果你告诉他错了，你以为他会感激你？不，永远不会！因为你伤了他的自尊。</li>
<li>如果你要纠正某人的错误，就不应该直率的告诉他；而要运用一种非常巧妙的方法，才不会把对方得罪了。</li>
<li>普天下的人，决不会责怪你说这样的话：「或许是不对的，让我们看看，究竟是怎么一回事！」</li>
<li>我们有时发现自己会在毫无抵抗和阻力中，改变自己的意念。可是，如果有人告诉我们所犯的错误，我们却会感到懊恼和怀恨。我们不会去注意一种意念养成，可是当有人要抹去我们那股意念时，我们对这份意念突然坚实而固执起来。并非是我们对那份意念有强烈的偏爱，而是我们自尊受到了损伤。</li>
<li>如果有人硬把不合胃口的事实，往我们的喉咙塞下去，我们是无法接受下来的。</li>
<li>换句话说，别跟你的顾客、丈夫，或是敌手争辩，别指摘他错了，别激怒他，而不妨用点外交手腕。</li>
<li>别跟你的顾客、丈夫，或是敌手争辩，别指摘他错了，别激怒他，而不妨用点外交手腕。</li>
<li>尊重别人的意见，永速别指摘对方是错的。</li>
<li>假如我们已知道一定要受到责罚，那我们何不先责备自己，找出自己的缺点，那是不是比从别人嘴说出的批评，要好受得多</li>
<li>当我们错误的时候，我们要快速的、坦直的承认我们的错误。运用这种方法，不但能获得惊人的效果，而且在若干情形下，比替自己辩护更为有趣</li>
<li>用争夺的方法，你永远无法得到满足。可是当你谦让的时候，你可以得到比你所期望的更多</li>
<li>如果你错了，迅速、郑重的承认下来。</li>
<li>如果你握紧了两个拳头来找我，我可以告诉你，我的拳头会握得更紧。</li>
<li>友善的对他，赞许他、夸奖他，相信这办法，一定非常有效</li>
<li>温柔、友善的力量，永远胜过愤怒和暴力。</li>
<li>慈爱、友善的接近，能使人改变了他原有的心意，那比暴力的攻击更为有效</li>
<li>以友善的方法开始。</li>
<li>跟人们谈话时，别开始就谈你们意见相左的事，不妨谈些彼此间赞同的事情。如果可能的话，你更应该提出你的见解，告诉对方，你们所追求的是同一个目标，所差异的祇是方法而已。</li>
<li>有说话技巧的人，开始的时候就能得到很多「是」的反应，唯有如此，他才能将听者的心埋，导向正面方向。</li>
<li>争辩并不是一个聪明的办法。要从对方的观点去看事，设法让别人回答『是，是』，那才是一套成功的办法</li>
<li>处理一个抱怨者的安全手法，必需要忍耐的怀着舒畅的心情，静静的听着，而且用最诚恳的态度鼓励他，让他把所要说的话，完全说完。</li>
<li>如果你想得到仇人，你就胜过你的朋友，可是，如果想获得更多的朋友，就让你的朋友胜过你</li>
<li>你要获得对方对你的同意，第六项规则是：尽量让对方有多说话的机会</li>
<li>生命是短促的，别把我们不值一提的成就，作为谈话的资料，令人听了厌烦。我们要鼓励别人多说话。仔细想一想，你实在没有什么可以夸耀的。</li>
<li>你对你自己所发现的意念，是不是比别人代你说出的更信得过？如果是的话，你把你的意见，硬生生塞下别人喉咙里，这是不是错误的观念？如果提出意见，启发别人自己去得到他的结论，这不是一个更聪明的辨法吗？</li>
<li>没有人喜欢强迫自己去买一样东西，或是被人派遣去做一件事。我们都喜欢随自已的心愿买东西，或是照着自己的意思去做事情。同时，希望有人跟我们谈谈我们的愿望、需要、想法</li>
<li>凡是都很费事的去征求别人的意见，且对他们的建议表示尊重</li>
<li>你要影响别人而使人同意于你，第七项规则是：使对方以为这是他的意念。</li>
<li>当对方并不承认有错误时，试着去了解对方，去原谅对方。</li>
<li>多学些待人的技巧，学学各种与人相处的手腕，常从别人的观点去看事物</li>
<li>当我们希望别人完成一件事的时候，不妨闭上眼睛，稍微想一想……把整个的情形，由对方的出发点来想一想！然后问自己：「他为什么要如此做？</li>
<li>当你接触到每一件事时，会处处替别人着想。而且以对方的观点，去观察这件事情</li>
<li>要真诚的以他人的观点去看事情。</li>
<li>对你所感觉到的情形，我一点也不会责怪你，如果我是你的话，我也有同样的感觉。</li>
<li>你明天遇到的人，其中可能有四分之三都饥渴似的需要同情…．！如果你同情他们，他们就会喜欢你。</li>
<li>同情是消解恶感最有效的药物</li>
<li>人类普遍的追求同情，孩子们会急切的显示他受伤的地方。有的甚至于故意自己割伤、弄伤，以博得大人们的同情</li>
<li>你要获得别人对你的同意，第九项规则是：同情对方的意念和欲望。</li>
<li>要改变一个人的意志，需要激发他高尚的动机</li>
<li>你要当那位顾客是恳切、诚实、可靠的，且他是极愿意付帐的。一旦使他相信那帐目是对的，他会毫不迟疑的乐意债还。也就是说，人们都是诚实的，而且愿意履行他们该有的义务。</li>
<li>实行、推进，别停顿下来</li>
<li>如果我们想要完成一件事，必须鼓励竞争，那并不是说争着去赚钱，而是要有一种胜过别人的欲望</li>
<li>争胜的欲望加上挑战的心理，对一个有血气的人来说，是一种最有效的激励。</li>
<li>任何一个成功的人，都喜爱的竞技．！因为那是个表现他自己的机会，证明他的能力、价值胜过别人。</li>
</ul>
<hr>
<ul>
<li>第一项规则：在辩论中，获得最大利益的唯一方法，就是避免辩论。</li>
<li>第二项规则：尊重别人的意见，永远别指摘对方是错的。</li>
<li>第三项规则：如果你错了，迅速、郑重的承认下来。</li>
<li>第四项规则：以友善的方法开始。</li>
<li>第五项规则：使对方很快的回答「是！是！」。</li>
<li>第六项规则：尽量让对方，有多说话的机会。</li>
<li>第七顼规则：使对方以为这是他的意念。</li>
<li>第八项规则：要真诚的以他人的观点去看事情。</li>
<li>第九项规则：同情对方的意念和欲望。</li>
<li>第十项规则：激发更高尚的动机。</li>
<li>第十一项规则：使你的意念戏剧化。</li>
<li>第十二项规则：提出一个挑战。</li>
</ul>
<hr>
<ul>
<li>当我们听到别人对我们的称赞后，如果再听到其它不愉快的话，就比较容易接受了。</li>
<li>不使对方难堪、反感，而改变一个人的意志，第一项规则是：用称赞和真诚的欣赏作开始。</li>
<li>我们要劝阻一件事，永远躲开正面的批评这是必需要记住的。如果有这个必要的话，我们不妨旁敲侧击的去暗示对方。对人正面的批评，那会毁损了他的自重，剥夺了他的自尊。如果你旁敲侧击，对方知道你用心良善，他不但接受，而且还会感激你。</li>
<li>所以要改变人们的意志，而不引起对方的反感，第二项规则是：间接的指出人们的过错。</li>
<li>如果批评的人，开始先谦冲的承认自己也不是十全十美的、无可指责的，然后再指出人们的错误，这样就比较容易让人接受了。</li>
<li>在批评对方之前，不妨先谈谈你自己的错误。</li>
<li>措辞，始终是建议，而不是命令</li>
<li>发问时，别用直接的命令。</li>
<li>顾全到一个人的面子，那是多么重要</li>
<li>即使只有稍微的进步，我们也要称赞，这样可以鼓励别人继续进步。</li>
<li>我们具有各种潜在的能力，可是却惯于不会利用</li>
<li>称赞最细微的进步，而且称赞每一个进步。</li>
<li>一般人，都会愿意接受指导，如果你得到他的敬重，并且对他的某种能力表示敬重的话。</li>
<li>如果你想改善一个人某方面的缺点，你要表示出，他已经具有这方面的优点了</li>
<li>给人一个美名让他去保全，每一个人都愿意竭尽其所能，保持别人赠予他的美誉。</li>
<li>多给人们一些鼓励，把事情看成很容易。使对方知道，你对他有信心，他有尚未发展出的才干，那他就会付出最大的努力，争取到这个胜利。</li>
<li>用鼓励，使你要改正的错误，看来很容易做到；使你要对方所做的事，好象很容易做到。</li>
<li>永远使人们乐意去做你所建议的事。</li>
</ul>
<hr>
<ul>
<li>第一项规则：用称赞和真诚的欣赏作开始。</li>
<li>第二项规则：间接的指出人们的错误。</li>
<li>第三项规则：在批评对方之前，不妨先谈谈你自己的过错。</li>
<li>第四项规则：发问时，别用直接的命令。</li>
<li>第五项规则：顾全对方的面子。</li>
<li>第六项规则：称赞最细微的进步，而且称赞每一个进步。</li>
<li>第七项规则：给人们一个美名让他去保全。</li>
<li>第八项规则：用鼓励，使你要改正的错误，看来很易做到；使你要对方所做的事，好象很易做到。</li>
<li>第九项规则：使人们乐意去做你所建议的事。</li>
</ul>
<hr>
<ul>
<li>使对方有一种自重、高贵的感觉</li>
<li>我们需要尽量鼓起对方的自尊心，但不是运用谄媚，或是虚伪，如果引误了这个出发点，是绝不会有效果的。</li>
<li>必需记住：我们每一个人，都是希望如何被人欣赏、如何被人重视……甚至会不顾一切的去达到这个目的。可是，没有人会接受不诚恳的、虚伪的奉承。</li>
<li><p>我愿意再说一遍：这书中所告诉你的原则，必需出自由衷才会有效果出现。我不希望人们用奸诡的骗术，去欺骗人家;而我所讲的，只是一种新的生活方式。</p>
</li>
<li><p>男人离开家庭的一个主要原因，那是因为他们的妻子又吵又闹，喋喋不休</p>
</li>
<li>从来不批评她，他在她面前，从不说出一句责备的话…！如果有人嘲笑她时，他立即为她强烈的辩护。</li>
<li>跟人们交住，第一件应学的事，那是不干涉人们自己原有那种特殊快乐的方法</li>
<li>婚姻的成功，那不祗是寻找一个适当的人，而是自已该如何做一个适当的人</li>
<li>别尝试改造你的伴侣</li>
<li>不要批评。</li>
<li>给予真诚的欣赏。</li>
<li>自古到现在，鲜花是代表爱情的语言</li>
<li>对你所敬爱的人，表示你常想念着她，你希望她愉快。而她的欢愉、快乐，也会使你有同样的感受。</li>
<li>这条路，我只能经过一次，所以，凡我所能为人做的任何好事，任何一点仁慈，让我现在就做吧！不要迟延，不要忽略，因为我将不会再从这里经过了。</li>
<li>礼貌是内心的一种特质，它可以教人忽略破旧的园门，而专心注意到园内的好花</li>
<li>礼貌在我们婚后的生活中，就像汽车离不开汽油一样。</li>
</ul>
<hr>
<ul>
<li>第一项规则：切莫喋喋不休。</li>
<li>第二项规则：别尝试改造你的伴侣。</li>
<li>第三项规则：不要任意的批评。</li>
<li>第四项规则：给予真诚的欣赏。</li>
<li>第五项规则：随时注意琐碎、细微的小地方。</li>
<li>第六项规则：要有礼貌。</li>
<li>第七项规则：阅读一本有关婚姻中性生活方面的好书。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>关于NSArray的几个问题</title>
    <url>/2015/08/29/%E5%85%B3%E4%BA%8ENSArray%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="数组里可放不同类型，不能放nil，特别注意插入、删除和查找时的越界问题"><a href="#数组里可放不同类型，不能放nil，特别注意插入、删除和查找时的越界问题" class="headerlink" title="数组里可放不同类型，不能放nil，特别注意插入、删除和查找时的越界问题"></a>数组里可放不同类型，不能放nil，特别注意插入、删除和查找时的越界问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray &lt;NSString *&gt; *array = @[@&quot;one&quot;，@&quot;two&quot;];</span><br><span class="line">// 此nil为结束标识符不计入数组内</span><br><span class="line">NSArray *arr = [NSArray arrayWithObjects:@1,@&quot;2&quot;, nil];</span><br></pre></td></tr></table></figure>
<h4 id="数组是否有值校验"><a href="#数组是否有值校验" class="headerlink" title="数组是否有值校验"></a>数组是否有值校验</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define ISARRAYHASVALUE(array)    (array &amp;&amp; [array isKindOfClass:[NSArray class]] &amp;&amp; [array count] &gt; 0)</span><br></pre></td></tr></table></figure>
<h4 id="indexOfObject-与-indexOfObjectIdenticalTo"><a href="#indexOfObject-与-indexOfObjectIdenticalTo" class="headerlink" title="indexOfObject 与 indexOfObjectIdenticalTo"></a>indexOfObject 与 indexOfObjectIdenticalTo</h4><p>答：indexOfObjectIdenticalTo比较内存地址是否相同，indexOfObject比较isEqual方法。<a href="https://stackoverflow.com/questions/3167849/indexofobject-vs-indexofobjectidenticalto" target="_blank" rel="noopener">参考</a></p>
<h4 id="怎么快速剔除数组中相同元素"><a href="#怎么快速剔除数组中相同元素" class="headerlink" title="怎么快速剔除数组中相同元素"></a>怎么快速剔除数组中相同元素</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *arr = @[@1,@1,@2,@2,@3,@4,@4];</span><br><span class="line">NSSet *set = [NSSet setWithArray:arr];</span><br><span class="line">NSLog(@&quot;%@&quot;,[set allObjects]);</span><br></pre></td></tr></table></figure>
<h4 id="快速过滤"><a href="#快速过滤" class="headerlink" title="快速过滤"></a>快速过滤</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *filteredArray = @[@2, @4, @6];</span><br><span class="line">NSArray *dataArray = @[@1,@2,@3,@4,@5,@6,@7];</span><br><span class="line">NSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@&quot;NOT (SELF IN %@)&quot;,filteredArray];</span><br><span class="line">NSLog(@&quot;过滤后：%@&quot;,[dataArray filteredArrayUsingPredicate:filterPredicate]);</span><br></pre></td></tr></table></figure>
<h4 id="for、for-in-还是-enumerateObjectsUsingBlock"><a href="#for、for-in-还是-enumerateObjectsUsingBlock" class="headerlink" title="for、for in 还是 enumerateObjectsUsingBlock"></a>for、for in 还是 enumerateObjectsUsingBlock</h4><p>答：</p>
<ol>
<li>for、 for in 差别不大，线程不安全。随便用</li>
<li>enumerateObjectsUsingBlock是线程安全的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *muArr = @[@0, @1, @2, @3, @4].mutableCopy;</span><br><span class="line">[muArr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;\</span><br><span class="line">if ([obj integerValue] == 2) &#123;</span><br><span class="line">// break; 不能用，如果想要同样效果用*stop = YES;</span><br><span class="line">// *stop = YES;</span><br><span class="line"></span><br><span class="line">// continue不能用，如果想要同样效果用return；</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;obj : %@ ,idx : %lu&quot;, obj, (unsigned long)idx);</span><br><span class="line">&#125;];</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *array = @[@1,@2,@3,@1,@2,@5,@4];</span><br><span class="line">NSArray *sortArr = [array sortedArrayWithOptions:NSSortStable usingComparator:</span><br><span class="line">^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</span><br><span class="line">int value1 = [obj1 intValue];</span><br><span class="line">int value2 = [obj2 intValue];</span><br><span class="line">if (value1 &gt; value2) &#123;</span><br><span class="line">return NSOrderedDescending;</span><br><span class="line">&#125;else if (value1 == value2)&#123;</span><br><span class="line">return NSOrderedSame;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return NSOrderedAscending;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="可变数组不能add和remove，但可以replace"><a href="#可变数组不能add和remove，但可以replace" class="headerlink" title="可变数组不能add和remove，但可以replace"></a>可变数组不能add和remove，但可以replace</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray *muArr = @[@1, @2, @3].mutableCopy;</span><br><span class="line">for (id elem in muArr) &#123;</span><br><span class="line">[muArr removeObject:elem];</span><br><span class="line">&#125;</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSGenericException&apos;, reason: &apos;*** Collection &lt;__NSArrayM: 0x600002052310&gt; was mutated while being enumerated.&apos;</span><br></pre></td></tr></table></figure>
<h4 id="快速取得最小值"><a href="#快速取得最小值" class="headerlink" title="快速取得最小值"></a>快速取得最小值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableArray* array = [NSMutableArray array];</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">CGFloat num = arc4random() % 100 + 1; </span><br><span class="line">[array addObject:[NSNumber numberWithFloat:num]];</span><br><span class="line">&#125;</span><br><span class="line">CGFloat maxValue = [[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];</span><br><span class="line">CGFloat minValue = [[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];</span><br><span class="line"></span><br><span class="line">/*min、max是NSArray的私有属性，通过.语法是拿不到的，会报错的。类似这种私有属性还有@”@avg.floatValue” (获取平均值)，@”@count.floatValue”(获取数组大小) @&quot;@sum.floatValue&quot;（求和）*/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数字的几个问题</title>
    <url>/2015/06/05/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h5 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h5><p>答: 基础数字类型的封装，继承自NSObject，引用类型。语法糖 @(123)</p>
<h5 id="32位系统上使用assign修饰NSNumber会Crash"><a href="#32位系统上使用assign修饰NSNumber会Crash" class="headerlink" title="32位系统上使用assign修饰NSNumber会Crash"></a>32位系统上使用assign修饰NSNumber会Crash</h5><p>原因：NSNumber在32bit设备之上0-12都是存在内存共享区，无论调用多少次指针指向的都是相同的一块内存区域，永远不会被销毁。而只要大于12就是正常的创建在堆上的对象。在64-bit机器上无论NSInterger保存的这个数有多大，只要在正常范围之内，一定是存放在常量区的，也就是永远不会释放。因此需要用retain或strong</p>
<h5 id="NSInteger是不是引用类型"><a href="#NSInteger是不是引用类型" class="headerlink" title="NSInteger是不是引用类型"></a>NSInteger是不是引用类型</h5><p>答：别看是以NS开头就以为是对象了！NSInteger不是引用类型，int同C的int，NSInteger是对int的封装，推荐使用，根据操作系统位数返回最大值。uint与NSUInteger同上。</p>
<h5 id="NSTimeInterval"><a href="#NSTimeInterval" class="headerlink" title="NSTimeInterval"></a>NSTimeInterval</h5><p>答: typedef double NSTimeInterval; 为什么专门typedef 一下? 最主要是方便用户使用,见名知义,一看就知道专门给time使用的</p>
<h5 id="CGFloat怎么这么奇怪？"><a href="#CGFloat怎么这么奇怪？" class="headerlink" title="CGFloat怎么这么奇怪？"></a>CGFloat怎么这么奇怪？</h5><p>答：- float同C的float，double同C的double，CGFloat在32位上是float，64位上是double，没查到为什么是CG开头？</p>
<h5 id="Bool的问题"><a href="#Bool的问题" class="headerlink" title="Bool的问题"></a>Bool的问题</h5><p>答:记住是YES或NO,不是true和false;0为NO,其它为flase;nil为NO,非nil为YES;</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>关于NSDictionary的几个问题</title>
    <url>/2015/06/21/%E5%85%B3%E4%BA%8ENSDictionary%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary &lt;NSString *, NSNumber *&gt; *dict = @&#123;@&quot;one&quot;:@1&#125;;</span><br><span class="line">dict.allKeys;   dict.allValues; // 顺序都是随机的</span><br></pre></td></tr></table></figure>
<h5 id="NSDictionary的key必须是字符串吗？"><a href="#NSDictionary的key必须是字符串吗？" class="headerlink" title="NSDictionary的key必须是字符串吗？"></a>NSDictionary的key必须是字符串吗？</h5><p>答：只要遵守NSCoding协议就行，也可以不是NSString<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary *dic = @&#123;@1 : @&quot;one&quot;&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,dic[@1]); // one</span><br></pre></td></tr></table></figure></p>
<h5 id="NSMutableDictionary的-setObject-forKey-与-setValue：-forKey-有啥区别？"><a href="#NSMutableDictionary的-setObject-forKey-与-setValue：-forKey-有啥区别？" class="headerlink" title="NSMutableDictionary的 setObject: forKey: 与 setValue： forKey: 有啥区别？"></a>NSMutableDictionary的 setObject: forKey: 与 setValue： forKey: 有啥区别？</h5><p>答：</p>
<ol>
<li>setObject: forKey: 的object不能为nil，否则会crash</li>
<li>setValue: forKey: 的value可以为nil，若nil则remove对应的key；此外，setValue: forKey: 是KVC方法，故key 必须是字符串<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSMutableDictionary *muDic = [[NSMutableDictionary alloc] init];</span><br><span class="line">//    [muDic setObject:nil forKey:@1]; crash</span><br><span class="line">[muDic setValue:nil forKey:@&quot;2&quot;];</span><br><span class="line">//    [muDic setValue:@&quot;第三个&quot; forKey:@3]; 黄牌警告</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="NSDictionary的-objectForKey-与-valueForKey-有啥区别？"><a href="#NSDictionary的-objectForKey-与-valueForKey-有啥区别？" class="headerlink" title="NSDictionary的 objectForKey: 与 valueForKey: 有啥区别？"></a>NSDictionary的 objectForKey: 与 valueForKey: 有啥区别？</h5><p>答：</p>
<ol>
<li>objectForKey: 根据key取值，否则返回nil</li>
<li>valueForKey: 根据key取值，key必须是字符串，且如果key以@开头会crash<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSDictionary *dic = @&#123;@&quot;1&quot;:@&quot;one&quot;, @&quot;@2&quot;:@&quot;two&quot;&#125;;</span><br><span class="line">NSLog(@&quot;%@&quot;,[dic objectForKey:@&quot;1&quot;]);</span><br><span class="line">NSLog(@&quot;%@&quot;,[dic objectForKey:@&quot;@2&quot;]);</span><br><span class="line">NSLog(@&quot;%@&quot;,[dic valueForKey:@&quot;1&quot;]);</span><br><span class="line">//    NSLog(@&quot;%@&quot;,[dic valueForKey:@&quot;@2&quot;]); crash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="http://www.isaced.com/post-235.html" target="_blank" rel="noopener">NSMapTable: 不只是一个能放weak指针的 NSDictionary</a></li>
<li><a href="http://www.cocoachina.com/industry/20140605/8683.html" target="_blank" rel="noopener">NSHashtable and NSMaptable</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>再读编写高质量iOS的52个方法</title>
    <url>/2015/12/29/%E5%86%8D%E8%AF%BB%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E7%9A%8452%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li>OC 的起源</li>
</ol>
<ol start="2">
<li>在头文件中尽量少引入其他头文件</li>
</ol>
<ul>
<li>使用@class 将引入头文件的时机尽量延后，同时用于两个文件相互引用的问题。</li>
<li>用#import 不用#include</li>
<li>必要的时候用一个 .h 文件来整理用到的引用</li>
</ul>
<ol start="3">
<li>可以用语法糖</li>
</ol>
<ul>
<li>要注意nil的情况，语法糖创建的都是不可变对象</li>
</ul>
<ol start="4">
<li>多用类型常量，少用#define预处理指令</li>
</ol>
<ul>
<li>少用#define 用类似 static const CGFloat time = 0.3 ，如需要则在 .h 中使用extern CGFloat const time 声明为外部可用的</li>
<li>常量在 .m 文件内用k开头，不过现在好像所有的都是k开头</li>
<li>变量一定要同时用static和const来声明，const表示不能修改，static则表示该变量仅在定义此变量的编- - 译单元中可见，不加static在编译器会自动加external 外部符号，若此时在另外声明同名变量，则报错</li>
</ul>
<ol start="5">
<li>用枚举表示状态选项状态码-fobjc-arc</li>
</ol>
<ul>
<li>尽量不用enum 用NS_ENUM ，</li>
<li>凡是以按位或操作的组合枚举都应使用NS_OPTIONS定义，枚举量对应的值可以用 1&lt;&lt;0 方便各选项通过“按位或”操作来组合。不需要互相组合则用NS_ENUM</li>
<li>使用switch来区分枚举的时候，最好不要加上default语句，这样当新加一种枚举类型时，编译器会报错</li>
</ul>
<ol start="6">
<li>理解属性这一概念</li>
</ol>
<ul>
<li>@dynamic 阻止编译器自动合成getter和setter方法，但如果自己也不实现，编译器是不会报错的</li>
<li>nonatomic   readwrite   readonly   assign   strong   weak  copy  unsafe_unretained  getter  setter</li>
<li>iOS中使用同步锁开销很大，开发Mac OS X程序时使用同步锁却没事</li>
</ul>
<ol start="7">
<li>在对象内部尽量直接访问实例变量</li>
</ol>
<ul>
<li>直接用下划线访问属性，不会触发KVO，不经过getter和setter方法</li>
<li>在getter和setter方法中不要出现self</li>
<li>在初始化及dealloc方法中，总是应该直接通过实例变量来读写数据,在init和dealloc方法中避免时候用self.property</li>
</ul>
<ol start="8">
<li>理解对象等同性这一概念</li>
</ol>
<ul>
<li>== 判断内存是否相等， isEqual 判断对象是都相等</li>
<li>相同对象必须有相同的哈希码，但两个哈希码相同的对象却未必相同</li>
</ul>
<ol start="9">
<li>以类簇隐藏实现细节</li>
</ol>
<ul>
<li>实现子类时，一定要注意父类指明覆盖的方法</li>
</ul>
<ol start="10">
<li>在既有类中使用关联对象存放自定义数据</li>
</ol>
<ul>
<li>objc_setAssociateObject    objc_getAssociatedObject  objc_removeAssociatedObjects</li>
<li>慎用，很难发现也很难排查</li>
</ul>
<ol start="11">
<li>理解objc_msgSend的作用</li>
</ol>
<ol start="12">
<li>理解消息转发机制</li>
</ol>
<ul>
<li>resolveInstanceMethod:  resolveClassMethod:</li>
<li>forwardingTargetForSelector</li>
<li>forwardInvocation</li>
</ul>
<ol start="13">
<li><p>用方法调配技术（method swizzling）调试黑盒方法</p>
</li>
<li><p>理解类对象的用意</p>
</li>
</ol>
<ul>
<li>id本身就是指针，所以不用 *</li>
<li>isMemberOfClass  isKindOfClass</li>
</ul>
<ol start="15">
<li>用前缀避免命名空间冲突</li>
</ol>
<ul>
<li>apple宣称其保留使用所有“两字母前缀”的权利，所以自己选用的前缀应该是三个字母及以上的</li>
<li>项目中所有的方法、函数都最好加前缀</li>
</ul>
<ol start="16">
<li>提供全能初始化方法</li>
</ol>
<ul>
<li>必须要实现的，放到init里让对象实例化的时候就实现。（全能初始化）</li>
<li>子类要包含父类全能初始化方法干的事。</li>
<li>可以抛出异常来提醒，但不建议，OC中只有发生严重错误时，才应该抛出异常。、</li>
</ul>
<ol start="17">
<li>实现description 方法</li>
</ol>
<ul>
<li>重写description 方法能自定义打印内容，其实可以Hook一下让所有的类以及其属性值都打印出来，不过暂时没必要。</li>
<li>debugDescription 是开发者在调试器中以控制台命令打印对象时才调用。</li>
</ul>
<ol start="18">
<li>尽量使用不可变对象</li>
</ol>
<ul>
<li>尽量少的暴露属性，即便暴露属性也要尽量设置为只读的。</li>
<li>暴露的readonly属性最好设置内存管理，并在内部重新声明为readwrite，避免正在写的时候外面有人在读，必要的时候可以用dispatch_sync 将存取操作设置为同步操作。</li>
<li>不要暴露可变的collection属性，应该提供相关方法修改内部可变的collection，而在公开属性中getter方法中对内部可变的copy操作。</li>
</ul>
<ol start="19">
<li>使用清晰而协调的命名方式</li>
</ol>
<ul>
<li>如果方法的返回值是新创建的，那么方法名的首个词应是返回值类型。</li>
<li>应该把表示参数类型的名词放在参数前面。</li>
<li>如果方法要在当前对象上执行凑走，那么久应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。</li>
<li>不要使用str这种简称，应该用string这样的全称。</li>
<li>BOOL属性应加is前缀。如果某方法返回非属性的BOOL值，那么应该根据其功能，选用has或is当前缀。</li>
<li>将get这个前缀留给那些借由“输出参数”来保存返回值的方法。</li>
</ul>
<ol start="20">
<li>为私有方法名加前缀</li>
</ol>
<ul>
<li>不要用下划线作为前缀定义私有方法，因为这是预留给苹果公司用的。</li>
<li>可以将使用的类名前缀用作私有方法前缀来避免冲突。</li>
</ul>
<ol start="21">
<li>理解Objective-C错误类型</li>
</ol>
<ul>
<li>如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放，即便不用ARC，也很难写出在抛出异常时不会导致内存泄漏的代码</li>
<li>OC采用的做法：只在极其罕见（致命）的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。</li>
<li>如果父类强制子类实现某方法，可以在父类对应方法里抛出异常。</li>
<li>出现不非致命错误是OC一般让方法返回nil，或者使用NSError。</li>
<li>NSError一般通过(NSError<strong>)error 这种输出参数来返回。实际上编译器会将NSError</strong>转换成NSError<em> _ _ autoreleasing</em> ,也就是说指针所指的对象会这方法执行完毕后自动释放。</li>
</ul>
<ol start="22">
<li>理解NSCopying协议</li>
</ol>
<ul>
<li>自己的类支持拷贝操作，就需要实现NSCopying协议。copyWithZone方法中zone参数是因为以前是按zone（区）来划分的，但现在都是使用default zone，因此可以不用管zone参数。</li>
<li>非属性的内部使用实例，可以通过 -&gt; 语法</li>
<li>mutableCopy   copy  区别</li>
</ul>
<ol start="23">
<li>通过委托与数据源协议进行对象间通信</li>
</ol>
<ul>
<li>delegate 属性要定义成weak，而不是strong的。</li>
<li>@optional</li>
</ul>
<ol start="24">
<li>将类的实现代码分散到便于管理的数个分类之中</li>
</ol>
<ul>
<li>将应该视为“私有”的方法归入名为private的分类中以隐藏实现细节。</li>
</ul>
<ol start="25">
<li>总是为第三方类的分类名称加前缀</li>
</ol>
<ul>
<li>如果相同属性或方法，分类会覆盖原来的，而且很可能覆盖很多次。。。解决的办法就是加前缀。</li>
</ul>
<ol start="26">
<li>勿在分类中声明属性</li>
</ol>
<ul>
<li>把封装数据所用到的全部属性都定义在主接口里</li>
</ul>
<ol start="27">
<li>使用“class-continuation分类”隐藏实现细节</li>
</ol>
<ul>
<li>必须定义在其接续的那个类的实现文件里，没有名字；并且是唯一能声明实例变量的分类  @interface Person() {  // something  }</li>
<li>非公开的属性最好写在class-continuation</li>
</ul>
<ol start="28">
<li>通过协议提供匿名对象</li>
</ol>
<ul>
<li>@property (nonatomic , weak) id <somedelegate> delegate;  id <somedelegate>就是匿名对象</somedelegate></somedelegate></li>
<li>协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法</li>
<li>使用匿名对象类隐藏类型名称（或类名）</li>
<li>如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以用匿名对象来表示。</li>
</ul>
<ol start="29">
<li>理解引用计数</li>
</ol>
<ul>
<li>retainCount方法不太准，不建议使用。</li>
<li>保留环，一则般需要设置weak处理，block的循环引用则用_ _weak     _ _strong    _ _block来处理</li>
</ul>
<ol start="30">
<li><p>以  ARC简化引用计数</p>
</li>
<li><p>在dealloc方法中只释放引用并解除监听</p>
</li>
</ol>
<ul>
<li>不应该自己调用dealloc，虽然非ARC用调 [super dealloc]，但ARC不用。应该做的就是释放引用，取消订阅或KVO</li>
<li>错误，异常，对于一些特殊操作很重要，提醒释放内存。</li>
<li>系统并不保证每个创建出来的对象的dealloc都会执行。</li>
<li>编写dealloc方法时，不要在里面随便调用其他方法。</li>
<li>dealloc里也不要调用属性的存取方法</li>
</ul>
<ol start="32">
<li>编写“异常安全代码”时留意内存管理问题</li>
</ol>
<ul>
<li>@try {} @catch {} @finally {}  捕获异常时，一定要注意将try块内所创立的对象清理干净。</li>
<li>默认情况下,ARC不生成安全处理异常所需的清理代码，开启编译器标志 –fobjc-arc-exceptions 后，可以生成清理代码，但开启后将导致程序变大，而且会降低运行效率。</li>
</ul>
<ol start="33">
<li>以若引用避免保留环</li>
</ol>
<ul>
<li>避免保留环的最佳方式就是弱引用。</li>
<li>weak 、assign 和 unsafe_unretained</li>
</ul>
<ol start="34">
<li>以自动释放池块降低内存峰值</li>
</ol>
<ul>
<li>通常只有一个地方需要创建自动释放池 @autoreleasepoll { // dosomething }，那就是在main函数里面</li>
<li>自动释放池可以嵌套，可以控制应用程序峰值</li>
<li>自动释放池的释放要等线程下一次runloop时才会清空</li>
</ul>
<ol start="35">
<li><p>用僵尸对象调试内存管理</p>
</li>
<li><p>不用使用retainCount</p>
</li>
</ol>
<ul>
<li>ARC已经废弃此方法，即便非ARC此方法获取的值也不准。</li>
</ul>
<ol start="37">
<li>理解“块”这一概念</li>
</ol>
<ul>
<li>int (^addBlock)(int a , int b) = ^(int a, int b){ return a+ b; };</li>
<li>Block捕获的变量在块内是不可变的，需要改的用_ _block修饰</li>
<li>_ _weak  _ _strong </li>
<li>定义Block的内存是分配在栈区，离开相应的范围之后，编译器有可能把分配给块的内存覆盖掉，因此需要用copy，拷贝到堆区当做一个一对象处理，拥有引用计数</li>
<li>全局块不会捕捉任何状态，运行时也无须状态来参与，声明在全局内存区，因此拷贝是个空操作，故全局块绝不可能为紫铜所收回，这种块实际上相当于单例。</li>
</ul>
<ol start="38">
<li>为常用的块类型创建typedef</li>
</ol>
<ul>
<li>块的类型有参数和返回值组成。</li>
</ul>
<ol start="39">
<li>用handler块降低代码分散程度</li>
</ol>
<ul>
<li>系统发现某个应用程序的主线程已经阻塞了一段时间后，就会令其停止。</li>
<li>建议使用同一个块来处理成功与失败的情况。</li>
<li>应该由调用API的人来决定handler应该运行在哪个线程上。</li>
</ul>
<ol start="40">
<li>用块引用其所属对象时不要出现保留环</li>
</ol>
<ul>
<li>一定要找个适当的时间解除保留环，而不能把责任推给API的调用者。</li>
</ul>
<ol start="41">
<li>多用派发队列，少用同步锁</li>
</ol>
<ul>
<li>@synchronized(self) 同步锁，会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。</li>
<li>NSLock</li>
<li>安全高效代替同步块和锁对象的是 串行同步队列</li>
<li>执行异步派发时，需要拷贝块</li>
<li>dispatch_barrier_async  dispatch_barrier_sync</li>
</ul>
<ol start="42">
<li>多用GCD，少用performSelector系列方法</li>
</ol>
<ul>
<li>用performSelector 调用一个方法，编译器并不知道将要调用的方法，也就不了解其方法签名以及返回值情况，所以没办法运用ARC的内存管理规则来判定返回值是不是应该释放，鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作，然而这么做可能导致内存泄漏。</li>
<li>一般返回只能是void或对象类型，而performSelector返回的是id类型，那么就需要执行一些转换操作，很容易出错！若返回类型为C的结构体，则不可使用performSelector方法。</li>
<li>没机会为被调用的方法指定参数，被调用的selec的输入可能指向位置的垃圾内存</li>
<li>如果跨线程执行，最好不用performSelector，而用GCD</li>
</ul>
<ol start="43">
<li>掌握GCD及操作队列的使用时机</li>
</ol>
<ul>
<li>GCD是纯C的API，而操作队列则是Ojbective-C的对象。</li>
<li>NSOperation 运行之前，可以取消某个操作（但已经启动的无法取消）；可指定操作间依赖关系；通过KVO观察属性；指定操作的优先级（GCD可以控制队列的优先级，不是块的）</li>
</ul>
<ol start="44">
<li>通过Dispatch Group机制，根据系统资源状况来执行任务</li>
</ol>
<ul>
<li>dispatch_group_t  dispatch_group_async  dispatch_group_enter  dispatch_group_leave  dispatch_group_wait  dispatch_group_notify</li>
</ul>
<ol start="45">
<li>使用dispatch_once来执行只需运行一次的线程安全代码</li>
</ol>
<ul>
<li>标记应该声明static或global作用域中，而且每次标记应该相同</li>
</ul>
<ol start="46">
<li>不要使用dispatch_get_current_queue</li>
</ol>
<ul>
<li>iOS6 之后已经弃用dispatch_get_current_queue，极其容易造成死锁</li>
<li>典型错误用法：用dispatch_get_current_queue检测当前队列是不是某个特定队列，试图避免执行同步派发时可能遭遇的死锁问题。</li>
<li>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。</li>
</ul>
<ol start="47">
<li><p>熟悉系统框架</p>
</li>
<li><p>多用块枚举，少用for循环、</p>
</li>
</ol>
<ul>
<li>块枚举法，本身就能通过NSEnumerationOptions 配置GCD来并发执行遍历操作。</li>
<li>若提前知道待遍历对象类型，则应修改块签名，指出对象的具体类型。</li>
</ul>
<ol start="49">
<li>对自定义其内存管理语义的collection使用无缝桥接</li>
</ol>
<ul>
<li>_ <em>bridge 本身的意思是：ARC仍然具备这个OC对象的所有权，而</em> _bridge_retained意味着ARC将交出对象的所有权</li>
</ul>
<ol start="50">
<li>构建缓存时选用NSCache而非NSDictionary</li>
</ol>
<ul>
<li>当系统资源将要耗尽时，NSCache可以自动删减缓存。</li>
<li>NSCache并不会“拷贝”键，而是会“保留”它。</li>
<li>NSCache是线程安全的，不加锁多个线程也可以同时访问。</li>
</ul>
<ol start="51">
<li>精简initialize与load的实现代码</li>
</ol>
<ul>
<li>当包含类或分类的程序载入系统时会调用load方法，而且只会调一次。如果类和分类都实现了load方法，则先调类的，再调分类的。</li>
<li>load方法中使用其他类是不安全的，因为比先执行超类的load方法，而根据某个给定的程序库却无法判断出其中各个类的载入顺序。</li>
<li>load方法并不像普通方法那样，如果某个类本身没实现load方法，那么不管其各级超类是否实现此方法，系统都不会调用</li>
<li>load方法必须实现的精简，因为整个应用程序在执行load方法时都会阻塞。</li>
<li><ul>
<li>(void) initialize   与 – (void) init 不一样</li>
</ul>
</li>
<li><ul>
<li>(void) initialize 对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。</li>
</ul>
</li>
<li><ul>
<li>(void) initialize方法时惰性调用的，用不到的类不会运行，但load方法是程序会一直阻塞到所有类的load都执行完。</li>
</ul>
</li>
<li><ul>
<li>(void) initialize 与其他方法一样，如果某个类未实现它，而超类实现了，则运行超类的实现代码。</li>
</ul>
</li>
<li><ul>
<li>(void) initialize 方法要尽量精简，只应该用来设置内部数据，不应该调用其他方法，即便是本类自己的方法最好也别调用；若某个全局状态无法再编译期间初始化，则可放到initialize里来做。</li>
</ul>
</li>
</ul>
<ol start="52">
<li>别忘了NSTimer会保留其目标对象</li>
</ol>
<ul>
<li>设置成重复执行模式计时器，很容易引入保留环</li>
<li>self.timer  设置self为target  就产生了保留环。</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>冷启动优化</title>
    <url>/2017/05/21/%E5%86%B7%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>&emsp;&emsp;关于APP运行理论，百度知道上有一篇不错的文章：<a href="https://zhidao.baidu.com/question/1370352051634002499.html" target="_blank" rel="noopener">App 运行理论</a>。</p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><h4 id="1-preMain阶段"><a href="#1-preMain阶段" class="headerlink" title="1 preMain阶段"></a>1 preMain阶段</h4><h5 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h5><ol>
<li>解析info.plist</li>
<li>加载可执行文件（自身App的所有 .o 文件）</li>
<li>加载dyld，以便递归加载所有依赖的动态链接库</li>
<li>加载动态链接库：分析并找到库的mach-o文件、验证并注册文件、把动态库的每个segment映射到内存</li>
<li>rebase/bind：由于ASLR需要这两步修复镜像中的资源指针</li>
<li>注册Objc类、插入category</li>
<li>initializers</li>
</ol>
<h5 id="测量方式"><a href="#测量方式" class="headerlink" title="测量方式"></a>测量方式</h5><p>&emsp;&emsp;在Xcode的菜单中选择Project→Scheme→Edit Scheme…，然后找到 Run → Environment Variables →+，添加name为DYLD_PRINT_STATISTICSvalue为1的环境变量</p>
<h5 id="可做事情"><a href="#可做事情" class="headerlink" title="可做事情"></a>可做事情</h5><ol>
<li>减少不必要的framework，因为动态链接比较耗时</li>
<li>check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查</li>
<li>合理设置pod库权限，例如只在debug用到的，可标记为 :configurations =&gt; [‘Debug’]</li>
<li>合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能</li>
<li>删减没有被调用到或者已经废弃的方法，参考 <a href="http://stackoverflow.com/questions/35233564/how-to-find-unused-code-in-xcode-7" target="_blank" rel="noopener">http://stackoverflow.com/questions/35233564/how-to-find-unused-code-in-xcode-7</a></li>
<li>将不必须在+load方法中做的事情延迟到+initialize中</li>
</ol>
<h4 id="2-main阶段"><a href="#2-main阶段" class="headerlink" title="2 main阶段"></a>2 main阶段</h4><ol>
<li>int main(int argc, char * argv[])开始</li>
<li><ul>
<li>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions 结束</li>
</ul>
</li>
</ol>
<h5 id="测量方式-1"><a href="#测量方式-1" class="headerlink" title="测量方式"></a>测量方式</h5><p>&emsp;&emsp;打点，输出log！不建议使用Time Profiler，因为很容易陷到模块初始化的细节里面去</p>
<h5 id="可做事情-1"><a href="#可做事情-1" class="headerlink" title="可做事情"></a>可做事情</h5><p>&emsp;&emsp;集中在didFinishLaunchingWithOptions方法内，这是大头也是重点，核心就是延迟处理，推荐原则：一次只修改一部分、写好测试用例、设置降级措施</p>
<ol>
<li>将三方SDK分类，将部分SDK延后，例如ShareSDK、PushSDK等</li>
<li>选择性加载，提供几个维度：版本角度、用户角度、依赖关系等</li>
<li>延后部分模块或单例的初始化工作，例如，本地化模块、广告模块等</li>
<li>延后大部分的网络请求至home阶段</li>
</ol>
<h4 id="3-home阶段"><a href="#3-home阶段" class="headerlink" title="3 home阶段"></a>3 home阶段</h4><ol>
<li>tabbar </li>
<li>home viewdidload 和 viewDidAppear</li>
</ol>
<h5 id="测量方式-2"><a href="#测量方式-2" class="headerlink" title="测量方式"></a>测量方式</h5><p>&emsp;&emsp;打点log 或 Time Profiler</p>
<h5 id="可做事情-2"><a href="#可做事情-2" class="headerlink" title="可做事情"></a>可做事情</h5><ol>
<li>严查tabbar，我们在tabbar和4个tab初始化时竟然做了非常多的业务逻辑，这些完全可以延后</li>
<li>尽量使用缓存且尽量只加载第一屏缓存</li>
<li>尽量避免批量加载图片，如果必须加载使用异步</li>
<li>使用懒加载，尽量只处理第一屏内容</li>
<li>如果条件允许，使用占位符</li>
<li>尽量减少view层级、减少布局时浮点数的使用</li>
</ol>
<h3 id="其它优化措施"><a href="#其它优化措施" class="headerlink" title="其它优化措施"></a>其它优化措施</h3><ol>
<li>使用闪屏广告（倒计时 3 2 1 那种）</li>
<li>使用部分动画，降低用户焦虑</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://techblog.toutiao.com/2017/01/17/iosspeed/#more" target="_blank" rel="noopener">今日头条iOS客户端启动速度优化</a></li>
<li><a href="https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA" target="_blank" rel="noopener">iOS App 启动性能优化</a></li>
<li><a href="https://zhidao.baidu.com/question/1370352051634002499.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1370352051634002499.html</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程和链式编程</title>
    <url>/2017/11/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>&emsp;&emsp;简单说下函数式编程和链式编程的理解</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>&emsp;&emsp;函数式编程所强调的函数，上述两点可翻译为：1、不依赖外部状态；2、不改变外部状态</p>
<ul>
<li>理想状态下的纯函数</li>
<li>变量作用域在函数内，如果需要外部变量需要当做函数的参数传入</li>
<li>不会产生副作用，不能改变被转入数据或其他数据</li>
<li>相同入参，返回值必然相同 </li>
<li>函数作为一等公民，跟swift一样理解即可</li>
<li>高阶函数：可以把函数作为参数传递给另一个函数</li>
<li>优化技术：尾调用优化技术，即最后一个return返回一个函数，减少压栈次数，参考：<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">尾调用优化</a></li>
</ul>
<h4 id="OC实现，代表RAC"><a href="#OC实现，代表RAC" class="headerlink" title="OC实现，代表RAC"></a>OC实现，代表RAC</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (Person *)walk:(NSString * (^)(void))hotel;</span><br><span class="line">- (Person *)eat:(NSString * (^)(NSArray *))food;</span><br><span class="line">- (Person *)sayGood;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (Person *)walk:(NSString * (^)(void))hotel &#123;</span><br><span class="line">NSLog(@&quot;go to %@&quot;,hotel());</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Person *)eat:(NSString * (^)(NSArray *))food &#123;</span><br><span class="line">NSString *someFood = food(@[@&quot;apple&quot;,@&quot;banner&quot;,@&quot;potato&quot;]);</span><br><span class="line">NSLog(@&quot;eat %@&quot;,someFood);</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Person *)sayGood &#123;</span><br><span class="line">NSLog(@&quot;the food is vear good!&quot;);</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">Person *person = [[Person alloc] init];</span><br><span class="line">[[[person walk:^NSString * _Nonnull&#123;</span><br><span class="line">return @&quot;my home&quot;;</span><br><span class="line">&#125;] eat:^NSString * _Nonnull(NSArray * _Nonnull foods) &#123;</span><br><span class="line">return foods[1];</span><br><span class="line">&#125;] sayGood ];</span><br></pre></td></tr></table></figure>
<h3 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h3><p>&emsp;&emsp;多个方法使用点语法链接起来，让代码更加简洁，可读性更强</p>
<h4 id="OC实现，代表Masonry"><a href="#OC实现，代表Masonry" class="headerlink" title="OC实现，代表Masonry"></a>OC实现，代表Masonry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@class Person;</span><br><span class="line">typedef Person *_Nonnull(^actionBlock)(NSString *);</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property (nonatomic, strong) NSMutableString *log;</span><br><span class="line">@property (nonatomic, copy) actionBlock walk;</span><br><span class="line">@property (nonatomic, copy) actionBlock eat;</span><br><span class="line">@property (nonatomic, copy) actionBlock sayGood;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">_log = [[NSMutableString alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (actionBlock)walk &#123;</span><br><span class="line">__block NSMutableString *log = _log;</span><br><span class="line">return ^(NSString *str)&#123;</span><br><span class="line">[log appendString:[NSString stringWithFormat:@&quot;go to %@&quot;,str]];</span><br><span class="line">return self;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">- (actionBlock)eat &#123;</span><br><span class="line">__block NSMutableString *log = _log;</span><br><span class="line">return ^(NSString *str)&#123;</span><br><span class="line">[log appendString:[NSString stringWithFormat:@&quot; eat %@&quot;,str]];</span><br><span class="line">return self;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">- (actionBlock)sayGood &#123;</span><br><span class="line">__block NSMutableString *log = _log;</span><br><span class="line">return ^(NSString *str)&#123;</span><br><span class="line">[log appendString:[NSString stringWithFormat:@&quot; the %@ is vear good!&quot;,str]];</span><br><span class="line">return self;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.walk(@&quot;my home&quot;).eat(@&quot;apple&quot;).sayGood(@&quot;apple&quot;);</span><br><span class="line">NSLog(@&quot;%@&quot;,p.log);</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.cnblogs.com/zy1987/p/3788670.html" target="_blank" rel="noopener">https://www.cnblogs.com/zy1987/p/3788670.html</a></li>
<li><a href="http://mrpeak.cn/blog/functional/" target="_blank" rel="noopener">http://mrpeak.cn/blog/functional/</a></li>
<li><a href="https://blog.csdn.net/sinat_27706697/article/details/48946485" target="_blank" rel="noopener">https://blog.csdn.net/sinat_27706697/article/details/48946485</a></li>
</ul>
<h4 id="更新参考"><a href="#更新参考" class="headerlink" title="更新参考"></a>更新参考</h4><ul>
<li><a href="https://mp.weixin.qq.com/s/0gErQ3tjDLZuD1bYOhi0mQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/0gErQ3tjDLZuD1bYOhi0mQ</a></li>
<li><a href="https://www.liaoxuefeng.com/article/1260118907809920" target="_blank" rel="noopener">https://www.liaoxuefeng.com/article/1260118907809920</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>创业36条军规</title>
    <url>/2016/02/01/%E5%88%9B%E4%B8%9A36%E6%9D%A1%E5%86%9B%E8%A7%84/</url>
    <content><![CDATA[<h4 id="军规1-不是每个人都适合创业"><a href="#军规1-不是每个人都适合创业" class="headerlink" title="军规1 不是每个人都适合创业"></a>军规1 不是每个人都适合创业</h4><ul>
<li>创业很难，成功者寥寥无几！就像俞敏洪说的，很多人死在了第二天晚上</li>
<li>创业是做未知的事，不可能出发前就想清楚所有的事，创业者需要在前进的过程中随机应变</li>
<li>创业路上，最常见的不是成功或失败，而是长时间的苦苦挣扎</li>
<li>创业的机会成本很高，开始创业之前一定要认清自己，战略规划在前</li>
<li>创业者要过非人的生活</li>
<li>创业者的时间表上没有生活时间</li>
<li>创业者要给所有人交代！必须承担所有的责任，很简单因为没得选！但请记住没有选择往往是最好的选择</li>
<li>只有不到十分之一的人适合创业</li>
<li>打工和创业所需能力不一样</li>
<li>领军人物应具备4个素质：1、目标高远，意志坚定；2、心胸开阔，情商要高；3、企业利益放第一位；4、学习能力强，爱学习而且会学习</li>
<li>创业者应具备4个素质：1、事业心，是否把企业当做命根子来做；2、眼光和境界，要比别人想得多，要比别人看得远；3、心理素质，能否百折不挠处变不惊；4、学习能力。是否已学习为生活方式，有无及时复盘的习惯</li>
<li>接受正规的职业化训练是非常必要的。</li>
</ul>
<h4 id="军规2-梦想是唯一的创业理由"><a href="#军规2-梦想是唯一的创业理由" class="headerlink" title="军规2 梦想是唯一的创业理由"></a>军规2 梦想是唯一的创业理由</h4><ul>
<li>创业就是一个逐梦的过程</li>
<li>人的时间是有限的，所以不要按照别人的意愿去活，这是浪费时间！做你想做的事！</li>
<li>拒绝行尸走肉，人的梦想是不会终结的</li>
<li>越是被别人嘲笑的梦想，越有实现的价值！</li>
<li>创业是一个不断试错的过程</li>
<li>一切都是未知的，比的是耐力、智慧和运气，这也正是创业的魅力所在</li>
<li>坚持与放弃，源于战略规划、战术智慧和冷静决断的结合！优柔寡断不可取，刚愎自用更不可取</li>
<li>创业没什么高不可攀</li>
<li>创业并不神秘也不高不可攀，只是一个生活方式</li>
<li>不要想得太复杂，也不用给自己界定太明确是具体成功时点，只是拼尽全力去做</li>
<li>早开始一点没坏处，不要幻想把一切都准备好再出发，因为你永远都准备不完，创业是一步一步干出来的，不是想出来的</li>
<li>关于创业的三个错误观念</li>
<li>不要把上市当做创业目标，实际上99%的企业上不了市，还有很多企业根本不适合上市</li>
<li>不要有为了就业而创业的思想。就业 = 安逸，创业就要做好思想准备</li>
<li>不要为了那些美丽的大道理去创业。那是“果”，不是“因”</li>
</ul>
<h4 id="军规3-学先进，傍大款，走正道"><a href="#军规3-学先进，傍大款，走正道" class="headerlink" title="军规3 学先进，傍大款，走正道"></a>军规3 学先进，傍大款，走正道</h4><ul>
<li>创业必须走正道</li>
<li>要善于向优秀的同行学习，要追求与强者合作，要坚守规范经营的原则。投机取巧看似占便宜，实则吃大亏，出来混早晚是要换的</li>
<li>有所为，有所不为，是为有为</li>
<li>对手不正当竞争，不等于你也可以不正当竞争。面对对手死缠烂打，第一要淡定，要冷静应付，不能自乱阵脚；第二，多做实事反击是在市场上，能不说就不说，能少说就少说，不得不说的时候要高举用户利益的大旗，重复正确的话，不回应攻击者，也不反击攻击者，切记言多必失，对攻击者的蔑视是最好的反击，切记不要去争论和回应对方的具体问题。最后坚持桌面上出牌</li>
<li>学先进要全盘学习</li>
<li>坚守自己的道德底线</li>
<li>学先进必须要先僵化，再固化，再优化。国情不同我们是特殊的，这绝对是个陷阱；绝大多数的事，绝大多数时候，没有谁特殊！进步的捷径就是直接学习那些已经成功的企业和人，学习他们已经被验证了的行之有效的方法！落后的组织，落后的人怎么会有水平判断先进方法的对错？所以必须先僵化的学习，教条似的做，等做熟练了，再坐下来复盘研究是否有优化之处</li>
<li>傍大款不是靠大款</li>
<li>和好的最强者合作发展，好处多多！正向激励 + 资源保证 + 流程优化 等等</li>
<li>傍大款是为了提升自己，互惠互利</li>
</ul>
<h4 id="军规4-创新是最好的武器"><a href="#军规4-创新是最好的武器" class="headerlink" title="军规4 创新是最好的武器"></a>军规4 创新是最好的武器</h4><ul>
<li>伟大不是模仿来的</li>
<li>再小的创新，再小的分支细节，放到14亿人口里都是一个非常可观的成功</li>
<li>模仿是不是成功的捷径！即便复制美国创新东西，也要先跟踪先复制，最后还要本土化创新</li>
<li>小公司尤其不可能通过模仿生存。大公司对市场的反应必然会慢半拍，小公司必须敢于冒险，勇于创新，快速反应才有机会。只有差异化才有市场空间</li>
<li>个人认为：模仿就是copy，因为很多差异化都体现在很小的细节</li>
<li>只有创新才有机会</li>
<li>每个成功的企业都是一系列创新的结果。做企业就是两件事–创新和营销。创新分为两类，一类发现新大陆，一类打破常规</li>
<li>企业的每个角落都需要不断地创新。产品创新很重要，但并不是企业创新的全部，这是每个创业者必须明确的理念。</li>
<li>一把手要为创新构建一个环境</li>
<li>创新者一定是少数派，会遭到大多数普通人的质疑；创新必然会经过艰难的探索，甚至不断地失败；创新会触犯很多既得利益者或市场领先者。这些都决定了创新是很艰难的，而这也正式创新的意义所在</li>
</ul>
<h4 id="军规5-放下身段死缠烂打"><a href="#军规5-放下身段死缠烂打" class="headerlink" title="军规5 放下身段死缠烂打"></a>军规5 放下身段死缠烂打</h4><ul>
<li>每一个成功都是拼出来的</li>
<li>成功有规律，走正道、创新和死缠烂打这三个普世成立的真理，可以帮助你更好的成功</li>
<li>成功者不找借口！逮住机会就死缠烂打，别太把自己当回事！成功者该放下身段时都能放下身段，放下身段从最基础的业务做起！对于创业公司，最基础的业务是最迫切的业务</li>
<li>成功者都善于调整自己的心态；他们往往缺乏过程感，急躁冒进，幻想一夜成功，把小公司当大公司来做，过分关注战略，规划，制度，流程等大公司的东西，提高了成本又降低了效率</li>
<li>成功者都有极强的意志力，再难也能咬牙扛过去！（可怜我总嚷嚷怕什么天塌下来大不了用脑袋顶着）</li>
<li>成功者风光的背后是和你一样的坎坷，都是雨里泥里爬出来的，只是你没有看到</li>
<li>伟大都是熬出来的</li>
<li>剩者为王，俞敏洪说很多人都死在了第二天晚上！所以首先要活下去，慢慢熬</li>
<li>成功的关键在于多坚持5分钟！你筋疲力尽时也是对手筋疲力尽的时候，虽然对手表面装的不累！</li>
<li>把每个机会都当做最后一根稻草才能成功</li>
<li>机会太多的人往往不容易成功，因为他们很容易放弃，遇阻则推，不愿坚持，心想反正还有下一个机会！ </li>
<li>成功与否主要还是看自己！不否认客观因素存在，那是事实，你没得选，唯一能做的就是想尽办法去克服</li>
</ul>
<h4 id="军规6-凡事只能靠自己"><a href="#军规6-凡事只能靠自己" class="headerlink" title="军规6 凡事只能靠自己"></a>军规6 凡事只能靠自己</h4><ul>
<li>任何时候创始人都不能放弃</li>
<li>创始人别无退路：凡事只能靠自己，万事皆有解且有唯一正解，凡是你担心的事一定会发生，享受创业过程</li>
<li>创业初期最难的三件事只能靠创始人自己</li>
<li>三座大山基本上只能靠你自己爬：找方向，找人和找钱</li>
<li>自己不会做的事不要指望下属创造惊喜</li>
<li>不是说创始人不需要合伙人、团队，而是说所有结果都由你自己负全责，所以你只能靠自己做决定</li>
<li>不要指望别人来救你</li>
<li>顾问公司只能帮锦上添花的忙</li>
<li>随时准备自救才能长命百岁，所有人都喜欢锦上添花，如果你自己都不竭尽全力，别人更不会伸出援手</li>
<li>不能以授权为名推卸自己的责任</li>
</ul>
<h4 id="军规7-领导要有预见性"><a href="#军规7-领导要有预见性" class="headerlink" title="军规7 领导要有预见性"></a>军规7 领导要有预见性</h4><ul>
<li>预见未来是领军者的责任</li>
<li>只有预见未来才能做对的事，对未来预见的越早越清晰，你就越可能做正确的事。永远要比别人多思考一点，永远要做好最坏的打算、最全面的准备</li>
<li>只有预见未来才能走的更远，要站得高，看得远还要理的清！要留意新兴事务，要开阔眼界还要跳出具体业务细节看事情的能力</li>
<li>早做布局，早5分钟行动</li>
<li>快速决策，快速行动。要善于决断，敢于取舍！问题不会自己解决，“拖”着只能让事变的更糟 - 早做布局。居安思危，早作打算！先发优势不容小觑！</li>
<li>留两分余力，随时准备自救</li>
<li>任何时候都不要孤注一掷！赌博中输的最惨的就是拼一把</li>
<li>越是顺风顺水，越要警惕。越要克制冲动和贪婪，睡觉都得睁半只眼！</li>
</ul>
<h4 id="军规8-心力强大者胜"><a href="#军规8-心力强大者胜" class="headerlink" title="军规8 心力强大者胜"></a>军规8 心力强大者胜</h4><ul>
<li>所有的比拼最终都是精神的比拼，必须拥有强大的心理素质和自我复盘学习的能力</li>
<li>什么奇迹都可能出现，前提是你不能认输！</li>
<li>创业者要不断强大自己的心力！凡是不能消灭你的，都只能让你变得更强！</li>
<li>领导者必须树立远大的理想！记住取法其上，得乎其中</li>
<li>创始人必须志存高远，有远大的理想且意志坚定，要知道绝大多数人是没有主意的！</li>
<li>远大理想是鼓舞团队奋斗的动力！没有理想的队伍就是一盘散沙</li>
<li>领导者必须有必胜的信念</li>
<li>必胜的信念是创业者最宝贵的品质。你都不能破釜沉舟必胜而还的信念，下属为什么要跟着你？再说你的极限也是对手的极限，成功往往在于多坚持5分钟</li>
<li>只要肉体没被消灭，精神就不应该垮掉！必须的有股子狠劲！</li>
</ul>
<h4 id="军规9-要敢于冒险"><a href="#军规9-要敢于冒险" class="headerlink" title="军规9 要敢于冒险"></a>军规9 要敢于冒险</h4><ul>
<li>有五成把握就要开始行动</li>
<li>敢于打破常规才有机会！敢于质疑，敢于说不，敢于行动！</li>
<li>所有的成功都是突破常规的结果。天鹅肉从来都是被第一个敢张嘴的蛤蟆吃掉的。现实生活中，绝大多数的雷池是我们自己想象出来的！</li>
<li>敢于冒险才有胜机</li>
<li>成功总是青睐那些具有探险精神的人，宁愿失败也不要平庸！</li>
<li>小公司只能靠冒险寻求生存空间</li>
<li>大公司必须以规避风险为主，追求稳步发展少犯错</li>
<li>我们失去的只是锁链，一旦成功，我们获得的将是整个世界</li>
</ul>
<h4 id="军规10-相信直觉"><a href="#军规10-相信直觉" class="headerlink" title="军规10 相信直觉"></a>军规10 相信直觉</h4><ul>
<li>与直觉相悖的事不要干</li>
<li>根据直觉先做一个大胆假设，然后小心求证</li>
<li>别人的建议尤其是具体建议要慎听，永远不要用集体决策代替自己的决策</li>
<li>建议和经验要贴合自身实际而慎重选择</li>
<li>直觉是上天赐给创业者的礼物</li>
<li>大胆假设，小心求证。</li>
</ul>
<h4 id="军规11-创业要靠团队"><a href="#军规11-创业要靠团队" class="headerlink" title="军规11 创业要靠团队"></a>军规11 创业要靠团队</h4><ul>
<li>一个人包打天下的时代已经过去了</li>
<li>创业需要一个团队，一个志同道合、优势互补、紧密配合、把公司当做命根子 </li>
<li>团队强大才能打胜仗</li>
<li>没有合适的人做“1”，再多的“0”也没用！管理者的能力是找到对的人</li>
<li>每个团队都有基因。扩张新业务需要新基因</li>
<li>建立高效的团队：1，头是唯一的；2，组织结构要清晰；3，令行禁止；4，个人利益服从整体利益；5，互相补台</li>
<li>团队要协同作战：1，共同的愿景和价值观；2，彼此信任；3，注重沟通技巧</li>
<li>需要主次配合，主动去理解领导意图，积极去贯彻领导意图，是团队成员素质基础！领导对错，小兵说了不算，那还不如提高执行力</li>
<li>团队必须有唯一的“头”儿</li>
<li>必须有领导者，否则就是一盘散沙，领军人物的威信只能在战斗中形成 </li>
</ul>
<h4 id="军规12-干部要靠自己培养"><a href="#军规12-干部要靠自己培养" class="headerlink" title="军规12 干部要靠自己培养"></a>军规12 干部要靠自己培养</h4><ul>
<li>下决心自己培养干部</li>
<li>培养干部是革命的首要问题！提拔个排长当团长，也比空降个师长当团长好！外来的和尚未必会念经！</li>
<li>人才标准需要一把手亲自制定，优秀干部标准：1，理解上意；2，有意见和见解可以表达，但一旦做了决策，就必须马上忘记自己的分歧，坚决彻底的贯彻决议；3，做任何一件事，都要和上级明晰目标、结构规划和里程碑，宁可不做，不要做错；4，及时汇报，多汇报没坏处</li>
<li>建立起人才的培养机制， 企业选材标准：1，悟性，能举一反三分析出事物的本质；2，心胸宽广；3，有大局观；4，学习能力强，勤于思考，逻辑清楚，善于归纳总结提炼 </li>
<li>创业不要用职业经理人</li>
<li>职业经理人是创业公司的天敌。职业经理人注定短视，注重流程且道德堪忧，再苦再难也不要请！</li>
<li>慎用空降兵</li>
<li>空降兵的误区：1，如果真厉害早就自己干了，为啥给你干；2，和你的基因不一定相符，且不一定接受低的职位；3，他的经验不一定有用，反而可能有害；4，外来的和尚未必会念你的经，未必会执着的念你的经</li>
<li>空降兵尤其不适合创业期</li>
</ul>
<h4 id="军规13-选对股东"><a href="#军规13-选对股东" class="headerlink" title="军规13 选对股东"></a>军规13 选对股东</h4><ul>
<li>股东对企业至关重要</li>
<li>股东是企业的基因，慎重选择，优劣势是啥？ </li>
<li>企业要处理好三个圈子：股东圈、员工圈和朋友圈</li>
<li>企业垮掉一半以上是因为股东问题</li>
<li>股东有问题企业很难持久，股东常常是可以共患难不可以共富贵</li>
<li>如何选择股东？1，志同道合；2，认同合体规则；3，出资，不要给干股；4，优先选择有资源有经验的</li>
<li>创业者选股东的四个误区：1，用股份来激励员工；2，让短期能帮上忙的朋友成功股东；3，让亲朋好友当股东；4，吸收不好的“战略投资者”</li>
</ul>
<h4 id="军规14-搭好治理结构"><a href="#军规14-搭好治理结构" class="headerlink" title="军规14 搭好治理结构"></a>军规14 搭好治理结构</h4><ul>
<li>企业的治理结构很关键</li>
<li>两个核心问题：1，公司股东的构成及其相互比例关系；2，董事会和管理层之间的权利分配</li>
<li>治理结构有问题公司很难成功</li>
<li>企业必须有主人</li>
<li>股东层面，企业要有大股东</li>
<li>经营层面，管理层必须有“主人翁”意识，可以给股权，也可给激励</li>
<li>理想的股东结构是怎样的？</li>
</ul>
<h4 id="军规15-事先要签股东协议"><a href="#军规15-事先要签股东协议" class="headerlink" title="军规15 事先要签股东协议"></a>军规15 事先要签股东协议</h4><ul>
<li>定好规则才能合作长久</li>
<li>认可规则和遵守规则是成为股东的前提。先小人后君子，规则一定要说出来</li>
<li>股东协议要约定哪些事？</li>
<li>约定股东义务，最好不要把业务对象发展为股东</li>
<li>约定退出机制。</li>
<li>约定决策机制。</li>
<li>约定公司方向</li>
</ul>
<h4 id="军规16-做最肥的市场"><a href="#军规16-做最肥的市场" class="headerlink" title="军规16 做最肥的市场"></a>军规16 做最肥的市场</h4><ul>
<li>选对创业方向最重要</li>
<li>正确的创业方向让你事半功倍！创业最常犯的错误是“会啥做啥”，最好是自己爱好、自己特长和用户需求三大因素的平衡点来创业</li>
<li>盯住用户的真需求</li>
<li>围绕用户需求创业，目标用户是谁？解决哪些痛点？学会取舍</li>
<li>区分真假需求。无关痛痒的和超出实际的都是假需求；创业者容易吧自己的爱好当做用户需求，把个别需求当普遍需求；有人需要你跟有市场是两回事</li>
<li>盯住最肥的市场</li>
<li>选择创业方向的原则：1，市场应该足够大，利用率应该足够高；2，事情本省应该是有意义的；3，事情应该是有所创新的</li>
<li>小池塘养不出大鱼；看五年，想三年，认认真真做好一两年</li>
</ul>
<h4 id="军规17-做减法"><a href="#军规17-做减法" class="headerlink" title="军规17 做减法"></a>军规17 做减法</h4><ul>
<li>成功是做了一件事。砍掉鸡肋项目，抓住用户的一个需求把它做到极致</li>
<li>遍地开花不可能成功。任何一个领域，只要深入进去都会发现机会遍地，但这只是表象！如果找不到切入点，形不成用户规模，哪个机会都是理论上的机会，形不成你的市场</li>
<li>做好一件事好过做了很多事</li>
<li>应该时刻提醒自己“做减法”，很多技术性企业都希望把产品的功能做到极致和全面，但想要打开市场，抓好一个点就够了！关键不在于技术上有多么高深，而在于你能不能解决用户的某个迫切需求</li>
<li>资源永远是稀缺的</li>
<li>天下没有免费的午餐！分配好有限的资源，聚焦聚焦再聚焦 </li>
<li>专注于一件事更容易成功</li>
<li>创业期企业要做到四个“最小”：1，只确定最关键点的战略，集中力量突破一点；2，只设最低限度指标，指标多重点必然分散，核心指标达成了其他指标自然合格；3，只用最不得不用的人，不胜任要换人而不是加人；4，只管到最低程度，给下属留出发展空间；</li>
</ul>
<h4 id="军规18-好的商业模式是成功的一半"><a href="#军规18-好的商业模式是成功的一半" class="headerlink" title="军规18 好的商业模式是成功的一半"></a>军规18 好的商业模式是成功的一半</h4><ul>
<li>商业模式是企业的核心</li>
<li>商业模式就是你的赚钱方式，核心四个问题：你的用户是谁？你为他们解决了什么问题？你用什么产品解决他们的问题？如何收费？</li>
<li>何为好的商业模式</li>
<li>好的商业模式特点：1，产品简单；2，前提要简单；3，一次创意型；4，可低成本扩张；5，要有一定的门槛</li>
<li>商业模式是否成立需要验证</li>
<li>尽早验证你的商业模式</li>
</ul>
<h4 id="军规19-集中兵力突破重点"><a href="#军规19-集中兵力突破重点" class="headerlink" title="军规19 集中兵力突破重点"></a>军规19 集中兵力突破重点</h4><ul>
<li>创业期公司要关注业务问题</li>
<li>在公司没有找到方向之前，公司的主要矛盾就是找方向</li>
<li>找到方向后先验证商业模式，再找到有效的业务推广方法。创业公司要抓开源而非节流，抓业务突破而非管理的规范化</li>
<li>突破重点才能解决问题</li>
<li>要想成功必须打赢“命运之战”，决定目标是否达成的一定是一两个关键项目，创业者需要学会舍得，必须保持头脑清醒，禁得住诱惑，时刻牢记你的主战场是什么</li>
<li>创业公司唯一的战略就是突破重点</li>
<li>找到突破点，突破突破点。创业头两年的公司不要考虑什么宏伟的战略规划，那东西只有坏处没有益处</li>
</ul>
<h4 id="军规20-先赚到钱再考虑发展"><a href="#军规20-先赚到钱再考虑发展" class="headerlink" title="军规20 先赚到钱再考虑发展"></a>军规20 先赚到钱再考虑发展</h4><ul>
<li>赢利的公司有的是发展机会。</li>
<li>要性感还是要赚钱？小钱都挣不了，怎么挣大钱！赚钱才是企业的头等大事</li>
<li>能赚钱和赚到钱是两码事。</li>
<li>烧钱的发展模式不可取</li>
<li>烧钱的发展模式是特例 </li>
<li>赚不赚钱是衡量公司好坏的第一标准</li>
<li>估值不是衡量公司好坏的核心标准。企业的核心价值是满足用户需求，为用户创造价值。 </li>
<li>赚钱的公司最优秀</li>
<li>公司初创时要有愿景，但是具体的伟大战略都是在公司在市场上站稳脚跟，衣食无忧后才规划的 </li>
</ul>
<h4 id="军规21-为公司找一个好的总经理"><a href="#军规21-为公司找一个好的总经理" class="headerlink" title="军规21 为公司找一个好的总经理"></a>军规21 为公司找一个好的总经理</h4><ul>
<li>好的总经理是成功的一半</li>
<li>每个伟大的企业都有一个伟大的总经理</li>
<li>不是每个人都适合当总经理，创始人如果不适合，最好三顾茅庐找到合适的总经理并让贤</li>
<li>创业公司的总经理必须是股东，因为屁股决定脑袋</li>
<li>总经理需要具备什么素质？</li>
<li>总经理要什么素质？1，有事业心；2，有战略水平；3，有胸怀；4，心理素质好；5，学习能力强</li>
<li>技术专家做总经理非常危险，技术专家易陷误区：1，技术自负，把技术等同于经营；2，藐视管理，崇尚自由，拒绝规范；3，独享心态，不认同产业链，妄图自己全部自力更生；4，拒绝授权，只愿意自己把握航向自己决策，不愿意授权</li>
<li>如何当总经理</li>
<li>总经理的职责：1，对行业的认知；2，打造企业文化；3，设计管理工具；4，建班子、定战略、带队伍；</li>
</ul>
<h4 id="军规22-企业文化必须一开始就建立：制度早建、规矩早定、丑话早说"><a href="#军规22-企业文化必须一开始就建立：制度早建、规矩早定、丑话早说" class="headerlink" title="军规22 企业文化必须一开始就建立：制度早建、规矩早定、丑话早说"></a>军规22 企业文化必须一开始就建立：制度早建、规矩早定、丑话早说</h4><ul>
<li>企业文化要尽早建立</li>
<li>没有好的企业文化就没有好的企业，企业文化包括企业的核心价值观、方法论以及战术原则</li>
<li>企业文化特征：1，为愿景使命服务的；2，是品牌的重要组成部分；3，因时而变，因势而变，与时俱进</li>
<li>生存重要还是文化重要？越是小公司、越是创业公司，越需要企业文化；你要带领一群人去未知的远方，人家凭什么？ </li>
<li>文化是企业战斗力的倍增器</li>
<li>核心价值观创造企业的凝聚力</li>
<li>方法论提升我们的工作能力。拉卡拉的方法论：先问目的，再做推演，亲自打样，及时复盘</li>
<li>战术原则提高我们的工作水平</li>
<li>企业文化需要大力宣传</li>
<li>提出来，明确价值观，并分解为易于理解和执行的几个角度</li>
<li>天天讲，</li>
<li>身体力行：1,企业和领导正在做什么？2，已经做了什么？3，怎么做的？4，未来要做什么</li>
</ul>
<h4 id="军规23-管理是一门专业"><a href="#军规23-管理是一门专业" class="headerlink" title="军规23 管理是一门专业"></a>军规23 管理是一门专业</h4><ul>
<li>没有人生来就是管理者</li>
<li>创业最大的难题是创始人不懂管理</li>
<li>管理方法的核心就是三大要素：建班子、定战略、带队伍</li>
<li>不同阶段的企业用不同的方法管理</li>
<li>创业期公司的关键是抓业务，最忌讳的就是小公司大做</li>
<li>小公司的6个管理天条：1，由点及面式定战略，执行战略不撞南墙不回头；2，跟我冲而不是给我上；3，只做最低限度的规范化管理，以奖惩分明作为管理核心；4，精兵简政，聚焦目标做减法，给精兵发一个半人的钱让他做两个人的事；5，老事定指标精细化管理，新事设目标鼓励试错；6，先打样再推广，打样不怕慢，推广必须快</li>
<li>大公司管人</li>
<li>大公司管理的核心是通过管人来管事</li>
<li>分权管理，授权的核心：授对人，授对事，授对法</li>
</ul>
<h4 id="军规24-建班子是管理的首要问题"><a href="#军规24-建班子是管理的首要问题" class="headerlink" title="军规24 建班子是管理的首要问题"></a>军规24 建班子是管理的首要问题</h4><ul>
<li>一个好汉三个帮</li>
<li>班子领导非常重要，领导班子的核心是一把手</li>
<li>建班子是管理的首要问题</li>
<li>如何建班子</li>
<li>班子成员需要什么素质？1，把公司当命根子做；2，身经百战，有把聪明转化为智慧的能力；3，互补和团结</li>
<li>建班子四部曲：选对人、定核心、塑文化、建机制</li>
<li>一把手建班子注意问题：1，避免一言堂；2，充分调动班子成员的积极性；3，班子的调整机制</li>
</ul>
<h4 id="军规25-坚持战略和定战略同样重要"><a href="#军规25-坚持战略和定战略同样重要" class="headerlink" title="军规25 坚持战略和定战略同样重要"></a>军规25 坚持战略和定战略同样重要</h4><ul>
<li>定战略意义重大，核心是确定打法和领军人物！</li>
<li>四不做：1，没有合适领军人物的项目不做；2，没有下决心死磕的项目不做；3，不掌握主动权的项目不做；4，无法复制的项目不做</li>
<li>如何定战略 </li>
<li>联想的战略七步法：1，设定愿景；2，设定战略目标；3，制定战略路线，要有清晰的打法；4，确定领军人物，千万不要“凑合”；5，战术分解，沙盘上推演不出的结果，实战中根本不可能达成；6，确定组织结构和预算；7，考核激励，及时复盘调整</li>
<li>执行战略的过程就是坚持战略的过程</li>
<li>经常复盘校正战略</li>
<li>撞了南墙再考虑调整战略</li>
</ul>
<h4 id="军规26-打造一支铁军"><a href="#军规26-打造一支铁军" class="headerlink" title="军规26 打造一支铁军"></a>军规26 打造一支铁军</h4><ul>
<li>带出一支铁军才能战无不胜</li>
<li>让员工“入模”</li>
<li>打胜仗只能靠我们自己的队伍，不要相信外来的和尚会念经，一定要清楚引入新人是对我们队伍的补充而非代替，引入新人必须要融入队伍。</li>
<li>选好材才能带好兵</li>
<li>“三心”用人标准，员工必须要有责任心，中层干部要有上进心，核心高管必须要有事业心 </li>
<li>什么样的人有潜力：事业心、有韧劲和善总结 </li>
<li>如何带队伍</li>
<li>建立有效的组织结构</li>
<li>建立管理模式，拉卡拉管理模式：设目标，做计划，抓考评和理规范</li>
<li>宣贯文化</li>
<li>建立培训体系</li>
</ul>
<h4 id="军规27-物质激励是第一位的"><a href="#军规27-物质激励是第一位的" class="headerlink" title="军规27 物质激励是第一位的"></a>军规27 物质激励是第一位的</h4><ul>
<li>人人都需要激励，都喜欢激励</li>
<li>多激励少惩罚。激励业务，惩治违规</li>
<li>公司必须建立起一套激励体系</li>
<li>比较通用的激励方法：中低级岗位现金激励，中高级岗位现金+期权，高级岗位期权激励</li>
<li>激励的三大误区</li>
<li>误区1，只讲物质激励，特别是只讲钱</li>
<li>误区2，学而优则仕式奖励，记住并不是所有人都有管理控制他人的能力和欲望</li>
<li>误区3，江湖式分配，记住革命不是靠自觉</li>
<li>激励的三大原则</li>
<li>公平是激励的第一原则，要杜绝大锅饭</li>
<li>红包式激励不可取，激励必须是可预见的，可计算的</li>
<li>激励必须和严格的目标考评配套</li>
<li>高效激励的4个原则</li>
<li>1，物质激励与精神激励相结合</li>
<li>2，当期激励与远期激励相结合，奖惩的时效性远比奖惩的力度更重要，远期激励可以增大员工的离职成本</li>
<li>3，现金激励与期权激励相结合</li>
<li>4，单场奖和连胜奖相结合</li>
</ul>
<h4 id="军规28-不要搞大跃进，大跃进的必然结果就是大倒退！"><a href="#军规28-不要搞大跃进，大跃进的必然结果就是大倒退！" class="headerlink" title="军规28 不要搞大跃进，大跃进的必然结果就是大倒退！"></a>军规28 不要搞大跃进，大跃进的必然结果就是大倒退！</h4><ul>
<li>成功没有捷径</li>
<li>做企业是跑长跑，要快速启动，迅速行动，但过程之中要一步一步来</li>
<li>创业者要有过程感，不要急于求成</li>
<li>俞永福的企业发展“三关”论</li>
<li>产品关，关注于产品本身，而不是技术深度或者营销策略！</li>
<li>市场关，要学会自己尝试，独自开创出一条适合自己的道路来</li>
<li>管理关，创业初期犯错成本不高，但随着业务发展，代价必然直线上升。因此企业必须建立相关的规范管理制度</li>
<li>企业发展速度要按经济规律来</li>
<li>革命晚成功半年又如何？任何时候做事的关键都是控制，让一切在你的控制之内比速度力度都重要，革命可以晚成功但不能翻车</li>
<li>出来混总是要还的。企业的发展速度并非越快越好</li>
</ul>
<h4 id="军规29-先试点再推广"><a href="#军规29-先试点再推广" class="headerlink" title="军规29 先试点再推广"></a>军规29 先试点再推广</h4><ul>
<li>推广前先试点</li>
<li>先试点，一般情况下试点要找一个有代表性的，但又不是主要市场的地方展开，核心是验证想法是否可行，拿出有说服力的数据来！不要认为自己是产品的用户！</li>
<li>榜样的力量是无穷的</li>
<li>营销的核心是找到推广方法</li>
<li>企业经营重在两件事：营销和创新</li>
<li>营销的核心是找到可复制的推广方法，特点：1，能够产生规模销量；2，简单且可复制；3，投入产出比合适</li>
<li>如何试点</li>
<li>一般而言试点目的：1，验证方法是否可行；2，抓数据，量化方案；3，写菜谱，形成手册，让所有的人可以复制</li>
<li>推广之前必须打样，方法：1，亲自抓；2，可复制；3，要抠细节；4，打样的过程要细；5，要写手册</li>
</ul>
<h4 id="军规30-坚持是必须的，维持是没有意义的"><a href="#军规30-坚持是必须的，维持是没有意义的" class="headerlink" title="军规30 坚持是必须的，维持是没有意义的"></a>军规30 坚持是必须的，维持是没有意义的</h4><ul>
<li>转型不是失败，为了维持的维持才是最大的失败</li>
<li>几乎所有的成功都历经磨难</li>
<li>几乎所有伟大的公司都经历过转型</li>
<li>维持没有意义</li>
<li>分清坚持还是维持，要学会跳出画面看画，必须让自己脱离公司的日常事务</li>
<li>抬头看路比低头拉车更重要</li>
</ul>
<h4 id="军规31-成功后不折腾"><a href="#军规31-成功后不折腾" class="headerlink" title="军规31 成功后不折腾"></a>军规31 成功后不折腾</h4><ul>
<li>成功后不要头脑发热</li>
<li>多元化要慎重，首先隔行如隔山，其次多元化会导致资源分散，管理能力不足</li>
<li>加速度要节制，重要的是可持续增长</li>
<li>不要被转件忽悠</li>
<li>纸上谈兵的正规化对企业有害无利，要善于揣摩、借鉴别人的管理经验，但绝不能生搬硬套</li>
<li>靠专家建议定战略基本上没戏!战略是一门实践科学，记住不在其位不谋其政，不担其责</li>
<li>要敢于坚守自己的成功之道。谦虚是好事，但不能怀疑自己，尤其不要邯郸学步。管理要改良而不是革命</li>
</ul>
<h4 id="军规32-借助资本的力量创业"><a href="#军规32-借助资本的力量创业" class="headerlink" title="军规32 借助资本的力量创业"></a>军规32 借助资本的力量创业</h4><ul>
<li>现在是资本时代</li>
<li>资本的介入已经改变了企业的成长周期</li>
<li>只有用好资本才能成功</li>
<li>不融资就会输在起跑线上</li>
<li>借助资本的力量加快发张速度</li>
<li>和最强的资本结合</li>
<li>学会和资本打交道是创始人的必修课</li>
</ul>
<h4 id="军规33-融资要敢于吃亏"><a href="#军规33-融资要敢于吃亏" class="headerlink" title="军规33 融资要敢于吃亏"></a>军规33 融资要敢于吃亏</h4><ul>
<li>别相信那些融资神话，企业融不到资是常态</li>
<li>想清楚缺钱干什么再去融资</li>
<li>竭尽全力之后再去融资。自己的钱都不敢花，别人凭什么给你钱？做好你的事，钱会来找你的</li>
<li>尽可能多的验证你的想法</li>
<li>融资要找对人，一般而言只有合伙人在基金中才能发挥作用，只有决策委员会才能最终决策</li>
<li>融资的窍门是吃亏，融资的三个窍门：1，融资价格要低点儿；2，融资规模要小点儿；3，融资时间要早点儿</li>
</ul>
<h4 id="军规34-风险投资只是你的一段情"><a href="#军规34-风险投资只是你的一段情" class="headerlink" title="军规34 风险投资只是你的一段情"></a>军规34 风险投资只是你的一段情</h4><ul>
<li>风险投资进入企业的唯一目的是获利退出</li>
<li>不要指望投资人能帮你钱以外的事情</li>
<li>克服融资时的“弱势”心理</li>
<li>不要被“战略投资”控制</li>
<li>不要被team sheet忽悠，team sheet几投资条款清单</li>
<li>不要“卖”了公司</li>
</ul>
<h4 id="军规35-任何时候都不要让投资人替你决策"><a href="#军规35-任何时候都不要让投资人替你决策" class="headerlink" title="军规35 任何时候都不要让投资人替你决策"></a>军规35 任何时候都不要让投资人替你决策</h4><ul>
<li>投资人和公司不在一条船上</li>
<li>投资人和公司的利益即统一有对立</li>
<li>投资人不是陪伴企业终生的人</li>
<li>投资人代表的尴尬地位</li>
<li>融资条款很关键</li>
<li>所谓的行业惯例条款都是可以改的 </li>
<li>记住你才是企业的主人</li>
<li>任何时候都不要放弃你对公司的责任</li>
<li>不要对赌</li>
</ul>
<h4 id="军规36-不要为了上市而上市"><a href="#军规36-不要为了上市而上市" class="headerlink" title="军规36 不要为了上市而上市"></a>军规36 不要为了上市而上市</h4><ul>
<li>上市不是目的</li>
<li>上市时企业的成人礼</li>
<li>上市能够极大的促进企业的规范发展</li>
<li>上市不是判断企业是否成功的标准</li>
<li>下决心上市才能成功</li>
<li>只有横下一条心上市才可能成功</li>
<li>漫长的国内上市路</li>
<li>上市之后，考试才刚刚开始</li>
<li>包装上市不可取 </li>
</ul>
<h3 id="附录：名将是怎样炼成的"><a href="#附录：名将是怎样炼成的" class="headerlink" title="附录：名将是怎样炼成的"></a>附录：名将是怎样炼成的</h3><p>&emsp;&emsp;名将学校开学了，第一个年级要学习的是军事理论。所有想成为名将的人，必须要学习一些经典的理论知识，包括孙子兵法、吴子兵法等等，只有在积累了大量的理论知识后，你才能跨入下一个年级，但这个年纪有一个很特殊的规定，因为有些同学家里穷，买不起书本，所以他们只能在实战中去学习这些理论。他们之中的优秀代表就是李云龙同学。<br><br>&emsp;&emsp;穷人家的孩子早当家，实在没有说错的，这些在实战中学习理论的同学将可以跳过第二个程序，直接进入第三个程序。<br><br>&emsp;&emsp;我们还是和大多数同学一起，来看看第二个年级要学习些什么，第二个年级学习的内容是实战。这是极为重要的，那些理论中学习的优秀者如果不能过这一关，他们就将被授予一个光荣的称号–纸上谈兵，这个称号的第一个获得者是赵括同学，授予者是二年级的年级主任赵奢。<br><br>&emsp;&emsp;我们来解释一下为什么实战如此重要，这是因为虽然军事理论都是高年级的学长们经验总结，但由于他们写这些东西的时候，情况和现状是不完全一样的，在实战中，如果照搬是要吃大亏的。赵括同学就是没有学好，才不能毕业的。<br><br>&emsp;&emsp;作为一个学员，想成为名将，一般都是从小兵干起，当然除了**外，比如赵括同学，由于年级主任赵奢是他父亲，所以他一开始就是大将，这是不妥当的。<br><br>&emsp;&emsp;因为只有战场才能让一个人成为真正的名将，他必须亲手持刀去追击敌人，见识战场的惨烈，明白人被刀砍是要死的，了解你不杀我，我就杀你这条战场上永不过时的真理，知道所谓打仗就是以性命相搏，他们才会明白什么是战场，什么是实战。<br><br>&emsp;&emsp;大多数学员会在这一关被淘汰，他们会改行，一生当一个军事票友，这对他们来说并不见得是一件坏事。<br><br>&emsp;&emsp;而留存下来的那些学员，在残酷的实战中逐渐了解了战争的规律，开始真正走上名将之路。<br><br>&emsp;&emsp;好了，我们带领剩下的学员来到三年级，三年级要学习的是冷酷。<br><br>&emsp;&emsp;成为一个名将，就必须和仁慈、温和之类的名词说再见，他必须心如铁石，冷酷无情，当然历史上也有很多以仁出名的儒将，但请大家注意，他们的仁是对士兵和老百姓而言的，对敌人他们比谁都冷酷。<br><br>&emsp;&emsp;所谓仁不带兵，义不行贾，冷酷不是残忍，不是杀戮无辜的老百姓，而是坚忍，比如你的一个很好的朋友触犯了军纪，但你为了执行军纪，一定要杀了他，只有这样，你才能控制军队，即使他是你最要好的朋友，甚至是你的亲人，你也要这样做。<br><br>&emsp;&emsp;这才是真正的冷酷！<br><br>&emsp;&emsp;学员们将在战场上学会冷酷，他们可能都是善良的年轻人，平时从不与人争吵，但当他们走上战场，亲眼看到自己的同乡和战友被敌人杀死，或者身负重伤在地上痛苦的呻吟，他们会被愤怒和痛苦所鼓动，毫不留情的杀死一切与自己敌对的人，给地上的伤兵补上一刀，然后一个人在尸体旁边喃喃自语，就在这地狱一般的环境中，他们变了。<br><br>&emsp;&emsp;从杀鸡都怕见血到敌人的脑浆和鲜血溅到身上浑然不知，从温文尔雅到冷酷无情，他们在残酷的环境中毕业了，不合格者将被淘汰，而那些心如坚石的人将进入四年级的学习，他们离成为名将越来越近。<br><br>&emsp;&emsp;四年级要学习的是理智，这也是极为重要的一个环节，我们作为普通人，生活中会被许多事情左右自己的情绪，比如买彩票中个二等奖几百块，你也会高兴半天，要是炒股票赚了大钱，就更不用说了。那么如果你玩的游戏是以人命为赌注呢？你会有何反应。<br><br>&emsp;&emsp;当你在极度紧张的环境中与敌人僵持了很长时间，突然敌人退却了，你能遏制住心中的激动，先判断形势再去追击吗？当你抵挡不住敌人的进攻，全军即将崩溃时，你能及时冷静下来，发现敌人的弱点吗？<br><br>&emsp;&emsp;是的，这太难了，我们都是凡人，都有感情，容易激动，而我们的学员们就必须保持冷静和理智，在任何时候都不被感情左右，就如同赛车一样，赛车是一项激情四射的运动，然而车手却必须保持绝对的冷静。<br><br>&emsp;&emsp;这就是四年级学员要做到的，能过这一关的人，已经很少了，剩下的精英们，我们继续前进！<br><br>&emsp;&emsp;五年级是最重要的一个年级，在这个年级里，学员们要学习的是判断。<br><br>&emsp;&emsp;这是名将的重要特征，不需要理由，不需要依据，你能依靠的就是你自己的判断。你要明白的是，你所掌握的是无数士兵的生命，而所有的人都等着你拿注意。<br><br>&emsp;&emsp;小兵只管打仗，遇到问题，他会问伍长，伍长会问百户，百户会问千户，千户问指挥，你就是指挥，你还能去问谁？！<br><br>&emsp;&emsp;在士兵的眼中，你就是上帝，就是主宰世界的神！他们能否活下来就看你的了！<br><br>&emsp;&emsp;兵法之所以奇妙，关键在于一个变字，所谓善出奇者，无穷如天地，不竭如江海！战场是一个瞬息万变的世界，决断只在一线之间，进攻还是防守，前进还是退却，都要你拿注意，在你身边也许有一大群参谋，但他们往往并不站在真理一边，决断的还是你。如果参谋比你高明，为什么要你当主帅？！<br><br>&emsp;&emsp;如果你能从那变化莫测的世界中，发现其中的奥妙，并就此做出正确的决断，那么恭喜你，你已经具备了名将最主要的素质。但是还有一关是你必须通过的，只有过了这一关，你才是真正的名将。<br><br>&emsp;&emsp;现在我们来到最后一个年级，这个年级我们要学习的是坚强。<br><br>&emsp;&emsp;从某种意义上说，这是非常重要的一个学习内容，所谓胜败兵家常事，不过安慰自己而已，打了败仗，死几万人，你能承受这样的心理压力吗，你怎么去面对那些士兵的家人，怎么有脸去见将指挥权交给你的上级？那是几万人命，不是几万只鸡！<br><br>&emsp;&emsp;然而你的选择只能是坚强，即使你屡战屡败，但必须屡败屡战！我们可以想象，当你数次败在同一个人手下时，你会畏惧这个人，所谓的恐某症就是这么来的，即使你有着杰出的军事才能，不能战胜自己的软弱，还是不能成为名将的。<br><br>&emsp;&emsp;而那些最优秀的人能够从失败中爬起来，去挑战那个多次战胜自己的人，这才是坚强！<br><br>&emsp;&emsp;当你具备了以上所有条件后，你就成为了真正的名将，但还有一点，是你必须具备的，那就是运气。<br><br>&emsp;&emsp;说起来似乎有点滑稽，这也是很重要的一个因素，没准就在你万事俱备，准备大展身手时，一支冷箭射来，就此死掉，那才是比窦娥还冤，你的一切抱负和能力都无法展现了。战史上只会这样记载，某年某月某日，某某人在战场上被不知名小兵射死，其人具体情况不详。<br><br>&emsp;&emsp;所以名将之路是一条艰苦的道路，非大智大勇，大吉大利之人不能为。<br><br>&emsp;&emsp;故兵无常势，水无常形。能因敌变化而取胜者，谓之神。<br><br>&emsp;&emsp;在这变化无穷的战场上，要想成为真正的军神，你必须在一次次的残杀中幸存下来，看着周围的人死去，忍受无尽的痛苦，在战争中学习战争，努力获取那不为人知的奥秘和规律，经历无数次失败，有勇气从无数士兵的尸体上站立起来，去打败对手。<br><br>&emsp;&emsp;这才是真正的名将之路，一条痛苦、孤独、血腥的道路，在这条路上，能信任和依靠的人只有你自己。但只要你走到终点，光荣和胜利就会在那里等待着你。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>动画3：核心动画高级技巧笔记</title>
    <url>/2016/08/25/%E5%8A%A8%E7%94%BB3%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>参考：<a href="https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="noopener">https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques</a></p>
<ul>
<li>UIView和CAlayer关系：UIView处理交互，CAlayer处理渲染</li>
<li>CALayer的contents属性，如果赋值不是CGImage，那么图层将是空白的</li>
<li>CALayer的contentsGravity属性决定填充样式</li>
<li>layer.contentsScale = [UIScreen mainScreen].scale;</li>
<li>contentsRect 裁切显示一部分</li>
<li>contentsCenter 定义了固定边界和可拉伸区域</li>
<li>CALayerDelegate</li>
<li>anchorPoint 锚点</li>
<li>坐标转化：convertPoint: fromLayer 同  convertPoint: fromView:</li>
<li>zPosition 可以设置layer显示层级，但最好不用</li>
<li>CALayer不支持自动布局，想要调整最好用delegate方法layoutSublayersOfLayer</li>
<li>cornerRadius 圆角</li>
<li>masksToBound 剪切</li>
<li>borderWidth 和 borderColor</li>
<li>shadowColor，shadowOffset和shadowRadius</li>
<li>mask蒙层的color其实无关紧要，重要的是实心部分会保留，其它抛弃</li>
<li>CALayer为此提供了三种拉伸过滤方法，他们是：kCAFilterLinear，kCAFilterNearest，kCAFilterTrilinear。minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear</li>
<li>使用shouldRasterize属性解决组透明问题</li>
<li>CAShapeLayer能通过CGPath来表示形状</li>
<li>CATextLayer使用了Core text，用于文字绘制</li>
<li>CATransformLayer 解决3D变化</li>
<li>CAGradientLayer是用来生成两种或更多颜色平滑渐变的</li>
<li>CAReplicatorLayer的目的是为了高效生成许多相似的图层，使用CAReplicatorLayer并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果</li>
<li>UIScrollView并没有用CAScrollLayer</li>
<li>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入</li>
<li>CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果</li>
<li>CAEAGLLayer是CALayer的一个子类，用来显示任意的OpenGL图形</li>
<li>AVPlayerLayer是用来在iOS上播放视频的</li>
<li>[CATransaction begin]; 。。。。。。   [CATransaction commit];</li>
<li>动画过程中可以通过-presentationLayer方法来访问图层，但是它的属性值代表了在任何指定时刻当前外观效果</li>
<li>把图层的speed设置成0，它会暂停任何添加到图层上的动画。类似的，设置speed大于1.0将会快进，设置成一个负值将会倒回动画</li>
<li>设置speed为0，然后来使用timeOffset让你手动控制动画</li>
<li>异步绘制，然后将由此绘出的图片直接设置为图层的内容。Core Animation提供了一些选择：CATiledLayer和drawsAsynchronously属性</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>单例的利与弊</title>
    <url>/2016/01/18/%E5%8D%95%E4%BE%8B%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A/</url>
    <content><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li>概念：一个单例类，在整个程序中只有一个实例，并且提供一个类方法供全局调用，在编译时初始化这个类，然后一直保存在内存中，到程序（APP）退出时由系统自动释放这部分内存。</li>
<li>存储位置：全局区</li>
<li>系统的单例：UIApplication、NSNotificationCenter、NSFileManager、NSUserDefaults</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li><p>通用版单例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (ZKSingleManager *)sharedInstance &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static ZKSingleManager *instance = nil;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">if (instance == nil) &#123;</span><br><span class="line">instance = [[ZKSingleManager alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>严格版单例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ZKSingleManager : NSObject</span><br><span class="line">+ (ZKSingleManager *)sharedInstance;</span><br><span class="line"></span><br><span class="line">// NS_UNAVAILABLE 表示禁止此方法调用</span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">// 效果同上，但可以带上文字说明</span><br><span class="line">+ (instancetype)new __attribute__((unavailable(&quot;单例只能通过sharedInstance初始化&quot;)));</span><br><span class="line">- (id)copy  __attribute__((unavailable(&quot;单例禁止深拷贝&quot;)));</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ZKSingleManager.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKSingleManager</span><br><span class="line"></span><br><span class="line">+ (ZKSingleManager *)sharedInstance &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static ZKSingleManager *instance = nil;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">if (instance == nil) &#123;</span><br><span class="line">instance = [[ZKSingleManager alloc] initPrivate];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initPrivate &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h4><ul>
<li>优点：1、在整个程序中只会实例化一次，所以在程序如果出了问题，可以快速的定位问题所在；2、由于在整个程序中只存在一个对象，节省了系统内存资源，提高了程序的运行效率；</li>
<li>缺点:1、不能被继承，不能有子类；2、不易被重写或扩展（可以使用分类）；3、同时，由于单例对象只要程序在运行中就会一直占用系统内存，该对象在闲置时并不能销毁，在闲置时也消耗了系统内存资源；</li>
</ul>
<h4 id="当你使用单例的时候-你需要问自己以下四个问题"><a href="#当你使用单例的时候-你需要问自己以下四个问题" class="headerlink" title="当你使用单例的时候 你需要问自己以下四个问题"></a>当你使用单例的时候 你需要问自己以下四个问题</h4><ol>
<li>这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？; </li>
<li>这个单例持有的内存一直存在；</li>
<li>是否能用类方法代替？；  </li>
<li>这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为另一个单例的属性</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://objccn.io/issue-13-2/" target="_blank" rel="noopener">避免滥用单例</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>卡顿优化</title>
    <url>/2017/07/30/%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>&emsp;&emsp;iOS卡顿优化其实已经烂大街了，网上全都是各种各样的文章！所有操作无非就两件事：降低主线程工作和降低CPU工作。常用策略：</p>
<ul>
<li>少创建、更改对象</li>
<li>少用图层混合、透明、阴影、裁切</li>
<li>少用图片拉伸</li>
<li>能让小弟（子线程）干的让小弟干</li>
<li>缓存、缓存和缓存，让下一次更快速</li>
<li>提前、提前和提前，让这一次更快速</li>
</ul>
<p>&emsp;&emsp;等等等等…</p>
<p>&emsp;&emsp;但实际开发中确实：WC这个clearColor需保留，NM那个阴影不能改，神马鬼缓存更新不及时、shit提前计算有偏差…到最后就变成了：管它合适不合适，用<a href="https://www.cnblogs.com/lxlx1798/p/6933604.html" target="_blank" rel="noopener">Time Profiler</a>查出来的耗时高就改改!其它…真的不是不想改，而是不敢改、不能改甚至不愿意改</p>
<h3 id="1-优化记录"><a href="#1-优化记录" class="headerlink" title="1 优化记录"></a>1 优化记录</h3><p>&emsp;&emsp;好了，吐槽吐完了！该来的总会来，该改的也总的改，逃是逃不过去的！先水水为期2期的卡顿优化我们都干了啥</p>
<h4 id="1-推动Crab平台升级"><a href="#1-推动Crab平台升级" class="headerlink" title="1 推动Crab平台升级"></a>1 推动Crab平台升级</h4><p>&emsp;&emsp;如果我告诉你我们一半以上的卡顿都是监控卡顿的三方库造成的，你会不会很惊讶？我们也很惊讶！怪不得手百要自研APM(刚开始真的推不动以至于我们也想造轮子，但领导不同意)！因为CrabSDK集成了<a href="https://github.com/plausiblelabs/plcrashreporter" target="_blank" rel="noopener">plcrashreporter</a>直接在卡顿时进行符号化，结果就是本来是卡顿，经过plcrashreporter变成了卡死！！！当然推动SDK更新也没啥好办法，只能每天”打卡“式催进度…</p>
<p>&emsp;&emsp;其实还有BPush的SDK也很卡（想不明白一个pushSDK为啥要卡主线程）也是推动升级来解决的…</p>
<p>&emsp;&emsp;催进度过程中倒学了点经验，最最主要”别把这事当个事，也别把这事不当事！“</p>
<ol>
<li>放平心态：谁都知道能动手码代码就别废话，但这次你需要废话！所以一定要放平心态：就当是做销售练习吧</li>
<li>要有礼貌：都说理工男情商低，程序员就更不用说了！但催进度时，你不是程序员，你有求于人，所以一定要有礼貌！什么谢谢、好的、能不能、稍微啥的该上就得上！就当你社会课没上完，进行再教育呢</li>
<li>要有耐心：程序员都追求效率，恨不得能让机器干的都让机器干！这次，不好意思，你对面那个是”大爷“不是机器，你除了供着就只能等着！着急也没用</li>
</ol>
<h4 id="2-等比缩放"><a href="#2-等比缩放" class="headerlink" title="2 等比缩放"></a>2 等比缩放</h4><p>&emsp;&emsp;这个就是一个超级大坑，之前UI就推行了一套所谓的等比缩放方案，举个例子：在iphone5上展示要等比例缩放iphone6上！如果所有的都等比例缩放也许还比较好处理一点，但UI又要求左右两边间距必须是40px，只有中间内容缩放、1像素横线边框线不缩放等等，到最后的实现方案布局约束都是一个计算函数和一个找补函数。这样就带来了一堆问题</p>
<ol>
<li>频繁函数计算，特别是浮点数实时计算！</li>
<li>大量的”找补“方法，神奇数字！</li>
<li>层级复杂，为了正确显示效果，不得不增加无用图层</li>
<li>频繁刷新，layoutIfNeed满大街都是</li>
<li>复用率低，很多cell刷新是都会将subview都刷一下，防止”对不齐“</li>
<li>开发效率低</li>
</ol>
<p>&emsp;&emsp;结合以上问题，试验了几种方法</p>
<h4 id="2-1-异步渲染内容到图片"><a href="#2-1-异步渲染内容到图片" class="headerlink" title="2.1 异步渲染内容到图片"></a>2.1 异步渲染内容到图片</h4><p>&emsp;&emsp;参考：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a>注意Dome中可能会出现几十个线程卡顿问题，那是因为global最多也就64个线程，超了就卡了</p>
<ul>
<li>好处：1、充分利用GPU和CPU； 2、减少view层级</li>
<li>坏处：1、代码较多； 2、预先计算，增加VM层；</li>
<li>结论：被弃！修改起来成本较高，后续新增可考虑</li>
</ul>
<h4 id="2-2-类似微信读配置文件"><a href="#2-2-类似微信读配置文件" class="headerlink" title="2.2 类似微信读配置文件"></a>2.2 类似微信读配置文件</h4><ul>
<li>好处：1、灵活，以后可以做调整字体需求；2、避免复杂实时计算</li>
<li>坏处：1、配置文件和view的映射关系复杂；2、复杂约束难以表达；3、调试麻烦</li>
<li>结论：被弃！因为开发调试实在是太麻烦了，重构一个简单的小页面都累死个人</li>
</ul>
<h4 id="2-3-折中方案"><a href="#2-3-折中方案" class="headerlink" title="2.3 折中方案"></a>2.3 折中方案</h4><ol>
<li>绝大多数model因打点需求都包含id字段，可重写isEqual来判断model是否改变来减少刷新次数</li>
<li>将cell刷新方法拆分refreshContent和refreshFrame两个，将cell分类，对更新数据源只调整显示不调整frame的cell高度进行缓存并只调动refreshContent</li>
<li>将大部分的layoutIfNeed替换成setNeedsLayout</li>
<li>小部分cell采用异步渲染到图片的方案：例如公告轮播、导航条</li>
</ol>
<h4 id="3-局部刷新"><a href="#3-局部刷新" class="headerlink" title="3 局部刷新"></a>3 局部刷新</h4><p>&emsp;&emsp;简单的说就几条</p>
<ol>
<li>tablview等只刷新标记需要刷新的cell。我们采用的方式是通过新旧数据源isEqual来判断哪些cell需要刷新，另外允许cell改变自身数据源时回调tableview刷新自己</li>
<li>基金排行等类似页面巧用childViewController来延迟加载延迟刷新</li>
<li>hidden VS 懒加载，我个人认为不涉及到约束改变使用懒加载，涉及到约束更改用hidden！例如登录和未登录的头部信息，完全互斥，以前代码是都加载通过hidden来处理，现在改成了懒加载！毕竟一般人不会来回登录着玩，登录了十几天也不一定退一次</li>
</ol>
<h4 id="4-按需加载被废弃"><a href="#4-按需加载被废弃" class="headerlink" title="4 按需加载被废弃"></a>4 按需加载<del>被废弃</del></h4><p>&emsp;&emsp;废弃原因：PM和领导觉得一共也没多少数据还显示默认图不能接受！而且没有上拉加载更多，这个功能比较鸡肋…</p>
<p>&emsp;&emsp;一样可参考：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a>，核心原理就是检测滑动状态，只加载用户可见范围的cell</p>
<ol>
<li>可见cell的定义，需根据手机屏幕大小进行自定义，但这会增加代码复杂度</li>
<li>快速滑动可能出现白屏，建议用”默认图“代替</li>
<li>像首页这种多接口内容拼接而成并且支持服务端排序的页面不合适</li>
</ol>
<h4 id="5-资源同步改异步"><a href="#5-资源同步改异步" class="headerlink" title="5 资源同步改异步"></a>5 资源同步改异步</h4><ol>
<li>竟然在mian使用dataWithContentsOfURL方法同步下载头像！着实吓了我一跳，犹豫半天问了好几圈才敢改代码</li>
<li>使用imageNamed方法批量加载小图片（48个），imageNamed方法一般情况下还是很好用的，但像这种批量加载小图片还是建议异步使用imageWithContentsOfFile方法然后NSArray内存缓存的方式实现</li>
</ol>
<h4 id="6-少用-synchronized，少在主线程深拷贝"><a href="#6-少用-synchronized，少在主线程深拷贝" class="headerlink" title="6 少用@synchronized，少在主线程深拷贝"></a>6 少用@synchronized，少在主线程深拷贝</h4><p>&emsp;&emsp;在使用Time Profiler检查耗时时，无意中发现项目里大量用了@synchronized锁，甚至很多锁都是不必要的，例如明显上下文都在主线程里也要加上@synchronized锁来确保安全。这个问题我在例会上提出来之后，也没人能解释为什么，估计就是历史遗留问题了！当然处理起来比较麻烦，因为不知道为什么，降级措施也不好处理，最终我也只去掉了3个锁的使用</p>
<p>&emsp;&emsp;几乎伴随着锁的就是在主线程中进行深拷贝，而且是整个页面数据的深拷贝！也许是为了安全，但确实有些烂用了，没必要addObject之类的操作都要深拷贝一份再操作</p>
<h4 id="7-减少图层混合"><a href="#7-减少图层混合" class="headerlink" title="7 减少图层混合"></a>7 减少图层混合</h4><p>&emsp;&emsp;推荐策略</p>
<ul>
<li>设opaque为YES、</li>
<li>设backgroundColor和父视图颜色一致且不透明、</li>
<li>不设 &lt;1 的alpha值</li>
<li>确保UIImage没有alpha通道</li>
</ul>
<p>&emsp;&emsp;怎么检测图层混合</p>
<ol>
<li>模拟器debug中color blended layers红色区域表示图层发生了混合</li>
<li>真机上Instrument-选中Core Animation-勾选Color Blended Layers</li>
</ol>
<p>&emsp;&emsp;注意事项：这个确实是体力活，更是个细心活，一定要注意上下文环境</p>
<h4 id="8-图片的使用"><a href="#8-图片的使用" class="headerlink" title="8 图片的使用"></a>8 图片的使用</h4><p>&emsp;&emsp;最麻烦的其实是找UI要图…提前准备好挨批的准备</p>
<ol>
<li>图片缩放问题，对于高频图片采用重绘方式避免重复拉伸。对低频拉伸图片争取让UI给合适大小的图</li>
<li>阴影和圆角都尽可能找图片代替</li>
<li>尽量使用png</li>
<li>尽量使用SD下载网络图片，因为SD已经在子线程解码图片</li>
</ol>
<h3 id="2-监控"><a href="#2-监控" class="headerlink" title="2 监控"></a>2 监控</h3><p>&emsp;&emsp;其实一开始不想写这个的！卡顿监控方案已经烂大街了，而且这种重复造轮子的算不得KPI（虽然crab这个破轮子卡的都快不能跑了）！但是PM说没感觉有什么太大效果，这个就不能忍了！</p>
<h4 id="1-runloop"><a href="#1-runloop" class="headerlink" title="1 runloop"></a>1 runloop</h4><p>&emsp;&emsp;这个算上市面上最通用的方案了，参考：<a href="http://www.tanhao.me/code/151113.html/" target="_blank" rel="noopener">iOS实时卡顿监控</a>，里面写的非常详细！核心思路：主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</span><br><span class="line">&#123;</span><br><span class="line">MyClass *object = (__bridge MyClass*)info;</span><br><span class="line"></span><br><span class="line">// 记录状态值</span><br><span class="line">object-&gt;activity = activity;</span><br><span class="line"></span><br><span class="line">// 发送信号</span><br><span class="line">dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line">- (void)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">kCFRunLoopAllActivities,</span><br><span class="line">YES,</span><br><span class="line">0,</span><br><span class="line">&amp;runLoopObserverCallBack,</span><br><span class="line">&amp;context);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">// 创建信号</span><br><span class="line">semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">// 在子线程监控时长</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">while (YES)</span><br><span class="line">&#123;</span><br><span class="line">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">if (st != 0)</span><br><span class="line">&#123;</span><br><span class="line">if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</span><br><span class="line">&#123;</span><br><span class="line">if (++timeoutCount &lt; 5)</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;好像有点儿卡哦&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">timeoutCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的</p>
<ol>
<li>dome里使用PLCrashReporter进行符号化会很卡</li>
<li>卡顿只dump主线程调用栈就可以了</li>
<li>调用栈也许有”延迟“</li>
</ol>
<h4 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2 子线程"></a>2 子线程</h4><p>&emsp;&emsp;这个思路及很有意思，简单的说就是不断的用子线程去主线程去撞：我打你一拳，你踢我一脚。过段时间你没踢我，你有问题！可参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&amp;mid=2650264136&amp;idx=1&amp;sn=052c1db8131d4bed8458b98e1ec0d5b0&amp;chksm=f406837dc3710a6b49e76ce3639f671373b553e8a91b544e82bb8747e9adc7985fea1093a394#rd" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a> , PS: 获取调用栈我觉得直接用<a href="https://github.com/plausiblelabs/plcrashreporter" target="_blank" rel="noopener">plcrashreporter</a>就好，plcrashreporter的核心原理：新期一个线程A，挂起除A外的所有线程，dump调用栈！另外对符号化感兴趣的，请阅读<a href="https://blog.csdn.net/abc649395594/article/details/52350426" target="_blank" rel="noopener">获取任意线程调用栈的那些事</a> 和 <a href="https://www.jianshu.com/p/29051908c74b" target="_blank" rel="noopener">iOS Crash 捕获及堆栈符号化思路剖析</a></p>
<p>&emsp;&emsp;一个swift版的三方库可做参考：<a href="https://github.com/zixun/ANREye" target="_blank" rel="noopener">ANREye</a></p>
<h4 id="3-组合拳"><a href="#3-组合拳" class="headerlink" title="3 组合拳"></a>3 组合拳</h4><p>&emsp;&esmp;参考<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ%3D%3D&amp;idx=1&amp;mid=207890859&amp;scene=23&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;srcid=0921FzoCw9j1W7n4uFYKuarC#rd" target="_blank" rel="noopener">微信iOS卡顿监控系统</a>，微信这个思路很全面，runloop、CPU、FPS都监控，[代码]<a href="https://aozhimin.github.io/iOS-Monitor-Platform/)如下：" target="_blank" rel="noopener">https://aozhimin.github.io/iOS-Monitor-Platform/)如下：</a></p>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark CPU</span><br><span class="line">// cpu利用率</span><br><span class="line">+ (CGFloat)cpuUsage &#123;</span><br><span class="line">kern_return_t kr;</span><br><span class="line">task_info_data_t tinfo;</span><br><span class="line">mach_msg_type_number_t task_info_count;</span><br><span class="line"></span><br><span class="line">task_info_count = TASK_INFO_MAX;</span><br><span class="line">kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_array_t         thread_list;</span><br><span class="line">mach_msg_type_number_t thread_count;</span><br><span class="line"></span><br><span class="line">thread_info_data_t     thinfo;</span><br><span class="line">mach_msg_type_number_t thread_info_count;</span><br><span class="line"></span><br><span class="line">thread_basic_info_t basic_info_th;</span><br><span class="line"></span><br><span class="line">// get threads in the task</span><br><span class="line">kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long total_time     = 0;</span><br><span class="line">long total_userTime = 0;</span><br><span class="line">CGFloat total_cpu   = 0;</span><br><span class="line">int j;</span><br><span class="line"></span><br><span class="line">// for each thread</span><br><span class="line">for (j = 0; j &lt; (int)thread_count; j++) &#123;</span><br><span class="line">thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">kr = thread_info(thread_list[j], THREAD_BASIC_INFO,</span><br><span class="line">(thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line"></span><br><span class="line">if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">total_time     = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">total_cpu      = total_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">return total_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CPU核数</span><br><span class="line">+ (NSUInteger)cpuNumber &#123;</span><br><span class="line">return [NSProcessInfo processInfo].processorCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//// CPU类型</span><br><span class="line">//+ (NSString *)cpuType &#123;</span><br><span class="line">//    host_basic_info_data_t hostInfo;</span><br><span class="line">//    mach_msg_type_number_t infoCount;</span><br><span class="line">//    infoCount = HOST_BASIC_INFO_COUNT;</span><br><span class="line">//    host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&amp;hostInfo, &amp;infoCount);</span><br><span class="line">//    switch (hostInfo.cpu_type) &#123;</span><br><span class="line">//        case CPU_TYPE_ARM64:</span><br><span class="line">//            return @&quot;ARM64&quot;;</span><br><span class="line">//            break;</span><br><span class="line">//            </span><br><span class="line">//        default:</span><br><span class="line">//            return @&quot;unknown&quot;;</span><br><span class="line">//            break;</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark 内存相关</span><br><span class="line">// 当前进程内存</span><br><span class="line">+ (long long)appUsedMemory &#123;</span><br><span class="line">struct mach_task_basic_info info;</span><br><span class="line">mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">int r = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp; info, &amp; count);</span><br><span class="line">if (r == KERN_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">return info.resident_size/MBSize;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 物理内存</span><br><span class="line">+ (long long)physicalMemory &#123;</span><br><span class="line">return [NSProcessInfo processInfo].physicalMemory/MBSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前设备已用内存</span><br><span class="line">+ (long long)deviceUsedMemory&#123;</span><br><span class="line">size_t length = 0;</span><br><span class="line">int mib[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int pagesize = 0;</span><br><span class="line">mib[0] = CTL_HW;</span><br><span class="line">mib[1] = HW_PAGESIZE;</span><br><span class="line">length = sizeof(pagesize);</span><br><span class="line">if (sysctl(mib, 2, &amp;pagesize, &amp;length, NULL, 0) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_msg_type_number_t count = HOST_VM_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">vm_statistics64_data_t vmstat;</span><br><span class="line"></span><br><span class="line">if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int wireMem = vmstat.wire_count * pagesize;</span><br><span class="line">int activeMem = vmstat.active_count * pagesize;</span><br><span class="line">return (wireMem + activeMem)/MBSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当前设备可用内存</span><br><span class="line">+ (long long)deviceFreeMemory &#123;</span><br><span class="line">size_t length = 0;</span><br><span class="line">int mib[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int pagesize = 0;</span><br><span class="line">mib[0] = CTL_HW;</span><br><span class="line">mib[1] = HW_PAGESIZE;</span><br><span class="line">length = sizeof(pagesize);</span><br><span class="line">if (sysctl(mib, 2, &amp;pagesize, &amp;length, NULL, 0) &lt; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_msg_type_number_t count = HOST_VM_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">vm_statistics64_data_t vmstat;</span><br><span class="line"></span><br><span class="line">if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int freeMem = vmstat.free_count * pagesize;</span><br><span class="line">int inactiveMem = vmstat.inactive_count * pagesize;</span><br><span class="line"></span><br><span class="line">return (freeMem + inactiveMem)/MBSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if( self )&#123;</span><br><span class="line">[self setup];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark FPS</span><br><span class="line"></span><br><span class="line">- (void)setup &#123;</span><br><span class="line">_updateInterval = 0.5f;</span><br><span class="line">_historyCount = 0;</span><br><span class="line">_historySum = 0;</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver: self</span><br><span class="line">selector: @selector(applicationWillResignActiveNotification)</span><br><span class="line">name: UIApplicationWillResignActiveNotification</span><br><span class="line">object: nil];</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver: self</span><br><span class="line">selector: @selector(applicationDidBecomeActiveNotification)</span><br><span class="line">name: UIApplicationDidBecomeActiveNotification</span><br><span class="line">object: nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startDisplayLink &#123;</span><br><span class="line">_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkProc)];</span><br><span class="line">[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopDisplayLink &#123;</span><br><span class="line">[_displayLink setPaused:YES];</span><br><span class="line">[_displayLink removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">[_displayLink invalidate];</span><br><span class="line">_displayLink = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActiveNotification &#123;</span><br><span class="line">[self.displayLink setPaused:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActiveNotification &#123;</span><br><span class="line">[self.displayLink setPaused:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不准有延迟</span><br><span class="line">- (void)displayLinkProc &#123;</span><br><span class="line">_historyCount += _displayLink.frameInterval;</span><br><span class="line"></span><br><span class="line">CFTimeInterval interval = _displayLink.timestamp - _lastTime;</span><br><span class="line">if( interval &gt;= _updateInterval ) &#123;</span><br><span class="line">_lastTime = _displayLink.timestamp;</span><br><span class="line">// 回调上层刷新展示</span><br><span class="line">NSUInteger fps = (NSUInteger)(_historyCount / interval);</span><br><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(frezingCheker:currentFPS:)]) &#123;</span><br><span class="line">[self.delegate frezingCheker:self currentFPS:fps];</span><br><span class="line">&#125;</span><br><span class="line">_fps = fps;</span><br><span class="line">_historyCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[self stopDisplayLink];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li>
<li><a href="https://aozhimin.github.io/iOS-Monitor-Platform/" target="_blank" rel="noopener">https://aozhimin.github.io/iOS-Monitor-Platform/</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>响应链</title>
    <url>/2016/05/03/%E5%93%8D%E5%BA%94%E9%93%BE/</url>
    <content><![CDATA[<p>&emsp;&emsp;响应链是啥？我也说不清，不管了，我就写点我知道的吧</p>
<p>&emsp;&emsp;最简单的查看响应链的方法就是递归打印nextResponder, 可见顺序是当前view一直到UIApplication的顺序，有view响应则此链中断<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">UIButton *btn1 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 300, 500)];</span><br><span class="line">btn1.backgroundColor = [UIColor redColor];</span><br><span class="line">[self.view addSubview:btn1];</span><br><span class="line">UIButton *btn2 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 250, 400)];</span><br><span class="line">btn2.backgroundColor = [UIColor blueColor];</span><br><span class="line">[btn1 addSubview:btn2];</span><br><span class="line">UIButton *btn3 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 200, 300)];</span><br><span class="line">btn3.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[btn2 addSubview:btn3];</span><br><span class="line"></span><br><span class="line">NSArray *arr = @[btn1, btn2, btn3];</span><br><span class="line">for (UIButton *btn in arr) &#123;</span><br><span class="line">[btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)btnClick:(UIButton *)btn &#123;</span><br><span class="line">[self logNextResponder:btn];</span><br><span class="line">&#125;</span><br><span class="line">- (void)logNextResponder:(UIResponder *)responder &#123;</span><br><span class="line">NSLog(@&quot;responder:%@&quot;,responder);</span><br><span class="line">UIResponder *next = responder.nextResponder;</span><br><span class="line">if (next) &#123;</span><br><span class="line">[self logNextResponder:next];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再说事件传递，就是点了下屏幕，系统时怎么知道“点击”的？点击之后，由UIApplication管理事件，然后递归查找最合适的view类接收事件！对的，跟nextResponder的顺序相反！但系统怎么知道到底是哪个view呢？毕竟UIApplication最“大”，点击的那个view只是大量subviews中的一个！这时需要借助两个UIView的函数：</p>
<ul>
<li>pointInside: withEvent: 用于判断某个事件是否在某个view的bound范围内</li>
<li>hitTest: withEvent: 用于判断某个view是否响应某个事件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">//首先判断是否可以接收事件</span><br><span class="line">if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</span><br><span class="line">//然后判断点是否在当前视图上</span><br><span class="line">if ([self pointInside:point withEvent:event] == NO) return nil;</span><br><span class="line">//循环遍历所有子视图，查找是否有最合适的视图</span><br><span class="line">for (NSInteger i = self.subviews.count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">UIView *childView = self.subviews[i];</span><br><span class="line">//转换点到子视图坐标系上</span><br><span class="line">CGPoint childPoint = [self convertPoint:point toView:childView];</span><br><span class="line">//递归查找是否存在最合适的view</span><br><span class="line">UIView *fitView = [childView hitTest:childPoint withEvent:event];</span><br><span class="line">//如果返回非空，说明子视图中找到了最合适的view，那么返回它</span><br><span class="line">if (fitView) &#123;</span><br><span class="line">return fitView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环结束，仍旧没有合适的子视图可以处理事件，那么就认为自己是最合适的view</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;pointInside: withEvent:的妙用，可控制view的响应范围</p>
<ul>
<li>例如扩大button的点击范围<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event &#123;</span><br><span class="line">CGRect bounds = self.bounds;</span><br><span class="line">CGFloat widthDelta = MAX(100.0 , bounds.size.height);;</span><br><span class="line">CGFloat heightDelta = MAX(100.0 , bounds.size.height);</span><br><span class="line">bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);</span><br><span class="line">return CGRectContainsPoint(bounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;hitTest: withEvent:的妙用，常用于事件透传或转发<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">CGPoint yellowPoint = [self convertPoint:point toView:_yellowView];</span><br><span class="line">if ([_yellowView pointInside:yellowPoint withEvent:event]) &#123;</span><br><span class="line">return _yellowView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;说实话，我很怀疑有些同志问的问题自己都说不清：你知道响应链吗？响应链是啥？呵呵，响应链是啥这种问题，叫我怎么回答？响应链要我说就是view的事件响应优先级！不过这么回答，肯定错了！他们想知道的是：为啥用hittest、pointinside，以及怎么用。。。。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.jianshu.com/p/36d2eb74fb23" target="_blank" rel="noopener">https://www.jianshu.com/p/36d2eb74fb23</a></li>
<li><a href="https://www.jianshu.com/p/2f664e71c527" target="_blank" rel="noopener">https://www.jianshu.com/p/2f664e71c527</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>图片处理1：常用工具</title>
    <url>/2016/06/12/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%861%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  UIImage+tool.m</span><br><span class="line">//  test</span><br><span class="line">//</span><br><span class="line">//  Created by JZK on 2016/7/4.</span><br><span class="line">//  Copyright © 2016 test. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;UIImage+tool.h&quot;</span><br><span class="line"></span><br><span class="line">static inline CGFloat DegreesToRadians(CGFloat degrees) &#123;</span><br><span class="line">return M_PI * (degrees / 180.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation UIImage (tool)</span><br><span class="line"></span><br><span class="line">#pragma mark 裁剪</span><br><span class="line"></span><br><span class="line">- (UIImage *)clipInRect:(CGRect)rect &#123;</span><br><span class="line">CGImageRef imageRef = CGImageCreateWithImageInRect([self CGImage], rect);</span><br><span class="line">UIImage *croppedImage = [UIImage imageWithCGImage:imageRef];</span><br><span class="line">CGImageRelease(imageRef);</span><br><span class="line">return croppedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 缩放</span><br><span class="line">//</span><br><span class="line">- (UIImage *)scaleToSize:(CGSize)size &#123;</span><br><span class="line">UIGraphicsBeginImageContext(size);</span><br><span class="line">[self drawInRect:CGRectMake(0 ,0 ,size.width ,size.height)];</span><br><span class="line">UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">// 整体缩放等比缩放</span><br><span class="line">- (UIImage *) scaleImageByScale:(float)scaleSize &#123;</span><br><span class="line">UIGraphicsBeginImageContext(CGSizeMake(self.size.width * scaleSize, self.size.height * scaleSize));</span><br><span class="line">[self drawInRect:CGRectMake(0, 0, self.size.width * scaleSize, self.size.height * scaleSize)];</span><br><span class="line">UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return scaledImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据给定bound画最高质量的图片</span><br><span class="line">- (UIImage *)resizedImageInBounds:(CGSize)bounds &#123;</span><br><span class="line">return [self resizedImageInBounds:bounds quality:kCGInterpolationHigh];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)resizedImageInBounds:(CGSize)bounds quality:(CGInterpolationQuality)quality &#123;</span><br><span class="line">// UIViewContentModeScaleAspectFit</span><br><span class="line">CGFloat horizontalRatio = bounds.width / self.size.width;</span><br><span class="line">CGFloat verticalRatio = bounds.height / self.size.height;</span><br><span class="line">CGFloat ratio = MIN(horizontalRatio, verticalRatio);</span><br><span class="line">CGSize newSize = CGSizeMake(self.size.width * ratio, self.size.height * ratio);</span><br><span class="line"></span><br><span class="line">CGAffineTransform transform = [self transformForOrientation:newSize];</span><br><span class="line"></span><br><span class="line">CGRect newRect = CGRectIntegral(CGRectMake(0, 0, newSize.width, newSize.height));</span><br><span class="line">CGRect toRect = CGRectMake(0, 0, newRect.size.height, newRect.size.width);</span><br><span class="line">CGImageRef imageRef = self.CGImage;</span><br><span class="line"></span><br><span class="line">CGContextRef bitmap = CGBitmapContextCreate(NULL,</span><br><span class="line">newRect.size.width,</span><br><span class="line">newRect.size.height,</span><br><span class="line">8,</span><br><span class="line">0,</span><br><span class="line">CGImageGetColorSpace(imageRef),</span><br><span class="line">kCGImageAlphaNoneSkipLast);</span><br><span class="line">CGContextConcatCTM(bitmap, transform);</span><br><span class="line">CGContextSetInterpolationQuality(bitmap, quality);</span><br><span class="line">CGContextDrawImage(bitmap, toRect, imageRef);</span><br><span class="line">// 或 UIGraphicsGetImageFromCurrentImageContext</span><br><span class="line">CGImageRef newImageRef = CGBitmapContextCreateImage(bitmap);</span><br><span class="line">UIImage *newImage = [UIImage imageWithCGImage:newImageRef];</span><br><span class="line"></span><br><span class="line">CGContextRelease(bitmap);</span><br><span class="line">CGImageRelease(newImageRef);</span><br><span class="line"></span><br><span class="line">return newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 拉伸</span><br><span class="line">// 使用中心点拉伸</span><br><span class="line">- (UIImage *)stretchableImageByCenter &#123;</span><br><span class="line">CGFloat leftCapWidth = floorf(self.size.width / 2);</span><br><span class="line">if (leftCapWidth == self.size.width / 2) &#123;</span><br><span class="line">leftCapWidth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat topCapHeight = floorf(self.size.height / 2);</span><br><span class="line">if (topCapHeight == self.size.height / 2) &#123;</span><br><span class="line">topCapHeight--;</span><br><span class="line">&#125;</span><br><span class="line">return [self stretchableImageWithLeftCapWidth:leftCapWidth</span><br><span class="line">topCapHeight:topCapHeight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">注意事项：</span><br><span class="line">1，UIEdgeInsets 上 左 下 右</span><br><span class="line">2，UIImageResizingMode 解释</span><br><span class="line">UIImageResizingModeTile：平铺模式，通过 重复 UIEdgeInsets指定的矩形区域来填充图</span><br><span class="line">UIImageResizingModeStretch：拉伸模式，通过 拉伸 UIEdgeInsets指定的矩形区域来填充图片</span><br><span class="line"></span><br><span class="line">[originImage resizableImageWithCapInsets:UIEdgeInsetsMake(10, 10, 10, 10) resizingMode:UIImageResizingModeStretch];</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark 旋转图片</span><br><span class="line">/*</span><br><span class="line">UIImageOrientationUp,            // 默认方向</span><br><span class="line">UIImageOrientationDown,          // 让默认方向旋转180度</span><br><span class="line">UIImageOrientationLeft,          // 让默认方向逆时针旋转90度</span><br><span class="line">UIImageOrientationRight,         // 让默认方向顺时针旋转90度</span><br><span class="line">UIImageOrientationUpMirrored,    // 默认方向的竖线镜像</span><br><span class="line">//（即以原图的左(或右)边的竖线为对称轴，对原图进行对称投影得到的镜像）</span><br><span class="line">UIImageOrientationDownMirrored,  // 让镜像旋转180度</span><br><span class="line">UIImageOrientationLeftMirrored,  // 让镜像逆时针旋转90度</span><br><span class="line">UIImageOrientationRightMirrored, // 让镜像顺时针旋转90度</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 按方向旋转图片</span><br><span class="line">- (UIImage *)rotatedByOrientation:(UIImageOrientation)orientation &#123;</span><br><span class="line">return [UIImage imageWithCGImage:self.CGImage scale:self.scale orientation:orientation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按角度旋转图片</span><br><span class="line">- (UIImage *)rotatedByDegrees:(CGFloat)degrees&#123;</span><br><span class="line"></span><br><span class="line">UIView *rotatedViewBox = [[UIView alloc] initWithFrame:CGRectMake(0,0,self.size.width, self.size.height)];</span><br><span class="line">// 逆时针旋转angle弧度</span><br><span class="line">CGAffineTransform t = CGAffineTransformMakeRotation(DegreesToRadians(degrees));</span><br><span class="line">rotatedViewBox.transform = t;</span><br><span class="line"></span><br><span class="line">CGSize rotatedSize = rotatedViewBox.frame.size;</span><br><span class="line">UIGraphicsBeginImageContext(rotatedSize);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextTranslateCTM(context, rotatedSize.width/2, rotatedSize.height/2);</span><br><span class="line">CGContextRotateCTM(context, DegreesToRadians(degrees));</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">CGContextDrawImage(context, CGRectMake(-self.size.width / 2, -self.size.height / 2, self.size.width, self.size.height), [self CGImage]);</span><br><span class="line">UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark 修正图片方向</span><br><span class="line">- (UIImage *)imageFixOrientation &#123;</span><br><span class="line">if (self.imageOrientation == UIImageOrientationUp) return self;</span><br><span class="line"></span><br><span class="line">CGAffineTransform transform =  [self transformForOrientation:self.size];</span><br><span class="line">CGFloat width = self.size.width;</span><br><span class="line">CGFloat height = self.size.height;</span><br><span class="line">size_t bits = CGImageGetBitsPerComponent(self.CGImage);</span><br><span class="line">CGColorSpaceRef colorSpace = CGImageGetColorSpace(self.CGImage);</span><br><span class="line">CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</span><br><span class="line">CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(self.CGImage);</span><br><span class="line"></span><br><span class="line">if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</span><br><span class="line">uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</span><br><span class="line">if (alpha == kCGImageAlphaNone) &#123;</span><br><span class="line">bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">bitmapInfo |= kCGImageAlphaNoneSkipFirst;</span><br><span class="line">&#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</span><br><span class="line">bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">bitmapInfo |= kCGImageAlphaPremultipliedFirst;</span><br><span class="line">&#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line">CGContextRef ctx = CGBitmapContextCreate(NULL, width, height, bits, 0, colorSpace, bitmapInfo);</span><br><span class="line">if (ctx == NULL) &#123;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">CGContextConcatCTM(ctx, transform);</span><br><span class="line">switch (self.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">// Grr...</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// And now we just create a new UIImage from the drawing context</span><br><span class="line">CGImageRef cgimg = CGBitmapContextCreateImage(ctx);</span><br><span class="line">UIImage *img = [UIImage imageWithCGImage:cgimg];</span><br><span class="line">CGContextRelease(ctx);</span><br><span class="line">CGImageRelease(cgimg);</span><br><span class="line">return img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">- (CGAffineTransform)transformForOrientation:(CGSize)newSize &#123;</span><br><span class="line">/*</span><br><span class="line">CGAffineTransform 处理形变的类,二维坐标系,即向右为x轴正方向,向上为y轴正方向</span><br><span class="line">方法简介：</span><br><span class="line">CGAffineTransformTranslate // x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformScale // x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformRotate // 逆时针旋转弧度,M_PI=180角度)</span><br><span class="line"></span><br><span class="line">以下都是针对视图的原定最初位置的中心点为起始参照进行相应操作的，</span><br><span class="line">CGAffineTransformMakeTranslation // 将坐标系统x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformMakeScale // 将坐标系统x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformMakeRotation // 将坐标系统逆时针旋转弧度,M_PI=180角度)</span><br><span class="line">在操作结束之后可对设置量进行还原：</span><br><span class="line">view.transform＝CGAffineTransformIdentity;</span><br><span class="line">*/</span><br><span class="line">CGAffineTransform transform = CGAffineTransformIdentity;</span><br><span class="line"></span><br><span class="line">switch(self.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationDown:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, newSize.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, 0);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI_2);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, 0, newSize.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, -M_PI_2);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(self.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationUpMirrored:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.height, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return transform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 生成image</span><br><span class="line"></span><br><span class="line">+ (UIImage *)createImageWithView:(UIView *)view&#123;</span><br><span class="line">// size区域大小，opaque是否透明，屏幕分辨率 0表示 [UIScreen mainScreen].scale</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.opaque, 0.0);</span><br><span class="line">// 将view的layer渲染到当前的绘制的上下文中</span><br><span class="line">[view.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return image;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 水印</span><br><span class="line"></span><br><span class="line">// 图片水印</span><br><span class="line">- (UIImage *)waterImage:(UIImage *)otherImage &#123;</span><br><span class="line">// 右下角</span><br><span class="line">CGFloat x = self.size.width - (self.size.width - otherImage.size.width)/2;</span><br><span class="line">CGFloat y = self.size.height - (self.size.height - otherImage.size.height)/2;</span><br><span class="line">return [self mergeImage:otherImage center:CGPointMake(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)mergeImage:(UIImage *)otherImage center:(CGPoint)center&#123;</span><br><span class="line">UIGraphicsBeginImageContext(self.size);</span><br><span class="line">[self drawInRect:CGRectMake(0, 0, self.size.width, self.size.height)];</span><br><span class="line">CGFloat width = otherImage.size.width;</span><br><span class="line">CGFloat height = otherImage.size.height;</span><br><span class="line">[otherImage drawInRect:CGRectMake(center.x - width/2, center.y - height/2, width, height)];</span><br><span class="line">UIImage *resultingImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return resultingImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#warning TODO：实现一个文字版水印效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>图片处理2：CGImage</title>
    <url>/2016/06/15/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%862%EF%BC%9ACGImage/</url>
    <content><![CDATA[<h3 id="序-UIImage、CGImage与CIImage"><a href="#序-UIImage、CGImage与CIImage" class="headerlink" title="序 UIImage、CGImage与CIImage"></a>序 UIImage、CGImage与CIImage</h3><ul>
<li>UIImage：UIKit的封装，最常用</li>
<li>CGImage：UIImage类的Core Graphics版本的结构体指针，用C语言编写，只能表示位图</li>
<li>CIImage：并不是一张图片。它包含了所有生成一张图片所有的必要信息。CIImage对象通常用在CIFilter,CIContext,CIColor,CIVector。跟GPU的处理相关。 </li>
</ul>
<h3 id="CGImage"><a href="#CGImage" class="headerlink" title="CGImage"></a>CGImage</h3><h4 id="绘制图片的方式"><a href="#绘制图片的方式" class="headerlink" title="绘制图片的方式"></a>绘制图片的方式</h4><ol>
<li><p>根据数据源创建位图CGImageCreate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// 图片宽度，单位像素, CGImageGetWidth(imageRef);</span><br><span class="line">size_t width</span><br><span class="line">// 图片高度，单位像素, CGImageGetHeight(imageRef);</span><br><span class="line">size_t height</span><br><span class="line">// 每个颜色的比特数，在rgba-32模式下为 8, CGImageGetBitsPerComponent(imageRef)</span><br><span class="line">size_t bitsPerComponent</span><br><span class="line">// 每个像素的总比特数，The number of bytes per pixel is equal to `(bitsPerComponent * number of components + 7)/8&apos; ，参照CGBitmapContextCreate的注释， CGImageGetBitsPerPixel(imageRef)</span><br><span class="line">size_t bitsPerPixel,</span><br><span class="line">// 每一行占用的字节数，注意单位是字节,`bytesPerRow&apos; bytes, which must be at least width * bytes per pixel&apos; bytes 即 width * bitsPerPixel / BYTE_SIZE ，参照CGBitmapContextCreate的注释，通常1字节=8位,CGImageGetBytesPerRow(imageRef)</span><br><span class="line">size_t bytesPerRow,</span><br><span class="line">// 颜色空间,iOS中一般为CGColorSpaceCreateDeviceRGB， CGImageGetColorSpace(imageRef)</span><br><span class="line">CGColorSpaceRef cg_nullable space,</span><br><span class="line">// 位图的布局信息，iOS上一般为小端32位序，获取方式参见 备注2</span><br><span class="line">CGBitmapInfo bitmapInfo,</span><br><span class="line">// 数据提供者 ，CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</span><br><span class="line">CGDataProviderRef cg_nullable provider,</span><br><span class="line">// 固定为NULL，即不允许重新映射颜色值</span><br><span class="line">const CGFloat * __nullable decode,</span><br><span class="line">// 固定为false，即不采用插值算法，高分辨率上可能会显示锯齿</span><br><span class="line">bool shouldInterpolate,</span><br><span class="line">// 渲染意图，kCGRenderingIntentDefault</span><br><span class="line">CGColorRenderingIntent intent</span><br><span class="line">*/</span><br><span class="line">CGImageRef image = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, YYCGColorSpaceGetDeviceRGB(), bitmapInfo, provider, NULL, false, kCGRenderingIntentDefault);</span><br><span class="line"></span><br><span class="line">// 备注1：size_t 在64位机器上为8字节，32位机器上为4字节</span><br><span class="line">// 备注2：直接使用CGImageGetBitmapInfo(imageRef)获得的CGBitmapInfo 位图布局信息是不准的，以下是AFNetwork的代码</span><br><span class="line">//    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</span><br><span class="line">//    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</span><br><span class="line">//</span><br><span class="line">//    if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</span><br><span class="line">//        uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</span><br><span class="line">//#pragma clang diagnostic push</span><br><span class="line">//#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</span><br><span class="line">//        if (alpha == kCGImageAlphaNone) &#123;</span><br><span class="line">//            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">//            bitmapInfo |= kCGImageAlphaNoneSkipFirst;</span><br><span class="line">//        &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</span><br><span class="line">//            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">//            bitmapInfo |= kCGImageAlphaPremultipliedFirst;</span><br><span class="line">//        &#125;</span><br><span class="line">//#pragma clang diagnostic pop</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上下文创建位图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 同时设data为NULL、bytesPerRow为0 （必须两个都设），表示系采用统会自动分配一段合适的内存，保存位图数据</span><br><span class="line">CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">if (!context) return NULL;</span><br><span class="line">CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode</span><br><span class="line">CGImageRef newImage = CGBitmapContextCreateImage(context);</span><br><span class="line">CFRelease(context);</span><br><span class="line">// 如果有图像数据了，当然用CGImageCreate，毕竟用CGBitmapContextCreate还需要拷贝啥的比较耗时</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIGraphicsBeginImageContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 生成纯色图片</span><br><span class="line">CGRect rect=CGRectMake(0,0, 1, 1);</span><br><span class="line">UIGraphicsBeginImageContext(rect.size);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetFillColorWithColor(context, [color CGColor]);</span><br><span class="line">CGContextFillRect(context, rect);</span><br><span class="line">UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><ul>
<li><p>蒙层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建mask图片图层,参数和CGImageCreate一样</span><br><span class="line">CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow,CGDataProviderRef cg_nullable provider, const CGFloat * __nullable decode, bool shouldInterpolate)</span><br><span class="line">//调用CGImageCreateWithMask并指定图像作为蒙版，则必须使用设备灰色颜色空间定义图像。</span><br><span class="line">CGImageCreateWithMask(CGImageRef cg_nullable image, CGImageRef cg_nullable mask)</span><br></pre></td></tr></table></figure>
</li>
<li><p>截图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CGImageCreateWithImageInRect(CGImageRef cg_nullable image, CGRect rect)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从NSData生成CGImageRef</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 以下为AFNetwork源码</span><br><span class="line">CGImageRef imageRef = NULL;</span><br><span class="line">CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</span><br><span class="line"></span><br><span class="line">if ([response.MIMEType isEqualToString:@&quot;image/png&quot;]) &#123;</span><br><span class="line">imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);</span><br><span class="line">&#125; else if ([response.MIMEType isEqualToString:@&quot;image/jpeg&quot;]) &#123;</span><br><span class="line">imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);</span><br><span class="line"></span><br><span class="line">if (imageRef) &#123;</span><br><span class="line">CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);</span><br><span class="line">CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);</span><br><span class="line"></span><br><span class="line">// CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale</span><br><span class="line">if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;</span><br><span class="line">CGImageRelease(imageRef);</span><br><span class="line">imageRef = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>圆角阴影</title>
    <url>/2016/11/22/%E5%9C%86%E8%A7%92%E9%98%B4%E5%BD%B1/</url>
    <content><![CDATA[<p>&emsp;&emsp;水文一篇，其实本来也不想水的！但真心忍不住吐槽一下UI的审美：都审美年代了还在搞大阴影伪立体的设计！！！以下为正文</p>
<p>&emsp;&emsp;最简单的是用<strong>图片</strong>!<strong>图片</strong>!<strong>图片</strong>! 重要的事情说三遍！但如果你遇到了我们这种UI，更年期提前！要张图片真能要了她的命…一张图片拖了三天就是不给…更年期的女人惹不起呀</p>
<p>&emsp;&emsp;很早之前，UI过来说给加个阴影吧！当然没问题，简单的很！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor licaiColor_E9EDF7].CGColor;</span><br><span class="line">view.layer.shadowOpacity = 1.0f;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(1, 1);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;&emsp;&emsp;今天UI又来了，还是加阴影！不过加的位置比较恶心，是一个section组加一个阴影。这意味着：第一个cell要左上右三个方向有阴影；最后一个cell要左下右三个方向有阴影；中间的cell要左右两个方向有阴影…脑子里的第一种方案比较简单，巧用clipsToBounds，阴影view做的长一点通过superView裁剪来实现相应的效果，代码很简单！自然是不行的，可以的话就没必要水了！主要问题：superView设置clipsToBounds，子view还要实现阴影效果必然会对原有布局进行移动修改！不可取！</p>
<p>&emsp;&emsp;那只剩下自己画这条路了，其实也很简单！<a href="https://stackoverflow.com/questions/3690972/why-maskstobounds-yes-prevents-calayer-shadow" target="_blank" rel="noopener">https://stackoverflow.com/questions/3690972/why-maskstobounds-yes-prevents-calayer-shadow</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation UIView (shadow)</span><br><span class="line"></span><br><span class="line">- (void)setShadowColor:(UIColor *)color</span><br><span class="line">opacity:(CGFloat)opacity</span><br><span class="line">offset:(CGSize)offset</span><br><span class="line">blurRadius:(CGFloat)blurRadius</span><br><span class="line">corners:(UIRectCorner)corners</span><br><span class="line">cornerRadious:(CGFloat)cornerRadious &#123;</span><br><span class="line"></span><br><span class="line">UIBezierPath *bPath = [UIBezierPath bezierPathWithRoundedRect:self.bounds</span><br><span class="line">byRoundingCorners:corners cornerRadii:CGSizeMake(cornerRadious, cornerRadious)];</span><br><span class="line"></span><br><span class="line">[self.layer setShadowColor:color.CGColor];</span><br><span class="line">[self.layer setShadowOpacity:opacity];</span><br><span class="line">[self.layer setShadowOffset:offset];</span><br><span class="line">//    [self.layer setShadowRadius:blurRadius];</span><br><span class="line">[self.layer setShadowPath:bPath.CGPath];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *imageSketch = [CAShapeLayer layer];</span><br><span class="line">imageSketch.path = bPath.CGPath;</span><br><span class="line">imageSketch.fillRule = kCAFillRuleEvenOdd;</span><br><span class="line">imageSketch.fillColor = self.backgroundColor.CGColor;</span><br><span class="line"></span><br><span class="line">[self.layer addSublayer:imageSketch];</span><br><span class="line">self.backgroundColor = [UIColor clearColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;UI又来了，说要把一个section都放到一个阴影里！这个更恶心，意味着第一个cell要显示左上右三个边的阴影；最后一个cell要显示左下右三个变阴影；中间cell要显示左右两边阴影；而且第一个和最后一个cell需要把clipsToBounds设为No，用于显示外阴影；我一开始打算直接用UIBezierPath画一下，也不麻烦无非就是三个边和两个圆角，就行了！但实验发现<em>不行</em>。即便我画的path是不闭合的U字形，设置阴影之后就阴影就自己闭合了！这个好恶心呀！想来想去没什么好办法，只能先画阴影再用clipsToBounds把用不到的阴影裁掉才行。核心代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface JZKCornerShadowView ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIView *shadowView;</span><br><span class="line">@property (nonatomic, strong) UIView *clipView;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#define kShadowOffset 20</span><br><span class="line"></span><br><span class="line">@implementation JZKCornerShadowView</span><br><span class="line"></span><br><span class="line">- (void)shadowWithSize:(CGSize)size</span><br><span class="line">shadowColor:(UIColor *)shadowColor</span><br><span class="line">corners:(UIRectCorner)corners</span><br><span class="line">cornerRadious:(CGFloat)cornerRadious&#123;</span><br><span class="line"></span><br><span class="line">BOOL topLeft = corners &amp; UIRectCornerTopLeft ? YES : NO;</span><br><span class="line">BOOL topRight = corners &amp; UIRectCornerTopRight ? YES : NO;</span><br><span class="line">BOOL bottomLeft = corners &amp; UIRectCornerBottomLeft ? YES : NO;</span><br><span class="line">BOOL bottomRight = corners &amp; UIRectCornerBottomRight ? YES : NO;</span><br><span class="line"></span><br><span class="line">// 四个角</span><br><span class="line">if (topLeft &amp;&amp; topRight &amp;&amp; bottomLeft &amp;&amp; bottomRight) &#123;</span><br><span class="line">[self.layer setShadowColor:[UIColor yellowColor].CGColor];</span><br><span class="line">[self.layer setShadowOpacity:1.0];</span><br><span class="line">[self.layer setShadowOffset:CGSizeMake(1, 1)];</span><br><span class="line">[self layoutIfNeeded];</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.clipsToBounds = NO;</span><br><span class="line">self.superview.clipsToBounds = NO;</span><br><span class="line">[self setUpShadowView:size shadowColor:shadowColor corners:corners cornerRadious:cornerRadious];</span><br><span class="line">// 对角或三个角</span><br><span class="line">if ((topLeft &amp;&amp; bottomRight) || (topRight &amp;&amp; bottomLeft)) &#123;</span><br><span class="line">[self layoutIfNeeded];</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">// 两个角</span><br><span class="line">if (topLeft &amp;&amp; topRight) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.bottom.equalTo(self.mas_bottom);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else if (bottomLeft &amp;&amp; bottomRight) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.top.equalTo(self.mas_top);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else if (topLeft &amp;&amp; bottomLeft) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.right.equalTo(self.mas_right);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else if (topRight &amp;&amp; bottomRight) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.equalTo(self.mas_left);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">// 一个角</span><br><span class="line">if (topLeft) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.right.equalTo(self.mas_right);</span><br><span class="line">make.bottom.equalTo(self.mas_bottom);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else if (topRight) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.equalTo(self.mas_left);</span><br><span class="line">make.bottom.equalTo(self.mas_bottom);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else if (bottomLeft) &#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.right.equalTo(self.mas_right);</span><br><span class="line">make.top.equalTo(self.mas_top);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else if (bottomRight)&#123;</span><br><span class="line">[_clipView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.equalTo(self.mas_left);</span><br><span class="line">make.top.equalTo(self.mas_top);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[self layoutIfNeeded];</span><br><span class="line">self.backgroundColor = [UIColor clearColor];</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUpClipView &#123;</span><br><span class="line">if (_clipView) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">_clipView = [[UIView alloc] init];</span><br><span class="line">_clipView.backgroundColor = [UIColor clearColor];</span><br><span class="line">_clipView.clipsToBounds = YES;</span><br><span class="line">[self addSubview:_clipView];</span><br><span class="line">[_clipView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.top.equalTo(self.mas_top).offset(-kShadowOffset);</span><br><span class="line">make.left.equalTo(self.mas_left).offset(-kShadowOffset);</span><br><span class="line">make.bottom.equalTo(self.mas_bottom).offset(kShadowOffset);</span><br><span class="line">make.right.equalTo(self.mas_right).offset(kShadowOffset);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUpShadowView:(CGSize)size shadowColor:(UIColor *)shadowColor corners:(UIRectCorner)corners cornerRadious:(CGFloat)cornerRadious&#123;</span><br><span class="line">if (_shadowView) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (!_clipView) &#123;</span><br><span class="line">[self setUpClipView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_shadowView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, size.width, size.height)];</span><br><span class="line">UIBezierPath *bPath = [UIBezierPath bezierPathWithRoundedRect:_shadowView.bounds</span><br><span class="line">byRoundingCorners:corners cornerRadii:CGSizeMake(cornerRadious, cornerRadious)];</span><br><span class="line"></span><br><span class="line">[_shadowView.layer setShadowColor:shadowColor.CGColor];</span><br><span class="line">[_shadowView.layer setShadowOpacity:1.0];</span><br><span class="line">[_shadowView.layer setShadowOffset:CGSizeMake(1, 1)];</span><br><span class="line">[_shadowView.layer setShadowPath:bPath.CGPath];</span><br><span class="line"></span><br><span class="line">CAShapeLayer *imageSketch = [CAShapeLayer layer];</span><br><span class="line">imageSketch.path = bPath.CGPath;</span><br><span class="line">imageSketch.fillRule = kCAFillRuleEvenOdd;</span><br><span class="line">imageSketch.fillColor = self.backgroundColor.CGColor;</span><br><span class="line"></span><br><span class="line">[_shadowView.layer addSublayer:imageSketch];</span><br><span class="line">_shadowView.backgroundColor = [UIColor clearColor];</span><br><span class="line">[_clipView addSubview:_shadowView];</span><br><span class="line">[_shadowView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.centerX.equalTo(self.mas_centerX);</span><br><span class="line">make.centerY.equalTo(self.mas_centerY);</span><br><span class="line">make.width.equalTo(@(size.width));</span><br><span class="line">make.height.equalTo(@(size.height));</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;另外附录CALayer的子类</p>
<ul>
<li>CAShapeLayer能通过CGPath来表示形状</li>
<li>CATextLayer使用了Core text，用于文字绘制</li>
<li>CATransformLayer 解决3D变化</li>
<li>CAGradientLayer是用来生成两种或更多颜色平滑渐变的</li>
<li>CAReplicatorLayer的目的是为了高效生成许多相似的图层，使用CAReplicatorLayer并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果</li>
<li>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入</li>
<li>CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果</li>
<li>CAEAGLLayer是CALayer的一个子类，用来显示任意的OpenGL图形</li>
<li>UIScrollView并没有用CAScrollLayer</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>复习swift：IQKeyboardManager</title>
    <url>/2018/03/17/%E5%A4%8D%E4%B9%A0swift%EF%BC%9AIQKeyboardManager/</url>
    <content><![CDATA[<p>&emsp;&emsp;关于IQKeyboardManager的原理，自己去<a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">github</a>上看吧，有完整的流程图（在最下面），我就写我自己感兴趣的，觉得好玩的东西</p>
<ol>
<li><p>大家都在用viewTag，但一般都是正数！其实是integer类型，可以是负数！另外tag值较小的，如0-100为苹果保留使用，自己用最好1000以上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">Default tag for toolbar with Done button   -1002.</span><br><span class="line">*/</span><br><span class="line">private static let  kIQDoneButtonToolbarTag         =   -1002</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什要保留通知 _kbShowNotification ? 看过源码发现，其实就是个标志位…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/** To save keyboardWillShowNotification. Needed for enable keyboard functionality. */</span><br><span class="line">private var         _kbShowNotification: Notification?</span><br></pre></td></tr></table></figure>
</li>
<li><p>as ad? as!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">is   用于类型检查</span><br><span class="line">as   向上转型</span><br><span class="line">as？ 尝试向下转型，可选值</span><br><span class="line">as！ 强制向下转型</span><br></pre></td></tr></table></figure>
</li>
<li><p>.self到底是啥?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">self可以用在类型后面取得类型本身，也可以用在实例后面取得这个实例本身</span><br><span class="line">Self表示特定类型，并且只能用在协议中或者作为某个类的方法的返回值类型, &apos;Self&apos; is only available in a protocol or as the result of a method in a class</span><br><span class="line">*/</span><br><span class="line">let classNameString = NSStringFromClass(type(of: textFieldViewController.self))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">元类型用 .Type 表示。比如 Int.Type 就是 Int 的元类型，是类型不是实例值</span><br><span class="line">AnyClass 其实就是一个元类型 typealias AnyClass = AnyObject.Type</span><br><span class="line"></span><br><span class="line">扩展1：Any vs AnyObject</span><br><span class="line">AnyObject 可以代表任何 class 类型的实例</span><br><span class="line">Any 可以表示任意类型，甚至包括方法（func）类型。</span><br><span class="line">参考：https://swifter.tips/any-anyobject/</span><br><span class="line"></span><br><span class="line">扩展2：type(of:) vs .self</span><br><span class="line">通过 type(of:) 和 .self都可以获得元类型的值,但.self取到的是静态的元类型，声明的时候是什么类型就是什么类型。type(of:) 取的是运行时候的元类型，也就是这个实例 的类型</span><br><span class="line">*/ </span><br><span class="line">private var registeredClasses  = [UIView.Type]()</span><br></pre></td></tr></table></figure>
</li>
<li><p>关联对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">public let kIQUseDefaultKeyboardDistance = CGFloat.greatestFiniteMagnitude</span><br><span class="line">private var kIQKeyboardDistanceFromTextField = &quot;kIQKeyboardDistanceFromTextField&quot;</span><br><span class="line"></span><br><span class="line">@objc var keyboardDistanceFromTextField: CGFloat &#123;</span><br><span class="line">get &#123;</span><br><span class="line">if let aValue = objc_getAssociatedObject(self, &amp;kIQKeyboardDistanceFromTextField) as? CGFloat &#123;</span><br><span class="line">return aValue</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return kIQUseDefaultKeyboardDistance</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set(newValue) &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kIQKeyboardDistanceFromTextField, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>animate</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">a.union(b) //并集</span><br><span class="line">a.intersection(b)//交集</span><br><span class="line">a.subtracting(b) //取差值</span><br><span class="line">a.symmetricDifference(b)//去掉相同值</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">swift版NSOption是  struct实现OptionSet协议 </span><br><span class="line">public struct AnimationOptions : OptionSet</span><br><span class="line">*/ </span><br><span class="line">UIView.animate(withDuration: _animationDuration, delay: 0, options: _animationCurve.union(.beginFromCurrentState), animations: &#123; () -&gt; Void in</span><br><span class="line">// 逃逸闭包，dosomething</span><br><span class="line">&#125;) &#123; _ in</span><br><span class="line">// 尾随闭包，dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OperationQueue.main.addOperation &#123;</span><br><span class="line">self.adjustPosition()</span><br><span class="line">self._privateHasPendingAdjustRequest = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 写法1</span><br><span class="line"></span><br><span class="line">/*  Automatically called from the `+(void)load` method. */</span><br><span class="line">+ (IQKeyboardManager*)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">//Singleton instance</span><br><span class="line">static IQKeyboardManager *kbManager;</span><br><span class="line"></span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">kbManager = [[self alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return kbManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法2</span><br><span class="line">@objc public class var shared: IQKeyboardManager &#123;</span><br><span class="line">struct Static &#123;</span><br><span class="line">//Singleton instance. Initializing keyboard manger.</span><br><span class="line">static let kbManager = IQKeyboardManager()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** @return Returns the default singleton instance. */</span><br><span class="line">return Static.kbManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法3</span><br><span class="line">static let sharedInstance = IQKeyboardManager()</span><br></pre></td></tr></table></figure>
</li>
<li><p>#selector</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// #selector() 的好处是不再需要使用字符串来构造</span><br><span class="line">// 但使用属性时，需要getter、setter前缀</span><br><span class="line">if textField.responds(to: #selector(setter: UITextField.inputAccessoryView)) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 实现多个协议方法大家都知道</span><br><span class="line">class ExampleTableViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UIPopoverPresentationControllerDelegate &#123;&#125;</span><br><span class="line">// 要求一个类型同时遵循多个协议，用协议合成</span><br><span class="line">@objc public weak var delegate: (UITextFieldDelegate &amp; UITextViewDelegate)?</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>复习swift：Reachability</title>
    <url>/2018/02/10/%E5%A4%8D%E4%B9%A0swift%EF%BC%9AReachability/</url>
    <content><![CDATA[<p>&emsp;&emsp;刚转行的时候正好赶上Swift横空出世，但当时API非常不稳定，外加项目都是用OC写的就学了OC！对于Swift也是持观望态度！16年学习一段时间的Swift，后来来百度后发现都是用OC写的，而且还专门讨论过要不要引入Swift混编，结论自然是不行的：1、引入后编译变慢，包体积变大；2、其它同学都不会；再后来就不了了之了！</p>
<p>&emsp;&emsp;但现在已经8102年了，作为一个iOS开发你再说你不会Swift，那就真有点说不过去了！所以我决定从水Swift开始吧！至于为什么选择Reachability？因为权威和简单，好长时间不用Swift了，这次就当复习！作为复习资料，自然要找权威的、简单的！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// import Foundation.NSThread</span><br><span class="line">import SystemConfiguration</span><br><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">// 实现Error协议</span><br><span class="line">public enum ReachabilityError: Error &#123;</span><br><span class="line">// 枚举关联值，个人认为最NB的特性，其实理解成元组就好理解多了</span><br><span class="line">case failedToCreateWithAddress(sockaddr, Int32)</span><br><span class="line">case failedToCreateWithHostname(String, Int32)</span><br><span class="line">case unableToSetCallback(Int32)</span><br><span class="line">case unableToSetDispatchQueue(Int32)</span><br><span class="line">case unableToGetFlags(Int32)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">@available 放在函数（方法），类或者协议前面,声明这些的生命周期依赖于特定的平台和操作系统版本。</span><br><span class="line">而#available用在判断语句中（if, guard, while等），在不同的平台上做不同的逻辑</span><br><span class="line">*/</span><br><span class="line">@available(*, unavailable, renamed: &quot;Notification.Name.reachabilityChanged&quot;)</span><br><span class="line">public let ReachabilityChangedNotification = NSNotification.Name(&quot;ReachabilityChangedNotification&quot;)</span><br><span class="line"></span><br><span class="line">// 基本已经成为通知命名的固定写法了</span><br><span class="line">public extension Notification.Name &#123;</span><br><span class="line">static let reachabilityChanged = Notification.Name(&quot;reachabilityChanged&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Reachability &#123;</span><br><span class="line">// 定义两个函数类型，入参Reachability，无返回值</span><br><span class="line">public typealias NetworkReachable = (Reachability) -&gt; ()</span><br><span class="line">public typealias NetworkUnreachable = (Reachability) -&gt; ()</span><br><span class="line"></span><br><span class="line">@available(*, unavailable, renamed: &quot;Connection&quot;)</span><br><span class="line">public enum NetworkStatus: CustomStringConvertible &#123;</span><br><span class="line">case notReachable, reachableViaWiFi, reachableViaWWAN</span><br><span class="line">public var description: String &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case .reachableViaWWAN: return &quot;Cellular&quot;</span><br><span class="line">case .reachableViaWiFi: return &quot;WiFi&quot;</span><br><span class="line">case .notReachable: return &quot;No Connection&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CustomStringConvertible协议就是用来输出的</span><br><span class="line">public enum Connection: CustomStringConvertible &#123;</span><br><span class="line">@available(*, deprecated, renamed: &quot;unavailable&quot;)</span><br><span class="line">case none</span><br><span class="line">case unavailable, wifi, cellular</span><br><span class="line">public var description: String &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case .cellular: return &quot;Cellular&quot;</span><br><span class="line">case .wifi: return &quot;WiFi&quot;</span><br><span class="line">case .unavailable: return &quot;No Connection&quot;</span><br><span class="line">case .none: return &quot;unavailable&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">public var whenReachable: NetworkReachable?</span><br><span class="line">public var whenUnreachable: NetworkUnreachable?</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, renamed: &quot;allowsCellularConnection&quot;)</span><br><span class="line">public let reachableOnWWAN: Bool = true</span><br><span class="line"></span><br><span class="line">/// Set to `false` to force Reachability.connection to .none when on cellular connection (default value `true`)</span><br><span class="line">public var allowsCellularConnection: Bool</span><br><span class="line"></span><br><span class="line">// The notification center on which &quot;reachability changed&quot; events are being posted</span><br><span class="line">public var notificationCenter: NotificationCenter = NotificationCenter.default</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, renamed: &quot;connection.description&quot;)</span><br><span class="line">public var currentReachabilityString: String &#123;</span><br><span class="line">return &quot;\(connection)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(*, unavailable, renamed: &quot;connection&quot;)</span><br><span class="line">public var currentReachabilityStatus: Connection &#123;</span><br><span class="line">return connection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算型属性</span><br><span class="line">public var connection: Connection &#123;</span><br><span class="line">// 习惯于OC的 _flags需要适应一下，swift里除非重名，都可以直接用相关属性</span><br><span class="line">if flags == nil &#123;</span><br><span class="line">/*</span><br><span class="line">Swift 中有 4 种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用 do-catch 语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生</span><br><span class="line">显然这里啥也没干，上层调用者不关心</span><br><span class="line">*/</span><br><span class="line">try? setReachabilityFlags()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch flags?.connection &#123;</span><br><span class="line">case .unavailable?, nil: return .unavailable</span><br><span class="line">case .none?: return .unavailable</span><br><span class="line">case .cellular?: return allowsCellularConnection ? .cellular : .unavailable</span><br><span class="line">case .wifi?: return .wifi</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">private 真正私有</span><br><span class="line">fileprivate 文件内私有</span><br><span class="line">Internal 默认，可以访问自己module或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体</span><br><span class="line">public 可以被任何人访问。但其他module中不可以被override和继承，而在module内可以被override和继承。</span><br><span class="line">open 可以被任何人使用，包括override和继承。</span><br><span class="line">*/</span><br><span class="line">fileprivate var isRunningOnDevice: Bool = &#123;</span><br><span class="line">#if targetEnvironment(simulator)</span><br><span class="line">return false</span><br><span class="line">#else</span><br><span class="line">return true</span><br><span class="line">#endif</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">// 只有set是fileprivate</span><br><span class="line">fileprivate(set) var notifierRunning = false</span><br><span class="line">// let 常量不可修改，但可init时赋值</span><br><span class="line">fileprivate let reachabilityRef: SCNetworkReachability</span><br><span class="line">fileprivate let reachabilitySerialQueue: DispatchQueue</span><br><span class="line">// 可选常量，因init是指定了默认值 .main</span><br><span class="line">fileprivate let notificationQueue: DispatchQueue?</span><br><span class="line">fileprivate(set) var flags: SCNetworkReachabilityFlags? &#123;</span><br><span class="line">// 属性观察器willSet和didSet使swift天然具备MVVM模式, 注意不要和set、get一起写没有意义</span><br><span class="line">didSet &#123;</span><br><span class="line">// 一开始我也不理解guard的作用，写起来感觉和if没什么区别，直到我遇到if嵌套</span><br><span class="line"></span><br><span class="line">// 当然下面这个写法我个人觉得还不如if</span><br><span class="line">guard flags != oldValue else &#123; return &#125;</span><br><span class="line">notifyReachabilityChanged()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 必要构造器，入参默认值是个好东西</span><br><span class="line">required public init(reachabilityRef: SCNetworkReachability,</span><br><span class="line">queueQoS: DispatchQoS = .default,</span><br><span class="line">targetQueue: DispatchQueue? = nil,</span><br><span class="line">notificationQueue: DispatchQueue? = .main) &#123;</span><br><span class="line">self.allowsCellularConnection = true</span><br><span class="line">self.reachabilityRef = reachabilityRef</span><br><span class="line">// C语言的GCD，在swift中被整成了class，不过使用方式没变</span><br><span class="line">// 为什么 DispatchQueue就一个class声明，所有的属性方法都在extension里？</span><br><span class="line">self.reachabilitySerialQueue = DispatchQueue(label: &quot;uk.co.ashleymills.reachability&quot;, qos: queueQoS, target: targetQueue)</span><br><span class="line">self.notificationQueue = notificationQueue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 便利构造器</span><br><span class="line">public convenience init(hostname: String,</span><br><span class="line">queueQoS: DispatchQoS = .default,</span><br><span class="line">targetQueue: DispatchQueue? = nil,</span><br><span class="line">notificationQueue: DispatchQueue? = .main) throws &#123;</span><br><span class="line">guard let ref = SCNetworkReachabilityCreateWithName(nil, hostname) else &#123;</span><br><span class="line">throw ReachabilityError.failedToCreateWithHostname(hostname, SCError())</span><br><span class="line">&#125;</span><br><span class="line">self.init(reachabilityRef: ref, queueQoS: queueQoS, targetQueue: targetQueue, notificationQueue: notificationQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public convenience init(queueQoS: DispatchQoS = .default,</span><br><span class="line">targetQueue: DispatchQueue? = nil,</span><br><span class="line">notificationQueue: DispatchQueue? = .main) throws &#123;</span><br><span class="line">var zeroAddress = sockaddr()</span><br><span class="line">zeroAddress.sa_len = UInt8(MemoryLayout&lt;sockaddr&gt;.size)</span><br><span class="line">zeroAddress.sa_family = sa_family_t(AF_INET)</span><br><span class="line"></span><br><span class="line">guard let ref = SCNetworkReachabilityCreateWithAddress(nil, &amp;zeroAddress) else &#123;</span><br><span class="line">throw ReachabilityError.failedToCreateWithAddress(zeroAddress, SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.init(reachabilityRef: ref, queueQoS: queueQoS, targetQueue: targetQueue, notificationQueue: notificationQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构，跟dealloc一样</span><br><span class="line">deinit &#123;</span><br><span class="line">stopNotifier()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public extension Reachability &#123;</span><br><span class="line"></span><br><span class="line">// MARK: - *** Notifier methods ***</span><br><span class="line">func startNotifier() throws &#123;</span><br><span class="line">guard !notifierRunning else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">let callback: SCNetworkReachabilityCallBack = &#123; (reachability, flags, info) in</span><br><span class="line">guard let info = info else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">// `weakifiedReachability` is guaranteed to exist by virtue of our</span><br><span class="line">// retain/release callbacks which we provided to the `SCNetworkReachabilityContext`.</span><br><span class="line">/*</span><br><span class="line">OC对于 CF 系的 API，如果 API 的名字中含有 Create，Copy 或者 Retain的话，在使用完成后，我们需要调用 CFRelease 来进行释放</span><br><span class="line">Swift 中我们不再需要显式地去释放带有这些关键字的内容了。也就是说，CF 现在也在 ARC 的管辖范围之内了</span><br><span class="line">但是有一点例外（极少会用到），那就是对于非系统的CF的API(比如你自己写的或者是第三方的),将这些返回CF对象的API导入Swift时，它们的类型会被对对应为 Unmanaged&lt;T&gt;。这意味着在使用时我们需要手动进行内存管理，takeUnretainedValue 将保持原来的引用计数不变，在你明白你没有义务去释放原来的内存时，应该使用这个方法。而如果你需要释放得到的 CF 的对象的内存时，应该使用 takeRetainedValue 来让引用计数加一，然后在使用完后对原来的 Unmanaged 进行手动释放。为了能手动操作 Unmanaged 的引用计数，Unmanaged 中还提供了 retain，release 和 autorelease 这样的 &quot;老朋友&quot; 供我们使用</span><br><span class="line">*/</span><br><span class="line">let weakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info).takeUnretainedValue()</span><br><span class="line"></span><br><span class="line">// The weak `reachability` _may_ no longer exist if the `Reachability`</span><br><span class="line">// object has since been deallocated but a callback was already in flight.</span><br><span class="line">weakifiedReachability.reachability?.flags = flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let weakifiedReachability = ReachabilityWeakifier(reachability: self)</span><br><span class="line">let opaqueWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.passUnretained(weakifiedReachability).toOpaque()</span><br><span class="line"></span><br><span class="line">var context = SCNetworkReachabilityContext(</span><br><span class="line">version: 0,</span><br><span class="line">info: UnsafeMutableRawPointer(opaqueWeakifiedReachability),</span><br><span class="line">retain: &#123; (info: UnsafeRawPointer) -&gt; UnsafeRawPointer in</span><br><span class="line">let unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)</span><br><span class="line">_ = unmanagedWeakifiedReachability.retain()</span><br><span class="line">return UnsafeRawPointer(unmanagedWeakifiedReachability.toOpaque())</span><br><span class="line">&#125;,</span><br><span class="line">release: &#123; (info: UnsafeRawPointer) -&gt; Void in</span><br><span class="line">let unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)</span><br><span class="line">unmanagedWeakifiedReachability.release()</span><br><span class="line">&#125;,</span><br><span class="line">copyDescription: &#123; (info: UnsafeRawPointer) -&gt; Unmanaged&lt;CFString&gt; in</span><br><span class="line">let unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)</span><br><span class="line">let weakifiedReachability = unmanagedWeakifiedReachability.takeUnretainedValue()</span><br><span class="line">let description = weakifiedReachability.reachability?.description ?? &quot;nil&quot;</span><br><span class="line">return Unmanaged.passRetained(description as CFString)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if !SCNetworkReachabilitySetCallback(reachabilityRef, callback, &amp;context) &#123;</span><br><span class="line">stopNotifier()</span><br><span class="line">throw ReachabilityError.unableToSetCallback(SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if !SCNetworkReachabilitySetDispatchQueue(reachabilityRef, reachabilitySerialQueue) &#123;</span><br><span class="line">stopNotifier()</span><br><span class="line">throw ReachabilityError.unableToSetDispatchQueue(SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Perform an initial check</span><br><span class="line">try setReachabilityFlags()</span><br><span class="line"></span><br><span class="line">notifierRunning = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func stopNotifier() &#123;</span><br><span class="line">// defer的作用就是函数结束前会调，无论函数是怎么结束的！</span><br><span class="line">defer &#123; notifierRunning = false &#125;</span><br><span class="line"></span><br><span class="line">SCNetworkReachabilitySetCallback(reachabilityRef, nil, nil)</span><br><span class="line">SCNetworkReachabilitySetDispatchQueue(reachabilityRef, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MARK: - *** Connection test methods ***</span><br><span class="line">@available(*, deprecated, message: &quot;Please use `connection != .none`&quot;)</span><br><span class="line">var isReachable: Bool &#123;</span><br><span class="line">return connection != .unavailable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, message: &quot;Please use `connection == .cellular`&quot;)</span><br><span class="line">var isReachableViaWWAN: Bool &#123;</span><br><span class="line">// Check we&apos;re not on the simulator, we&apos;re REACHABLE and check we&apos;re on WWAN</span><br><span class="line">return connection == .cellular</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, message: &quot;Please use `connection == .wifi`&quot;)</span><br><span class="line">var isReachableViaWiFi: Bool &#123;</span><br><span class="line">return connection == .wifi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var description: String &#123;</span><br><span class="line">return flags?.description ?? &quot;unavailable flags&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileprivate extension Reachability &#123;</span><br><span class="line"></span><br><span class="line">// 上抛错误</span><br><span class="line">func setReachabilityFlags() throws &#123;</span><br><span class="line">try reachabilitySerialQueue.sync &#123; [unowned self] in</span><br><span class="line">var flags = SCNetworkReachabilityFlags()</span><br><span class="line">if !SCNetworkReachabilityGetFlags(self.reachabilityRef, &amp;flags) &#123;</span><br><span class="line">self.stopNotifier()</span><br><span class="line">throw ReachabilityError.unableToGetFlags(SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.flags = flags</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 发通知</span><br><span class="line">func notifyReachabilityChanged() &#123;</span><br><span class="line">/*</span><br><span class="line">swift中所有的class类型变量都默认采用strong修饰</span><br><span class="line">Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned ，如果存在被释放的可能，那就选择用 weak</span><br><span class="line">*/</span><br><span class="line">let notify = &#123; [weak self] in</span><br><span class="line">// 保证self存在</span><br><span class="line">guard let self = self else &#123; return &#125;</span><br><span class="line">// (Reachability) -&gt; ()类型的可选属性</span><br><span class="line">self.connection != .unavailable ? self.whenReachable?(self) : self.whenUnreachable?(self)</span><br><span class="line">// @escaping 逃逸闭包必须在闭包中显式地引用 self</span><br><span class="line">self.notificationCenter.post(name: .reachabilityChanged, object: self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// notify on the configured `notificationQueue`, or the caller&apos;s (i.e. `reachabilitySerialQueue`)</span><br><span class="line">// ?? 可选可用用可选，可选不能用用后面</span><br><span class="line">notificationQueue?.async(execute: notify) ?? notify()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此外还有一个class，比较好玩！注释的很清楚了，思路挺好,其实就是weakproxy的作用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">`ReachabilityWeakifier` weakly wraps the `Reachability` class</span><br><span class="line">in order to break retain cycles when interacting with CoreFoundation.</span><br><span class="line"></span><br><span class="line">CoreFoundation callbacks expect a pair of retain/release whenever an</span><br><span class="line">opaque `info` parameter is provided. These callbacks exist to guard</span><br><span class="line">against memory management race conditions when invoking the callbacks.</span><br><span class="line"></span><br><span class="line">#### Race Condition</span><br><span class="line"></span><br><span class="line">If we passed `SCNetworkReachabilitySetCallback` a direct reference to our</span><br><span class="line">`Reachability` class without also providing corresponding retain/release</span><br><span class="line">callbacks, then a race condition can lead to crashes when:</span><br><span class="line">- `Reachability` is deallocated on thread X</span><br><span class="line">- A `SCNetworkReachability` callback(s) is already in flight on thread Y</span><br><span class="line"></span><br><span class="line">#### Retain Cycle</span><br><span class="line"></span><br><span class="line">If we pass `Reachability` to CoreFoundtion while also providing retain/</span><br><span class="line">release callbacks, we would create a retain cycle once CoreFoundation</span><br><span class="line">retains our `Reachability` class. This fixes the crashes and his how</span><br><span class="line">CoreFoundation expects the API to be used, but doesn&apos;t play nicely with</span><br><span class="line">Swift/ARC. This cycle would only be broken after manually calling</span><br><span class="line">`stopNotifier()` — `deinit` would never be called.</span><br><span class="line"></span><br><span class="line">#### ReachabilityWeakifier</span><br><span class="line"></span><br><span class="line">By providing both retain/release callbacks and wrapping `Reachability` in</span><br><span class="line">a weak wrapper, we:</span><br><span class="line">- interact correctly with CoreFoundation, thereby avoiding a crash.</span><br><span class="line">See &quot;Memory Management Programming Guide for Core Foundation&quot;.</span><br><span class="line">- don&apos;t alter the public API of `Reachability.swift` in any way</span><br><span class="line">- still allow for automatic stopping of the notifier on `deinit`.</span><br><span class="line">*/</span><br><span class="line">private class ReachabilityWeakifier &#123;</span><br><span class="line">weak var reachability: Reachability?</span><br><span class="line">init(reachability: Reachability) &#123;</span><br><span class="line">self.reachability = reachability</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>复习swift：Swift tips &amp; tricks笔记上</title>
    <url>/2018/03/27/%E5%A4%8D%E4%B9%A0swift%EF%BC%9ASwift-tips-tricks%E7%AC%94%E8%AE%B0%E4%B8%8A/</url>
    <content><![CDATA[<p>&emsp;&emsp;本文只摘抄了自己觉得有用的tip并加了点自己的理解，并不是全部tips。想看全部的自己看<a href="https://github.com/JohnSundell/SwiftTips#1-namespacing-with-nested-types" target="_blank" rel="noopener">大神的Swift tips &amp; tricks</a></p>
<ol>
<li><p>嵌套类型，好处大大滴！权限控制、结构划分等等</p>
</li>
<li><p>自动闭包，能使用自动闭包类型是是这样的() -&gt; T</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func logIfTure(_ predicate: ()-&gt;Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;jzk&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure(&#123; () -&gt; Bool in</span><br><span class="line">return 2 &gt; 1</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123;</span><br><span class="line">return 3 &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123;4&gt;3&#125;)</span><br><span class="line">logIfTure&#123;5&gt;4&#125;</span><br><span class="line"></span><br><span class="line">// 自动闭包写起来就优雅多了</span><br><span class="line">func logIfTure2(_ predicate:@autoclosure ()-&gt;Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;jzk&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure2(6&gt;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用typealiases减少长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias DownSuccess = (json: NSURLResponse, filePath: String?) -&gt; ()</span><br><span class="line">func Post(url:String? ,success: DownSuccess)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用与库同名的类、结构体…，慎用！还是不重复的好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Command &#123;</span><br><span class="line">enum Error: Swift.Error &#123;</span><br><span class="line">case missing</span><br><span class="line">case invalid(String)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用#function来保证UserDefault的key不重复! 慎用，思路不错，但不严谨</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension UserDefaults &#123;</span><br><span class="line">var onboardingCompleted: Bool &#123;</span><br><span class="line">get &#123; return bool(forKey: #function) &#125;</span><br><span class="line">set &#123; set(newValue, forKey: #function) &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把func和操作符当做闭包传递</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let array = [3, 9, 1, 4, 6, 2]</span><br><span class="line">let sorted = array.sorted(by: &lt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用guard拆分条件判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard maxObjectDepth &gt; 0 else &#123; return &#125;</span><br><span class="line">guard maxObjectDepth &lt; 100 else &#123; return &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用swith的default，目的强制编译器检查case是否完全</p>
</li>
<li><p>使用 .语法和闭包来初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">public func logSomething(_ str: String = &quot;&quot;) &#123;</span><br><span class="line">print(&quot;----\(str)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第一个比较好理解，参数默认值</span><br><span class="line">func test(log: Logger = .init())&#123;</span><br><span class="line">log.logSomething(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">/*</span><br><span class="line">但这个我就理解不了了，注意Logger.init后面没有括号</span><br><span class="line">*/</span><br><span class="line">func test2(log:@escaping () -&gt; Logger = Logger.init) &#123;</span><br><span class="line">let log2 = log();</span><br><span class="line">log2.logSomething(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 === 比较内存相等</p>
</li>
<li><p>枚举可有关联值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum JSONKey &#123;</span><br><span class="line">case index(Int)</span><br><span class="line">case key(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Canvas &#123;</span><br><span class="line">func add(_ shapes: Shape...) &#123;</span><br><span class="line">shapes.forEach(add)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Avoiding mocking UserDefaults! mocking啥呀，建新的！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoginTests: XCTestCase &#123;</span><br><span class="line">private var userDefaults: UserDefaults!</span><br><span class="line">private var manager: LoginManager!</span><br><span class="line"></span><br><span class="line">override func setUp() &#123;</span><br><span class="line">super.setup()</span><br><span class="line"></span><br><span class="line">userDefaults = UserDefaults(suiteName: #file)</span><br><span class="line">userDefaults.removePersistentDomain(forName: #file)</span><br><span class="line"></span><br><span class="line">manager = LoginManager(userDefaults: userDefaults)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加速包测试速度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swift test --parallel</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用闭包创建lazy属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">private lazy var str: String = &#123;</span><br><span class="line">print(&quot;lazy str init&quot;)</span><br><span class="line">return &quot;jzk&quot;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">public func log()&#123;</span><br><span class="line">print(&quot;my name is \(str)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let log1 = Logger();</span><br><span class="line">log1.log();</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合函数序列! </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal func +&lt;A, B, C&gt;(lhs: @escaping (A) throws -&gt; B,</span><br><span class="line">rhs: @escaping (B) throws -&gt; C) -&gt; (A) throws -&gt; C &#123;</span><br><span class="line">return &#123; try rhs(lhs($0)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func run() throws &#123;</span><br><span class="line">try (determineTarget + build + analyze + output)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using DispatchWorkItem， OC用dispatch_block_t</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let workItem = DispatchWorkItem &#123;</span><br><span class="line">// Your async code goes in here</span><br><span class="line">&#125;// 注意没括号</span><br><span class="line"></span><br><span class="line">// Execute the work item after 1 second</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: workItem)</span><br><span class="line"></span><br><span class="line">// You can cancel the work item if you no longer need it</span><br><span class="line">workItem.cancel()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用weak或o避免循环引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned ，如果存在被释放的可能，那就选择用 weak</span><br><span class="line">dataLoader.loadData(from: url) &#123; [weak self] result in</span><br><span class="line">// 这句检查self基本是定式了</span><br><span class="line">guard let self = self else &#123; </span><br><span class="line">return </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.cache(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步返回的尽量用enum</p>
</li>
<li><p>使用关联的枚举值以避免特定于状态的选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// BEFORE: Lots of state-specific, optional properties</span><br><span class="line"></span><br><span class="line">class Player &#123;</span><br><span class="line">var isWaitingForMatchMaking: Bool</span><br><span class="line">var invitingUser: User?</span><br><span class="line">var numberOfLives: Int</span><br><span class="line">var playerDefeatedBy: Player?</span><br><span class="line">var roundDefeatedIn: Int?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AFTER: All state-specific information is encapsulated in enum cases</span><br><span class="line"></span><br><span class="line">class Player &#123;</span><br><span class="line">enum State &#123;</span><br><span class="line">case waitingForMatchMaking</span><br><span class="line">case waitingForInviteResponse(from: User)</span><br><span class="line">case active(numberOfLives: Int)</span><br><span class="line">case defeated(by: Player, roundNumber: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var state: State</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型约束中使用闭包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Sequence where Element == () -&gt; Void &#123;</span><br><span class="line">func callAll() &#123;</span><br><span class="line">forEach &#123; $0() &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Sequence where Element == () -&gt; String &#123;</span><br><span class="line">func joinedResults(separator: String) -&gt; String &#123;</span><br><span class="line">return map &#123; $0() &#125;.joined(separator: separator)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callbacks.callAll()</span><br><span class="line">let names = nameProviders.joinedResults(separator: &quot;, &quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用静态定义url</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let url: URL = &quot;https://www.swiftbysundell.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak或lazy属性应该设置readoonly</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">private(set) weak var parent: Node?</span><br><span class="line">private(set) lazy var children = [Node]()</span><br><span class="line"></span><br><span class="line">func add(child: Node) &#123;</span><br><span class="line">children.append(child)</span><br><span class="line">child.parent = self</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Passing self to required Objective-C dependencies</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Using lazy properties in Swift, you can pass self to required Objective-C dependencies without having to use force-unwrapped optionals.</span><br><span class="line"></span><br><span class="line">class DataLoader: NSObject &#123;</span><br><span class="line">lazy var urlSession: URLSession = self.makeURLSession()</span><br><span class="line"></span><br><span class="line">private func makeURLSession() -&gt; URLSession &#123;</span><br><span class="line">return URLSession(configuration: .default, delegate: self, delegateQueue: .main)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Renderer &#123;</span><br><span class="line">lazy var displayLink: CADisplayLink = self.makeDisplayLink()</span><br><span class="line"></span><br><span class="line">private func makeDisplayLink() -&gt; CADisplayLink &#123;</span><br><span class="line">return CADisplayLink(target: self, selector: #selector(screenDidRefresh))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体初始化时可设置self值，但其他方法修改self需要添加mutabling</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Bool: AnswerConvertible &#123;</span><br><span class="line">public init(input: String) throws &#123;</span><br><span class="line">switch input.lowercased() &#123;</span><br><span class="line">case &quot;y&quot;, &quot;yes&quot;, &quot;👍&quot;:</span><br><span class="line">self = true</span><br><span class="line">default:</span><br><span class="line">self = false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用extension来组织代码</p>
</li>
<li><p>使用set减少枚举时的if/else if使用! 高，真高！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class RoadTile: Tile &#123;</span><br><span class="line">var connectedDirections = Set&lt;Direction&gt;()</span><br><span class="line"></span><br><span class="line">func render() &#123;</span><br><span class="line">switch connectedDirections &#123;</span><br><span class="line">case [.up, .down]:</span><br><span class="line">image = UIImage(named: &quot;road-vertical&quot;)</span><br><span class="line">case [.left, .right]:</span><br><span class="line">image = UIImage(named: &quot;road-horizontal&quot;)</span><br><span class="line">default:</span><br><span class="line">image = UIImage(named: &quot;road&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议可继承、可扩展！自然也就可重载、覆盖，然后就可以干点事情了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Declare a public protocol that acts as your immutable API</span><br><span class="line">public protocol ModelHolder &#123;</span><br><span class="line">associatedtype Model</span><br><span class="line">var model: Model &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Declare an extended, internal protocol that provides a mutable API</span><br><span class="line">internal protocol MutableModelHolder: ModelHolder &#123;</span><br><span class="line">var model: Model &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// You can now implement the requirements using &apos;public internal(set)&apos;</span><br><span class="line">public class UserHolder: MutableModelHolder &#123;</span><br><span class="line">public internal(set) var model: User</span><br><span class="line"></span><br><span class="line">internal init(model: User) &#123;</span><br><span class="line">self.model = model</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Converting Swift errors to NSError</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case .some(let error as NSError) where error.code == NSURLErrorNotConnectedToInternet:</span><br><span class="line">presenter.showOfflineView()</span><br></pre></td></tr></table></figure>
</li>
<li><p>lazy属性最好加上类型，外部调用最好加上self ！同时swift4也支持lazy的自动类型推断</p>
</li>
<li><p>静态依赖注入! 参数默认值的妙用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Before: Almost impossible to test due to the use of singletons</span><br><span class="line"></span><br><span class="line">class Analytics &#123;</span><br><span class="line">static func log(_ event: Event) &#123;</span><br><span class="line">Database.shared.save(event)</span><br><span class="line"></span><br><span class="line">let dictionary = event.serialize()</span><br><span class="line">NetworkManager.shared.post(dictionary, to: eventURL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// After: Much easier to test, since we can inject mocks as arguments</span><br><span class="line"></span><br><span class="line">class Analytics &#123;</span><br><span class="line">static func log(_ event: Event,</span><br><span class="line">database: Database = .shared,</span><br><span class="line">networkManager: NetworkManager = .shared) &#123;</span><br><span class="line">database.save(event)</span><br><span class="line"></span><br><span class="line">let dictionary = event.serialize()</span><br><span class="line">networkManager.post(dictionary, to: eventURL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以元组作为闭包的参数！好处：简单、可扩展且命名更规范</p>
</li>
<li><p>任何静态方法或属性都可以与点语法一起使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum RepeatMode &#123;</span><br><span class="line">case times(Int)</span><br><span class="line">case forever</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public extension RepeatMode &#123;</span><br><span class="line">static var never: RepeatMode &#123;</span><br><span class="line">return .times(0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static var once: RepeatMode &#123;</span><br><span class="line">return .times(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view.perform(animation, repeated: .once)</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数的本地拷贝，swift中除了类是引用，其他都是值类型，即当做参数都是copy进入的let常量，这时候在函数内部使用，最好拷贝一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init(repeatMode: RepeatMode, closure: @escaping () -&gt; UpdateOutcome) &#123;</span><br><span class="line">// Shadow the argument with a local, mutable copy</span><br><span class="line">var repeatMode = repeatMode</span><br></pre></td></tr></table></figure>
</li>
<li><p>强大的where，可用于 协议、for in、case、catch、泛型 等，但if let、guard和while中被去掉了，使用 ，逗号分割不同条件</p>
</li>
<li>Extending optionals<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func validateTextFields() -&gt; Bool &#123;</span><br><span class="line">guard !usernameTextField.text.isNilOrEmpty else &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Since all optionals are actual enum values in Swift, we can easily</span><br><span class="line">// extend them for certain types, to add our own convenience APIs</span><br><span class="line"></span><br><span class="line">extension Optional where Wrapped == String &#123;</span><br><span class="line">var isNilOrEmpty: Bool &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case let string?:</span><br><span class="line">return string.isEmpty</span><br><span class="line">case nil:</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Since strings are now Collections in Swift 4, you can even</span><br><span class="line">// add this property to all optional collections:</span><br><span class="line"></span><br><span class="line">extension Optional where Wrapped: Collection &#123;</span><br><span class="line">var isNilOrEmpty: Bool &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case let collection?:</span><br><span class="line">return collection.isEmpty</span><br><span class="line">case nil:</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>复习swift：Swift tips &amp; tricks笔记下</title>
    <url>/2018/03/28/%E5%A4%8D%E4%B9%A0swift%EF%BC%9ASwift-tips-tricks%E7%AC%94%E8%AE%B0%E4%B8%8B/</url>
    <content><![CDATA[<p>&emsp;&emsp;上篇学习了前50个，本文学习剩下的。拆成2篇是因为有道同步太坑了，上篇前50个就一直同步失败！</p>
<p>&emsp;&emsp;想看全部的自己看<a href="https://github.com/JohnSundell/SwiftTips#1-namespacing-with-nested-types" target="_blank" rel="noopener">大神的Swift tips &amp; tricks</a>，</p>
<ol start="51">
<li><p>UIView bounds and transforms</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let view = UIView()</span><br><span class="line">view.frame.size = CGSize(width: 100, height: 100)</span><br><span class="line">view.transform = CGAffineTransform(scaleX: 2, y: 2)</span><br><span class="line"></span><br><span class="line">print(view.frame) // (-50.0, -50.0, 200.0, 200.0)</span><br><span class="line">print(view.bounds) // (0.0, 0.0, 100.0, 100.0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展equatable实现 多值命中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Equatable &#123;</span><br><span class="line">func isAny(of candidates: Self...) -&gt; Bool &#123;</span><br><span class="line">return candidates.contains(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let isHorizontal = direction.isAny(of: .left, .right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制该协议只适用于class类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过将AnyObject协议添加到协议的继承列表中，来限制该协议只适用于class类型，而不适用于枚举和结构体。</span><br><span class="line">protocol DataContainer: AnyObject &#123;</span><br><span class="line">var data: Data? &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把实例方法当做static方法调用! 好牛逼</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In Swift, you can call any instance method as a static function and it will return a closure representing that method. This is how running tests using SPM on Linux works.</span><br><span class="line"></span><br><span class="line">More about this topic in my blog post &quot;https://www.swiftbysundell.com/posts/first-class-functions-in-swiftt&quot;.</span><br><span class="line"></span><br><span class="line">// This produces a &apos;() -&gt; Void&apos; closure which is a reference to the</span><br><span class="line">// given view&apos;s &apos;removeFromSuperview&apos; method.</span><br><span class="line">let closure = UIView.removeFromSuperview(view)</span><br><span class="line"></span><br><span class="line">// We can now call it just like we would any other closure, and it</span><br><span class="line">// will run &apos;view.removeFromSuperview()&apos;</span><br><span class="line">closure()</span><br><span class="line"></span><br><span class="line">// This is how running tests using the Swift Package Manager on Linux</span><br><span class="line">// works, you return your test functions as closures:</span><br><span class="line">extension UserManagerTests &#123;</span><br><span class="line">static var allTests = [</span><br><span class="line">(&quot;testLoggingIn&quot;, testLoggingIn),</span><br><span class="line">(&quot;testLoggingOut&quot;, testLoggingOut),</span><br><span class="line">(&quot;testUserPermissions&quot;, testUserPermissions)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>where子句和associated关联类型提供更多自由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public protocol PathFinderMap &#123;</span><br><span class="line">associatedtype Node</span><br><span class="line">// Using the &apos;where&apos; clause for associated types, we can</span><br><span class="line">// ensure that a type meets certain requirements (in this</span><br><span class="line">// case that it&apos;s a sequence with Node elements).</span><br><span class="line">associatedtype NodeSequence: Sequence where NodeSequence.Element == Node</span><br><span class="line"></span><br><span class="line">// Instead of using a concrete type (like [Node]) here, we</span><br><span class="line">// give implementors of this protocol more freedom while</span><br><span class="line">// still meeting our requirements. For example, one</span><br><span class="line">// implementation might use Set&lt;Node&gt;.</span><br><span class="line">func neighbors(of node: Node) -&gt; NodeSequence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义option sets，即OC的NS_OPTIONS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 必须是实现OptionSet协议</span><br><span class="line">struct Options: OptionSet &#123;</span><br><span class="line">static let saveToDisk = Options(rawValue: 1)</span><br><span class="line">static let clearOnMemoryWarning = Options(rawValue: 1 &lt;&lt; 1)</span><br><span class="line">static let clearDaily = Options(rawValue: 1 &lt;&lt; 2)</span><br><span class="line"></span><br><span class="line">let rawValue: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可用ChildViewController，它们会自动调整大小以匹配其父视图</p>
</li>
<li>使用元组来设置view状态，其实就是代替model，但不建议这么搞！因为没有规范，使用Class可明确含义，使用struct还能实现MVVM，元祖是最差的选择了，除非用于快速测试</li>
<li><p>swift访问剪贴板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Cocoa</span><br><span class="line"></span><br><span class="line">let clipboard = NSPasteboard.general.string(forType: .string)</span><br></pre></td></tr></table></figure>
</li>
<li><p>巧用self来实现链式…额不知道叫什么！不过，其实可以实现链式编程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Extension adding builder pattern-like properties that return</span><br><span class="line">// a new sequence value with the given configuration applied</span><br><span class="line">extension FileSequence &#123;</span><br><span class="line">var recursive: FileSequence &#123;</span><br><span class="line">var sequence = self</span><br><span class="line">sequence.isRecursive = true</span><br><span class="line">return sequence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var includingHidden: FileSequence &#123;</span><br><span class="line">var sequence = self</span><br><span class="line">sequence.includeHidden = true</span><br><span class="line">return sequence</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BEFORE</span><br><span class="line"></span><br><span class="line">let files = folder.makeFileSequence(recursive: true, includeHidden: true)</span><br><span class="line"></span><br><span class="line">// AFTER</span><br><span class="line"></span><br><span class="line">let files = folder.files.recursive.includingHidden</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用&amp; 来合成协议 UIViewController &amp; LoadableFromURL 、 protocolA &amp; protocolB</p>
</li>
<li><p>Parsing command line arguments using UserDefaults</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A really cool &quot;hidden&quot; feature of UserDefaults is that it contains any arguments that were passed to the app at launch!</span><br><span class="line"></span><br><span class="line">Super useful both in Swift command line tools &amp; scripts, but also to temporarily override a value when debugging iOS apps.</span><br><span class="line"></span><br><span class="line">let defaults = UserDefaults.standard</span><br><span class="line">let query = defaults.string(forKey: &quot;query&quot;)</span><br><span class="line">let resultCount = defaults.integer(forKey: &quot;results&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typealias Pair&lt;T&gt; = (T, T)</span><br><span class="line"></span><br><span class="line">extension Game &#123;</span><br><span class="line">func calculateScore(for players: Pair&lt;Player&gt;) -&gt; Int &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>associatedtype的使用,typealias 重命名RawValue是关键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol UnboxTransformable &#123;</span><br><span class="line">associatedtype RawValue</span><br><span class="line"></span><br><span class="line">static func transform(_ value: RawValue) throws -&gt; Self?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Array: UnboxTransformable where Element: UnboxTransformable &#123;</span><br><span class="line">typealias RawValue = [Element.RawValue]</span><br><span class="line"></span><br><span class="line">static func transform(_ value: RawValue) throws -&gt; [Element]? &#123;</span><br><span class="line">return try value.compactMap(Element.transform)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw是本函数异常，rethrow是本函数没事但本函数的闭包异常（即闭包有throw）</p>
</li>
<li><p>联类型的默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol Identifiable &#123;</span><br><span class="line">associatedtype RawIdentifier: Codable = String</span><br><span class="line"></span><br><span class="line">var id: Identifier&lt;Self&gt; &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User: Identifiable &#123;</span><br><span class="line">let id: Identifier&lt;User&gt;</span><br><span class="line">let name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Group: Identifiable &#123;</span><br><span class="line">typealias RawIdentifier = Int</span><br><span class="line"></span><br><span class="line">let id: Identifier&lt;Group&gt;</span><br><span class="line">let name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Encodable &amp; Decodable的扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Encodable &#123;</span><br><span class="line">func encoded() throws -&gt; Data &#123;</span><br><span class="line">return try JSONEncoder().encode(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Data &#123;</span><br><span class="line">func decoded&lt;T: Decodable&gt;() throws -&gt; T &#123;</span><br><span class="line">return try JSONDecoder().decode(T.self, from: self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let data = try user.encoded()</span><br><span class="line"></span><br><span class="line">// By using a generic type in the decoded() method, the</span><br><span class="line">// compiler can often infer the type we want to decode</span><br><span class="line">// from the current context.</span><br><span class="line">try userDidLogin(data.decoded())</span><br><span class="line"></span><br><span class="line">// And if not, we can always supply the type, still making</span><br><span class="line">// the call site read very nicely.</span><br><span class="line">let otherUser = try data.decoded() as User</span><br></pre></td></tr></table></figure>
</li>
<li><p>Matching multiple enum cases with associated values</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum DownloadState &#123;</span><br><span class="line">case inProgress(progress: Double)</span><br><span class="line">case paused(progress: Double)</span><br><span class="line">case cancelled</span><br><span class="line">case finished(Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func downloadStateDidChange(to state: DownloadState) &#123;</span><br><span class="line">switch state &#123;</span><br><span class="line">case .inProgress(let progress), .paused(let progress):</span><br><span class="line">updateProgressView(with: progress)</span><br><span class="line">case .cancelled:</span><br><span class="line">showCancelledMessage()</span><br><span class="line">case .finished(let data):</span><br><span class="line">process(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>展开可选值或抛出错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Optional &#123;</span><br><span class="line">func orThrow(_ errorExpression: @autoclosure () -&gt; Error) throws -&gt; Wrapped &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case .some(let value):</span><br><span class="line">return value</span><br><span class="line">case .none:</span><br><span class="line">throw errorExpression()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let file = try loadFile(at: path).orThrow(MissingFileError())</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用associatedtype约束protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protocol Component &#123;</span><br><span class="line">associatedtype Container</span><br><span class="line">func add(to container: Container)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Protocols that inherit from other protocols can include</span><br><span class="line">// constraints to further specialize them.</span><br><span class="line">protocol ViewComponent: Component where Container == UIView &#123;</span><br><span class="line">associatedtype View: UIView</span><br><span class="line">var view: View &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ViewComponent &#123;</span><br><span class="line">func add(to container: UIView) &#123;</span><br><span class="line">container.addSubview(view)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;最后:下篇其实干货不是很多，而且写这个的大神非常推崇元组，光元祖就写了一大堆</p>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>复习swift：SwiftyJSON</title>
    <url>/2018/03/24/%E5%A4%8D%E4%B9%A0swift%EF%BC%9ASwiftyJSON/</url>
    <content><![CDATA[<p>&emsp;&emsp;继续复习swift，就平时写dome那点代码量，swift还是会忘光的，反正也不知道水啥！开始复习</p>
<ul>
<li><p>SwiftyJSON内部通过枚举和私有属性将Data转为具体类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Type: Int &#123;</span><br><span class="line">case number</span><br><span class="line">case string</span><br><span class="line">case bool</span><br><span class="line">case array</span><br><span class="line">case dictionary</span><br><span class="line">case null</span><br><span class="line">case unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Private object</span><br><span class="line">fileprivate var rawArray: [Any] = []</span><br><span class="line">fileprivate var rawDictionary: [String: Any] = [:]</span><br><span class="line">fileprivate var rawString: String = &quot;&quot;</span><br><span class="line">fileprivate var rawNumber: NSNumber = 0</span><br><span class="line">fileprivate var rawNull: NSNull = NSNull()</span><br><span class="line">fileprivate var rawBool: Bool = false</span><br></pre></td></tr></table></figure>
</li>
<li><p>init的核心方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// Private method to unwarp an object recursively</span><br><span class="line">// 递归的拆解object对象，拆成数组、字典或基本类型</span><br><span class="line">private func unwrap(_ object: Any) -&gt; Any &#123;</span><br><span class="line">switch object &#123;</span><br><span class="line">case let json as JSON:</span><br><span class="line">return unwrap(json.object)</span><br><span class="line">case let array as [Any]:</span><br><span class="line">return array.map(unwrap)</span><br><span class="line">case let dictionary as [String: Any]:</span><br><span class="line">// 小细节，dictionary是let常量</span><br><span class="line">var d = dictionary</span><br><span class="line">// 小细节2，手动命名元祖pair，命名更清晰</span><br><span class="line">dictionary.forEach &#123; pair in</span><br><span class="line">d[pair.key] = unwrap(pair.value)</span><br><span class="line">&#125;</span><br><span class="line">return d</span><br><span class="line">default:</span><br><span class="line">return object</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>merge的核心方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">Private woker function which does the actual merging</span><br><span class="line">Typecheck is set to true for the first recursion level to prevent total override of the source JSON</span><br><span class="line">*/</span><br><span class="line">fileprivate mutating func merge(with other: JSON, typecheck: Bool) throws &#123;</span><br><span class="line">if type == other.type &#123;</span><br><span class="line">switch type &#123;</span><br><span class="line">case .dictionary:</span><br><span class="line">for (key, _) in other &#123;</span><br><span class="line">try self[key].merge(with: other[key], typecheck: false)</span><br><span class="line">&#125;</span><br><span class="line">case .array:</span><br><span class="line">self = JSON(arrayValue + other.arrayValue)</span><br><span class="line">default:</span><br><span class="line">self = other</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if typecheck &#123;</span><br><span class="line">throw SwiftyJSONError.wrongType</span><br><span class="line">&#125; else &#123;</span><br><span class="line">self = other</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>厉害的枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">这个枚举定义的好，支持泛型对子类型进行包装！</span><br><span class="line">又是实现协议，间接让JSON有了Collection的能力</span><br><span class="line">*/</span><br><span class="line">public enum Index&lt;T: Any&gt;: Comparable &#123;</span><br><span class="line">case array(Int)</span><br><span class="line">case dictionary(DictionaryIndex&lt;String, T&gt;)</span><br><span class="line">case null</span><br><span class="line"></span><br><span class="line">// 实现协议</span><br><span class="line">static public func == (lhs: Index, rhs: Index) -&gt; Bool &#123;</span><br><span class="line">switch (lhs, rhs) &#123;</span><br><span class="line">case (.array(let left), .array(let right)):           return left == right</span><br><span class="line">case (.dictionary(let left), .dictionary(let right)): return left == right</span><br><span class="line">case (.null, .null):                                  return true</span><br><span class="line">default:                                              return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static public func &lt; (lhs: Index, rhs: Index) -&gt; Bool &#123;</span><br><span class="line">switch (lhs, rhs) &#123;</span><br><span class="line">case (.array(let left), .array(let right)):           return left &lt; right</span><br><span class="line">case (.dictionary(let left), .dictionary(let right)): return left &lt; right</span><br><span class="line">default:                                              return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>厉害的数组path取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Int从数组中取，string从字典中取</span><br><span class="line">fileprivate subscript(sub sub: JSONSubscriptType) -&gt; JSON &#123;</span><br><span class="line">get &#123;</span><br><span class="line">switch sub.jsonKey &#123;</span><br><span class="line">/*</span><br><span class="line">第一次看到self[index: index]差点就绕进去了，后来才反应过来</span><br><span class="line">调用上面的fileprivate subscript(index index: Int) -&gt; JSON</span><br><span class="line">*/  </span><br><span class="line">case .index(let index): return self[index: index]</span><br><span class="line">case .key(let key):     return self[key: key]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">switch sub.jsonKey &#123;</span><br><span class="line">case .index(let index): self[index: index] = newValue</span><br><span class="line">case .key(let key):     self[key: key] = newValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public subscript(path: [JSONSubscriptType]) -&gt; JSON &#123;</span><br><span class="line">get &#123;</span><br><span class="line">// 越来越喜欢swift了，OC最起码10行起!</span><br><span class="line">// 友情提示：self起始参数、$0[sub: $1]下标取值</span><br><span class="line">return path.reduce(self) &#123; $0[sub: $1] &#125;</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">switch path.count &#123;</span><br><span class="line">case 0: return</span><br><span class="line">case 1: self[sub:path[0]].object = newValue.object</span><br><span class="line">default:</span><br><span class="line">var nextJSON = self[sub: path[0]]</span><br><span class="line">// 这里是递归，前提必须用下标语法</span><br><span class="line">var aPath = path</span><br><span class="line">aPath.remove(at: 0)</span><br><span class="line">nextJSON[aPath] = newValue</span><br><span class="line"></span><br><span class="line">self[sub: path[0]] = nextJSON</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>吐槽OC的可变参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 摘抄这段是因为swift的可变参数比OC的强太多了</span><br><span class="line">// OC的可变参数取值麻烦还是次要的，主要是第一个参数很多人容易忘了取，具体见我很早前写的博客</span><br><span class="line">public subscript(path: JSONSubscriptType...) -&gt; JSON &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return self[path]</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">self[path] = newValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载标识符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// MARK: - Comparable</span><br><span class="line"></span><br><span class="line">extension JSON: Swift.Comparable &#123;&#125;</span><br><span class="line"></span><br><span class="line">public func == (lhs: JSON, rhs: JSON) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">switch (lhs.type, rhs.type) &#123;</span><br><span class="line">case (.number, .number): return lhs.rawNumber == rhs.rawNumber</span><br><span class="line">case (.string, .string): return lhs.rawString == rhs.rawString</span><br><span class="line">case (.bool, .bool):     return lhs.rawBool == rhs.rawBool</span><br><span class="line">case (.array, .array):   return lhs.rawArray as NSArray == rhs.rawArray as NSArray</span><br><span class="line">case (.dictionary, .dictionary): return lhs.rawDictionary as NSDictionary == rhs.rawDictionary as NSDictionary</span><br><span class="line">case (.null, .null):     return true</span><br><span class="line">default:                 return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程1：概念和GCD</title>
    <url>/2016/04/17/%E5%A4%9A%E7%BA%BF%E7%A8%8B1%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8CGCD/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程2：NSOperation、NSThread和pthread</title>
    <url>/2016/04/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B2%EF%BC%9ANSOperation%E3%80%81NSThread%E5%92%8Cpthread/</url>
    <content><![CDATA[<h3 id="1-操作队列"><a href="#1-操作队列" class="headerlink" title="1 操作队列"></a>1 操作队列</h3><p>&emsp;&emsp;NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象！更高级意味着</p>
<ul>
<li>可以添加依赖关系，便于控制执行顺序，</li>
<li>可以设定优先级</li>
<li>监控操作状态（isExecuteing、isFinished、isCancelled）</li>
<li>可以实现completionBlock来实现完成时自动回调</li>
</ul>
<p>&emsp;&emsp;个人理解：使用NSOperationQueue才真正的创建新线程，NSOperation就相当于就是GCD里面的block！还有就是我们只能“创建”线程，但具体到底创建了几个线程，是由系统决定的……好坑！不过一般情况下不用关心线程数量</p>
<p>&emsp;&emsp;另外需要注意的是：cancel某个操作（或操作队列），并不代表操作立即取消，只是设置个标志位告诉系统这个操作（或操作队列）需要cancel，系统去决定什么时候cancel</p>
<h4 id="1-1-NSOperation使用"><a href="#1-1-NSOperation使用" class="headerlink" title="1.1 NSOperation使用"></a>1.1 NSOperation使用</h4><ul>
<li><p>NSBlockOperation的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSBlockOperation *opearation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;];</span><br><span class="line">// 添加额外子操作，等所有子操作(包括do something)都完成，才认为这次操作完成了</span><br><span class="line">[opearation addExecutionBlock:^&#123;</span><br><span class="line">// other something</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 以下为NSOperation属性以及解释</span><br><span class="line">opearation.name = @&quot;name可做标志位&quot;;</span><br><span class="line">opearation.completionBlock = ^&#123;</span><br><span class="line">NSLog(@&quot;已完成&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">// 开启任务</span><br><span class="line">[opearation start];</span><br><span class="line">// 是否正在执行</span><br><span class="line">[opearation isExecuting];</span><br><span class="line">// 是否执行完了</span><br><span class="line">[opearation isFinished];</span><br><span class="line">// 当前操作是否执行完了</span><br><span class="line">[opearation isAsynchronous];</span><br><span class="line">// 是否准备好去执行</span><br><span class="line">[opearation isReady];</span><br><span class="line">// 添加依赖, 就是要等beferOpearation完成，才执行opearation</span><br><span class="line">// 注意一定不要创建一个循环依赖，A依赖B，B依赖A，这样会造成死锁</span><br><span class="line">// [opearation addDependency:beferOpearation];</span><br><span class="line">// 移除依赖</span><br><span class="line">// [opearation removeDependency:beferOpearation];</span><br><span class="line">// 阻塞当前线程，直到该操作结束, GCD的栅栏效果</span><br><span class="line">[opearation waitUntilFinished];</span><br><span class="line">// 取消</span><br><span class="line">if (![opearation isCancelled]) &#123;</span><br><span class="line">[opearation cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSInvocationOperation的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSInvocationOperation *opearation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">[opearation start];</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSOperation的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface MyOperation: NSOperation</span><br><span class="line">@end</span><br><span class="line">@implementation MyOperation</span><br><span class="line">- (void)main &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">MyOperation *operation = [[MyOperation alloc] init];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-2-NSOperationQueue使用"><a href="#1-2-NSOperationQueue使用" class="headerlink" title="1.2 NSOperationQueue使用"></a>1.2 NSOperationQueue使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSBlockOperation *opearation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;];</span><br><span class="line">// 创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">// 添加操作，操作顺序有依赖关系和qualityOfService决定，并不一定是FIFO</span><br><span class="line">[queue addOperation:opearation];</span><br><span class="line">// 添加一组操作，并阻塞线程到这一组操作都完成</span><br><span class="line">[queue addOperations:@[opearation] waitUntilFinished:YES];</span><br><span class="line">// 添加一个新操作</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">// new opearation will do something</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;当前所有的操作：%@，注意操作完成后会自动从数组中移除&quot;, queue.operations);</span><br><span class="line">NSLog(@&quot;当前所有的操作数量：%i&quot;, queue.operationCount);</span><br><span class="line">/*</span><br><span class="line">最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</span><br><span class="line">不等于并发线程的数量，线程个数是系统决定的，而且一个操作也有可能不止再一个线程执行</span><br><span class="line">当然maxConcurrentOperationCount为1，即表示串行队列</span><br><span class="line">*/</span><br><span class="line">queue.maxConcurrentOperationCount = 1;</span><br><span class="line">// 暂停或开启所有操作</span><br><span class="line">if (queue.suspended) &#123;</span><br><span class="line">[queue setSuspended:NO];</span><br><span class="line">&#125;</span><br><span class="line">// 阻塞当前线程，直到队列中的操作全部执行完毕</span><br><span class="line">[queue waitUntilAllOperationsAreFinished];</span><br><span class="line">// 取消所有操作</span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure>
<h3 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2 NSThread"></a>2 NSThread</h3><p>&emsp;&emsp;NSThread和pthread很不常用，而且需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销!</p>
<ul>
<li><p>创建线程方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1 创建线程并启动</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];   </span><br><span class="line"></span><br><span class="line">// 2 创建线程，但需要手动启动</span><br><span class="line">NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];   </span><br><span class="line">[myThread setName=@&quot;调试用&quot;];</span><br><span class="line">[myThread setThreadPriority:NSQualityOfServiceDefault];// 设置优先级</span><br><span class="line">[myThread start]; // 启动</span><br><span class="line">[myThread cancel]; // 取消</span><br><span class="line">[myThread exit]; // 退出</span><br><span class="line"></span><br><span class="line">// 3 系统会创建一个子线程并启动</span><br><span class="line">[self performSelectorInBackground:@selector(threadRun) withObject:self];</span><br><span class="line">// 一般配合使用来更新UI</span><br><span class="line">[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; </span><br><span class="line"></span><br><span class="line">// 4 继承NSThread需重写main方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 获取当前线程</span><br><span class="line">[NSThread currentThread]</span><br><span class="line">// 当前线程是不是主线程</span><br><span class="line">[[NSThread currentThread] isMainThread]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-1：主线程检测的最标准写法"><a href="#2-1：主线程检测的最标准写法" class="headerlink" title="2.1：主线程检测的最标准写法"></a>2.1：主线程检测的最标准写法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// RAC源码</span><br><span class="line">+ (BOOL)isOnMainThread &#123;</span><br><span class="line">return [NSOperationQueue.currentQueue isEqual:NSOperationQueue.mainQueue] || [NSThread isMainThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-pthread"><a href="#3-pthread" class="headerlink" title="3 pthread"></a>3 pthread</h3><ul>
<li>转载自：<a href="https://github.com/ming1016/study/wiki/iOS并发编程" target="_blank" rel="noopener">https://github.com/ming1016/study/wiki/iOS并发编程</a></li>
<li><p>下面是并发4个线程在一百万个数字中找最小值和最大值的pthread例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">struct threadInfo &#123;</span><br><span class="line">uint32_t * inputValues;</span><br><span class="line">size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct threadResult &#123;</span><br><span class="line">uint32_t min;</span><br><span class="line">uint32_t max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void * findMinAndMax(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">struct threadInfo const * const info = (struct threadInfo *) arg;</span><br><span class="line">uint32_t min = UINT32_MAX;</span><br><span class="line">uint32_t max = 0;</span><br><span class="line">for (size_t i = 0; i &lt; info-&gt;count; ++i) &#123;</span><br><span class="line">uint32_t v = info-&gt;inputValues[i];</span><br><span class="line">min = MIN(min, v);</span><br><span class="line">max = MAX(max, v);</span><br><span class="line">&#125;</span><br><span class="line">free(arg);</span><br><span class="line">struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));</span><br><span class="line">result-&gt;min = min;</span><br><span class="line">result-&gt;max = max;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">size_t const count = 1000000;</span><br><span class="line">uint32_t inputValues[count];</span><br><span class="line"></span><br><span class="line">// 使用随机数字填充 inputValues</span><br><span class="line">for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">inputValues[i] = arc4random();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始4个寻找最小值和最大值的线程</span><br><span class="line">size_t const threadCount = 4;</span><br><span class="line">pthread_t tid[threadCount];</span><br><span class="line">for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));</span><br><span class="line">size_t offset = (count / threadCount) * i;</span><br><span class="line">info-&gt;inputValues = inputValues + offset;</span><br><span class="line">info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line">int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);</span><br><span class="line">NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err);</span><br><span class="line">&#125;</span><br><span class="line">// 等待线程退出</span><br><span class="line">struct threadResult * results[threadCount];</span><br><span class="line">for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">int err = pthread_join(tid[i], (void **) &amp;(results[i]));</span><br><span class="line">NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err);</span><br><span class="line">&#125;</span><br><span class="line">// 寻找 min 和 max</span><br><span class="line">uint32_t min = UINT32_MAX;</span><br><span class="line">uint32_t max = 0;</span><br><span class="line">for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">min = MIN(min, results[i]-&gt;min);</span><br><span class="line">max = MAX(max, results[i]-&gt;max);</span><br><span class="line">free(results[i]);</span><br><span class="line">results[i] = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;min = %u&quot;, min);</span><br><span class="line">NSLog(@&quot;max = %u&quot;, max);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用NSThread来写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface FindMinMaxThread : NSThread</span><br><span class="line">@property (nonatomic) NSUInteger min;</span><br><span class="line">@property (nonatomic) NSUInteger max;</span><br><span class="line">- (instancetype)initWithNumbers:(NSArray *)numbers;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FindMinMaxThread &#123;</span><br><span class="line">NSArray *_numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithNumbers:(NSArray *)numbers</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">_numbers = numbers;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)main</span><br><span class="line">&#123;</span><br><span class="line">NSUInteger min;</span><br><span class="line">NSUInteger max;</span><br><span class="line">// 进行相关数据的处理</span><br><span class="line">self.min = min;</span><br><span class="line">self.max = max;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//启动一个新的线程，创建一个线程对象</span><br><span class="line">NSMutableSet *threads = [NSMutableSet set];</span><br><span class="line">NSUInteger numberCount = self.numbers.count;</span><br><span class="line">NSUInteger threadCount = 4;</span><br><span class="line">for (NSUInteger i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">NSUInteger offset = (count / threadCount) * i;</span><br><span class="line">NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);</span><br><span class="line">NSRange range = NSMakeRange(offset, count);</span><br><span class="line">NSArray *subset = [self.numbers subarrayWithRange:range];</span><br><span class="line">FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</span><br><span class="line">[threads addObject:thread];</span><br><span class="line">[thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读一本书</title>
    <url>/2015/03/01/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/</url>
    <content><![CDATA[<h3 id="1-阅读的层次"><a href="#1-阅读的层次" class="headerlink" title="1 阅读的层次"></a>1 阅读的层次</h3><h4 id="1-1-阅读的活力与艺术"><a href="#1-1-阅读的活力与艺术" class="headerlink" title="1.1 阅读的活力与艺术"></a>1.1 阅读的活力与艺术</h4><ul>
<li>泛滥的资讯属于被动阅读（是不是很有意思，明明是自己没事干，刷 刷 刷 刷出来的），用不着自己思考</li>
<li>阅读越主动，效果越好。参与其中，思考技巧。</li>
<li>一看就懂的属于资讯，看了半天不动的是为了理解。增强理解能力是核心。</li>
</ul>
<h4 id="1-2-阅读的层次"><a href="#1-2-阅读的层次" class="headerlink" title="1.2 阅读的层次"></a>1.2 阅读的层次</h4><ul>
<li>基础阅读：认识字，能把文段串起来。</li>
<li>检视阅读：一定时间内抓重点，检视目录，最起码知道书叫什么？架构？哪些部分？</li>
<li>分析阅读：全盘阅读，完整阅读。一种专注活动，要抓紧阅读，直到这本书成为他自己为止。</li>
<li>高层次阅读：主题阅读，涉及面广，读的书多</li>
</ul>
<h4 id="1-3-基础阅读"><a href="#1-3-基础阅读" class="headerlink" title="1.3 基础阅读"></a>1.3 基础阅读</h4><h4 id="1-4-检视阅读"><a href="#1-4-检视阅读" class="headerlink" title="1.4 检视阅读"></a>1.4 检视阅读</h4><ul>
<li>有系统的略读或粗读，事实上即便应该精读的书开始也要略读粗读。</li>
<li>略读建议：</li>
<li>A，先看书名，快速看序，特别注意副标题等相关说明；</li>
<li>B，仔细阅读目录页；</li>
<li>C，如果书中附有索引，也要检阅一下，可以快速评估书论述范围，重点引用可能跟论点论据有关；</li>
<li>D，如果那是本包着书衣的新书，不妨读一下出版者的介绍。自我介绍都不行，瞎吹，就可以放弃了；</li>
<li>E，从你对一本书的目录很概略，甚至有点模糊的印象当中，开始挑几个看来跟主题嘻嘻相关的篇章来看，如果这些篇章在开头或者结尾有摘要说明，就要仔细的阅读这些说明；</li>
<li>F，最后一步，把书打开来，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。最重要的是，不要忽略最后的两三页，就算最后有后记，一本书的最后结尾的两三页也还是不可忽视的。</li>
<li>粗浅的阅读：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂得地方不停下来查询或思索。不要被一个看不懂的地方阻挠或泄气，先读一遍再说。</li>
<li>阅读的速度，许多书其实连略读都不值得的，另外一些书只需要快速读过就行了。核心就是，要知道什么时候用什么速度是恰当的。慢不该慢到不值得，快不该快到有损于满足于理解。</li>
<li>逗留与倒退，简单的说就是快速看书，感觉看不清而暂停或回头重看，这是坏习惯！！！事实上大脑可以在“一瞥”间掌握一个句子或段落，只要眼睛能够提供足够的资讯。</li>
<li>训练方法：将大拇指与食指，中指合并在一起，用这个“指针”顺着一行一行的字移动下去，速度要比你的眼睛感觉还要快一点，强迫自己的眼睛跟着手部的动作移动。一旦你的眼睛跟着手部移动，你就能读到那些字句了。</li>
<li>理解的问题，一旦你能跟随自己的手指阅读，就很难打瞌睡，胡思乱想了</li>
</ul>
<h4 id="1-5-如何做一个自我要求的读者"><a href="#1-5-如何做一个自我要求的读者" class="headerlink" title="1.5 如何做一个自我要求的读者"></a>1.5 如何做一个自我要求的读者</h4><ul>
<li>主动阅读的基础，关于一本书，你一定要提出四个主要问题：</li>
<li>A，整体来说，这本书到底在谈些什么？一定要想办法找出主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来；</li>
<li>B，作者细部说了什么，怎么说的？一定要想办法找出主要的想法，声明和论点，这些组合成作者想要传达的特殊讯息；</li>
<li>C，这本书说的有道理吗？是全部有道理还是部分有道理？</li>
<li>D，这本书跟我有什么关系？</li>
<li>任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题，然后尽可能的找到答案。</li>
<li>如何让一本书真正属于你自己</li>
<li>最好的方式就是写下来，做笔记，最好有一套自己的标注习惯，笔记习惯！</li>
<li>还有一个办法，脑图！</li>
<li>培养阅读习惯：慢慢来</li>
</ul>
<h3 id="2-阅读的三个层次：分析阅读"><a href="#2-阅读的三个层次：分析阅读" class="headerlink" title="2 阅读的三个层次：分析阅读"></a>2 阅读的三个层次：分析阅读</h3><h4 id="2-1-一本书的分类"><a href="#2-1-一本书的分类" class="headerlink" title="2.1 一本书的分类"></a>2.1 一本书的分类</h4><ul>
<li>书籍分类的重要性，分析阅读的第一个规则可以这么说，你一定要知道自己在读的是哪一类书，而且越早知道越好，最好在i开始阅读之前就先知道。</li>
<li>区分实用书和理论书，首先要学习去怀疑一切；传统理论书被分类成历史、科学和哲学（如果一本理论书超越你日常生活经验，那就是科学书）等等</li>
</ul>
<h4 id="2-2-透视一本书"><a href="#2-2-透视一本书" class="headerlink" title="2.2 透视一本书"></a>2.2 透视一本书</h4><ul>
<li>分析阅读的第二个规则：实用一个单一的句子，或最多几句话（一小段话）来叙述整本书的内容。好的作者，总是在帮读者整理，而且最重要的是总结只有好坏之分没有对错之别。</li>
<li>第三个规则可以说成：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。</li>
<li>按照顺序与关系，列出全书的重要部分，将全书的纲要拟出来后，再将各个部分的纲要也一一列出。自己列的提纲不一定与作者列的一样，只是根据自己的理解自己总结的东西罢了。</li>
<li>千万不要在读不出头绪的时候，就认为是自己的问题，也有可能是作者本来就很烂呀！但还是要尽量读出点东西来！</li>
<li>找出作者在问的问题，或作者想要解决的问题。</li>
</ul>
<h4 id="2-3-与作者找出共通的词义。"><a href="#2-3-与作者找出共通的词义。" class="headerlink" title="2.3 与作者找出共通的词义。"></a>2.3 与作者找出共通的词义。</h4><ul>
<li>规则四：找出共通的词义</li>
<li>规则五：找出重要的单字，透过它们与作者达成共识。一个字可能表达很多意思，一定要根据上下文推敲此字义和作者要表达的是否一致。找出关键字，作者使用的大多数字都不重要。</li>
<li>规则六：将一本书中最重要的句子圈出来，找出其中的主旨。主旨是表达观点或知识。</li>
<li>规则七：从相关文句的关联中，设法架构出一本书的基本论述。发现读不懂的句子，找出组成关键句的文字，找到顺序，有始有终。“用你自己的话来说”是测验你懂不懂一个句子的主旨的最佳方法。如果可以找出书中说明重要论述的段落。</li>
<li>规则八：找出作者在书中想要解决的主要问题</li>
</ul>
<h4 id="2-4-批判性阅读"><a href="#2-4-批判性阅读" class="headerlink" title="2.4 批判性阅读"></a>2.4 批判性阅读</h4><ul>
<li>规则九：要求读者先完整的了解一本书，不要急着开始评论</li>
<li>规则十：恳请读者不要争强好辩或盲目反对，谨记争论是在教导和受教，需要很大的耐心</li>
<li>规则十一：要求读者要为自己的不同意见找到理论基础。要区分是对作者还是对书有争论</li>
</ul>
<h4 id="2-5-怎么说服人"><a href="#2-5-怎么说服人" class="headerlink" title="2.5 怎么说服人"></a>2.5 怎么说服人</h4><ul>
<li>在读者说出：“我了解，但我不同意”之后，他可以用一下概念想作者说明：</li>
<li>A，你的知识不足；</li>
<li>B，你的知识有错误；</li>
<li>C，你不合逻辑，你的推论sh无法使人信服；</li>
<li>D，你的分析不够完整。</li>
</ul>
<h4 id="2-6-不要被别人影响"><a href="#2-6-不要被别人影响" class="headerlink" title="2.6 不要被别人影响"></a>2.6 不要被别人影响</h4><ul>
<li>不建议外在阅读，简单的说就是什么书评，文凭啥的尽量少看，自己去思考自己去想！导读摘要可以看，但也尽量少看！根本原因是，这些东西不一定符合作者的意思，不一定是对的，不一定是完整的！</li>
</ul>
<h4 id="2-7-如何阅读实用型的书"><a href="#2-7-如何阅读实用型的书" class="headerlink" title="2.7 如何阅读实用型的书"></a>2.7 如何阅读实用型的书</h4><ul>
<li>任何实用书都不能解决该书所关心的实际问题，只能靠行动来解决！</li>
<li>这书谈什么？目的？真实？与我何干？如果理解且接受了，那就行动吧！</li>
</ul>
<h4 id="2-8-简单的说就是如何做阅读理解"><a href="#2-8-简单的说就是如何做阅读理解" class="headerlink" title="2.8 简单的说就是如何做阅读理解"></a>2.8 简单的说就是如何做阅读理解</h4><h3 id="第二十章-主题阅读"><a href="#第二十章-主题阅读" class="headerlink" title="第二十章 主题阅读"></a>第二十章 主题阅读</h3><ol>
<li>先检视阅读一下，确定书和主题是否有关，接下来五步</li>
<li>找到相关章节</li>
<li>带着共识</li>
<li>理清问题</li>
<li>界定议题</li>
<li>分体讨论</li>
</ol>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>学习技巧</title>
    <url>/2015/11/30/%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>&emsp;&emsp;我，半个码农！还没入行Java，马上又换行到iOS，重新自学新语言：Object-C！因是公司内部转岗，基本上所有的东西都要自学，东一榔头，西一棒子的学，也不可能专门拿出两三个月专门去培训（还是因为穷，不工作连房租饭费都没有！更不要说1万多的天文培训费，真心没钱！贷款培训？我傻吗！有工作不干，借钱吃饭贷款培训！！！），历经种种阵痛，现在也算是可以写tableview的iOS，现总结一下以往的学习经验</p>
<p>&emsp;&emsp;<strong>公司和学校真的不一样</strong>！我承认我是学渣，渣的不能再渣！大学（也很渣…）4年，上午的课几乎就没去过(嗯，我要说都怪晚上11点半才断电，手机电脑还能撑好几个小时你们可以理解吧)！下午的课，看心情……整天不是在看小说就是在玩游戏（三国志系列和P社四萌是我的最爱，但真心不推荐玩，比网游更费时间）！啰里啰嗦的说了这么多，其实我想说的：学校里的东西真的很简单，没人强迫你拿出产出，考试过了就可以了。我虽然是渣中之渣，但混个60分还是很简单的：考前两三天看看书背一背就可以了（额…高数，用了两周）！当然也挂过科，唯一一次挂科贡献给了一门选修课！但等到工作的时候，再背书就不管用了，再集中突击，该不会的还不会！而现实是我必须要尽快上手(公司内部转岗，给我一两周学习已经是天大的恩赐了)！压力不一样，心态和效率也就不一样！</p>
<p>&emsp;&emsp;<strong>学习新语言必先学语法</strong>！很多人告诉我，语法看看就行了，先去做项目，多做几遍什么语法都会了！等等，这些语法都是什么鬼？这么多层嵌套都是咋回事？嗯，一开始我就是这么被坑的，我真的花了一两天时间熟悉一下语法就去看项目了！一看它认识我，我不认识它！啃了一天也没弄明白数据是怎么流动的，又强忍着性子，从新学习语法！再重申一遍：学习新语言必先学语法！不要求百分之百都记下来，但特殊语法一定要记下来！例如，基本类型、枚举、结构体等一带而过就可以，这些东西99%都一样，没必要花费时间去仔细研究，大不了采坑！但像block，MRC、引用计数啥的要敲些代码仔细研究一下使用方法才好！</p>
<p>&emsp;&emsp;<strong>尽快学习IDE的使用技巧</strong>！xcode是我见过的，最简单、最可靠、功能最齐全的IDE,说实话一开始配置SSH（Spring、Struts、Hibernate）时，我着实的折腾了一两天，还是在同学的帮助下弄完的！但XCode只能用一个字来形容：爽！学习一门新语言要尽快适应IDE，学习IDE使用技巧和调试技巧！这是稳赚不赔的买卖，提升的何止是效率！我印象最深的教训：第一次使用xib时，我足足花了一下午的时间去学习xib的属性是怎么和h文件的属性连接在一起的！因我们项目整体是手动计算frame的，几乎没用到xib，而我是快速自学的，代码都是参照现有项目来的，没见过xib！网上的文章将xib的都是什么属性怎么用，我最关心的怎么连接这点事根本就没人写,最后还是找了个视频才知道….还真就是太简单了才没人写</p>
<p>&emsp;&emsp;<strong>关于教学视频，我是不喜欢的</strong>！现在网上资源十分丰富，很多人都是通过教学视频来入门各种语言的，但我个人不以为然！原因如下：1，大多数的教学视频质量真的不咋地！2，质量稍微好点的都要去培训班，而我没时间去！3，大多数视频时间太长，能用5分钟解决的，非要用一小时去哔哔！当然，每个人都有自己的看法，我只不过没有养成认真听讲的习惯……</p>
<p>&emsp;&emsp;<strong>关于看书,最好一目十行，找到不懂得或感兴趣的再仔细研究</strong>！现在的书籍同质化太严重了，翻来覆去就那点东西，网上大堆大堆的iOS入门书籍，大多是废话连篇，没啥干货，连我这种还没入门的小菜鸟都忽悠不了！但有些经典书还是非常好的，编写高质量iOS和OSX的52个方法和OC高级编程iOS与OSX多线程和内存管理就非常不错</p>
<p>&emsp;&emsp;<strong>请教问题是个大学问</strong>！我总结了一下我认为比较合理的方法：1、百度不到再去问人！不要浪费别人的时间，何况别人的时间更值钱！2、在别人有时间的时候见缝插针的提问，能问到更好，问不到也别纠缠！重要是别让人烦！3、态度要诚恳，语气要温和！你有问题没解决你很着急，但这管他什么事？把他惹毛了就不告诉你，你岂不是更尴尬更难受！4、实在处理不了，要学会放弃！毕竟是菜鸟，与其问也问不到写也不会写还死扛着，还不如认怂交给老大做，老大做完你再慢慢学吗</p>
<p>&emsp;&emsp;<strong>最最重要的是会百度，肯踩坑</strong>！</p>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>子线程绘制UI检查工具</title>
    <url>/2017/07/07/%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%98%E5%88%B6UI%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>&emsp;&emsp;今天UI走查，对样式进行了大量修改，但改完后一个view的背景色等总是慢半拍！一开始没注意到这个问题，直到UI童鞋给我提了BUG…</p>
<h4 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h4><ol>
<li>是不是网络延迟的事？改为写死颜色值！结论：复现</li>
<li>是不是动画造成的？删除相关动画，保留基础代码！结论：复现</li>
<li>打点后查看日志，发现 Main Thread Checker: UI API called on a background thread ，子线程渲染UI！改为主线程刷新，解决问题！</li>
</ol>
<h4 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h4><ol>
<li>我习惯于网络请求成功后回调前切换到主线程回调，这样上层UI不需要关心线程问题，拿来数据进行渲染就可以了！毕竟UI请求时也没切换到子线程去请求</li>
<li>同事习惯于网络请求成功后先回调给UI，如果UI需要渲染在自己切换主线程……我就是这么掉坑里的</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>自己写了个简单的子线程UI绘制检查方案，如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation UIView (MainThread)</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(setNeedsLayout) swizzledSelector:@selector(mainThread_setNeedsLayout)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(setNeedsDisplay) swizzledSelector:@selector(mainThread_setNeedsDisplay)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(setNeedsDisplayInRect:) swizzledSelector:@selector(mainThread_setNeedsDisplayInRect:)];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mainThread_setNeedsLayout &#123;</span><br><span class="line">[self UIMainThreadCheck];</span><br><span class="line">[self mainThread_setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mainThread_setNeedsDisplay &#123;</span><br><span class="line">[self UIMainThreadCheck];</span><br><span class="line">[self mainThread_setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)mainThread_setNeedsDisplayInRect:(CGRect)rect &#123;</span><br><span class="line">[self UIMainThreadCheck];</span><br><span class="line">[self mainThread_setNeedsDisplayInRect:rect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)UIMainThreadCheck &#123;</span><br><span class="line">NSString *desc = [NSString stringWithFormat:@&quot;%@ 类没在主线程执行请检查相关代码实现&quot;, self.class];</span><br><span class="line">NSAssert([NSThread isMainThread], desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">+ (void)hookWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">Class class = [self class];</span><br><span class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">originalSelector,</span><br><span class="line">method_getImplementation(swizzledMethod),</span><br><span class="line">method_getTypeEncoding(swizzledMethod));</span><br><span class="line">if (didAddMethod) &#123;</span><br><span class="line">class_replaceMethod(class,</span><br><span class="line">swizzledSelector,</span><br><span class="line">method_getImplementation(originalMethod),</span><br><span class="line">method_getTypeEncoding(originalMethod));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>安装包瘦身</title>
    <url>/2017/03/25/%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<h3 id="1、编译选项"><a href="#1、编译选项" class="headerlink" title="1、编译选项"></a>1、编译选项</h3><ul>
<li><p>参考：<a href="https://www.jianshu.com/p/11710e7ab661" target="_blank" rel="noopener">https://www.jianshu.com/p/11710e7ab661</a> 或 <a href="https://stackoverflow.com/questions/17650138/ios-ipa-file-size-xcode-archive-vs-xcodebuild-command" target="_blank" rel="noopener">https://stackoverflow.com/questions/17650138/ios-ipa-file-size-xcode-archive-vs-xcodebuild-command</a></p>
</li>
<li><p>1，做SDK最好设置Generate Debug Symbols为NO，防止泄露源代码，但APP最好设置Generate Debug Symbols为YES,因为需要dysm文件</p>
</li>
<li>2，xcode-archive打包，xcode会默认把Deployment Postprocessing设为YES，但xcodebuild-command不会</li>
</ul>
<h3 id="2、资源瘦身"><a href="#2、资源瘦身" class="headerlink" title="2、资源瘦身"></a>2、资源瘦身</h3><h4 id="2-1-压缩图片"><a href="#2-1-压缩图片" class="headerlink" title="2.1 压缩图片"></a>2.1 压缩图片</h4><ul>
<li>PNG压缩参考： <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></li>
<li>暂不考虑webP格式，iOS使用webp需引入<a href="https://github.com/carsonmcdonald/WebP-iOS-example" target="_blank" rel="noopener">WebP-iOS-example</a> , 安卓有webP瘦身计划，可等他们一起做</li>
</ul>
<p>&emsp;&emsp;其它图片压缩工具</p>
<ul>
<li>1、pngquant <a href="https://pngquant.org" target="_blank" rel="noopener">官网</a>  <a href="https://github.com/kornelski/pngquant" target="_blank" rel="noopener">github</a></li>
<li><p>2、IconFont技术：用字体显示图标来减小包体积，<a href="https://www.jianshu.com/p/3b10bb95b332" target="_blank" rel="noopener">参考</a>,例RN的使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">NSURL *fontUrl = [NSURL fileURLWithPath:path];</span><br><span class="line">if (!fontUrl) return nil;</span><br><span class="line">if (![[NSFileManager defaultManager] fileExistsAtPath:path]) return nil;</span><br><span class="line">CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)fontUrl);</span><br><span class="line">CGFontRef fontRef = CGFontCreateWithDataProvider(fontDataProvider);</span><br><span class="line">CGDataProviderRelease(fontDataProvider);</span><br><span class="line">CTFontManagerUnregisterGraphicsFont(fontRef, NULL);</span><br><span class="line">CTFontManagerRegisterGraphicsFont(fontRef, NULL);</span><br><span class="line">NSString *fontName = CFBridgingRelease(CGFontCopyPostScriptName(fontRef));</span><br><span class="line">CGFontRelease(fontRef);</span><br><span class="line">return fontName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、pngcrush 一款开源的png压缩工具，Xcode自带pngcrush，默认目录为/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/pngcrush ，<a href="https://blog.csdn.net/u011774517/article/details/51627261" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pngcrush使用命令为：</span><br><span class="line">pngcrush [options]  infile.png  outfile.png</span><br><span class="line">其中：</span><br><span class="line">infile.png：输入的原始图片；</span><br><span class="line">outfile.png：压缩后的输出图片；</span><br><span class="line">[options]：参数，支持如下设置</span><br><span class="line">-rem allb ：移除所有多余的数据；</span><br><span class="line">-brute ：将尝试所有可能的优化方法；</span><br><span class="line">-reduce ：删除无用颜色及减少表示颜色的位大小；</span><br><span class="line">图片的最大压缩方式为：pngcrush -rem allb -brute -reduce original.png optimized.png</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-使用Asset-Catalog管理图片"><a href="#2-2-使用Asset-Catalog管理图片" class="headerlink" title="2.2  使用Asset Catalog管理图片"></a>2.2  使用Asset Catalog管理图片</h4><ul>
<li>使用方法: <a href="https://blog.csdn.net/lihuiqwertyuiop/article/details/51286219" target="_blank" rel="noopener">https://blog.csdn.net/lihuiqwertyuiop/article/details/51286219</a></li>
<li>特殊说明：只有使用了imageNamed：方式加载的图片才能使用Asset catalog管理，其他形式加载的图片依然使用bundle管理。</li>
<li>Asset Catalog中图片需要供2X和3X两种尺寸图片，发布包可根据发布的机型进行图片资源的裁剪，若仅提供某一尺寸图片时，表现如下：</li>
<li>1、若仅提供1x图，假设图片100<em>100 px，2x、3x机型上都可以读取图片，图片尺寸均为100</em>100 pt，推荐设备无关的图片使用该尺寸；</li>
<li>2、若仅提供2x图，假设图片100<em>100 px，2x、3x机型上都可以读取图片，图片尺寸均为50</em>50 pt，该方式会造成3x设备图片清晰度降低，推荐分别提供2x、3x图片；</li>
<li>3、若仅提供3x图，假设图片150<em>150 px，2x、3x机型上都可以读取图片，图片尺寸均为50</em>50 pt，该方式会造成2x设备图片资源体积浪费，推荐分别提供2x、3x图片；</li>
<li><a href="https://help.apple.com/xcode/mac/current/#/dev10510b1f7" target="_blank" rel="noopener">Xcode Help - WORK WITH ASSETS</a></li>
<li><a href="https://stackoverflow.com/questions/22630418/analysing-assets-car-file-in-ios/44597439#44597439" target="_blank" rel="noopener">Analysing Assets.car file in iOS</a></li>
</ul>
<h4 id="2-3-音视频压缩"><a href="#2-3-音视频压缩" class="headerlink" title="2.3 音视频压缩"></a>2.3 音视频压缩</h4><h4 id="2-4-清理重复资源或文件"><a href="#2-4-清理重复资源或文件" class="headerlink" title="2.4 清理重复资源或文件"></a>2.4 清理重复资源或文件</h4><ol>
<li>先下载最新版的fudpes并解压，<a href="https://github.com/adrianlopezroche/fdupes" target="_blank" rel="noopener">https://github.com/adrianlopezroche/fdupes</a></li>
<li>进入解压后目录，执行下面的命令安装fdupes：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make fdupes</span><br><span class="line">su root</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="2-5-无用的类"><a href="#2-5-无用的类" class="headerlink" title="2.5 无用的类"></a>2.5 无用的类</h4><ul>
<li><a href="https://github.com/dblock/fui" target="_blank" rel="noopener">fui</a>   PS:需要手动检查并删除，注意有些类以前删除时只删除了引用</li>
</ul>
<h4 id="2-6-删除无用的图片"><a href="#2-6-删除无用的图片" class="headerlink" title="2.6 删除无用的图片"></a>2.6 删除无用的图片</h4><ul>
<li><a href="https://github.com/tinymind/LSUnusedResources" target="_blank" rel="noopener">LSUnusedResources</a> PS：需要手动检查并删除</li>
</ul>
<h3 id="3、代码瘦身"><a href="#3、代码瘦身" class="headerlink" title="3、代码瘦身"></a>3、代码瘦身</h3><h4 id="3-1-静态库瘦身"><a href="#3-1-静态库瘦身" class="headerlink" title="3.1 静态库瘦身"></a>3.1 静态库瘦身</h4><ul>
<li><p>xcode默认支持，无须手动处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xcode的Architectures setting默认支持armv7（如果以后不支持4和4s机型，可考虑移除armv7架构支持，减少ipa体积达8M多）、armv7s和arm64架构</span><br><span class="line">，release打包时xcode将默认剔除i386和x86_64等模拟器架构，无须手动处理！</span><br><span class="line">release打包默认剔除i386和x86_64，构验证如下：</span><br><span class="line">验证工具：lipo 使用方法https://blog.csdn.net/yepiaouang/article/details/79353377</span><br><span class="line">A、libZXingObjC-iOS.a ，大小为20.2M， 默认支持架构如下</span><br><span class="line">默认打包后ipa大小为34.9M</span><br><span class="line">B、libZXingObjC-iOS.a  经过lipo去除i386和x86_64架构支持后，为10.4M，支持架构如下</span><br><span class="line">打包后大小也为34.9M</span><br><span class="line">即证明设置xcode的Architectures setting后打包xcode会剔除i386和x86_64等模拟器架构，无须手动处理！</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="http://iliunian.cn/15064930162279.html" target="_blank" rel="noopener">关于Xcode “Build Setting”中的Architectures详解</a></p>
</li>
</ul>
<h4 id="3-2-无用的方法"><a href="#3-2-无用的方法" class="headerlink" title="3.2 无用的方法"></a>3.2 无用的方法</h4><ul>
<li>可用APPCode(收费) 或 <a href="https://github.com/ming1016/SMCheckProject" target="_blank" rel="noopener">MCheckProject</a> </li>
<li>由于OC的动态性，还是慎用！可作为重构参考</li>
</ul>
<h4 id="3-3-查找相似代码并封装"><a href="#3-3-查找相似代码并封装" class="headerlink" title="3.3 查找相似代码并封装"></a>3.3 查找相似代码并封装</h4><h3 id="4-监控"><a href="#4-监控" class="headerlink" title="4 监控"></a>4 监控</h3><p>&emsp;&emsp;主要通过自动打包平台每次打包时统计包大小，针对突然增加的情况给客户端组发邮件！有一定的参考意义，但意义不大！因为经常因为分支合入而误报！</p>
<h3 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h3><ul>
<li><a href="http://blog.cnbang.net/tech/2544/" target="_blank" rel="noopener">iOS可执行文件瘦身方法</a>   干货不多</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=207986417&amp;idx=1&amp;sn=77ea7d8e4f8ab7b59111e78c86ccfe66&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="noopener">iOS微信安装包瘦身</a> ,获取linkmap文件</li>
<li>1，累加每个obj文件计算大小；</li>
<li>2，通过正则表达式([+|-][.+\s(.+)])过滤LinkMap文件的<strong>TEXT.</strong>text提取所有的方法SelectorsAll，再使用otool命令otool -v -s <strong>DATA </strong>objc_selrefs逆向<strong>DATA.</strong>objc_selrefs段提取使用到的方法（UsedSelectorsAll），来计算没用到的方法（SelectorsAll-UsedSelectorsAll），但注意，系统API的Protocol可能被列入无用方法名单里；</li>
<li>3，通过otool命令逆向<strong>DATA.</strong>objc_classlist段和<strong>DATA.</strong>objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类，但无法判断是否被使用</li>
<li><a href="https://www.jianshu.com/p/c94dedef90b7" target="_blank" rel="noopener">iOS APP安装包瘦身实践</a>  干货不多，基础建议</li>
<li><a href="https://developer.apple.com/library/archive/qa/qa1795/_index.html" target="_blank" rel="noopener">Reducing the size of my App</a>  官方文档，干货不多</li>
<li><a href="https://www.infoq.cn/article/clang-plugin-ios-app-size-reducing" target="_blank" rel="noopener">基于clang插件的一种iOS包大小瘦身方案</a>  怎么通过clang这种静态分析去查找无用的类和方法</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器</title>
    <url>/2016/03/30/%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<h3 id="1-NSTimer"><a href="#1-NSTimer" class="headerlink" title="1 NSTimer"></a>1 NSTimer</h3><h4 id="1-1-NSTimer准不准？"><a href="#1-1-NSTimer准不准？" class="headerlink" title="1.1 NSTimer准不准？"></a>1.1 NSTimer准不准？</h4><ul>
<li>无论是单次执行的NSTimer还是重复执行的NSTimer都不是准时的</li>
<li>原因</li>
<li>只添加到了runloop的defaultmode里，当scrollView滑动时runloop会切换到UITrackingRunLoopMode下，造成NSTimer延后</li>
<li>当前线程阻塞或正在进行大量数据计算，NSTimer会延后处理</li>
<li></li>
</ul>
<h4 id="1-2-创建NSTimer需要加到runloop里"><a href="#1-2-创建NSTimer需要加到runloop里" class="headerlink" title="1.2 创建NSTimer需要加到runloop里"></a>1.2 创建NSTimer需要加到runloop里</h4><ul>
<li>默认NSTimer加到runloop是NSDefaultRunLoopMode模式，此模式下scrollview滑动时会切换到UITrackingRunLoopMode下暂停NSTimer，因此需要让NSTimer都响应，需要使用NSRunLoopCommonModes</li>
<li>故runloop强持有NSTimer，来保证timer按时触发<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSTimer *bTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(automaticCountDown) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:bTimer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-scheduledTimerWith和timerWith的区别"><a href="#1-3-scheduledTimerWith和timerWith的区别" class="headerlink" title="1.3 scheduledTimerWith和timerWith的区别"></a>1.3 scheduledTimerWith和timerWith的区别</h4><ul>
<li>timerWith创建的NSTimer需要手动添加到runloop里</li>
<li>scheduledTimerWith创建的NSTimer已经自动添加到当前runloop的NSDefaultRunLoopMode模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// Creates and returns a new NSTimer object initialized with the specified block object. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire.</span><br><span class="line">/// - parameter:  timeInterval  The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span><br><span class="line">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span><br><span class="line">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br><span class="line">/// Creates and returns a new NSTimer object initialized with the specified block object and schedules it on the current run loop in the default mode.</span><br><span class="line">/// - parameter:  ti    The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span><br><span class="line">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span><br><span class="line">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-NSTimer内存泄漏"><a href="#1-4-NSTimer内存泄漏" class="headerlink" title="1.4 NSTimer内存泄漏"></a>1.4 NSTimer内存泄漏</h4><ul>
<li><p>NSTimer的target是strong强持有的，即NSTimer持有target！如果target强持有NSTimer，就会形成循环引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target： The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated.</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak修饰NSTimer不管用，只能解除target对NSTimer的强持有！一般情况下循环引用只要断掉一环就可以释放了，但runloop还引用着NSTimer，NSTimer又引用target，因此也无法解决内存泄漏问题</p>
</li>
<li><p>很多时候使用retain或strong修饰，更多是提醒开发者需要手动处理NSTimer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">_timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)timerRun &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[self.timer invalidate];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用block解除引用，参考《Effective Objective-C》第52条</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">__weak id weakSelf = self;</span><br><span class="line">NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer *timer) &#123;</span><br><span class="line">NSLog(@&quot;block %@&quot;,weakSelf);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation NSTimer(BlockTimer)</span><br><span class="line">+ (NSTimer*)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats blockTimer:(void (^)(NSTimer *))block&#123;</span><br><span class="line">NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(timered:) userInfo:[block copy] repeats:repeats];</span><br><span class="line">return timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)timered:(NSTimer*)timer &#123;</span><br><span class="line">void (^block)(NSTimer *timer)  = timer.userInfo;</span><br><span class="line">block(timer);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意当repeats=NO时执行完定时任务，会自动执行invalidate操作，即不会有循环引用</p>
</li>
</ul>
<h4 id="1-5-销毁NSTimer"><a href="#1-5-销毁NSTimer" class="headerlink" title="1.5 销毁NSTimer"></a>1.5 销毁NSTimer</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)invalidateTimer &#123;</span><br><span class="line">[_timer invalidate];</span><br><span class="line">_timer = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-立即执行"><a href="#1-6-立即执行" class="headerlink" title="1.6 立即执行"></a>1.6 立即执行</h4><ul>
<li>NSTimer无论是循环repeats=YES，还是延迟repeats=NO，第一次调用都是X时间后，如果想立即执行，可采用fire方法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_timer fire];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-7-创建和销毁要在同一线程"><a href="#1-7-创建和销毁要在同一线程" class="headerlink" title="1.7 创建和销毁要在同一线程"></a>1.7 创建和销毁要在同一线程</h4><ul>
<li>因为创建Timer要把Timer加入到该线程对应的RunLoop中，故在同一个线程中才能cancel这个Timer<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建</span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line">[thread start];</span><br><span class="line">- (void)newThread &#123;</span><br><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line">_timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];</span><br><span class="line">// 即便是scheduledTimerWith方法也需手动加入runloop</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">// 子线程需手动开启runloop</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁</span><br><span class="line">[self performSelector:@selector(invalidateTimer) onThread:thread withObject:nil waitUntilDone:YES];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-CADisplayLink"><a href="#2-CADisplayLink" class="headerlink" title="2 CADisplayLink"></a>2 CADisplayLink</h3><ul>
<li>CADisplayLink是用于同步屏幕刷新频率的计时器，ios都是60hz，即每秒60次回调selector，回调频率通过frameInterval属性设置，CADisplayLink的selector每秒调用次数=60/frameInterval</li>
<li>精准度比较高,但并不保证都是60hz的刷新频率，例如主线程卡顿</li>
</ul>
<h4 id="2-1-重要属性介绍"><a href="#2-1-重要属性介绍" class="headerlink" title="2.1 重要属性介绍"></a>2.1 重要属性介绍</h4><ul>
<li>frameInterval 标识间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。官方文档中强调，当该值被设定小于1时，结果是不可预知的。</li>
<li>duration 表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。</li>
<li>timestamp 当前帧的时间戳</li>
</ul>
<h4 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) CADisplayLink* displayLink;</span><br><span class="line"></span><br><span class="line">- (void)startDisplayLink &#123;</span><br><span class="line">_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkProc)];</span><br><span class="line">[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopDisplayLink &#123;</span><br><span class="line">[_displayLink setPaused:YES];</span><br><span class="line">[_displayLink removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">[_displayLink invalidate];</span><br><span class="line">_displayLink = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)displayLinkProc &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-GCD实现timer"><a href="#3-GCD实现timer" class="headerlink" title="3 GCD实现timer"></a>3 GCD实现timer</h3><ul>
<li><p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) dispatch_source_t countDownTimer;</span><br><span class="line">// 开启timer</span><br><span class="line">- (void)startTimer &#123;</span><br><span class="line">if (!_timer) &#123;</span><br><span class="line">// 设置时间间隔，每秒执行</span><br><span class="line">NSTimeInterval period = 1.0;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">/*</span><br><span class="line">dispatch_walltime 可以让计时器按照真实时间间隔进行计时，但使用dispatch_time 或者 DISPATCH_TIME_NOW 时当系统休眠的时候计时器会停止</span><br><span class="line">*/ </span><br><span class="line">dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0);</span><br><span class="line">/*</span><br><span class="line">dispatch_source_set_event_handler 这个函数在执行完之后，block 会立马执行一遍,相当于NSTimer fire</span><br><span class="line">*/ </span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 关闭timer</span><br><span class="line">- (void)stopTimer &#123;</span><br><span class="line">if (_timer) &#123;</span><br><span class="line">dispatch_source_cancel(_timer);</span><br><span class="line">_timer = nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意挂起后不得释放timer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dispatch_suspend(_timer);</span><br><span class="line">_timer = nil; // EXC_BAD_INSTRUCTION 崩溃</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://skyline75489.github.io/post/2016-7-19_dispatch_source_timer_intro.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>实现类似NSURLSessionDownloadDelegate的协议</title>
    <url>/2017/09/01/%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCNSURLSessionDownloadDelegate%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>&emsp;&emsp;今天排查 NSURLSession 的https证书时发现一个好玩的东西，玩了iOS这么多年竟然没注意这个小知识点！废话不多说，先看一般初始化的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</span><br><span class="line"></span><br><span class="line">@property (readonly, retain) NSOperationQueue *delegateQueue;</span><br><span class="line">@property (nullable, readonly, retain) id &lt;NSURLSessionDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;嗯，初始化一个 NSURLSession，并设置代理 NSURLSessionDelegate</p>
<p>&emsp;&emsp;当然玩过NSURLSession都知道，用到下载要实现 NSURLSessionDownloadDelegate 协议，继承关系如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@protocol NSURLSessionDelegate &lt;NSObject&gt;</span><br><span class="line">// 巴拉巴拉</span><br><span class="line"></span><br><span class="line">@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;</span><br><span class="line">// 巴拉巴拉</span><br><span class="line"></span><br><span class="line">@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">// 巴拉巴拉</span><br></pre></td></tr></table></figure></p>
<h4 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h4><p>&emsp;&emsp;那么问题来了，初始化设置代理时明明设置的是NSURLSessionDelegate，为什么NSURLSessionDownloadDelegate的代理方法也能响应呢？这还不简单，父类指针指向子类实例，自然能够调用子类的方法！嗯，我一开始也是这么想的，但问题又来了，一般我们这么写的时候需要强制类型转化！当然这也不难使用 conformsToProtocol 检测一下，强制转化就行！好吧，试一下！测试代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@protocol JZKTest1Protocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)test1Method;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@protocol JZKTest2Protocol &lt;JZKTest1Protocol&gt;</span><br><span class="line"></span><br><span class="line">- (void)test2Method;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JZKCornerShadowView : UIView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id&lt;JZKTest1Protocol&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (void)logSomething1; // call test1Method</span><br><span class="line">- (void)logSomething2; // call test2Method</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来是 logSomething2 方法，最开始我是这么写的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)logSomething2 &#123;</span><br><span class="line">    if ([_delegate conformsToProtocol:@protocol(JZKTest2Protocol)]) &#123;</span><br><span class="line">        id&lt;JZKTest2Protocol&gt; tempDelegate = _delegate;</span><br><span class="line">        if ([tempDelegate respondsToSelector:@selector(test2Method)]) &#123;</span><br><span class="line">            [tempDelegate test2Method];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但这么写会提示警告：Initializing ‘<strong>strong id<jzktest2protocol>‘ with an expression of incompatible type ‘id<jzktest1protocol>  _Nullable </jzktest1protocol></jzktest2protocol></strong>weak’ 。好吧！改吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)logSomething2 &#123;</span><br><span class="line">    if ([_delegate conformsToProtocol:@protocol(JZKTest2Protocol)]) &#123;</span><br><span class="line">        id&lt;JZKTest2Protocol&gt; _Nullable __weak tempDelegate = (id&lt;JZKTest2Protocol&gt;)_delegate;</span><br><span class="line">        if ([tempDelegate respondsToSelector:@selector(test2Method)]) &#123;</span><br><span class="line">            [tempDelegate test2Method];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;等等 _Nullable __weak 这倒没什么！但后面 (id<jzktest2protocol>) 看起来实在是太别扭了！好丑！而且这两个Protocol都是ViewController实现的！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController ()&lt;JZKTest1Protocol,JZKTest2Protocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)test1Method &#123;</span><br><span class="line">    NSLog(@&quot;test1Method&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2Method &#123;</span><br><span class="line">    NSLog(@&quot;test2Method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    JZKCornerShadowView *shadow = [[JZKCornerShadowView alloc] init];</span><br><span class="line">    shadow.delegate = self;</span><br><span class="line">    [shadow logSomething1];</span><br><span class="line">    [shadow logSomething2];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></jzktest2protocol></p>
<p>&esmp;&emsp;即_delegate其实是指向同一个对象！那就省事了<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)logSomething2 &#123;</span><br><span class="line">    if ([_delegate respondsToSelector:@selector(test2Method)]) &#123;</span><br><span class="line">        [_delegate performSelector:@selector(test2Method)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;经过测试，即便用两个VC去分别实现JZKTest1Protocol和JZKTest2Protocol协议，这么写也行！当然performSelector有诸多的不便！很不爽…，想来想去只有消息转发了，试试走起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (id)performSelector:(SEL)aSelector withArguments:(NSArray *)arguments &#123;</span><br><span class="line">    </span><br><span class="line">    if (aSelector == nil) return nil;</span><br><span class="line">    NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">    invocation.target = self;</span><br><span class="line">    invocation.selector = aSelector;</span><br><span class="line">    </span><br><span class="line">    // invocation 有2个隐藏参数，所以 argument 从2开始</span><br><span class="line">    if ([arguments isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSInteger count = MIN(arguments.count, signature.numberOfArguments - 2);</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            const char *type = [signature getArgumentTypeAtIndex:2 + i];</span><br><span class="line">            </span><br><span class="line">            // 需要做参数类型判断然后解析成对应类型，这里默认所有参数均为OC对象</span><br><span class="line">            if (strcmp(type, &quot;@&quot;) == 0) &#123;</span><br><span class="line">                id argument = arguments[i];</span><br><span class="line">                [invocation setArgument:&amp;argument atIndex:2 + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    id returnVal;</span><br><span class="line">    if (strcmp(signature.methodReturnType, &quot;@&quot;) == 0) &#123;</span><br><span class="line">        [invocation getReturnValue:&amp;returnVal];</span><br><span class="line">    &#125;</span><br><span class="line">    // 需要做返回类型判断。比如返回值为常量需要包装成对象，这里仅以最简单的`@`为例</span><br><span class="line">    return returnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="PS1-class-conformsToProtocol-与-conformsToProtocol-的区别"><a href="#PS1-class-conformsToProtocol-与-conformsToProtocol-的区别" class="headerlink" title="PS1 :class_conformsToProtocol 与 conformsToProtocol 的区别"></a>PS1 :class_conformsToProtocol 与 conformsToProtocol 的区别</h5><ul>
<li>class_conformsToProtocol 不检测父类中实现的Protocol,而 [NSObject conformsToProtocol:]检测所有继承类中实现的Protocol</li>
<li>[NSObject conformsToProtocol:] 仅限于NSObject ,而class_conformsToProtocol 适用于所有Class</li>
<li>苹果建议用 [NSObject conformsToProtocol:]</li>
</ul>
<h5 id="PS2-weak和-strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！"><a href="#PS2-weak和-strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！" class="headerlink" title="PS2 : weak和 strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！"></a>PS2 : <strong>weak和 </strong>strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation JZKCornerShadowView &#123;</span><br><span class="line">    UILabel * __weak _titleLabel;</span><br><span class="line">    // __weak UILabel *_titleLabel; 不建议这么写</span><br><span class="line">    UILabel * __strong _subTitleLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PS3：performSelector的问题"><a href="#PS3：performSelector的问题" class="headerlink" title="PS3：performSelector的问题"></a>PS3：performSelector的问题</h5><ul>
<li>运行时才校验，编译时不做校验！更适合那些runtime添加的方法</li>
<li>运行时才校验，因此参数返回值类型不确定，且参数个数有限！</li>
<li>实现多参数就是用NSDictionary，<strong>不要迷信网上所谓的消息转发方案</strong>。1、很多系统方法都在用performSelector；2、能用消息转发Apple没必要写三个几乎一样的performSelector方法了；3、hook试验时发现EXC_BAD_ACCESS问题，且没找到哦奥原因</li>
<li>performSelector… 为同步方法。但performSelector…afterDelay…等带afterDelay的为异步方法，即便afterDelay为0！特别注意afterDelay很容易造成内存泄漏，解决办法afterDelay调用的方法未执行时取消调用</li>
<li>onThread 和 InBackground 可指定线程运行某段代码，实现多线程</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>小强升职记</title>
    <url>/2015/07/31/%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>成功的关键在于构建自己的核心</li>
<li>成熟意味着什么？意味着确定的价值观、顺畅的时间管理、以及属于自己的处世哲学</li>
</ul>
<h3 id="1、寻找种子"><a href="#1、寻找种子" class="headerlink" title="1、寻找种子"></a>1、寻找种子</h3><ul>
<li>你真的很忙吗？记录时间日志、分类整理、原因分析、总结优化（工作、学习、娱乐同样重要,提高效率而不是做苦行僧）</li>
<li>时间黑洞：自己都不知道自己的时间花到哪去了，也就是我经常写的nothing，原因是：大脑不善于记忆，而善于创造性思维，只有对大脑形成强烈刺激的事情才会被存储下来。因此那些极具规律性、比较枯燥、或者目的性不强、没有主动性的事情，将很容易被遗忘。解决方案：每个一个小时写出下一个小时计划要做的事情，一个小时结束之后记录下结果，坚持一整天！慢慢来</li>
<li>衡量一件事是不是有意义，主要是看我们投入时间后是否有预期的产出！达到了预期就是有意义的，没达到自然是没意义的！有点意思，举例：比起每次玩完游戏就后悔，更应该比较的应该是计划做什么，结果是什么，应不应该后悔？</li>
<li>注意力被打断之后，如果想要重新集中注意力至少需要15分钟；而如果思路被打断，那可能永远都想不到了。。。所以要勇于“拒绝”</li>
<li>任务处理：</li>
<li>A、将所有的任务放入工作篮，不论是谁什么时候交给我的任务，统统放进工作篮里；</li>
<li>B、将可以置之不理的任务清除掉，将必须在某天处理或者必须转交别人处理的任务拿出来，将那些可以在两分钟之内完成的任务立即完成；</li>
<li>C，将需要在特定日期处理的事情写进日程表，将需要别人处理的事情立即转交并且设定到期提醒，将需要现在处理的事情摆在办公桌上；</li>
<li>D，在自己最高效的时间段，做最重要的事情，其他事情也要做合理的安排</li>
<li>提高工作效率的方法：</li>
<li>A、每天早晨别一上班就急着投入工作，先看看今天的工作重点是什么，哪些事情是重要并且紧迫的，将这些事情安排在你的高效时间段完成；</li>
<li>B、回顾你需要发布或者呈送上司的资料，不可能第一次就做的尽善尽美，不要吝啬时间！</li>
<li>C、看新闻用RSS，也可用广告拦截器，将注意力集中在新闻上，而不是铺天盖地的广告超链接；</li>
<li>D、减少检查邮件的次数，每天两次足够了，并且应该注意，往往在上网聊天或者无所事事的时候就会“习惯性”的检查邮件，因此应该找些事情来分散自己的注意力；</li>
<li><p>E、能休息的时候尽量休息，保持自己的精力，游戏!=休息、做别的!=休息、真正的休息就是：大脑放空，冥想或睡眠</p>
</li>
<li><p>价值观没有对错，也不是记忆，更不是一成不变的，而是要不断地从经验中去提炼！可以呀借助心理学的问答测试工具！！！写在卡片上，放到触目可见的地方，不断地巩固和修正，这很重要！</p>
</li>
</ul>
<h3 id="2、让种子发芽"><a href="#2、让种子发芽" class="headerlink" title="2、让种子发芽"></a>2、让种子发芽</h3><ul>
<li>四象限：很多人经常会被假象迷惑，认为“紧急”的就是“重要”的，其实“紧急”和“重要”一点关系都没有！</li>
<li>重要且紧急。必须马上处理，但真的有这么多重要且紧急的事情吗？</li>
<li>重要但不紧急。分解任务，制定计划，按部就班，绝不拖延，思考怎样避免它进入第一象限？</li>
<li>不重要但紧急。能不做就不做，或交给别人，思考如果尽量减少第三象限的事务？</li>
<li>不重要且不紧急。尽量别做，应该思考我们工作中是否有必要进入这个象限？</li>
<li>标签划分事务：A，先“轻重”，给所有任务以职业价值观为标准标出“重要”或“不重要”；B，再“缓急”，给所有任务以截止日期标出“紧急”或“不紧急”；C，最后按照自己的意愿给所有任务标出“高”“中”“低”三种优先级</li>
<li>走出第三象限（不重要且紧急）：其实就是推脱，哪怕暂时的推脱！当然，推脱也是讲究技巧的</li>
<li>第二象限工作法（重要但不紧急）：应该将自己的主要精力集中在解决重要但不紧急的事务，平时制定的工作计划和工作目标都是相对于第二象限来说的！</li>
<li>进行目标描述和任务分解的好处：项目分解做细，有计划更全面，知道现在在哪，逐步减轻压力和提升自信，及时发现问题并处理优化</li>
<li>时间管理三大杀手：拖延，犹豫不决，目标不明确</li>
<li>时间管理并不是追求在1个小时内能做3件或5件事情，时间管理的目的应该是充分利用时间来创造最大的价值</li>
<li>要有耐心，慢慢来！</li>
<li>找到最重要的事，集中精力，拿下它！</li>
<li>下一步行动是什么？怎么做？找出下一步行动的秘诀：A，动词开头；B，内容清晰；C，描述结果；D，设定开始时间、周期、最后期限；例如：早上9点带上做好的计划书在会议室开始讨论营销计划，2小时内说服与会者认同我的营销方案！</li>
<li>学习使用流程图之类的工具，先想好怎么做，做的时候就很简单了！一开始不妨做完一步，再想下一步是什么，怎么做；等以后熟练了再整体去想整个的流程步骤是什么！</li>
<li>衣柜整理法</li>
<li>收集一切我们注意的事情：集中处理某一件事的时候，有其他的事就记上，回头再处理！收集工具应该越少越好，随手能拿到，还有定期清理收集篮</li>
<li>加工处理后，确定它们的实质以及解决方法</li>
<li>处理收集篮原则：A，从最上面一项开始处理；B，一次只处理一件事；C，永远不要再放回收集篮；</li>
<li>不可执行事务：A，垃圾 -&gt; 丢弃； B，将来某时或也许的事 ；C，参考资料 -&gt; 分类归档</li>
<li>可执行事务：2分钟能搞定的 -&gt; 立即去做；B，需要多个步骤搞定的项目；C，指派给别人；D，特定时间做的事 -&gt; 写入日程表；E，普通待办事项</li>
<li>把它们列为我们的行动选择方案</li>
<li>行动</li>
<li>定期组织整理得出结论</li>
</ul>
<h3 id="3、生长出主干和枝丫"><a href="#3、生长出主干和枝丫" class="headerlink" title="3、生长出主干和枝丫"></a>3、生长出主干和枝丫</h3><ul>
<li>我们不但要设定目标，而且要强有力地执行它，一般人达不成自己的目标原因：A，设定了不可达成的目标；B，没有将目标分解为计划；C，放任偶尔的失败；D，没有写下来；E，没有及时修正目标；F，没有坚持行动</li>
<li>实现目标第一步，正确描述目标，是否符合smart原则？</li>
<li>实现目标的关键是将目标转变成计划：A，写出你的目标；B，为什么要达成此目标，最主要的理由写在最前面；C，我为什么可以达成此目标，首先要说服自己一定可以达成这个目标；D，哪些个人、团队、组织对我达成这个目标有帮助？没有一个人的成功是靠自己一个人完成的；E，这个目标要在多长时间内完成？过短或过长都是没意义的</li>
<li>提高执行力：A，找到最大的障碍，第一个就去解除这个障碍；B，写下来！一定要写下来！C，拒绝第一次失败，面对失败我们要，重视失败分析原因和以变化应对变化</li>
<li>目标应该是条铁链而不是铁砂，可以按六个高度原则（原则 &gt; 愿景 &gt; 目标 &gt; 责任范围 &gt; 任务 &gt; 下一步行动）设定目标</li>
<li>不要每天都做白日梦！只有从一块块砖头开始，一步步的才能达成目标；</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>小狗钱钱</title>
    <url>/2016/12/31/%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1/</url>
    <content><![CDATA[<h3 id="小狗钱钱-入门级理财书"><a href="#小狗钱钱-入门级理财书" class="headerlink" title="小狗钱钱 - 入门级理财书"></a>小狗钱钱 - 入门级理财书</h3><ul>
<li>想要金钱，必须真的有要钱的愿望，例如：必须找到10个我想变富裕的原因，再找出三个最重要的原因。</li>
<li>尝试纯粹是一种借口，你还没有做，就已经给自己想好了退路，不能试验，只有两个选择：做或者不做</li>
<li>做到三件事，1、准备一本相册，装满与梦想有关的照片；2、每天翻看几遍相册，想象着已经实现梦想的情景；3、为每一个梦想准备一个梦想储蓄罐</li>
<li>乐观前行，不放弃，越是被别人嘲笑的梦想，越值得去实现</li>
<li>是否能挣到钱，最关键的并不在于有没有一个好点子，不在于有多聪明，决定因素是你的自信程度；你的自信程度决定了你是否相信自己的能力，是否相信自己。不相信自己，怎么开始开始做？怎么做的好？</li>
<li>建立自信的方法：拿一个本子，就叫成功日记，然后就把所有成功的事情记录进去，最好每天都做，每次至少写5条个人成果</li>
<li>两个重要的建议：1，尝试为别人解决一个难题，那么你就能赚到很多钱；2，把经理集中在你知道，你会的和你拥有的东西上</li>
<li>无论什么时候都不能把希望寄托在一份工作上，它持续时间不会像你设想的那么长，所以你要立即寻找一份替代的工作</li>
<li>最好想清楚，你喜欢做什么，然后在考虑你怎么用它来挣钱</li>
<li>逆境需要坚持，顺境更需要坚持，培养自信，憧憬梦想，花费不超过10分钟，但就这10分钟，让你与众不同</li>
<li>当你决定做一件事的时候，必须在72小时内完成它，否则很可能就永远不会在做了！没得选就是最好的选择，早做早超生！</li>
<li>陷入债务的人需要听取四个忠告：1、欠债的人应该销毁所有的信用卡，因为使用虚拟的钱时，比用现金花的钱要多得多；2、支付许可范围内最小的分期付款数目，应当尽可能少的偿还他们的贷款；3、将扣除生活费之后富余的钱中50%再存起来，剩下的50%用于支付消费贷款，最好根本不要申请消费贷款；4、每次花费之前问自己：“这真的有必要吗？”。</li>
<li>要花钱，这是对的，但如果想变得富有，同时还要存钱，这笔钱是用于投资钱生钱的；最好是投资的钱（长期目标），储蓄罐的钱（短期目标），和用于生活的钱来划分</li>
<li>当你定下了大目标的时候，就意味着你必须付出比别人多得多的努力</li>
<li>你干的活最多只占报酬的一般，另一半是因为你的想法和实施这个想法的勇气</li>
<li>运气其实永远是充分的准备加上努力工作的结果</li>
<li>一个人要想过得更幸福、更满意的生活，就得对自身进行改变。</li>
<li>不要怕，恐惧是正常的，没必要因为恐惧而悲哀痛苦自暴自弃，克服恐惧，做了不敢做的事才是最美好的，不要怕</li>
<li>每当你觉得有些事情不好办的时候，你可以做一件事：翻一翻成功日记，你会从过去的事情中找到未来你也有能力完成任何事情的证据。恐惧重视在我们设想事情会如何不顺的时候出现，我们对失败的可能性想的越多就越害怕，当你朝着积极的目标去思考的时候，就不会心生畏惧</li>
<li>总结：1、确定自己的喜欢获得财务上的成功；2、自信，有想法，做自己喜欢做的事；3、把钱分成日常开销、梦想目标和全鹅账户三部分；4、进行明智的投资；5、享受生活</li>
<li>投资：1、应该把钱投资在安全的地方；2、我们当然想要最丰厚的利息；3、我们的投资应该简单明白</li>
<li>长线基金值得拥有，挑选基金的注意事项：1、基金应该至少有十年的历史，假如以前一直盈利，可以相信以后也会盈利；2、应该选择大型的跨国股票基金；3、对基金走势图进行比较，我们应该观察在过去10年间哪些基金的年终获利最好</li>
<li>年收益率 / 72 = 投资翻倍的年数</li>
<li>只有交易出去才能收益，才是赔钱或者赚钱了！不交易，没有任何意义</li>
<li>应该始终储备一些现金，绝不能把你全部的钱都投资在股票或基金上面</li>
<li>72 除以 3%的通货膨胀率 = 24，即24年后，钱只值现在的一半</li>
<li>不要着急否认，要多想，我只能告诉你要多想</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>引用计数引发的感想</title>
    <url>/2014/09/23/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>&emsp;&emsp;由于半道出家，从Java的垃圾回收机制，一下转到了引用计数机制，确实诸多不顺，简单写下我理解。我所知道的内存释放操作基本上有3类：手动释放、自动垃圾回收和引用计数！</p>
<h4 id="手动释放（C语言）"><a href="#手动释放（C语言）" class="headerlink" title="手动释放（C语言）"></a>手动释放（C语言）</h4><ul>
<li>程序员自己挖坑，自己埋</li>
<li>优点：内存使用率高，性能高</li>
<li>缺点：需要手动malloc 和 free，自己开辟内存，自己释放内存。由于编译器啥也管不了，所以所有的操作都依赖程序员的严谨性，另外需要注意的是，开辟内存和释放内存都必须注意野指针问题</li>
</ul>
<h4 id="自动垃圾回收（Java）"><a href="#自动垃圾回收（Java）" class="headerlink" title="自动垃圾回收（Java）"></a>自动垃圾回收（Java）</h4><ul>
<li>当创建对象时，GC就开始监视这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理heap（堆）中的素有对象。通过这种方式确定“不可达的”并清除</li>
<li>优点：简单，几乎不用程序员管</li>
<li>缺点：内存利用率低，造成大量碎片化空间，性能消耗高</li>
</ul>
<h4 id="引用计数（OC）"><a href="#引用计数（OC）" class="headerlink" title="引用计数（OC）"></a>引用计数（OC）</h4><ul>
<li>每个对象保存，持有当前对象的个数，当没人只有当前对象，即引用对象为0时，就释放内存</li>
<li>优点：可靠，</li>
<li>缺点：循环引用，MRC时需要手动更新引用计数，ARC不用手动更新引用计数</li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>&emsp;&emsp;以前写的过于肤浅，自动垃圾回收包含引用计数算法，即垃圾回收是概念，引用计数是算法垃圾回收算法。常用的垃圾回收算法有：</p>
<ul>
<li><p>引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。</p>
</li>
<li><p>根搜索算法：通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>悬浮球代码</title>
    <url>/2015/05/16/%E6%82%AC%E6%B5%AE%E7%90%83%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  ZKDebugFloatView.m</span><br><span class="line">//  test</span><br><span class="line">//</span><br><span class="line">//  Created by JZK on 2015/5/5.</span><br><span class="line">//  Copyright © 2015 baidu. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;ZKDebugFloatView.h&quot;</span><br><span class="line">#import &quot;AppDelegate.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKDebugFloatView&#123;</span><br><span class="line">//拖动按钮的起始坐标点</span><br><span class="line">CGPoint _touchPoint;</span><br><span class="line"></span><br><span class="line">//起始按钮的x,y值</span><br><span class="line">CGFloat _touchBtnX;</span><br><span class="line">CGFloat _touchBtnY;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)show&#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static BFDebugFloatView *floatView = nil;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">floatView = [[[NSBundle mainBundle] loadNibNamed:@&quot;ZKDebugFloatView&quot; owner:nil options:nil] firstObject];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">if (!floatView.superview) &#123;</span><br><span class="line">floatView.frame = CGRectMake(0, (kScreenHeight - 80)/ 2, 80, 80);</span><br><span class="line">floatView.layer.masksToBounds = YES;</span><br><span class="line">floatView.layer.cornerRadius = 40;</span><br><span class="line">[[UIApplication sharedApplication].keyWindow addSubview:floatView];</span><br><span class="line">[[UIApplication sharedApplication].keyWindow bringSubviewToFront:floatView];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">[super awakeFromNib];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - touchMove</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line"></span><br><span class="line">[super touchesBegan:touches withEvent:event];</span><br><span class="line"></span><br><span class="line">//按钮刚按下的时候，获取此时的起始坐标</span><br><span class="line">UITouch *touch = [touches anyObject];</span><br><span class="line">_touchPoint = [touch locationInView:self];</span><br><span class="line"></span><br><span class="line">_touchBtnX = self.frame.origin.x;</span><br><span class="line">_touchBtnY = self.frame.origin.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line"></span><br><span class="line">UITouch *touch = [touches anyObject];</span><br><span class="line">CGPoint currentPosition = [touch locationInView:self];</span><br><span class="line"></span><br><span class="line">//偏移量(当前坐标 - 起始坐标 = 偏移量)</span><br><span class="line">CGFloat offsetX = currentPosition.x - _touchPoint.x;</span><br><span class="line">CGFloat offsetY = currentPosition.y - _touchPoint.y;</span><br><span class="line"></span><br><span class="line">//移动后的按钮中心坐标</span><br><span class="line">CGFloat centerX = self.center.x + offsetX;</span><br><span class="line">CGFloat centerY = self.center.y + offsetY;</span><br><span class="line">self.center = CGPointMake(centerX, centerY);</span><br><span class="line"></span><br><span class="line">//父试图的宽高</span><br><span class="line">CGFloat superViewWidth = self.superview.frame.size.width;</span><br><span class="line">CGFloat superViewHeight = self.superview.frame.size.height;</span><br><span class="line">CGFloat btnX = self.frame.origin.x;</span><br><span class="line">CGFloat btnY = self.frame.origin.y;</span><br><span class="line">CGFloat btnW = self.frame.size.width;</span><br><span class="line">CGFloat btnH = self.frame.size.height;</span><br><span class="line"></span><br><span class="line">//x轴左右极限坐标</span><br><span class="line">if (btnX &gt; superViewWidth)&#123;</span><br><span class="line">//按钮右侧越界</span><br><span class="line">CGFloat centerX = superViewWidth - btnW/2;</span><br><span class="line">self.center = CGPointMake(centerX, centerY);</span><br><span class="line">&#125;else if (btnX &lt; 0)&#123;</span><br><span class="line">//按钮左侧越界</span><br><span class="line">CGFloat centerX = btnW * 0.5;</span><br><span class="line">self.center = CGPointMake(centerX, centerY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//默认都是有导航条的，有导航条的，父试图高度就要被导航条占据，固高度不够</span><br><span class="line">CGFloat defaultNaviHeight = 64;</span><br><span class="line">CGFloat judgeSuperViewHeight = superViewHeight - defaultNaviHeight;</span><br><span class="line"></span><br><span class="line">//y轴上下极限坐标</span><br><span class="line">if (btnY &lt;= 0)&#123;</span><br><span class="line">//按钮顶部越界</span><br><span class="line">centerY = btnH * 0.7;</span><br><span class="line">self.center = CGPointMake(centerX, centerY);</span><br><span class="line">&#125;</span><br><span class="line">else if (btnY &gt; judgeSuperViewHeight)&#123;</span><br><span class="line">//按钮底部越界</span><br><span class="line">CGFloat y = superViewHeight - btnH * 0.5;</span><br><span class="line">self.center = CGPointMake(btnX, y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line"></span><br><span class="line">CGFloat btnWidth = self.frame.size.width;</span><br><span class="line">CGFloat btnHeight = self.frame.size.height;</span><br><span class="line">CGFloat btnY = self.frame.origin.y;</span><br><span class="line">CGFloat btnX = self.frame.origin.x;</span><br><span class="line"></span><br><span class="line">CGFloat minDistance = 2;</span><br><span class="line"></span><br><span class="line">//结束move的时候，计算移动的距离是&gt;最低要求，如果没有，就调用按钮点击事件</span><br><span class="line">BOOL isOverX = fabs(btnX - _touchBtnX) &gt; minDistance;</span><br><span class="line">BOOL isOverY = fabs(btnY - _touchBtnY) &gt; minDistance;</span><br><span class="line"></span><br><span class="line">if (isOverX || isOverY) &#123;</span><br><span class="line">//超过移动范围就不响应点击 - 只做移动操作</span><br><span class="line">[self touchesCancelled:touches withEvent:event];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">[super touchesEnded:touches withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (self.center.x &gt;= self.superview.frame.size.width/2) &#123;</span><br><span class="line"></span><br><span class="line">[UIView animateWithDuration:0.5 animations:^&#123;</span><br><span class="line">//按钮靠右自动吸边</span><br><span class="line">CGFloat btnX = self.superview.frame.size.width - btnWidth;</span><br><span class="line">self.frame = CGRectMake(btnX, btnY, btnWidth, btnHeight);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else&#123;</span><br><span class="line"></span><br><span class="line">[UIView animateWithDuration:0.5 animations:^&#123;</span><br><span class="line">//按钮靠左吸边</span><br><span class="line">CGFloat btnX = 0;</span><br><span class="line">self.frame = CGRectMake(btnX, btnY, btnWidth, btnHeight);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>手势1：常用</title>
    <url>/2016/06/23/%E6%89%8B%E5%8A%BF1%EF%BC%9A%E5%B8%B8%E7%94%A8/</url>
    <content><![CDATA[<h4 id="1-点按手势-UITapGestureRecognizer"><a href="#1-点按手势-UITapGestureRecognizer" class="headerlink" title="1 点按手势 UITapGestureRecognizer"></a>1 点按手势 UITapGestureRecognizer</h4><ul>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建两根手指，连续点击三次的手势，常用于调出调试页面等</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];</span><br><span class="line">// 点击数，Default is 1.</span><br><span class="line">tap.numberOfTapsRequired = 3;</span><br><span class="line">// 手指数，Default is 1..</span><br><span class="line">tap.numberOfTouchesRequired = 2;</span><br><span class="line">[view addGestureRecognizer:tap];</span><br></pre></td></tr></table></figure>
</li>
<li><p>回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)tap:(UITapGestureRecognizer *)tapGesture&#123;</span><br><span class="line">NSLog(@&quot;调出调试页面&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-拖拽手势-UIPanGestureRecognizer"><a href="#2-拖拽手势-UIPanGestureRecognizer" class="headerlink" title="2 拖拽手势 UIPanGestureRecognizer"></a>2 拖拽手势 UIPanGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</span><br><span class="line">// default is 1. the minimum number of touches required to match</span><br><span class="line">pan.minimumNumberOfTouches = 1;</span><br><span class="line">// default is UINT_MAX. the maximum number of touches that can be down</span><br><span class="line">pan.maximumNumberOfTouches = 1;</span><br><span class="line">[view addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)pan:(UIPanGestureRecognizer *)panGesture &#123;</span><br><span class="line">// translationInView : 手指在视图上移动的偏移量</span><br><span class="line">CGPoint point1 = [panGesture translationInView:self.view];</span><br><span class="line">NSLog(@&quot;translationInView x: %f y:%f&quot;,point1.x , point1.y);</span><br><span class="line">// locationInView ： 手指在视图上的位置</span><br><span class="line">CGPoint point2 = [panGesture locationInView:self.view];</span><br><span class="line">NSLog(@&quot;locationInView x: %f y:%f&quot;,point2.x , point2.y);</span><br><span class="line">// velocityInView： 手指在视图上移动的速度, 正负也是代表方向，</span><br><span class="line">CGPoint point3 = [panGesture velocityInView:self.view];</span><br><span class="line">NSLog(@&quot;velocityInView x: %f y:%f&quot;,point3.x , point3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-清扫手势-UISwipeGestureRecognizer"><a href="#3-清扫手势-UISwipeGestureRecognizer" class="headerlink" title="3 清扫手势 UISwipeGestureRecognizer"></a>3 清扫手势 UISwipeGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UISwipeGestureRecognizer *swipeUp = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];</span><br><span class="line">//    手指数，default is 1</span><br><span class="line">swipeUp.numberOfTouchesRequired = 1;</span><br><span class="line">// 注意，手势方向虽然是NS_OPTIONS，但不要使用 或 方式设置，网上都是错的</span><br><span class="line">// https://stackoverflow.com/questions/3319209/setting-direction-for-uiswipegesturerecognizer</span><br><span class="line">//    swipeUp.direction = UISwipeGestureRecognizerDirectionUp | UISwipeGestureRecognizerDirectionDown;</span><br><span class="line">// 手势方向只是识别一个方向，需要多个方向可设置多个清扫手势，实现一个代理</span><br><span class="line">swipeUp.direction = UISwipeGestureRecognizerDirectionUp | UISwipeGestureRecognizerDirectionDown;</span><br><span class="line">[view addGestureRecognizer: swipeUp];</span><br><span class="line"></span><br><span class="line">UISwipeGestureRecognizer *swipeDown = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];</span><br><span class="line">swipeDown.direction = UISwipeGestureRecognizerDirectionDown;</span><br><span class="line">[view addGestureRecognizer: swipeDown];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)swipe:(UISwipeGestureRecognizer *)swipeGesture&#123;</span><br><span class="line">switch (swipeGesture.direction) &#123;</span><br><span class="line">case UISwipeGestureRecognizerDirectionLeft:</span><br><span class="line">NSLog(@&quot;向左清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">case UISwipeGestureRecognizerDirectionRight:</span><br><span class="line">NSLog(@&quot;向右清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">case UISwipeGestureRecognizerDirectionUp:</span><br><span class="line">NSLog(@&quot;向上清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">case UISwipeGestureRecognizerDirectionDown:</span><br><span class="line">NSLog(@&quot;向下清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-长按手势-UILongPressGestureRecognizer"><a href="#4-长按手势-UILongPressGestureRecognizer" class="headerlink" title="4 长按手势 UILongPressGestureRecognizer"></a>4 长按手势 UILongPressGestureRecognizer</h4><ul>
<li><p>实现 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];</span><br><span class="line">// 识别长按手势前需要点击几次，Default is 0， PS:从没见过这个属性的使用</span><br><span class="line">longPress.numberOfTapsRequired = 1;</span><br><span class="line">// 手指数</span><br><span class="line">longPress.numberOfTouchesRequired = 1;</span><br><span class="line">// 最短按多长时间才识别长按手势 Default is 0.5秒</span><br><span class="line">longPress.minimumPressDuration = 1;</span><br><span class="line">// 识别长按手势前允许的最大移动距离，Default is 10，手势识别后无效</span><br><span class="line">longPress.allowableMovement = 20;</span><br><span class="line"></span><br><span class="line">[view addGestureRecognizer:longPress];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 注意回调处理</span><br><span class="line">- (void)longPress:(UILongPressGestureRecognizer *)longPressGesture &#123;</span><br><span class="line">if (sender.state == UIGestureRecognizerStateEnded) &#123;</span><br><span class="line">// 结束</span><br><span class="line">&#125;</span><br><span class="line">else if (sender.state == UIGestureRecognizerStateBegan)&#123;</span><br><span class="line">// 开始</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-旋转手势-UIRotationGestureRecognizer"><a href="#5-旋转手势-UIRotationGestureRecognizer" class="headerlink" title="5 旋转手势 UIRotationGestureRecognizer"></a>5 旋转手势 UIRotationGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotation:)];</span><br><span class="line">[view addGestureRecognizer:rotation];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)rotation:(UIRotationGestureRecognizer *)rotationGesture &#123;</span><br><span class="line">//获取旋转的角度</span><br><span class="line">CGFloat scale = rotationGesture.rotation;</span><br><span class="line">//获取旋转的速度 radians/second</span><br><span class="line">NSLog(@&quot;转速： %f&quot;, rotationGesture.velocity);</span><br><span class="line">// 设置view的角度,使用transform设置</span><br><span class="line">rotationGesture.view.transform = CGAffineTransformRotate(rotationGesture.view.transform, scale);</span><br><span class="line">// 复位,否则旋转角度会叠加，会疯狂转圈</span><br><span class="line">rotationGesture.rotation = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-缩放-UIPinchGestureRecognizer"><a href="#6-缩放-UIPinchGestureRecognizer" class="headerlink" title="6 缩放 UIPinchGestureRecognizer"></a>6 缩放 UIPinchGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinch:)];</span><br><span class="line">[view addGestureRecognizer:pinch];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)pinch:(UIPinchGestureRecognizer *)pinchGesture &#123;</span><br><span class="line">CGFloat scale = pinchGesture.scale;</span><br><span class="line">pinchGesture.view.transform = CGAffineTransformScale(pinchGesture.view.transform, scale, scale);</span><br><span class="line">// 复位</span><br><span class="line">pinchGesture.state = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-屏幕边缘轻扫-UIScreenEdgePanGestureRecognizer"><a href="#7-屏幕边缘轻扫-UIScreenEdgePanGestureRecognizer" class="headerlink" title="7 屏幕边缘轻扫 UIScreenEdgePanGestureRecognizer"></a>7 屏幕边缘轻扫 UIScreenEdgePanGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIScreenEdgePanGestureRecognizer *screenPan = [[UIScreenEdgePanGestureRecognizer alloc]initWithTarget:self action:@selector(screenEdgePan:)];</span><br><span class="line">[view addGestureRecognizer:screenPan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//创建边缘事件</span><br><span class="line">-(void)screenEdgePan:(UIScreenEdgePanGestureRecognizer *)screenEdgePanGesture &#123;</span><br><span class="line">NSLog(@&quot;边缘&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>手势2：进阶</title>
    <url>/2016/06/24/%E6%89%8B%E5%8A%BF2%EF%BC%9A%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h3 id="1-UIGestureRecognizer"><a href="#1-UIGestureRecognizer" class="headerlink" title="1 UIGestureRecognizer"></a>1 UIGestureRecognizer</h3><p>&emsp;&emsp;手势识别器，前面介绍的基本手势的父类，注意UIGestureRecognizer : NSObject</p>
<h4 id="UIGestureRecognizerState"><a href="#UIGestureRecognizerState" class="headerlink" title="UIGestureRecognizerState"></a>UIGestureRecognizerState</h4><ul>
<li><p>官方注释翻译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIGestureRecognizerStatePossible,   // 默认，还没识别，可能正在遍历runloop</span><br><span class="line">UIGestureRecognizerStateBegan,      // 手势开始被识别，下个runloop会回调方法</span><br><span class="line">UIGestureRecognizerStateChanged,    // 手势识别发生改变的状态，下个runloop会回调方法</span><br><span class="line">UIGestureRecognizerStateEnded,      // 手势识别结束，下个runloop会回调方法，重置为UIGestureRecognizerStatePossible</span><br><span class="line">UIGestureRecognizerStateCancelled,  // 手势识别取消，下个runloop会回调方法，重置为UIGestureRecognizerStatePossible</span><br><span class="line">UIGestureRecognizerStateFailed,     // 识别失败，方法将不会被调用，重置为UIGestureRecognizerStatePossible</span><br><span class="line">UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIGestureRecognizerStateChanged为啥总调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://stackoverflow.com/questions/14227465/whats-the-different-between-uigesturerecognizerstatechanged-and-touchesmoved?r=SearchResults</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否手势都有UIGestureRecognizerStateBegan？否</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// UITapGestureRecognizer 只有一个UIGestureRecognizerStateEnded状态</span><br><span class="line"></span><br><span class="line">// UIGestureRecognizerState的官方解释如下</span><br><span class="line">// Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled</span><br><span class="line">// 非连续手势没有begin，changed的过渡，也不能失败或取消</span><br><span class="line"></span><br><span class="line">// 事实上UIGestureRecognizerState表示可能的状态，不要被begin，changed，end等字眼迷惑</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="几个容易乱的属性"><a href="#几个容易乱的属性" class="headerlink" title="几个容易乱的属性"></a>几个容易乱的属性</h4><ul>
<li>@property(nullable, nonatomic,readonly) UIView *view; // 表示添加手势的view，并不是响应连上的view</li>
<li>@property(nonatomic) BOOL cancelsTouchesInView; // 默认YES，即一旦响应手势就终止响应连</li>
<li>@property(nonatomic) BOOL delaysTouchesBegan;// 默认为NO，不会延迟响应触摸事件，如果我们设置为YES，在手势没有被识别失败前，都不会给事件传递链发送消息。</li>
<li>@property(nonatomic) BOOL delaysTouchesEnded;//默认为YES，手势识别失败立马调用touchEnd:withEvent。设置为NO，会等待一个很短的时间，如果没有接收到新的手势识别任务，才会发送touchesEnded消息到事件传递链。</li>
</ul>
<h4 id="iOS9之后的"><a href="#iOS9之后的" class="headerlink" title="iOS9之后的"></a>iOS9之后的</h4><ul>
<li>@property(nonatomic, copy) NSArray<nsnumber *> *allowedTouchTypes NS_AVAILABLE_IOS(9_0); // Array of UITouchTypes as NSNumbers.</nsnumber></li>
<li><p>@property(nonatomic, copy) NSArray<nsnumber *> *allowedPressTypes NS_AVAILABLE_IOS(9_0); // Array of UIPressTypes as NSNumbers.</nsnumber></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UITouchType) &#123;</span><br><span class="line">UITouchTypeDirect,                       // A direct touch from a finger (on a screen)</span><br><span class="line">UITouchTypeIndirect,                     // An indirect touch (not a screen)</span><br><span class="line">UITouchTypePencil NS_AVAILABLE_IOS(9_1), // Add pencil name variant</span><br><span class="line">UITouchTypeStylus NS_AVAILABLE_IOS(9_1) = UITouchTypePencil, // A touch from a stylus (deprecated name, use pencil)</span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(9_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property (nonatomic) BOOL requiresExclusiveTouchType NS_AVAILABLE_IOS(9_2); // defaults to YES</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Indicates whether the gesture recognizer will consider touches of different touch types simultaneously.</span><br><span class="line">// If NO, it receives all touches that match its allowedTouchTypes.</span><br><span class="line">// NO, 同一时刻接收所有允许的触摸类型</span><br><span class="line">// If YES, once it receives a touch of a certain type, it will ignore new touches of other types, until it is reset to UIGestureRecognizerStatePossible.</span><br><span class="line">// YES, 同一时刻只接受一种触摸类型</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h4><ul>
<li><p>设置手势优先级 requireGestureRecognizerToFail</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// [A requireGestureRecognizerToFail：B] 优先响应B，再尝试响应A，都失败的话则响应失败</span><br><span class="line"></span><br><span class="line">// 实现一个View，即响应双击，又响应单击</span><br><span class="line">// 参考：https://stackoverflow.com/questions/8876202/uitapgesturerecognizer-single-tap-and-double-tap?r=SearchResults</span><br><span class="line">- (void)addSingleAndDoubleTapGestureRecognizersToView:(UIView *)view &#123;</span><br><span class="line">// single tap    </span><br><span class="line">UITapGestureRecognizer *singleTapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget: tableViewController action: @selector(handleSingleTapOnView:)]; // must set 1                           </span><br><span class="line">[singleTapRecognizer setNumberOfTouchesRequired:1];</span><br><span class="line">[view addGestureRecognizer: singleTapRecognizer];</span><br><span class="line"></span><br><span class="line">// double tap </span><br><span class="line">UITapGestureRecognizer *doubleTapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget: tableViewController action: @selector (handleDoubleTapOnView:)]; // must set 2</span><br><span class="line">[doubleTapRecognizer setNumberOfTouchesRequired:2];         </span><br><span class="line">[singleTapRecognizer requireGestureRecognizerToFail: doubleTapRecognizer];</span><br><span class="line">[view addGestureRecognizer: doubleTapRecognizer];         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleSingleTapOnView:(id)sender&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleDoubleTapOnView:(id)sender&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手指在view中的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 单点位置</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];</span><br><span class="line">[imageView addGestureRecognizer:tap];</span><br><span class="line">- (void)tap:(UITapGestureRecognizer *)tapGesture &#123;</span><br><span class="line">CGPoint location = [tapGesture locationInView:self.view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多根手指</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];</span><br><span class="line">tap.numberOfTouchesRequired = 2;</span><br><span class="line">[imageView addGestureRecognizer:tap];</span><br><span class="line">- (void)tap:(UITapGestureRecognizer *)tapGesture &#123;</span><br><span class="line">NSInteger touchsCount = [tapGesture numberOfTouches];</span><br><span class="line">for (int index = 0; index &lt; touchsCount; index++) &#123;</span><br><span class="line">CGPoint point = [tapGesture locationOfTouch:index inView:self.view];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-UIGestureRecognizerDelegate"><a href="#2-UIGestureRecognizerDelegate" class="headerlink" title="2 UIGestureRecognizerDelegate"></a>2 UIGestureRecognizerDelegate</h3><ul>
<li><p>是否识别手势</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//将要开始时调用（Possible将要变成Began），返回NO，则手势识别失败</span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;</span><br><span class="line"></span><br><span class="line">// touchesBegan:withEvent:之前调用，返回NO，则手势不识别这个touch</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;</span><br><span class="line"></span><br><span class="line">// pressesBegan:withEvent:之前调用，返回NO，则手势不识别这个press</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多手势冲突怎么办</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//是否支持同时多个手势触发,默认NO</span><br><span class="line">//返回YES，则可以多个手势一起触发方法，返回NO则为互斥, 但不保证一定互斥，因为otherGestureRecognizer可能返回YES</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer </span><br><span class="line">shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)</span><br><span class="line">otherGestureRecognizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//返回YES，第二个手势的优先级高于第一个手势</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer </span><br><span class="line">shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)</span><br><span class="line">otherGestureRecognizer </span><br><span class="line"></span><br><span class="line">//返回YES，第一个手势的优先级高于第二个手势</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer </span><br><span class="line">shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)</span><br><span class="line">otherGestureRecognizer</span><br><span class="line"></span><br><span class="line">// 所以为什么要设置两个方法呢？一个方法返回YES或NO不就行了？因为返回YES能保证优先级改变，但返回NO不保证优先级，因为其他的可能返回NO</span><br><span class="line">// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&apos;s counterpart delegate or subclass methods may return YES</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义手势"><a href="#自定义手势" class="headerlink" title="自定义手势"></a>自定义手势</h3><h4 id="1-组合"><a href="#1-组合" class="headerlink" title="1 组合"></a>1 组合</h4><ul>
<li>通过组合多手势和优先级实现复杂手势操作<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 略，参见上文 requireGestureRecognizerToFail 部分代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-扩展"><a href="#2-扩展" class="headerlink" title="2 扩展"></a>2 扩展</h4><ul>
<li>实现一个只能横向或纵向的拖动手势<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 参考：https://stackoverflow.com/questions/7100884/uipangesturerecognizer-only-vertical-or-horizontal?r=SearchResults</span><br><span class="line"></span><br><span class="line">UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</span><br><span class="line">pan.delegate = self;</span><br><span class="line">[imageView addGestureRecognizer:pan];</span><br><span class="line"></span><br><span class="line">- (void)pan:(UIPanGestureRecognizer *)panGesture &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)panGestureRecognizer &#123;</span><br><span class="line">CGPoint velocity = [panGestureRecognizer velocityInView:self.view];</span><br><span class="line">return fabs(velocity.y) &gt; fabs(velocity.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-自定义"><a href="#3-自定义" class="headerlink" title="3 自定义"></a>3 自定义</h4><ul>
<li><p>主要步骤</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、创建一个UIGestureRecognizer的子类</span><br><span class="line">2、包含头文件#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span><br><span class="line">3、使用touch相关方法判断手指轨迹</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">4、轨迹完成后设置self.state = UIGestureRecognizerStateEnded;就会自动调用相关回调</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：实现一个松开调用的tap类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 参考: https://stackoverflow.com/questions/15628133/uitapgesturerecognizer-make-it-work-on-touch-down-not-touch-up?r=SearchResults</span><br><span class="line">TouchDownGestureRecognizer.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface TouchDownGestureRecognizer : UIGestureRecognizer</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">TouchDownGestureRecognizer.m</span><br><span class="line"></span><br><span class="line">#import &quot;TouchDownGestureRecognizer.h&quot;</span><br><span class="line">#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation TouchDownGestureRecognizer</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">if (self.state == UIGestureRecognizerStatePossible) &#123;</span><br><span class="line">self.state = UIGestureRecognizerStateRecognized;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">self.state = UIGestureRecognizerStateFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">self.state = UIGestureRecognizerStateFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">implementation:</span><br><span class="line"></span><br><span class="line">#import &quot;TouchDownGestureRecognizer.h&quot;</span><br><span class="line">TouchDownGestureRecognizer *touchDown = [[TouchDownGestureRecognizer alloc] initWithTarget:self action:@selector(handleTouchDown:)];</span><br><span class="line">[yourView addGestureRecognizer:touchDown];</span><br><span class="line"></span><br><span class="line">-(void)handleTouchDown:(TouchDownGestureRecognizer *)touchDown&#123;</span><br><span class="line">NSLog(@&quot;Down&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>把时间当做朋友</title>
    <url>/2017/11/30/%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<ul>
<li>时间是不可能被管理的。必须开启心智，看清楚，想明白：问题出在我们自己身上。而我们所面临的问题，与时间、管理或时间管理都没有多大的关系。解决方案只有一个，那就是“一切都靠积累”。深信积累的力量，时间就是你的朋友，否则它就是你的敌人。</li>
<li>不要再让自己成为自己大脑的奴隶，而是选择翻身做主人</li>
<li>管它呢，学呗，学了总有用处</li>
<li>告诉自己：我有不足，我需要时间，我没办法一蹴而就。就这样。</li>
<li>每个人的起点不同，有些人的地板是另外一些人的天花板。但起点就是起点，尽管不同，每个人都要从起点开始往前走。</li>
<li>拿出一张纸将其划分为左右两个部分，左边标题是“我有的”，右边标题是“我要的”。逐一罗列。而后尽量客观地判断，“我要的”那些有哪些是用“我有的”无法换取的—划掉。再仔细判断剩下的能用“我有的”换取的那些“我要的”之中究竟哪些是必须的、必要的、重要的、不可或缺的—加上重点标记，比如星号。</li>
<li>想到“我要什么”的时候，马上提醒自己要花上三倍的时间去想想“我有什么”。</li>
<li>做任何事情的时候，都需要时时刻刻忍受各种各样的不完美</li>
<li>为了进步，我们必须忍受一定的未知。</li>
<li>必须接受这个现实：未知永远存在。而后只能开始不断地尝试着去适应“在未知中不断前行”。</li>
<li>有问题解决不了时，暂时先把它记下来，而后继续前行。注意，一定要记下来</li>
<li>对现状不满，急于摆脱现状，往往是常人最常不知不觉就掉进去的陷阱</li>
<li>尽管现实总是如此难以接受，坚强的你却应该坦然</li>
<li>最好时常把自己的一些念头记录下来</li>
<li>不仅要接受，还要牢记；不仅要牢记，还要坚信，不容得半点动摇。</li>
<li>完成任何一个任务，往往都需要三倍于计划的时间—即便，从一开始就考虑到这个因素。</li>
<li>想要出类拔萃，就要努力至少一万小时。</li>
<li>开始越好”更好的答案是“现在就开始”。所谓做事拖拉，不是拖拖拉拉地做事，而是拖拖拉拉地就是不开始做正事。- 拖拉的人最本质的原因在于恐惧—无论是来自内部的（“不求有功，但求无过”），还是来自外部的（过分在意外界的评价）。</li>
<li>做事的时候，肯定会遇到困难，越是有价值的事情，困难越多越大。</li>
<li>没有人从一开始就能做对，没有人从一开始就能做好！只要做事，就一定会出问题。</li>
<li>简单的部分要迅速做完，而后把节约出来的时间投放在处理困难的部分上。</li>
<li>任务没有完整完成，所以，根本谈不上效率（相当于分子等于零）。</li>
<li>为了提高效率，我们必须把自己的大脑打造成一个“多任务操作系统，试着把一个复杂而又有机的任务与一个简单而又机械的任务搭配起来一起做。尽量并行两个任务，重要前提是：这两个任务之所以并行是因为你对自己了解所以才主动如此安排的</li>
<li>在做任何事情之前，通过关注HOW而反复拆分任务，最终确认每个子任务都是可完成的</li>
<li>“20分钟工作+5分钟休息”作为一个时间片，然后就开始像CPU一样处理任务</li>
<li>“没时间了”，其可怕程度几乎无异于死亡。也许有的时候，发现自己已经晚了，唯一的策略依然是“现在就开始”，否则更待何时？</li>
<li>很多的时候，“跟着感觉走”肯定是要吃亏的。</li>
<li>期望速成，从基本的层面上来看，有两个主要的原因。第一个是人希望自己的欲望马上得到满足的天性；另外一个期望速成的原因，也是浮躁的根源，是不懂得有些阶段就是无法跨越</li>
<li>无论对谁来讲，想进入自己的梦想职业都是成本高昂的</li>
<li>接受现状才是最优策略</li>
<li>不要常常觉得苦，而是要想办法在任何情况下找到情趣—快乐是一种本事</li>
<li>事情是否正确？看它是否现实。几乎一切愚蠢的行为都来自于否定现实逃避现实。</li>
<li>接受惩罚往往是积累经验的起点</li>
<li>很多人实际上根本不知道自己所谓的“喜欢做某件事情”实际上更可能只不过是因为那件事情相对简单、容易获得奖励而已</li>
<li>对于逃避困难的人来讲，最为关键的实际上不是WHAT，也不是WHY，而是HOW。</li>
<li>减少这种令人恼火的情况：被其他人的错误耽误自己的时间</li>
<li>先坐下来制定一个工作列表，把任务都罗列下来，而后把自己的时间切片。</li>
<li>基于过程的“事件-时间日志”记录可以调整我对时间的感觉，在估算任何工作量的时候，都更容易确定“真正现实可行的目标”。</li>
<li>既然“管理时间”是不可能的，那么解决方法就只能是：想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”，就是我的说法—“与时间做朋友”。</li>
<li>每天记录你的时间开销，每天都要制作你的时间预算。制作一个列表，把你今天需要做的事情罗列出来。给列表中的每项任务标上权重值—比如，你可以用1~5分进行标记</li>
<li>不要害怕修改。相信我，完成任何一项任务的过程中，修改都是不可或缺的内容。你在修改，就说明你在进步</li>
<li>判断每项任务的真实属性。然后选择“真的重要的”或者“显得不重要的”。“真的重要”，其实只需要一个标准：就是看这项任务的完成是否对你的目标达成确实有益</li>
<li>对像我这样的普通人来讲，证明我的目标现实可行的方法比较简单：1.已经有人做到了；2.我与那人没有太大的差距。</li>
<li>往往只有开始行动了之后，才可以做出正确的判断。在行动过程中，发现既定的目标确实是不现实的、不可行的，那么，半途而废不仅并不意味着失败，还意味着该决策者是无比理智的。</li>
<li>时间的浪费，往往是因为a.目标不现实或者目前暂时尚不可行；b.为了达到目标而制定的实施策略有误。</li>
<li>计划总是被变化打乱，更深层次的原因在于计划过于长远。</li>
<li>越是短期的目标，越容易清晰。越是清晰的目标越容易实现</li>
<li>乐观是靠努力和挣扎才可以获得的经验。</li>
<li>生活本身充满了意外，并且，总是意外到无以复加的地步。</li>
<li>做计划的时候，要知道这样一件事：做长期计划显然是正确的并且是必需的，但是，需要挣扎，需要努力，需要从一点一滴开始。不要一上来就开始制定过分长期的计划。</li>
<li>我知道那只不过是我的大脑的想法，而不应该是我的想法</li>
<li>没必要做计划的原因有两个：1.大多数计划其实非常简单”；2.“初始状态下，我们往往实际上并没有能力去制定合理有效的计划”。</li>
<li>大多数情况下，我的建议是这样的：如果你想改变你自己，或者你目前的处境并不令人满意，那就一切从简—找一个你觉得该给你带来改变的行动，然后去做就是了。不要怕碰壁，不要怕失败，那是必须经历的一个过程。还是那句话，失败并不可怕，因为你总是要失败许多次才会有结果，并且全天下又不是只有你一个人失败，怕什么？关键在于在每次挫折之后能否汲取教训。只要能汲取教训，然后自我调整，那就是进步了。</li>
<li>制作一个列表，往往会使自己做事井井有条，并保证自己不会没必要地浪费时间，列表没必要工整。关键在于要随时可以看到，随时可以书写和标记。真正最重要的任务永远只有一个—那个真正对你的目标实现有帮助的任务。真正紧急的事儿少之又少，除非万不得已，千万不要在整个任务完成之前中途更改列表中的项目。</li>
<li>有了什么新鲜主意，启用另外一个新的列表，标题是“下一阶段任务列表”，把你的新鲜主意记录在那里，然后马上回到当前的这个任务列表，专注在当前应该完成的任务上。</li>
<li>先判断你的这个列表所代表的那个任务是不是现实的，如果你真的觉得你能够、也应该完成这个任务，那就开始去做；并且一定要做到底。</li>
<li><p>我们所面临的大多数任务其实都是“重复性”的。只要遇到重复性任务，就要在做过一次之后，马上总结整理，将其流程梳理清楚，而后经过后来的实践把它变成“闭着眼睛也能做好”的事情。这是提高效率、减少失误的最根本手段。</p>
</li>
<li><p>为常见任务制定流程，是必须养成的习惯。在梳理流程的过程中，会不由自主地思考个中的细节，</p>
</li>
<li>在做任何事情之前，我都会尝试着把将要做的事情的整个过程在头脑中预演一遍甚至很多遍。执行的任务越重要，这种预演就越发不可或缺。学习的过程就是如此，它往往给你带来意想</li>
<li>遇到任何任务，都应该认真审视该任务，问自己一个问题并想办法回答清楚：“怎样才算做好？</li>
<li>学习是投资回报率最高的行为。</li>
<li>除了“试错”、“观察”、“阅读”之外，“思考”，准确地说，“正确地思考”，才是获取真正意义上的知识的主要手段。</li>
<li>每个人内心都充满了恐惧，所有的恐惧其实都源自于我们害怕未知。于是，恐惧是永恒的，因为我们永远不可能什么都知道。</li>
<li><p>知识传递过程中最大的障碍—“经验主义”</p>
</li>
<li><p>把那些目前暂时无法理解的、或者支持的、或者反对的，或者无所谓的论点观点记录下来。无法理解的，写下自己当时的疑惑究竟在什么地方；支持的，记录下几个自己的支持理由或者实例；反对的，也一样可以记录下几个自己的反对理由或者实例；甚至那些无所谓的，也可以写下为什么自己觉得这完全是无所谓的</p>
</li>
<li>在任何一个阶段，总是有一段时间进展缓慢，许久过后，所谓量变到质变的效果才会出现，才可能有突飞猛进的感觉</li>
<li>独立思考的钥匙之一是这样的：首先要了解：权威不一定等于正确。进一步要明白：就算权威正确，也只不过是权威表达了正确，而正确并不属于权威。最后要清楚：更准确地来说，权威只是权威、正确就是正确，它们俩什么时候都不是一回事儿。</li>
<li>接到任何任务之后，都勤于琢磨，去思考该任务的目标、实质、意义，而后再根据其目标、实质、意义去思考该任务的完成方法。于是，他们为了完成任务，实现目标，会去做很多领导原本甚至未曾想象过要交代的事情，最终，不仅完成任务，还常常有很多意外收获……</li>
<li>导致人们常常犯这些逻辑错误之中的最重要根源只有两个：概念不清和拒绝接受不确定性。</li>
<li>学习任何知识的时候，搞清楚所有它的基础概念是最重要的</li>
<li><p>“反过来不一定成立”这句话，值得牢记。</p>
</li>
<li><p>爱迪生是否是一个特别努力的人，本质上与我们没什么关系，我们该努力还得努力，不应该仅仅因为别人努力或者不努力，我们就放弃努力。</p>
</li>
<li>抱怨“上司的愚蠢”的人只有一个共同特征：他们只不过是把“上司很愚蠢”作为自己偷懒的借口而已</li>
<li>要么想办法帮助上司解决问题，要么就在爱莫能助的时候选择离开去自行其是。</li>
<li>人类拥有的普遍的认知偏差之一就是：把成功揽到自己身上，把失败归咎于别人或者坏运气。</li>
<li>努力从失败者身上汲取经验。有些时候，“成功者”的经验根本没有用，因为那些经验根本就是错误的。</li>
<li>人家说什么你就信什么，挺傻的。</li>
<li>强与弱才是自然界中真正存在的本质，善与恶更多的时候只不过是弱者一厢情愿的定义。</li>
<li>作为注定会老去死去的物种之一，人性中天生就充满了恐惧</li>
<li>过去的事情是无法更改的，现在的烦恼是无济于事的。但是，将来的尴尬也许是可以避免的—如果现在的行动没有出错的话</li>
<li>当脑子里闪出类似“要是……就好了！”的念头的时候，要马上提醒自己，“停！这个念头最耽误事儿了！”</li>
<li>人们只能听到自己想听到的，只能看到自己想看到的。</li>
<li>日积月累的过程中，要尽量有效甄别自己大脑中所存储的“已知信息”（大多是A类）的有效性。</li>
<li>为了真正做到有效倾听，最需要克制的就是“过早质疑”。就算需要质疑也一定要等到对方说完。</li>
<li>一旦决定倾听，就要主动帮助讲者进入“倾诉”状态。</li>
<li>为了避免在讨论的过程中出现不必要的麻烦，浪费不必要的时间[75]，我们必须深刻理解以下三个原则。</li>
<li>A，有意义之讨论的前提是双方不仅要“相互竞争”更重要的是还要“相互合作”。如果你在任何讨论中发现参与者里面有“自以为是”者存在，你其实只有一个选择，退出讨论</li>
<li>B：事实、真相、真理、道理（即所谓的“Truth”；下文中全部使用“Truth”这个英文单词指代）是独立存在的，从来不会依附于任何个人或者集体存在。</li>
<li>C：Truth不变，也不会因任何人而变；不停变化的只是人们对Truth的解释或者理解</li>
<li>避免自以为是地认为自己肯定理解对了，不妨套用以下这个句式，进行验证、反馈：“你的意思是……，是么？” 　　或者 　　“你的意思是……，你看我理解的对么？”</li>
<li>摆脱经验主义的局限，不仅需要对道理本身的了解，最终还需要勇气</li>
<li>深刻了解了经验之局限之后，所需要做的就是时时刻刻保持警惕</li>
<li>观察与阅读是扩充有限的自我经验的最好手段。</li>
<li>绝大多数人仅因为自己的态度而失去积累、成长的可能</li>
<li>类比思考几乎是跨越已知与未知之间的鸿沟的唯一手段。</li>
<li>一定要问清楚自己这个问题：我不喜欢做这件事情有没有可能仅仅是因为这件事儿我并没有做好？做好这件事情究竟对自己有没有意义？</li>
<li>并不是对正在做的事情没有兴趣，而是没能力把目前正在做的事情做好，最终没有人喜欢自己做不好的事情。</li>
<li>往往并不是有兴趣才能做好，而是做好了才有兴趣。</li>
<li>成功，都只靠两件事：策略和坚持，而坚持本身就是最重要的策略<br>方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。说</li>
<li>所谓的“好的方法”实际上是因人而异的。适合这个人的方法放到另外一个人身上很可能适得其反，适合所有人的方法可能根本不存在。与其不停地找更好的方法，还不如马上开始行动，省得虚度更多的时间。</li>
<li>自己所面临的痛苦并没有所感受到的那么强烈，第一种办法是当你面临尴尬的时候，记得一定要拿出纸笔来，把你所遇到的尴尬记录下来；另一个办法是，在面临尴尬的时候，尽量弱化你的痛苦。</li>
<li>尽管情绪有很多种，但最需要控制的大抵上只有一种：痛苦</li>
<li>很多的时候，比较是个坑，大坑。再干脆点，比较就是陷阱<br>比成功更重要的是成长。</li>
<li>一定要想清楚并记住这件事儿：相信运气其实是缺乏自制力的表现。</li>
<li>浪费时间、虚度年华的人，有个共同的特征—他们拼命想控制自己完全不能控制的，却在自己真正能掌控的地方彻底失控。</li>
<li>弱者相信运气，强者只究因果</li>
<li>努力往往真的会改变一个人的运气</li>
<li>千万不要相信“机不可失，时不再来”。当你没有准备好的时候，对你来讲，不存在任何机会。</li>
<li>承认自己能力有限，是心理健康的前提</li>
<li>“量力而行”是如此高难度的行为模式—a.承认自己能力有限；b.不怕在别人面前露怯；c.敢于不去证明自己是“好人”</li>
<li>生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉，因为只有优秀的人才拥有有效的人脉。</li>
<li>专心做可以提升自己的事情，学习并拥有更多更好的技能，成为一个值得交往的人。</li>
<li>停止嘲弄他人，己所不欲，勿施于人”</li>
<li>素材积累固然非常重要，然而，如果提前确定一个方向或者目标，那么就甚至可以积累很多原本不可能想象的素材—惊喜连连。</li>
<li>永远鼓励身边的人，哪怕多少有些盲目。</li>
<li>当你不停地鼓励所有人的时候，最大的受益者其实是你自己，因为最终你会发现你开始进入一种他人无法想象的状态：你成了一个不需要他人鼓励的人。</li>
<li>记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率</li>
<li>在做时间预算的时候，一定要留有空间。a.你必须清楚肯定会有意外事件发生，b.你必须用适当的方法休息、放松</li>
<li>“累”这个事实，造成一种幻觉“我一直在努力”。</li>
<li>凡是值得做的事情，都值得慢慢做—做很久很久。</li>
<li>要想办法提前预知自己需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能，而后制定长期计划，一点一点地执行该计划</li>
<li>不要盲目地试图减少睡眠时间。</li>
<li>尽量不要减少与家庭成员和亲属交流的时间。</li>
<li>最好不要放弃你的社交时间</li>
<li>“证明自己给别人看”恰恰是最浪费生命的一种行为。</li>
<li>任何积累都需要时间，并且必然需要漫长的时间。</li>
<li>“出来混的，早晚要还”</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>拖延心理学</title>
    <url>/2016/12/01/%E6%8B%96%E5%BB%B6%E5%BF%83%E7%90%86%E5%AD%A6/</url>
    <content><![CDATA[<ul>
<li>小步快跑、深呼吸、平常心、多运动、允许不完美<h2 id="拖延VS行为"><a href="#拖延VS行为" class="headerlink" title="拖延VS行为"></a>拖延VS行为</h2><h3 id="了解你自己"><a href="#了解你自己" class="headerlink" title="了解你自己"></a>了解你自己</h3></li>
<li>拖延情绪的根源涉及到内心感受、恐惧、希望、记忆、梦想、怀疑以及压力。</li>
<li>另一个根源是拖延者与时间的纠葛，如果将时间看成一个需要制服和取胜的对手，将更加拖延！</li>
<li>从你的经验中学习是一件令人兴奋的事–不否认、不遗忘、不判断，而是如实的接受，好好利用！</li>
<li>个人理解：害怕就是自欺欺人，事实上没人关心你到底是什么样子，如果自己害怕自己，那只不过是欺骗自己！</li>
</ul>
<h3 id="质疑拖延"><a href="#质疑拖延" class="headerlink" title="质疑拖延"></a>质疑拖延</h3><ul>
<li>智力和拖延没有关系！</li>
<li>拖延怪圈：开始信心满满-&gt;处理不好-&gt;拖延-&gt;懊恼-&gt;找借口-&gt;再次信心满满</li>
<li>允许不完美，学会不恐惧，要有敬畏心，静心慢慢来！</li>
</ul>
<h3 id="审问拖延"><a href="#审问拖延" class="headerlink" title="审问拖延"></a>审问拖延</h3><ul>
<li>恐惧失败，追求完美！一丁点的失误、挫折、焦虑、甚至恐惧，就代表着不完美，不完美就代表着失败！</li>
<li>我表现的好，我很有能力，所以我很喜欢自己！或我表现的不好，我没有能力，所以我不喜欢自己！事实上是自我价值感 等于 能力 不等于 表现！</li>
<li>完美主义的世界：对犯错极为在意或对自己期待过高，不够现实；自卑，无法忍受平庸或自大，凡事信手拈来；一切都自己来，认为求助是软弱的标志；无法忍受失去；总有一个正确的解决办法，要么全部要么没有；</li>
<li>完美主义者容易绝对化，常以灾难性的方式思考问题；而幻想的，看不见，摸不着的灾难更显得可怕</li>
</ul>
<h3 id="对话拖延：拖延你好，成功再见"><a href="#对话拖延：拖延你好，成功再见" class="headerlink" title="对话拖延：拖延你好，成功再见"></a>对话拖延：拖延你好，成功再见</h3><ul>
<li>实际上很可能是在恐惧成功，并利用拖延来避免成功的到来！</li>
<li>逃避成功的一般心理原因：成功需要太多的付出，这令我望而却步；成功是危险的，总有人会受到伤害；成功是禁区，我觉得自己不对劲；</li>
<li>成功不是一蹴而就的，顾虑害怕都很正常，但这不是拖延的理由，风险和机遇并存，just do it！做好自己就不错了，哪有时间和精力在乎别人怎么想的！</li>
</ul>
<h2 id="拖延VS心理"><a href="#拖延VS心理" class="headerlink" title="拖延VS心理"></a>拖延VS心理</h2><h3 id="挣扎中的拖延者：恐惧在争夺战中失败"><a href="#挣扎中的拖延者：恐惧在争夺战中失败" class="headerlink" title="挣扎中的拖延者：恐惧在争夺战中失败"></a>挣扎中的拖延者：恐惧在争夺战中失败</h3><ul>
<li>争夺控制权的较量，我偏不和我就不：跟规则斗，跟别人斗，跟自己斗！其实是 自我价值感 = 能力（具有独立性，反对受控制）= 表现（通过拖延，“我”说了算）</li>
<li>表现自己，表现自己意味着暴露自己的缺点、意味着承担责任、意味着突出、意味着合作、还意味着可能的失败等等！但这更意味着进步！</li>
<li>要知道未来是不可确定的，即便你非常认同的某些观点，非常确定的事情，未来也有可能发生改变的！何况一些事情本来并没有想象的那么可怕、那么死板！既然如此，那为何恐惧，为何害怕！先干了再说，那些选择放弃的人，他们不会失败，因为一开始他们就失败了！</li>
<li>如果不能抉择，哪为什么不听取别人的建议？选择的权利在于自己，多听建议永远是好的！</li>
</ul>
<h3 id="心理舒适区：对亲近与疏远的恐惧"><a href="#心理舒适区：对亲近与疏远的恐惧" class="headerlink" title="心理舒适区：对亲近与疏远的恐惧"></a>心理舒适区：对亲近与疏远的恐惧</h3><ul>
<li>对疏远的恐惧，我决不独自行走：害怕孤独、害怕迷茫、害怕失去、</li>
<li>恐惧亲近，关系太近让人不舒服</li>
<li>个人理解：扯淡，谁还没个心理舒适区，不耽搁事不就得了！该来的自然会来，该走的自然会走！不如意十之八九，但求一二！</li>
</ul>
<h3 id="拖延时钟：你知道现在几点吗？"><a href="#拖延时钟：你知道现在几点吗？" class="headerlink" title="拖延时钟：你知道现在几点吗？"></a>拖延时钟：你知道现在几点吗？</h3><ul>
<li>客观时间和主观时间：我认为花的时间和实际上花的时间的冲突，造成焦虑和拖延！无论是沉浸在过去还是沉浸在未来，都不如把握住现在！</li>
<li>时间就在那里，不长不短，不快不慢，唯一变化的是自己！要学会接受，更要接受适应！适应主客观时间，并有能力在两者之间有弹性、自然的过渡和变换</li>
</ul>
<h2 id="拖延VS大脑"><a href="#拖延VS大脑" class="headerlink" title="拖延VS大脑"></a>拖延VS大脑</h2><h3 id="世界上存在“拖延基因”吗"><a href="#世界上存在“拖延基因”吗" class="headerlink" title="世界上存在“拖延基因”吗"></a>世界上存在“拖延基因”吗</h3><ul>
<li>你的大脑处在不断地变化中：要学会跳出固有模式，学习批判性思维</li>
<li>感受很重要，即便它处于无意识中：接受并忍着，深呼吸！重要的是下一步怎么做，而不是现在多难受多害怕！</li>
<li>潜伏记忆的影响：深呼吸，告诉自己活在当下</li>
<li>联结的通路：沟通不畅造成自卑！</li>
<li>左逆转：多鼓励，多奖励，少自嘲，不自弃！</li>
</ul>
<h3 id="如何打造大脑的全局领导力"><a href="#如何打造大脑的全局领导力" class="headerlink" title="如何打造大脑的全局领导力"></a>如何打造大脑的全局领导力</h3><ul>
<li>执行功能障碍：分解拆分目标，自己开导自己</li>
<li>注意力缺失紊乱：注意力分散、冲动和躁动不安！根本原因是没有抑制能力！找到喜欢的 或 肾上腺素–加强运动！</li>
<li>抑郁症的倾向于变种：当你抑郁时，你会感到能量不足，不愿意参与，失去兴趣，没有目标，不在乐观！方法：聊天+运动，比较有效</li>
<li>强迫症：事情已经已经解决了，这是我的强迫症在作怪！</li>
<li>邋遢分子和囤积狂：优柔寡断 + 对犯错误的恐惧 = 邋遢分子，邋遢分子升级为囤积狂！方法：转移注意力+快刀斩乱麻</li>
<li>压力对人的影响：压力，面对或逃避，都需要时间来恢复精力</li>
<li>生物节奏：调整节奏，休息和运动同样重要</li>
</ul>
<h3 id="你是怎样变成一个拖延者的"><a href="#你是怎样变成一个拖延者的" class="headerlink" title="你是怎样变成一个拖延者的"></a>你是怎样变成一个拖延者的</h3><ul>
<li>家庭倾向造成拖延：施压、怀疑、控制、依附和疏远！根本就是压力和孤独</li>
<li>无条件的支持也会造成拖延症，因此压力太大了，所有人都支持你，你就不能失败，不能犯错！而不失败，不犯错最好的办法似乎就是拖延</li>
</ul>
<h3 id="拖延行为模式的法庭大调查"><a href="#拖延行为模式的法庭大调查" class="headerlink" title="拖延行为模式的法庭大调查"></a>拖延行为模式的法庭大调查</h3><ul>
<li>勇敢不是没有恐惧，而是克服恐惧，战胜恐惧</li>
<li>去认识那个拖延之外的你很重要，那个你就可以按照你自己的本来面目，而不是按照你所希望或者你认为的样子，来接受自己！诚实的了解自己，现实的评价自己，并最终接受你所发现的那个自己！</li>
<li>最可怕的事情就是去全然的接受自己。这个“可怕”的接受自己的过程–接受所有的缺陷、创痛和伤疤，同时也可以让你如释负重！</li>
<li>面对现实</li>
<li>生物现实：对于自己的弱项心怀敬畏的给予关注，友善的对待自己，并通过锻炼提高相应的技能！</li>
<li>情感现实：在你焦头烂额的时候不要指望可以迅速或者完全的从中恢复过来！其实感觉一个比较靠谱的办法就是深呼吸，数到20再做下一步反应！</li>
<li>价值现实：价值观是否相同，是否符合心意！也就是找志趣相投的</li>
<li>不要自欺欺人：万事无美好；努力尝试是一件好事，而不是愚蠢或软弱的表现；失败并不危险，失败才是生活的常态；真正的失败是不敢去经历，每个人都是局限，包括我自己；如果那是一件值得去做的事情，那么为它犯错误也是值得的；挑战有助于我的成长；我有成功的权利，我也能应对别人对此的反应；如果这一次我没有做好，下一次我还有机会；遵守别人的规则去做事，并不意味着我一点权利也没有；当我展现出真实的自我，真正喜欢我的人就会跟我坦诚相对；答案很多，但我需要找到那个最符合我的感觉的答案</li>
</ul>
<h2 id="拖延VS征服之战"><a href="#拖延VS征服之战" class="headerlink" title="拖延VS征服之战"></a>拖延VS征服之战</h2><h3 id="采取行动"><a href="#采取行动" class="headerlink" title="采取行动"></a>采取行动</h3><ul>
<li>观察并记录痛点，找到需求，just do it !</li>
</ul>
<h3 id="改变是一个过程"><a href="#改变是一个过程" class="headerlink" title="改变是一个过程"></a>改变是一个过程</h3><ul>
<li>慢慢来，平常心！just do it !</li>
<li>找出导致拖延的因素：</li>
<li>对成功所需的能力缺乏自信：可以设立一个比较现实的、能够达成的、同时又容易衡量的目标；再细分成容易操作的小单元。</li>
<li>对要去完成的某个任务有反感心理，认定做事的过程中会遭遇很多困难，结局也会很惨：自己吓自己，放轻松 + 奖励</li>
<li>目标和回报太遥远了，感受不到对我有什么意义：拆分目标 + 奖励</li>
<li>无法自我约束</li>
<li>如何运用这些技巧：一次尝试一个技巧、慢慢来、观察内心的抵抗、写日记记录优缺点记录心态变化等<h3 id="作战前传：拖延大清点"><a href="#作战前传：拖延大清点" class="headerlink" title="作战前传：拖延大清点"></a>作战前传：拖延大清点</h3></li>
<li>不要批判，只要清点</li>
<li>盘点内心的挣扎</li>
<li>善意的对待内在或外在的结果</li>
<li>拖延的领域、风格、借口</li>
</ul>
<h3 id="作战武器：明确的目标与可执行的计划"><a href="#作战武器：明确的目标与可执行的计划" class="headerlink" title="作战武器：明确的目标与可执行的计划"></a>作战武器：明确的目标与可执行的计划</h3><ul>
<li>可操作目标特性：可观察性、具体性和特殊性、可以被分解成几个小步骤、第一步可以在五分钟内被完成、</li>
<li>启动计划、番茄25分钟、5分钟休息、忠实的记录中断与借口、总结奖励与反思、下一步计划</li>
<li>灵活对待项目（时间、规划、聚合拆分等）、无需完美只需进步</li>
<li>灵活对待时间，逝去的已经逝去，与其懊恼不如把握现在！</li>
</ul>
<h3 id="作战方法A：学会怎样判断时间"><a href="#作战方法A：学会怎样判断时间" class="headerlink" title="作战方法A：学会怎样判断时间"></a>作战方法A：学会怎样判断时间</h3><ul>
<li>时间是固定的、可衡量的、有限的</li>
<li>个人理解：大多数情况预估时间都比实际花费时间短，我的办法是预估时间*系数</li>
<li>计划并不意味着每一天每一个小时都被占据，要有缓冲区！而且要提前考虑意外的情况！</li>
<li>要想计划成为你的朋友，计划应该务实、合理。计划必须围绕着脚踏实地做事情这个核心，而不是老在盘算你应该干什么</li>
<li>跟踪目标进度，填写分段时间表记录每段时间做的啥！而且有助于更有效的利用碎片化时间，告诉自己碎片化时间不是一无所获！自我监测有助于增进工作时间和提升工作成就</li>
<li>提升你定时能力的技巧：练习判断时间，预估时间与实际时间的对比有助于提升时间判断！学会利用零碎时间，而不是消极的等待整块的时间段出现，一步步向前挪，也是前进！</li>
<li>胡萝卜政策要比大棒政策要管用的多！</li>
<li>每个方案都有优化空间，但最主要的是解决问题和性价比，记住时间是昂贵的资源，一直在研究有没有更好的方案也花费很多的时间</li>
<li>不要过分分散精力，不要利用忙碌来逃避更重要的事情</li>
<li>找出你的最佳时间，而不是幻想着我要怎样怎样</li>
<li>学会在过去、现在和未来之间取得认知上的平衡，不要黏滞在时间中！</li>
<li>享受你的“自由”时间。“拖延”不是“自由”，甚至拖延都不能让你开心！</li>
</ul>
<h3 id="作战方法B：学会接受和拒绝"><a href="#作战方法B：学会接受和拒绝" class="headerlink" title="作战方法B：学会接受和拒绝"></a>作战方法B：学会接受和拒绝</h3><ul>
<li>我们应该有意识的接受那些提高我们生活品质的事情，而拒绝那些对此无益的事情，并且应该直接的表达出来，而不应该通过拖延的方式来拒绝。重要的是知道想要什么，不想要什么</li>
<li>学会接受有益于你的人和事：选对人、放开心胸不要处处为自己辩解、做一个公开的承诺、做完就要接受奖励、拖延就要受到惩罚、跟别人一起制订计划、尝试新的挑战、做更多你所热爱的事情、</li>
<li>当你寻求帮助的时候，没必要一定要采用它；当别人很有洞察力，看到了一些你看不到的事情，不必自卑！</li>
<li>交谈很重要，可以进一步拉一个人跟你一起做事(至少有人跟你一块受罪，哈哈)</li>
<li>学会拒绝那些没意义的追求</li>
<li>对浪费时间和让你退步的人和事说不：对没意义的事情说不、 对不必要的事情说不；不能说不，那就减少影响</li>
<li>对杂乱无序说不：怎样才能过的更幸福，定期扔东西，包括真实的或头脑中虚拟的！定期自查自省！</li>
<li>对电子上瘾说不：最简单最有效的方法，关掉手机关掉电脑等</li>
<li>坚持信息减肥：90%的信息都是没意义的，应该坚持扔掉！</li>
</ul>
<h3 id="作战方法C-利用你的身体减轻拖延"><a href="#作战方法C-利用你的身体减轻拖延" class="headerlink" title="作战方法C:利用你的身体减轻拖延"></a>作战方法C:利用你的身体减轻拖延</h3><ul>
<li>通过运动启动你的状态：将运动作为调整自身（拖延、情绪、身体等等）的一种方法，总之就是感觉不舒服或感觉太舒服，都要来点运动！运动还能刺激大脑</li>
<li>冥想: 常练冥想，有助于精力、睡眠！</li>
<li>深呼吸，越紧张越复杂越急躁越要深呼吸！</li>
</ul>
<h2 id="拖延VS建议"><a href="#拖延VS建议" class="headerlink" title="拖延VS建议"></a>拖延VS建议</h2><h3 id="对患有注意力缺失紊乱和执行功能障碍拖延者的一些建议："><a href="#对患有注意力缺失紊乱和执行功能障碍拖延者的一些建议：" class="headerlink" title="对患有注意力缺失紊乱和执行功能障碍拖延者的一些建议："></a>对患有注意力缺失紊乱和执行功能障碍拖延者的一些建议：</h3><ul>
<li>从外在开始，逐渐转向内在：借助工具，养成习惯</li>
<li>执行提示点：通过视觉、听觉、触觉等提醒自己要干活了，并立即马上just do it </li>
<li>架构和路线的重要性：toDoList；固定时间处理一些固定事务，例早起跑步；小步快跑</li>
<li>不要想在你的弱项上表现优异，而是要在你的强项上更上一层楼</li>
</ul>
<h3 id="拖延处理技巧汇编"><a href="#拖延处理技巧汇编" class="headerlink" title="拖延处理技巧汇编"></a>拖延处理技巧汇编</h3><ul>
<li>确立一个可操作的目标（可观察、具体而实在的），而不是那种模糊而抽象的目标。</li>
<li>设定一个务实的目标。不是异想天开，而要从小事做起。不要过于理想化，而要选择一个能接受的程度最低的目标。</li>
<li>将目标分解成短小具体的迷你目标。每个迷你目标都要比大目标容易达成，小目标可以累积成大目标。</li>
<li>现实的（而不是按照自己的愿望）对待时间。</li>
<li>just do it ! 不要想一下子做完整件事，每次只要迈出一小步</li>
<li>番茄工作法：坚持一小段时间，并逐步增长！注意利用碎片化时间</li>
<li>为困难和挫折做好心理准备！多想多问</li>
<li>可能的话，将任务分派出去，甚至扔掉不管！</li>
<li>保护你的时间，学会怎么样说不，不要去做额外的或不必要的事情</li>
<li>留意你的借口</li>
<li>奖励进步，将奖励聚焦于努力，而不是结果！小心非此即彼的思维方式：你可以说杯子是半空的，也可以说他是半满的！</li>
<li>将拖延看成一个信号，停下来问自己：拖延传递给我的是什么意思？</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>晨间日记的奇迹</title>
    <url>/2017/01/31/%E6%99%A8%E9%97%B4%E6%97%A5%E8%AE%B0%E7%9A%84%E5%A5%87%E8%BF%B9/</url>
    <content><![CDATA[<p>&emsp;&emsp;话说前些天啃内核知识啃得头疼，今天正好换换脑子！本来想看会小说的，发现这本书也就跟小说一样，一目十行都嫌慢的那种！正好放松一下脑子</p>
<ul>
<li>早上写日记的好处：1，可做一天的准备（计划性）；2，可以正确的写出昨天所发生的事情（效率性和忠实性）；3，冷静思考昨天的事（中立性）；4，早上比较自由（持续性）；5，可以将过去的宝贵经验应用于当天（灵活运用性）</li>
<li>累了一天到晚上写的日记大多情绪是负面的，潦草的，激进的，而反省是缺乏独立思考的</li>
<li>早上写日记能真实客观的正视问题，反省自己，并根据变化做出更好的改善意见</li>
<li>趁着昨天的记忆还在，可以在段时间内留下正确的记录。</li>
<li>注意写日记不是写流水账，也要写情绪，问题与方法，重要的有趣的好玩的别人重要的事等等</li>
<li>早上懒床就是借口。早起方法很多，最最主要的是梦想：我想进阿里，去做闲鱼</li>
<li>早上健身和沐浴让你身心精神百倍</li>
<li>写日记的5大好处：1，提升写作能力；2，谈话题材源源不断；3，提高贵人运；4，发现自我肉体与精神的状态和模式；5，在自己身上挖宝，彻底改变人生；</li>
<li>人过了30岁以后剩下的只有习惯</li>
<li>平常心，不骄不躁不急不惰</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>有意思的@try@Catch</title>
    <url>/2017/06/10/%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84-try-Catch/</url>
    <content><![CDATA[<p>&emsp;&emsp;今天和同事聊天，聊到了tryCatch的使用，他说trycatch用起来很简单！我问他有风险吗！他说，trycatch有啥风险，随便用！回头想想iOS的@try@catch，额…不提也…哎，其实也是可以水一篇的哈！</p>
<p>&emsp;&emsp;简单的来说，Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。</p>
<p>&emsp;&emsp;参考：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>Important: You should reserve the use of exceptions for programming or unexpected runtime errors such as out-of-bounds collection access, attempts to mutate immutable objects, sending an invalid message, and losing the connection to the window server. You usually take care of these sorts of errors with exceptions when an application is being created rather than at runtime.<br>If you have an existing body of code (such as third-party library) that uses exceptions to handle error conditions, you may use the code as-is in your Cocoa application. But you should ensure that any expected runtime exceptions do not escape from these subsystems and end up in the caller’s code. For example, a parsing library might use exceptions internally to indicate problems and enable a quick exit from a parsing state that could be deeply recursive; however, you should take care to catch such exceptions at the top level of the library and translate them into an appropriate return code or state.</p>
</blockquote>
<p>&emsp;&emsp;此外tryCatch比较耗性能，不能用于流程控制 <a href="https://stackoverflow.com/questions/3678438/try-catch-exception-handling-practice-for-iphone-objective-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/3678438/try-catch-exception-handling-practice-for-iphone-objective-c</a> ；容易造成内存泄漏 <a href="https://stackoverflow.com/questions/27140891/why-does-try-catch-in-objective-c-cause-memory-leak" target="_blank" rel="noopener">https://stackoverflow.com/questions/27140891/why-does-try-catch-in-objective-c-cause-memory-leak</a> ；更重要的是tryCatch干的活，基本上NSError和断点都能干 <a href="https://stackoverflow.com/questions/13774611/try-catch-equivalent-in-objective-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/13774611/try-catch-equivalent-in-objective-c</a></p>
<hr>
<p>&emsp;&emsp;当然这篇水文关注的不是tryCatch少用的原因！</p>
<p>&emsp;&emsp;其实我本来打算研究一下tryCatch为什么耗性能的！但真没研究出来，不过到发现一个好玩的东西，本着水一篇算一篇，水一会算一会的精神，我还是水了出来！</p>
<p>&emsp;&emsp;测试代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (void)test &#123;</span><br><span class="line">@try &#123;</span><br><span class="line">NSLog(@&quot;try&quot;);</span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">NSLog(@&quot;catch&quot;);</span><br><span class="line">&#125; @finally &#123;</span><br><span class="line">NSLog(@&quot;finally&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译后得到如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// @implementation Person</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">&#123;</span><br><span class="line">id volatile _rethrow = 0;</span><br><span class="line">try &#123;</span><br><span class="line">// 这里对应@try @catch</span><br><span class="line">try &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_0);</span><br><span class="line">&#125; catch (_objc_exc_NSException *_exception) &#123;</span><br><span class="line">/*</span><br><span class="line">从代码上看只捕获_objc_exc_NSException</span><br><span class="line"></span><br><span class="line">typedef struct objc_object NSException;</span><br><span class="line">typedef struct &#123;&#125; _objc_exc_NSException;</span><br><span class="line">*/</span><br><span class="line">NSException *exception = (NSException*)_exception;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (id e) &#123;</span><br><span class="line">// 理论上讲 非 _objc_exc_NSException才能走到这里</span><br><span class="line">_rethrow = e;</span><br><span class="line">&#125;</span><br><span class="line">&#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">id rethrow;</span><br><span class="line">&#125; _fin_force_rethow(_rethrow);</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;大家可直观的观察到包含两个trycatch，说实话哈！我是第一次见到try里面嵌套trycatch，很久以前学习JAVA时见过catch或finally里面还有trycatch，主要是因为JAVA处理异常时还可能发生别的异常，所以再加一个trycatch来捕获子异常。延伸一下，try配合多个catch 和 trycatch嵌套最主要的区别就是一个try多个catch只能捕获一次异常；而trycatch嵌套可以捕获多个异常。当然你要硬说<a href="https://stackoverflow.com/questions/136035/catch-multiple-exceptions-at-once" target="_blank" rel="noopener">一个try也可以捕获多个异常</a>，我也不反对，毕竟这种方式不太常用！</p>
<p>&emsp;&emsp;可以参考<a href="https://www.cnblogs.com/zhangchengye/p/5674240.html" target="_blank" rel="noopener">try catch里面try catch嵌套</a>加深对trycatch嵌套的理解！个人猜测，之所以try嵌套还是为了尽可能的捕获异常（我依然认为这么写的意义不大），但即便如此@try@catch无法捕获UncaughtException，而oc中大部分crash如：内存溢出、野指针等都是无法捕获的，而能捕获的只是像数组越界之类的，所以@try@catch真的比较鸡肋。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>极简主义</title>
    <url>/2017/05/08/%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89/</url>
    <content><![CDATA[<h1 id="极简主义"><a href="#极简主义" class="headerlink" title="极简主义"></a>极简主义</h1><h3 id="大多数时候我们都在寻找复杂的解决办法"><a href="#大多数时候我们都在寻找复杂的解决办法" class="headerlink" title="大多数时候我们都在寻找复杂的解决办法"></a>大多数时候我们都在寻找复杂的解决办法</h3><ul>
<li>常常问自己：要做的简单的是什么？是否还有更简单的？</li>
<li>尝试用25个字简单明了的描述清楚，一件事，一个问题，一个方案，一个建议等</li>
<li>尝试30秒内完成这件事，“电梯公关”有限时间内将信息完整准确的传递</li>
<li>如果发现采用了复杂的办法，就要审视是否可以更简单点</li>
<li>只问最简单的问题：who? what? when? where? why? how?</li>
<li>使用水平思维，改变固有思维模式</li>
<li>大多数会议，往往倾向于复杂的操作，而不是简单的</li>
</ul>
<h3 id="弄明白自己要做什么"><a href="#弄明白自己要做什么" class="headerlink" title="弄明白自己要做什么"></a>弄明白自己要做什么</h3><ul>
<li>做一点计划永远比盲目的尝试好很多</li>
<li>真正理解你努力想做的事：这个工作最终要达到什么目标？什么事件的出现标志着这项工作的结束？</li>
<li>搞清楚你想要走的事情是否也是其他人希望做的：让利益相关者永远开心是成功的关键，利益相关者也是有权重的。</li>
<li>具体工作形象化：其实就是幻想出要做的事情，能明确努力目标，缩小范围还能多角度观察要做的事情</li>
</ul>
<h3 id="任何事都有连续性"><a href="#任何事都有连续性" class="headerlink" title="任何事都有连续性"></a>任何事都有连续性</h3><ul>
<li>制定宏大的目标，却对“怎样”实现缺乏关注,即如果事件不具有连续性，那什么也做不了</li>
<li>建立事件连续性：一开始就做好计划；把计划做的详细周到；清楚的说清自己的意图；善于运用知识和假设；懂得运用因果关系；记录已经发生的事情</li>
<li>把要做的事情列成清单并定期更新</li>
<li>事情优先级排序：如果我现在只能做一件事，做什么呢？</li>
<li>加快速度，时间间隙可以做什么？</li>
</ul>
<h3 id="如果不去做，永远要做不完"><a href="#如果不去做，永远要做不完" class="headerlink" title="如果不去做，永远要做不完"></a>如果不去做，永远要做不完</h3><ul>
<li>分解落实到点并有效管理</li>
<li>处理点与点之间的关系与冲突</li>
<li>必须学会不做某事</li>
</ul>
<h3 id="事情的结果往往和预期不一样"><a href="#事情的结果往往和预期不一样" class="headerlink" title="事情的结果往往和预期不一样"></a>事情的结果往往和预期不一样</h3><ul>
<li>计划中必须要有应急预案</li>
<li>风险管理与预留余地，对于我，感觉是多想想和多想想的区别</li>
<li>渐进式完成，先完成必须要做，在完成做了更好的</li>
</ul>
<h3 id="明确界定事情的结果"><a href="#明确界定事情的结果" class="headerlink" title="明确界定事情的结果"></a>明确界定事情的结果</h3><ul>
<li>明确且有意义的目标：任务细分+具化量化</li>
<li>转移压力和缓解压力</li>
</ul>
<h3 id="学会从他人的角度看问题"><a href="#学会从他人的角度看问题" class="headerlink" title="学会从他人的角度看问题"></a>学会从他人的角度看问题</h3><ul>
<li>尽可能满足利益相关者获利条件</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>核心动画</title>
    <url>/2015/10/08/%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h3 id="CAlayer简介"><a href="#CAlayer简介" class="headerlink" title="CAlayer简介"></a>CAlayer简介</h3><h4 id="UIView与CALayer"><a href="#UIView与CALayer" class="headerlink" title="UIView与CALayer"></a>UIView与CALayer</h4><ul>
<li>关系</li>
<li>CALayer 是 Core Animation Layer</li>
<li>UIView默认有个CALayer，是负责真正的绘图部分</li>
<li>UIView可以理解为是CALayer的管理器，对CALayer进行封装，所以他们大部分属性都是类似的</li>
<li>区别</li>
<li>CALayer继承自NSObject不响应事件，UIView继承自UIResponder能够响应事件</li>
<li>CAlayer是QuatzCore框架内容，UIView是UIKit框架内容</li>
<li>CALayer直接支持3D展示，UIView需要借助transform</li>
<li>CALayer大部分属性修改都能形成隐式动画，UIView没有</li>
</ul>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>是否支持隐式动画</th>
</tr>
</thead>
<tbody>
<tr>
<td>anchorPoint</td>
<td>锚点，取值0到1，比例值！默认(0.5,0.5)，永远和position重合</td>
<td>是</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>图层背景颜色</td>
<td>是</td>
</tr>
<tr>
<td>borderColor</td>
<td>边框颜色</td>
<td>是</td>
</tr>
<tr>
<td>borderWidth</td>
<td>边框宽度</td>
<td>是</td>
</tr>
<tr>
<td>bounds</td>
<td>图层大小</td>
<td>是</td>
</tr>
<tr>
<td>contents</td>
<td>图层显示内容，例如可以将图片作为图层内容显示</td>
<td>是</td>
</tr>
<tr>
<td>contentsRect</td>
<td>图层显示内容的大小和位置</td>
<td>是</td>
</tr>
<tr>
<td>cornerRadius</td>
<td>圆角半径</td>
<td>是</td>
</tr>
<tr>
<td>doubleSided</td>
<td>图层背面是否显示，默认为YES</td>
<td>否</td>
</tr>
<tr>
<td>frame</td>
<td>图层大小和位置，不支持隐式动画</td>
<td>否</td>
</tr>
<tr>
<td>hidden</td>
<td>是否隐藏</td>
<td>是</td>
</tr>
<tr>
<td>mask</td>
<td>图层蒙版</td>
<td>是</td>
</tr>
<tr>
<td>maskToBounds</td>
<td>子图层是否剪切图层边界，默认为NO</td>
<td>是</td>
</tr>
<tr>
<td>opacity</td>
<td>透明度 ，类似于UIView的alpha</td>
<td>是</td>
</tr>
<tr>
<td>position</td>
<td>图层中心点位置，类似于UIView的center</td>
<td>是</td>
</tr>
<tr>
<td>shadowColor</td>
<td>阴影颜色</td>
<td>是</td>
</tr>
<tr>
<td>shadowOffset</td>
<td>阴影偏移量</td>
<td>是</td>
</tr>
<tr>
<td>shadowOpacity</td>
<td>阴影透明度，注意默认为0，如果设置阴影必须设置此属性</td>
<td>是</td>
</tr>
<tr>
<td>shadowPath</td>
<td>阴影的形状</td>
<td>是</td>
</tr>
<tr>
<td>shadowRadius</td>
<td>阴影模糊半径</td>
<td>是</td>
</tr>
<tr>
<td>sublayers</td>
<td>子图层</td>
<td>是</td>
</tr>
<tr>
<td>sublayerTransform</td>
<td>子图层形变</td>
<td>是</td>
</tr>
<tr>
<td>transform</td>
<td>图层形变</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：一般CALayer中很少使用frame，通常使用bounds和position代替</li>
<li>注意：UIView的transform是CGAffineTransform用于2D变化，CALayer的的transform是CATransform3D用于3D变化，可互转; CGAffineTransform和CATransform3D的共同点是带有rotation用于旋转、带有scale用于缩放、带有translation用于平移</li>
</ul>
<h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><h4 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a>CAAnimation</h4><ul>
<li>核心动画的根类<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 时间函数</span><br><span class="line">/*</span><br><span class="line">kCAMediaTimingFunctionLinear        // 匀速</span><br><span class="line">kCAMediaTimingFunctionEaseIn        // 慢进</span><br><span class="line">kCAMediaTimingFunctionEaseOut       // 慢出</span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut // 慢进慢出</span><br><span class="line">kCAMediaTimingFunctionDefault       // 默认值（慢进慢出）</span><br><span class="line">*/</span><br><span class="line">@property(nullable, strong) CAMediaTimingFunction *timingFunction;</span><br><span class="line"></span><br><span class="line">// 注意是strong，设置代理后必须在适当时机手动释放delegate</span><br><span class="line">@property(nullable, strong) id &lt;CAAnimationDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">// 动画执行完毕后是否从图层上移除，默认为YES（视图会恢复到动画前的状态），可设置为NO（图层保持动画执行后的状态，前提是fillMode设置为kCAFillModeForwards）</span><br><span class="line">@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAMediaTiming-协议"><a href="#CAMediaTiming-协议" class="headerlink" title="CAMediaTiming 协议"></a>CAMediaTiming 协议</h4><ul>
<li>CAMediaTiming是一个很好的使用协议实现多继承的样例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 开始时间，默认0即当前时间，延迟2秒可用 beginTime=CACurrentMediaTime() + 2;</span><br><span class="line">@property CFTimeInterval beginTime;</span><br><span class="line"></span><br><span class="line">// 动画持续时长，默认0</span><br><span class="line">@property CFTimeInterval duration;</span><br><span class="line"></span><br><span class="line">// 动画速度，默认1，设为0表示暂停动画</span><br><span class="line">// 动画的实际时间 = duration / speed</span><br><span class="line">@property float speed;</span><br><span class="line"></span><br><span class="line">// 动画已经进行了多长时间，默认0</span><br><span class="line">@property CFTimeInterval timeOffset;</span><br><span class="line"></span><br><span class="line">// 重复次数，默认0</span><br><span class="line">@property float repeatCount;</span><br><span class="line"></span><br><span class="line">// 重复时间，默认0</span><br><span class="line">@property CFTimeInterval repeatDuration;</span><br><span class="line"></span><br><span class="line">// 是否反转，即所有动画倒着来一遍，默认NO</span><br><span class="line">@property BOOL autoreverses;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首先设置animation.removeOnCompletion = NO</span><br><span class="line">kCAFillModeForwards  // 动画结束后保持最后一帧的状态</span><br><span class="line">kCAFillModeBackwards // 动画开始前报纸第一帧的状态</span><br><span class="line">kCAFillModeBoth      // 都有</span><br><span class="line">kCAFillModeRemoved   // 相当于动画对CALayer没影响，执行完就移除</span><br><span class="line">*/</span><br><span class="line">@property(copy) CAMediaTimingFillMode fillMode;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAAnimationDelegate"><a href="#CAAnimationDelegate" class="headerlink" title="CAAnimationDelegate"></a>CAAnimationDelegate</h4><ul>
<li>注意此delegate是用strong修饰的，使用完必须手动置nil<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 动画开始时回调</span><br><span class="line">- (void)animationDidStart:(CAAnimation *)anim;</span><br><span class="line"></span><br><span class="line">// 动画结束或中断时回调，finished为YES表示动画结束</span><br><span class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAPropertyAnimation"><a href="#CAPropertyAnimation" class="headerlink" title="CAPropertyAnimation"></a>CAPropertyAnimation</h4><ul>
<li>属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 一般基础动画和关键帧动画都都会通过去下便利初始化初始化</span><br><span class="line">+ (instancetype)animationWithKeyPath:(nullable NSString *)path;</span><br><span class="line"></span><br><span class="line">// 其实即使CALayer的属性（支持隐式动画的）参照上面</span><br><span class="line">// 注意是NSString，KVC方式来赋值的，所以特别注意拼写问题，大小写等</span><br><span class="line">// 使用transform时 ，应该具体到属性，例@&quot;transform.scale&quot;、@&quot;transform.rotation.z&quot;</span><br><span class="line">@property(nullable, copy) NSString *keyPath;</span><br><span class="line"></span><br><span class="line">// 插值计算函数，不用管，用系统的就好！</span><br><span class="line">@property(nullable, strong) CAValueFunction *valueFunction;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h4><ul>
<li>基础动画，通过属性修改进行动画参数控制，最常见用法是设置fromValue和toValue</li>
<li><p>注意：fromValue、toValue和byValue都是strong修饰的id类型，具体类型需要根据keyPath的类型处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">fromValue和toValue不为nil，keyPath属性值在fromValue与toValue之间渐变</span><br><span class="line">fromValue和byValue不为nil，keyPath属性值在fromValue与(fromValue+byValue)之间渐变</span><br><span class="line">byValue和toValue不为nil，keyPath属性值在(toValue-byValue)与toValue之间渐变</span><br><span class="line">fromValue不为nil，keyPath属性值在fromValue与图层对应当前值之间渐变</span><br><span class="line">toValue不为nil，keyPath属性值在图层对应当前值与toValue之间渐变</span><br><span class="line">byValue不为nil，keyPath属性值在图层对应当前值与(图层对应当前值+toValue)之间渐变</span><br><span class="line">*/</span><br><span class="line">@property(nullable, strong) id fromValue;</span><br><span class="line">@property(nullable, strong) id toValue;</span><br><span class="line">@property(nullable, strong) id byValue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然fromValue、toValue和byValue也可使用CATransform3D对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CATransform3D transformFrom = CATransform3DMakeScale(1.0, 1.0, 1.0);</span><br><span class="line">CASpringAnimation *springAnimation = [CASpringAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">springAnimation.fromValue = [NSValue valueWithCATransform3D:transformFrom];</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CABasicAnimation* animation;</span><br><span class="line">animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">animation.toValue = [NSNumber numberWithFloat: M_PI * 30 ];</span><br><span class="line">animation.duration = 2.0;</span><br><span class="line">// 可设时间函数</span><br><span class="line">//    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.cumulative = YES;</span><br><span class="line">animation.repeatCount = 0;</span><br><span class="line">animation.removedOnCompletion = NO;</span><br><span class="line">animation.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line">[view.layer addAnimation:rotationAnimation forKey:@&quot;rotationAnimation&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a>CAKeyframeAnimation</h4><ul>
<li><p>关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 关键帧（就是标志位）数组，类型由keyPath确定</span><br><span class="line">@property(nullable, copy) NSArray *values;</span><br><span class="line"></span><br><span class="line">// 将时间点和关键帧（标志位）一一对应，数值为总时长的百分比，默认均分</span><br><span class="line">@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;</span><br><span class="line"></span><br><span class="line">// 每个关键帧之间的动画缓冲效果，timingFunctions.count = keyTimes.count-1</span><br><span class="line">@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;</span><br><span class="line"></span><br><span class="line">// 指定动画路径，设置此属性将忽略values等</span><br><span class="line">@property(nullable) CGPathRef path;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double duration = 16 / 30.0;</span><br><span class="line">NSArray *keyTimes = @[@0, @((7/30.0)), @((13/30.0)), @((16/30.0))];</span><br><span class="line">CAKeyframeAnimation *sizeAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</span><br><span class="line">sizeAni.values = @[@1.0, @1.2, @0.90, @1.0];</span><br><span class="line">sizeAni.keyTimes = keyTimes;</span><br><span class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">group.animations = @[sizeAni];</span><br><span class="line">group.duration = duration;</span><br><span class="line">[view.layer addAnimation:group forKey:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CAAnimationGroup"><a href="#CAAnimationGroup" class="headerlink" title="CAAnimationGroup"></a>CAAnimationGroup</h3><ul>
<li>动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *keyTimes = @[@0, @((7/43.0)), @((17/43.0)), @((29/43.0)), @(1)];</span><br><span class="line">CAKeyframeAnimation *sizeAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</span><br><span class="line">sizeAni.values = @[@0, @1.1, @1, @1, @1];</span><br><span class="line">sizeAni.duration = duration;</span><br><span class="line">sizeAni.keyTimes = keyTimes;</span><br><span class="line">sizeAni.repeatCount = CGFLOAT_MAX;</span><br><span class="line"></span><br><span class="line">CAKeyframeAnimation *opacityAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];</span><br><span class="line">opacityAni.values = @[@0, @1, @1, @1, @1];</span><br><span class="line">opacityAni.keyTimes = keyTimes;</span><br><span class="line"></span><br><span class="line">CAKeyframeAnimation *positionAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">CGPoint centerPoint = adView.center;</span><br><span class="line">CGRect frameRect = adView.frame;</span><br><span class="line">CGPoint startPoint = CGPointMake(centerPoint.x, (frameRect.origin.y + frameRect.size.height));</span><br><span class="line">CGPoint endPoint = CGPointMake(centerPoint.x, centerPoint.y);</span><br><span class="line">NSArray *values = [NSArray arrayWithObjects:[NSValue valueWithCGPoint:startPoint], [NSValue valueWithCGPoint:endPoint],[NSValue valueWithCGPoint:endPoint], [NSValue valueWithCGPoint:endPoint], [NSValue valueWithCGPoint:endPoint], nil];</span><br><span class="line">positionAni.values = values;</span><br><span class="line">positionAni.keyTimes = keyTimes;</span><br><span class="line"></span><br><span class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">group.animations = @[sizeAni, positionAni];</span><br><span class="line">group.duration = duration;</span><br><span class="line">group.removedOnCompletion = NO;</span><br><span class="line">[adView.layer addAnimation:group forKey:@&quot;addArrowViewGroupAnimation&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h4><ul>
<li>事务的作用：保证一个或多个layer的一个或多个属性变化同时进行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[CATransaction begin];</span><br><span class="line">&#123;</span><br><span class="line">// some animaiton</span><br><span class="line">&#125;</span><br><span class="line">[CATransaction commit];</span><br><span class="line"></span><br><span class="line">[CATransaction setCompletionBlock:^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><p>&emsp;&emsp;不写了，除了弹簧动画需要自己测试下参数外，其它的都很简单！另外需要注意的是animate的completionblock不会引起循环引用，可放心使用！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cocoachina.com/articles/10005" target="_blank" rel="noopener">http://www.cocoachina.com/articles/10005</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>毛玻璃效果代码</title>
    <url>/2015/12/19/%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ul>
<li><p>方法1，使用CIFilter滤镜</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//生成一张毛玻璃图片 </span><br><span class="line">- (UIImage*)blur:(UIImage*)theImage  &#123; </span><br><span class="line">CIContext *context = [CIContext contextWithOptions:nil]; </span><br><span class="line">CIImage *inputImage = [CIImage imageWithCGImage:theImage.CGImage]; </span><br><span class="line"></span><br><span class="line">CIFilter *filter = [CIFilter filterWithName:@&quot;CIGaussianBlur&quot;]; </span><br><span class="line">[filter setValue:inputImage forKey:kCIInputImageKey]; </span><br><span class="line">[filter setValue:[NSNumber numberWithFloat:15.0f] forKey:@&quot;inputRadius&quot;]; </span><br><span class="line">CIImage *result = [filter valueForKey:kCIOutputImageKey]; </span><br><span class="line"></span><br><span class="line">CGImageRef cgImage = [context createCGImage:result fromRect:[inputImage extent]]; </span><br><span class="line"></span><br><span class="line">UIImage *returnImage = [UIImage imageWithCGImage:cgImage]; </span><br><span class="line">CGImageRelease(cgImage); </span><br><span class="line">return returnImage; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2，使用iOS8系统效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIImageView *imageView =[[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 200, 100)];</span><br><span class="line">imageView.image = [UIImage imageNamed:@&quot;logo&quot;];</span><br><span class="line">[self.view addSubview:imageView];</span><br><span class="line">/*</span><br><span class="line">UIBlurEffectStyleExtraLight,  //高亮</span><br><span class="line">UIBlurEffectStyleLight,       //亮</span><br><span class="line">UIBlurEffectStyleDark         //暗</span><br><span class="line">*/</span><br><span class="line">UIBlurEffect *blurEffect =[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark];</span><br><span class="line">UIVisualEffectView *effectView =[[UIVisualEffectView alloc]initWithEffect:blurEffect];</span><br><span class="line">effectView.frame = CGRectMake(0,0, imageView.frame.size.width, imageView.frame.size.height);</span><br><span class="line">[self.view addSubview:effectView];</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>模态视图的半透明背景问题</title>
    <url>/2016/08/03/%E6%A8%A1%E6%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>&emsp;&emsp;这两天做一个需求，弹出picker控件，本来很简单的需求，但开发过程中遇到一个坑：背景色怎么弄都没有半透明效果？查来查去才发现是presentViewController的坑</p>
<h3 id="模态视图相关"><a href="#模态视图相关" class="headerlink" title="模态视图相关"></a>模态视图相关</h3><ul>
<li><p>弹出和消失方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);</span><br><span class="line">// The completion handler, if provided, will be invoked after the dismissed controller&apos;s viewDidDisappear: callback is invoked.</span><br><span class="line">- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>弹出模态视图相关属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">Defines the transition style that will be used for this view controller when it is presented modally. Set</span><br><span class="line">this property on the view controller to be presented, not the presenter.  Defaults to</span><br><span class="line">UIModalTransitionStyleCoverVertical.</span><br><span class="line">*/</span><br><span class="line">// 弹出模态ViewController时的四种动画风格</span><br><span class="line">typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123;</span><br><span class="line">// 从底部滑入</span><br><span class="line">UIModalTransitionStyleCoverVertical = 0,</span><br><span class="line">// 水平翻转</span><br><span class="line">UIModalTransitionStyleFlipHorizontal __TVOS_PROHIBITED,</span><br><span class="line">// 交叉溶解</span><br><span class="line">UIModalTransitionStyleCrossDissolve,</span><br><span class="line">// 翻页效果</span><br><span class="line">UIModalTransitionStylePartialCurl NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</span><br><span class="line">&#125;;</span><br><span class="line">@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0);</span><br><span class="line"></span><br><span class="line">// 弹出模态ViewController时弹出风格</span><br><span class="line">typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123;</span><br><span class="line">// 由下到上,全屏覆盖</span><br><span class="line">UIModalPresentationFullScreen = 0,</span><br><span class="line">// 设备横屏，VC的显示方式则从横屏下方开始</span><br><span class="line">UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</span><br><span class="line">// VC显示都是从底部，宽度和屏幕宽度一样</span><br><span class="line">UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</span><br><span class="line">// VC的弹出方式和VC父VC的弹出方式相同</span><br><span class="line">UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),</span><br><span class="line">// 自定义视图展示风格,</span><br><span class="line">UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),</span><br><span class="line">// 如果视图没有被填满,底层视图可以透过</span><br><span class="line">UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),</span><br><span class="line">// 视图全部被透过</span><br><span class="line">UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),</span><br><span class="line">UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED,</span><br><span class="line">UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,</span><br><span class="line">&#125;;</span><br><span class="line">@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：弹出半透明的模态视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// presentViewController并且需要半透明时</span><br><span class="line">UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:VC];</span><br><span class="line">[VC setModalPresentationStyle:UIModalPresentationCustom];</span><br><span class="line">[nav setModalPresentationStyle:UIModalPresentationCustom];</span><br><span class="line">self.modalPresentationStyle = UIModalPresentationCustom;</span><br><span class="line">[self presentViewController:nav animated:NO completion:nil];</span><br><span class="line">// presentViewController必须手写，使用xib或story都会有不可预测bug</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>沙盒机制</title>
    <url>/2014/08/29/%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="沙盒机制是啥？"><a href="#沙盒机制是啥？" class="headerlink" title="沙盒机制是啥？"></a>沙盒机制是啥？</h3><ul>
<li>根据<a href="https://baike.baidu.com/item/沙盒原理/8039224?fr=aladdin" target="_blank" rel="noopener">百度百科：沙盒原理</a>来看，沙盒目的是安全，原理是隔离监控和回滚！但iOS系统上的沙盒机制却不是这样的，iOS系统上的沙盒机制：隔离和权限控制，应用只能访问自己的存储空间不可以访问其他程序存储空间，应用访问系统数据需请求权限，没权限不允许访问！iOS沙盒原理是验签，就是发布APP那一大堆签名证书的作用。</li>
</ul>
<h3 id="沙盒目录"><a href="#沙盒目录" class="headerlink" title="沙盒目录"></a>沙盒目录</h3><ul>
<li>Documents：保存重要数据，iTunes和icould会自动备份</li>
<li>Library 包含Caches和Preferences⼦目录</li>
<li>Caches：存放缓存文件，需手动清除，不会备份</li>
<li>Preferences 保存应用程序的所有偏好设置。NSUserDefaults存在这，不用管！</li>
<li>tmp：临时数据，可能被自动清除，不要放重要数据，不会备份</li>
<li>xxx.app：应用程序包，手动引入的资源都会打包到这里，不用管</li>
</ul>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">directory：搜索的路径名称,NSDocumentDirectory、NSCacheDirectory等.</span><br><span class="line">domainMask：限定了文件的检索范围只在沙箱内部.一般为NSUserDomainMask</span><br><span class="line">expandTilde：是否展开波浪线符号.展开后才是完整路径,一直为YES.</span><br><span class="line">reutrn：数组,在iphone中由于只有一个唯一路径(相对OC而言),所以直接取数组第一个元素即可.</span><br><span class="line">*/</span><br><span class="line">// NSArray&lt;NSString *&gt; *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);</span><br><span class="line"></span><br><span class="line">// 根目录路径</span><br><span class="line">NSString*homeDir = NSHomeDirectory();</span><br><span class="line">// Documents目录路径</span><br><span class="line">NSString*docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) firstObject];</span><br><span class="line">// Library的目录路径</span><br><span class="line">NSString*libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES) lastObject];</span><br><span class="line">// cache目录路径</span><br><span class="line">NSString*cachesDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES) firstObject];</span><br><span class="line">// tmp目录路径</span><br><span class="line">NSString*tmpDir =NSTemporaryDirectory();</span><br></pre></td></tr></table></figure>
<h3 id="Boundle"><a href="#Boundle" class="headerlink" title="Boundle"></a>Boundle</h3><ul>
<li>个人理解其实就是 xxx.app ，即你项目里打包进去的代码、图片、音视频等资源<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;HomeDirectory： %@&quot;,NSHomeDirectory());</span><br><span class="line">NSLog(@&quot;bundlePath： %@&quot;,[[NSBundle mainBundle] bundlePath]);</span><br><span class="line">// NSBoudle使用</span><br><span class="line">NSString *path= [[NSBundle mainBundle] pathForResource:@&quot;xxx&quot; ofType:@&quot;mp3&quot;];</span><br><span class="line">UIView *view = [[[NSBundle mainBundle] loadNibNamed:@&quot;ZKXxxView&quot; owner:nil options:nil] firstObject];</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>流量监控</title>
    <url>/2017/04/30/%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h3 id="why"><a href="#why" class="headerlink" title="why"></a>why</h3><p>&emsp;&emsp;流量监控？怎么也得整个网络优化才靠谱吧！其实一开始我的想法就是网络优化！但经过大家开会讨论过后，发现大家（领导）只认为两个数据有用：流量和网络错误率！</p>
<p>&emsp;&emsp;既然是开会讨论的结果，那自然有必要水一下为什么！会上大佬们认为移动网络很复杂，WIFI、4G、3G等，用户可能过个天桥网络都要切换好几次。在DNS 解析慢、失败率高（解决1：<a href="https://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&amp;mid=209805123&amp;idx=1&amp;sn=ced8d67c3e2cc3ca38ef722949fa21f8" target="_blank" rel="noopener">开源版HttpDNS方案详解</a>,也可直接用<a href="https://github.com/Tencent/mars/wiki" target="_blank" rel="noopener">Mars</a>）基础上讨论”时间“问题不靠谱！服务端什么样还不知道，单纯客户端统计”时间“意义不大！最主要APP内本身有数据缓存，用户进来看到的是缓存数据，请求慢一点没关系！网络安全问题大佬们倒是比较重视，但不在本次讨论范围之内…</p>
<p>&emsp;&emsp;而网络错误率这个实在是太简单了：request是现成，response是现成的，唯一要加的就一个总请求数！上报到接口就结束了，实在是没法水… 这次就水水流量监控吧！</p>
<h3 id="流量统计方案"><a href="#流量统计方案" class="headerlink" title="流量统计方案"></a>流量统计方案</h3><h4 id="1-App流量"><a href="#1-App流量" class="headerlink" title="1 App流量"></a>1 App流量</h4><p>&emsp;&emsp;毫无疑问NSURLProtocol（<a href="http://nshipster.cn/nsurlprotocol/" target="_blank" rel="noopener">关于NSURLProtocol</a>）是最简单的实现方案，Apple允许的合法的中间人！而且选用NSURLProtocol还有一个原因：我们现在另外一个正在筹备项目也要用NSURLProtocol，就当先踩坑了！</p>
<p>&emsp;&emsp;直接用<a href="https://github.com/aozhimin/iOS-Monitor-Platform/blob/master/iOS-Monitor-Platform_Network.md" target="_blank" rel="noopener">Wedjat Network</a>的代码吧，因为核心代码跟这个差不多！只是业务逻辑多了些，例如url分类、header处理等<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//为了避免 canInitWithRequest 和 canonicalRequestForRequest 出现死循环</span><br><span class="line">static NSString * const HJHTTPHandledIdentifier = @&quot;hujiang_http_handled&quot;;</span><br><span class="line"></span><br><span class="line">@interface HJURLProtocol () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSURLSessionDataTask *dataTask;</span><br><span class="line">@property (nonatomic, strong) NSOperationQueue     *sessionDelegateQueue;</span><br><span class="line">@property (nonatomic, strong) NSURLResponse        *response;</span><br><span class="line">@property (nonatomic, strong) NSMutableData        *data;</span><br><span class="line">@property (nonatomic, strong) NSDate               *startDate;</span><br><span class="line">@property (nonatomic, strong) HJHTTPModel          *httpModel;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</span><br><span class="line">if (![request.URL.scheme isEqualToString:@&quot;http&quot;] &amp;&amp;</span><br><span class="line">![request.URL.scheme isEqualToString:@&quot;https&quot;]) &#123;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ([NSURLProtocol propertyForKey:HJHTTPHandledIdentifier inRequest:request] ) &#123;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">NSMutableURLRequest *mutableReqeust = [request mutableCopy];</span><br><span class="line">[NSURLProtocol setProperty:@YES</span><br><span class="line">forKey:HJHTTPHandledIdentifier</span><br><span class="line">inRequest:mutableReqeust];</span><br><span class="line">return [mutableReqeust copy];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startLoading &#123;</span><br><span class="line">self.startDate                                        = [NSDate date];</span><br><span class="line">self.data                                             = [NSMutableData data];</span><br><span class="line">NSURLSessionConfiguration *configuration              = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">self.sessionDelegateQueue                             = [[NSOperationQueue alloc] init];</span><br><span class="line">self.sessionDelegateQueue.maxConcurrentOperationCount = 1;</span><br><span class="line">self.sessionDelegateQueue.name                        = @&quot;com.hujiang.wedjat.session.queue&quot;;</span><br><span class="line">NSURLSession *session                                 = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:self.sessionDelegateQueue];</span><br><span class="line">self.dataTask                                         = [session dataTaskWithRequest:self.request];</span><br><span class="line">[self.dataTask resume];</span><br><span class="line"></span><br><span class="line">httpModel                                             = [[NEHTTPModel alloc] init];</span><br><span class="line">httpModel.request                                     = self.request;</span><br><span class="line">httpModel.startDateString                             = [self stringWithDate:[NSDate date]];</span><br><span class="line"></span><br><span class="line">NSTimeInterval myID                                   = [[NSDate date] timeIntervalSince1970];</span><br><span class="line">double randomNum                                      = ((double)(arc4random() % 100))/10000;</span><br><span class="line">httpModel.myID                                        = myID+randomNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopLoading &#123;</span><br><span class="line">[self.dataTask cancel];</span><br><span class="line">self.dataTask           = nil;</span><br><span class="line">httpModel.response      = (NSHTTPURLResponse *)self.response;</span><br><span class="line">httpModel.endDateString = [self stringWithDate:[NSDate date]];</span><br><span class="line">NSString *mimeType      = self.response.MIMEType;</span><br><span class="line"></span><br><span class="line">// 解析 response，流量统计等</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSURLSessionTaskDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;</span><br><span class="line">if (!error) &#123;</span><br><span class="line">[self.client URLProtocolDidFinishLoading:self];</span><br><span class="line">&#125; else if ([error.domain isEqualToString:NSURLErrorDomain] &amp;&amp; error.code == NSURLErrorCancelled) &#123;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self.client URLProtocol:self didFailWithError:error];</span><br><span class="line">&#125;</span><br><span class="line">self.dataTask = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveData:(NSData *)data &#123;</span><br><span class="line">[self.client URLProtocol:self didLoadData:data];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123;</span><br><span class="line">[[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];</span><br><span class="line">completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">self.response = response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler &#123;</span><br><span class="line">if (response != nil)&#123;</span><br><span class="line">self.response = response;</span><br><span class="line">[[self client] URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;另外我们现在已经有部分页面转向WKWebview，而没有公开API可以注册NSURLProtocol，不过倒有私有API可用，参考 <a href="https://www.jianshu.com/p/8f5e1082f5e0" target="_blank" rel="noopener">NSURLProtocol对WKWebView的处理</a>。还有WKWebview不支持post拦截但这个真无解</p>
<h4 id="2-设备流量"><a href="#2-设备流量" class="headerlink" title="2 设备流量"></a>2 设备流量</h4><p>&emsp;&emsp;获得整个<a href="https://stackoverflow.com/questions/7946699/iphone-data-usage-tracking-monitoring?answertab=votes#tab-top" target="_blank" rel="noopener">设备的流量</a>也有一定的参考意义！因为现在流量其实不太值钱，如果监控到用户流量非常大，那是不是可以更高频刷新页面？更高质量的图片？更高分辨率的视频（我们接了一个三方库，用于视频认证）?<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 上行、下行流量</span><br><span class="line">- (NSArray *)getDataCounters</span><br><span class="line">&#123;</span><br><span class="line">BOOL success;</span><br><span class="line">struct ifaddrs *addrs;</span><br><span class="line">struct ifaddrs *cursor;</span><br><span class="line">struct if_data *networkStatisc;</span><br><span class="line">long WiFiSent = 0;</span><br><span class="line">long WiFiReceived = 0;</span><br><span class="line">long WWANSent = 0;</span><br><span class="line">long WWANReceived = 0;</span><br><span class="line">NSString *name=[[NSString alloc]init];</span><br><span class="line">success = getifaddrs(&amp;addrs) == 0;</span><br><span class="line">if (success)</span><br><span class="line">&#123;</span><br><span class="line">cursor = addrs;</span><br><span class="line">while (cursor != NULL)</span><br><span class="line">&#123;</span><br><span class="line">name=[NSString stringWithFormat:@&quot;%s&quot;,cursor-&gt;ifa_name];</span><br><span class="line">if (cursor-&gt;ifa_addr-&gt;sa_family == AF_LINK)</span><br><span class="line">&#123;</span><br><span class="line">if ([name hasPrefix:@&quot;en&quot;])</span><br><span class="line">&#123;</span><br><span class="line">networkStatisc = (struct if_data *) cursor-&gt;ifa_data;</span><br><span class="line">WiFiSent+=networkStatisc-&gt;ifi_obytes;</span><br><span class="line">WiFiReceived+=networkStatisc-&gt;ifi_ibytes;</span><br><span class="line">&#125;</span><br><span class="line">if ([name hasPrefix:@&quot;pdp_ip&quot;])</span><br><span class="line">&#123;</span><br><span class="line">networkStatisc = (struct if_data *) cursor-&gt;ifa_data;</span><br><span class="line">WWANSent+=networkStatisc-&gt;ifi_obytes;</span><br><span class="line">WWANReceived+=networkStatisc-&gt;ifi_ibytes;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cursor = cursor-&gt;ifa_next;</span><br><span class="line">&#125;</span><br><span class="line">freeifaddrs(addrs);</span><br><span class="line">&#125;</span><br><span class="line">return [NSArray arrayWithObjects:[NSNumber numberWithInt:WiFiSent/1024], [NSNumber numberWithInt:WiFiReceived/1024],[NSNumber numberWithInt:WWANSent/1024],[NSNumber numberWithInt:WWANReceived/1024], nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-其它方案"><a href="#3-其它方案" class="headerlink" title="3 其它方案"></a>3 其它方案</h4><ul>
<li>Hook NSURLConnection 和 NSURLSession进行统计！</li>
<li>iOS9可用VPN方式 <a href="https://developer.apple.com/documentation/networkextension?language=objc" target="_blank" rel="noopener">https://developer.apple.com/documentation/networkextension?language=objc</a></li>
<li>iOS10的NSURLSessionTaskMetrics</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/aozhimin/iOS-Monitor-Platform/blob/master/iOS-Monitor-Platform_Network.md" target="_blank" rel="noopener">https://github.com/aozhimin/iOS-Monitor-Platform/blob/master/iOS-Monitor-Platform_Network.md</a></li>
<li><a href="http://blog.cnbang.net/tech/3531/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">移动 APP 网络优化概述</a></li>
<li><a href="https://www.jianshu.com/p/8f5e1082f5e0" target="_blank" rel="noopener">NSURLProtocol对WKWebView的处理</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>消息传递1：方式</title>
    <url>/2016/05/20/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%921%EF%BC%9A%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;前几天做CR时发现，一个同事特别喜欢Block，甚至在Base里添加了几个方法，把tableview的常用代理方法都用block实现了一遍，我对此提出了异议！但其他同事觉得没什么，个人喜好而已！你不喜欢可以不用呀！额……好吧，我不喜欢，我可以不用……。那么咱们就讨论一下iOS里一共有几种消息传递方式？各自的优缺点以及使用场景？</p>
<h3 id="1-常见方式以及介绍"><a href="#1-常见方式以及介绍" class="headerlink" title="1 常见方式以及介绍"></a>1 常见方式以及介绍</h3><h4 id="1-1-KVO"><a href="#1-1-KVO" class="headerlink" title="1.1 KVO"></a>1.1 KVO</h4><ul>
<li>含义：属性观察器，当对象中的某个属性值发生了改变，可以对这些值的观察者做出通知。</li>
<li>优点：</li>
<li>简单的方法实现映射关系，很方便的实现“联动”效果</li>
<li>能够对非“我族类“进行观察观测，方便进行调试或及时响应</li>
<li>能够观察嵌套的属性，方便窥探私有属性。例如CAAnimation可用@”transform.scale”的方式进行缩放</li>
<li>耦合低，因被观察属性根本就不知道已经被偷窥了</li>
<li>缺点：</li>
<li>keyPath必须是NSString，很容易写错且XCode不会检查</li>
<li>观察多个属性时，if处理逻辑非常复杂，容易出错</li>
<li>依赖被观察属性，一旦改名就没用了</li>
<li>不能重复addObserver, dealloc时必须removeObserver</li>
<li>没有返回值，当然也不需要</li>
<li>注意事项：不能重复addObserver, dealloc时必须removeObserver</li>
</ul>
<h4 id="1-2-Notification"><a href="#1-2-Notification" class="headerlink" title="1.2 Notification"></a>1.2 Notification</h4><ul>
<li>含义：通知（广播），典型的”管杀不管埋“</li>
<li>优点：</li>
<li>解耦，最解耦的消息传递方式</li>
<li>简单，一个[NSNotificationCenter defaultCenter]走天下</li>
<li>一对多</li>
<li>参数传递比较简单，默认提供一个id类型的object，也可以用过aUserInfo字典传递</li>
<li>缺点：</li>
<li>没有编译检查,虽然可以通过NSString <em> const name = @”name”;extern NSString </em> const name; 的方式减少失误 </li>
<li>同一个线程调用，常见问题是异步线程postNotification，主线程接收造成UI绘制出问题</li>
<li>同步调用，注意NSNotificaiton是同步调用</li>
<li>无论通过id类型的object还是通过userInfo字典传递参数都必须做”苛刻“的参数校验，否则很容易出现类型转换问题</li>
<li>没有返回值，通知（广播）甚至都不关心是否有”人“响应</li>
<li>dealloc必须移除observer</li>
<li>注意事项：同一线程同步调用，dealloc必须移除observer<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notTest) name:@&quot;notTest&quot; object:nil];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">NSLog(@&quot;------ 1&quot;);</span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notTest&quot; object:nil];</span><br><span class="line">NSLog(@&quot;------ 3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)notTest &#123;</span><br><span class="line">NSLog(@&quot;------ 2&quot;);</span><br><span class="line">NSLog(@&quot;current queue:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-协议delegate（代理）"><a href="#1-3-协议delegate（代理）" class="headerlink" title="1.3 协议delegate（代理）"></a>1.3 协议delegate（代理）</h4><ul>
<li>已经是设计模式了</li>
<li>优点：</li>
<li>强制性编译器检查，默认都是@required，除非特殊标明@optional</li>
<li>代码可读性好，一般都按照UITableViewDataSource的格式写，而且一般都会将sender作为第一个参数传回去</li>
<li>参数以及返回值类型明确，是的可以有返回值</li>
<li>没有循环引用，因为一般delegate都设置为weak属性</li>
<li>调试比较方便，因为”数据“流向很清晰</li>
<li>耦合度比较低</li>
<li>缺点：</li>
<li>书写复杂，比较考验命名以及方法的拆分能力</li>
<li>发送对象和回调方法在代码上是”分开“的，不能一眼就看出来逻辑关系</li>
<li>delegate一般用weak修饰，避免野指针问题</li>
<li>@optional方法需要判断delegate是否实现</li>
<li>注意事项：@optional方法需要判断delegate是否实现，delegate一般用weak修饰</li>
</ul>
<h4 id="1-4-Block"><a href="#1-4-Block" class="headerlink" title="1.4 Block"></a>1.4 Block</h4><ul>
<li>代码块</li>
<li>优点</li>
<li>简单，不需要提前声明，不需要addObserver</li>
<li>类型安全，block声明时已经指定了参数和返回值类型，对可以有返回值</li>
<li>可读性强，更有连贯性</li>
<li>减少命名恐惧症，因为可以不命名</li>
<li>与GCD配合解决多线程问题</li>
<li>缺点</li>
<li>小心循环引用问题</li>
<li>多层bloc嵌套时，逻辑比较乱</li>
<li>小心block的捕获外部变量行为</li>
<li>作为属性时需要用copy修饰</li>
<li>耦合度高</li>
<li>需要判断block是否为nil</li>
<li>注意事项：循环引用问题</li>
</ul>
<h4 id="1-5-Target-Action"><a href="#1-5-Target-Action" class="headerlink" title="1.5 Target-Action"></a>1.5 Target-Action</h4><ul>
<li>Target-Action主要被用于响应用户界面事件时所需要传递的消息中。</li>
<li>iOS中的UIControl和Mac中的NSControl/NSCell都支持这种机制。Target-Action在消息的发送者和接收者之间建立了一个非常松散耦合。消息的接收者不知道发送者，甚至消息的发送者不需要预先知道消息的接收者。如果target是nil，action会在响应链(responder chain)中被传递，知道找到某个能够响应该aciton的对象。在iOS中，每个控件都能关联多个target-action。</li>
<li>基于target-action消息传递的机制有一个局限就是发送的消息不能携带自定义的payload。在Mac的action方法中，接收者总是被放在第一个参数中。而在iOS中，可以选择性的将发送者和和触发action的事件作为参数。除此之外，没有别的办法可以对发送action消息内容做控制。</li>
</ul>
<h3 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2 使用方式"></a>2 使用方式</h3><h4 id="2-1-其它博客推荐方式"><a href="#2-1-其它博客推荐方式" class="headerlink" title="2.1 其它博客推荐方式"></a>2.1 其它博客推荐方式</h4><ul>
<li>以下图片是破船翻译的Communication Patterns，已经给出了详细的设计方向，可精读。参考：<a href="http://www.cocoachina.com/articles/7543" target="_blank" rel="noopener">http://www.cocoachina.com/articles/7543</a><br><img src="http://cdn.cocimg.com/cms/uploads/allimg/131216/4196_131216091606_1.png" alt="image"></li>
</ul>
<h4 id="2-2-个人总结"><a href="#2-2-个人总结" class="headerlink" title="2.2 个人总结"></a>2.2 个人总结</h4><ul>
<li>KVO：属性观察器、反射</li>
<li>Notification：跨层级通信、一对多通信</li>
<li>协议delegate：通信事件比较多、强制用户实现</li>
<li>Block：一次性使用、简单的传值操作</li>
<li>Target-Action：UI控件、自定义控件专用</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>&emsp;&emsp;综上所述，我认为在Base里把tableview的常用代理方法都用block实现了一遍是得不偿失的，撇开Base更加臃肿和可能存在的循环引用不谈！用block代替tableview的delegate方法并不能保证调用者一会实现你的block，增加了调用者使用难度</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://www.cocoachina.com/articles/7543" target="_blank" rel="noopener">http://www.cocoachina.com/articles/7543</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>消息传递2：机制</title>
    <url>/2016/05/22/%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%922%EF%BC%9A%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>&emsp;&emsp;刚学OC时水过一次为啥叫消息发送，具体就不贴了！看了看实在是水的不行！前些天专门写了点消息发送的方式以及注意事项！今天就水一水，消息发送的机制是什么</p>
<h3 id="1-动态绑定VS静态绑定"><a href="#1-动态绑定VS静态绑定" class="headerlink" title="1 动态绑定VS静态绑定"></a>1 动态绑定VS静态绑定</h3><h4 id="1-1-静态绑定"><a href="#1-1-静态绑定" class="headerlink" title="1.1 静态绑定"></a>1.1 静态绑定</h4><p>-就是编译时已经写死了调用函数，硬编码的，不会变<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***********  例1 静态绑定   ***********/</span><br><span class="line">#import &lt;stdio.h&gt;</span><br><span class="line">void printHello() &#123;</span><br><span class="line">printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printGoodbye() &#123;</span><br><span class="line">printf(&quot;Goodbye, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void saySomething(int type) &#123;</span><br><span class="line">/*</span><br><span class="line">重点不是if，而是写死的printHello();和printGoodbye();</span><br><span class="line">这两个函数在编译时已经硬编码进了程序，是不会改变的</span><br><span class="line">*/ </span><br><span class="line">if (type == 0) &#123;</span><br><span class="line">printHello();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printGoodbye();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-动态绑定"><a href="#1-2-动态绑定" class="headerlink" title="1.2 动态绑定"></a>1.2 动态绑定</h4><ul>
<li>是运行时再绑定实际的调用函数，OC就是通过消息传递的方式来动态绑定的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/***********  例2 动态绑定   ***********/</span><br><span class="line">#import &lt;stdio.h&gt;</span><br><span class="line">void printHello() &#123;</span><br><span class="line">printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printGoodbye() &#123;</span><br><span class="line">printf(&quot;Goodbye, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void saySomething(int type)  &#123;</span><br><span class="line">/*</span><br><span class="line">通过函数指针的方式调用printHello();和printGoodbye();函数将具体调用哪个函数推迟到了运行时再确定，我们可修改函数指针指向一个printLog();函数来实现动态效果，而不需要修改硬编码</span><br><span class="line">*/ </span><br><span class="line">void (*func)();</span><br><span class="line">if (type == 0) &#123;</span><br><span class="line">func = printHello;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">func = printGoodbye;</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-PS-函数指针和指针函数"><a href="#1-3-PS-函数指针和指针函数" class="headerlink" title="1.3 PS:函数指针和指针函数"></a>1.3 PS:函数指针和指针函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 函数指针：函数的指针</span><br><span class="line">int (*fun)(int x,int y);</span><br><span class="line">// 指针函数：指针两字在前面，所以返回值是指针</span><br><span class="line">int * fun(int x,int y)；</span><br></pre></td></tr></table></figure>
<h3 id="2-objc-msgSend"><a href="#2-objc-msgSend" class="headerlink" title="2 objc_msgSend"></a>2 objc_msgSend</h3><h4 id="2-1-向某个OC对象发送消息"><a href="#2-1-向某个OC对象发送消息" class="headerlink" title="2.1 向某个OC对象发送消息"></a>2.1 向某个OC对象发送消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// OC写法</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br><span class="line">// 编译器转化为C语言调用</span><br><span class="line">id returnValue = objc_msgSend(someObject,</span><br><span class="line">@selector(messageName:),</span><br><span class="line">parameter);</span><br></pre></td></tr></table></figure>
<h4 id="2-2-objc-msgSend原型，"><a href="#2-2-objc-msgSend原型，" class="headerlink" title="2.2 objc_msgSend原型，"></a>2.2 objc_msgSend原型，</h4><ul>
<li>参考: <a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm.s.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm.s.auto.html</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// self表示调用函数的实例对象</span><br><span class="line">// SEL表示调用的函数指针</span><br><span class="line">// ...表示对应的参数，支持多参数</span><br><span class="line">id objc_msgSend(id self, SEL _cmd, ...);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-消息传递流程"><a href="#3-消息传递流程" class="headerlink" title="3 消息传递流程"></a>3 消息传递流程</h3><h4 id="3-1-一般流程"><a href="#3-1-一般流程" class="headerlink" title="3.1 一般流程"></a>3.1 一般流程</h4><p>&emsp;&emsp;由于动态绑定需在运行时确定具体函数地址，也就存在一个查找内存地址的过程：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 从方法缓存里找！为啥要缓存？当时是为了加快检索速度，毕竟常用方法就那么几个，每次都遍历一遍所有方法很耗时耗性能的</span><br><span class="line">2. 从类的所有方法形成的列表里找！找到则写入缓存，方便下次查找</span><br><span class="line">3. 沿着继承链从父类类中查找</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;正常流程下，如果遍历了所有父类依然没有找到对应的方法就会Crash，并给出unrecognized selector sent to instance的Crash信息，但OC贴心的为我们提供了补救措施</p>
<h4 id="3-2-补救措施"><a href="#3-2-补救措施" class="headerlink" title="3.2 补救措施"></a>3.2 补救措施</h4><ul>
<li><ol>
<li>动态方法解析，OC提供了两个方法用于处理找不到方法的情况<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用于解决类方法找不到的情况</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line">// 用于解决实例方法找不到的情况</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">[self performSelector:@selector(unrecognizedSelector)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line"></span><br><span class="line">NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">if ([selectorString isEqualToString:@&quot;unrecognizedSelector&quot;]) &#123;</span><br><span class="line">// 将sel的函数指针指向recognizedOtherSelector的地址</span><br><span class="line">class_addMethod(self,sel,(IMP)recognizedOtherSelector,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recognizedOtherSelector() &#123;</span><br><span class="line">NSLog(@&quot;----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="2">
<li>没有实现动态方法解析，则查看有没有备用接受者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 其实就是找个能响应aSelector方法的替死鬼</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">NSString *selectorString = NSStringFromSelector(aSelector);</span><br><span class="line">if ([selectorString isEqualToString:@&quot;unrecognizedSelector&quot;]) &#123;</span><br><span class="line">return @&quot;能够响应unrecognizedSelector的对象&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>消息转发<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">必须要覆盖两个方法在methodSignatureForSelector和forwardInvocation</span><br><span class="line"></span><br><span class="line">// 创建一个有效的签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">if (!signature) &#123;</span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">&#125;</span><br><span class="line">return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 转发给某个方法</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line"></span><br><span class="line">[anInvocation setSelector:@selector(forwardTo:)];</span><br><span class="line">NSString *arg1;</span><br><span class="line">[anInvocation getArgument:&amp;arg1 atIndex:2];</span><br><span class="line">[anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardTo:(NSString *)arg1 &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,arg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>&emsp;&emsp;调用一个<code></code>objc_msgSend(id theReceiver, SEL selectot,……)`方法系统执行的步骤为:</p>
<ol>
<li><p>判断receiver是否为nil，如果是nil的话则不往下执行，返回nil，这就是为什么在oc中一个nil发送消息不会引起奔溃。</p>
</li>
<li><p>从方法的缓存中查找被调用过的方法会存在缓存里面，每个类都会有一个表来存被调用过的方法，以便下次更快的调用。</p>
</li>
<li><p>从本类的方法表中查找方法寻找selector，找到则写入缓存，返回方法。否则再从父类中查找方法，如此往复，直到达到基类。如果找不到则执行方法的动态解析。</p>
</li>
<li><p>方法的动态解析： 调用+(BOOL)resolveInstanceMethod:(SEL)sel方法来查看是否能够返回一个selector，如果存在则返回selector。不存在进入下一步。</p>
</li>
<li><p>备用接受者 - (id)forwardingTargetForSelector:(SEL)aSelector这个方法来询问是否有接受者可以接受这个方法呀。如果有人接受，则交给它处理，就好像一切都没发生过一样。</p>
</li>
<li><p>方法的转发： 如果到这一步还不能够找到相应的Selector的话，就要进行完整的方法转发过程。调用方法(void)forwardInvocation:(NSInvocation *)anInvocation</p>
</li>
<li><p>最后还是没有找到的话就只有呵呵了，这时候unrecognized selector sent to instance 0x100111df0’的错误就来了。</p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.jianshu.com/p/64ed325c1f19" target="_blank" rel="noopener">https://www.jianshu.com/p/64ed325c1f19</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/64270" target="_blank" rel="noopener">https://www.zybuluo.com/MicroCai/note/64270</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>消除项目警告</title>
    <url>/2017/07/22/%E6%B6%88%E9%99%A4%E9%A1%B9%E7%9B%AE%E8%AD%A6%E5%91%8A/</url>
    <content><![CDATA[<h3 id="1-修复方法"><a href="#1-修复方法" class="headerlink" title="1 修复方法"></a>1 修复方法</h3><h4 id="1-1-Unused-Entity-Issues"><a href="#1-1-Unused-Entity-Issues" class="headerlink" title="1.1 Unused Entity Issues"></a>1.1 Unused Entity Issues</h4><ul>
<li>定了了但没使用的变量，解决方案：判断上下文，如果真没用到就注掉，最好别删掉</li>
</ul>
<h4 id="1-2-User-Defined-Issue"><a href="#1-2-User-Defined-Issue" class="headerlink" title="1.2 User-Defined Issue"></a>1.2 User-Defined Issue</h4><ul>
<li>自定义警告，看看是不是TODO？是不是可以用NSAssert代替？</li>
</ul>
<h4 id="1-3-Lexical-or-Preprocessor-Issue"><a href="#1-3-Lexical-or-Preprocessor-Issue" class="headerlink" title="1.3 Lexical or Preprocessor Issue"></a>1.3 Lexical or Preprocessor Issue</h4><ul>
<li>以前xcode传入weak对象会有警告，RAC就在里面做了屏蔽，现在xcode已经没有警告了！</li>
</ul>
<h4 id="1-4-Format-String-Issue"><a href="#1-4-Format-String-Issue" class="headerlink" title="1.4 Format String Issue"></a>1.4 Format String Issue</h4><ul>
<li>格式化字符串的警告！处理办法，点击警告，使用xcod推荐的格式</li>
</ul>
<h4 id="1-5-Apple-Mach-O-Linker-Id-Warning"><a href="#1-5-Apple-Mach-O-Linker-Id-Warning" class="headerlink" title="1.5 Apple Mach-O Linker (Id) Warning"></a>1.5 Apple Mach-O Linker (Id) Warning</h4><ul>
<li>文件夹路径或Framework路径报错</li>
<li>1，Click on your project (targets)；2， Click on Build Settings</li>
<li>if your error includes the -L flag, then delete the values in Library Search Paths</li>
<li>if your error includes the -F flag, then delete the values in Framework Search Paths</li>
<li>参考：<br><a href="https://stackoverflow.com/questions/9458739/ld-warning-directory-not-found-for-option?noredirect=1&amp;lq=1" target="_blank" rel="noopener">https://stackoverflow.com/questions/9458739/ld-warning-directory-not-found-for-option?noredirect=1&amp;lq=1</a></li>
</ul>
<h4 id="1-6-Deprecations"><a href="#1-6-Deprecations" class="headerlink" title="1.6 Deprecations"></a>1.6 Deprecations</h4><ul>
<li>已经废弃的方法</li>
<li>处理办法：使用推荐方法替换</li>
</ul>
<h4 id="1-7-semantic-issue"><a href="#1-7-semantic-issue" class="headerlink" title="1.7 semantic issue"></a>1.7 semantic issue</h4><ul>
<li>语法问题</li>
<li>根据警告添加、修改或注释相关方法</li>
</ul>
<h4 id="1-8-Unsupported-Configuration"><a href="#1-8-Unsupported-Configuration" class="headerlink" title="1.8 Unsupported Configuration"></a>1.8 Unsupported Configuration</h4><ul>
<li><a href="https://stackoverflow.com/questions/26547399/xcode-storyboard-warning-constraint-referencing-items-turned-off-in-current-con" target="_blank" rel="noopener">https://stackoverflow.com/questions/26547399/xcode-storyboard-warning-constraint-referencing-items-turned-off-in-current-con</a></li>
<li><a href="https://blog.csdn.net/phantom2000x/article/details/56008709" target="_blank" rel="noopener">https://blog.csdn.net/phantom2000x/article/details/56008709</a></li>
<li><a href="https://stackoverflow.com/questions/13531035/xcode-scene-is-unreachable-due-to-lack-of-entry-points-but-cant-find-it" target="_blank" rel="noopener">https://stackoverflow.com/questions/13531035/xcode-scene-is-unreachable-due-to-lack-of-entry-points-but-cant-find-it</a></li>
</ul>
<h4 id="1-9-SB的push方法"><a href="#1-9-SB的push方法" class="headerlink" title="1.9 SB的push方法"></a>1.9 SB的push方法</h4><ul>
<li><a href="https://stackoverflow.com/questions/26417175/xcode-6-push-segues-are-deprecated-in-ios-8-0-and-later" target="_blank" rel="noopener">https://stackoverflow.com/questions/26417175/xcode-6-push-segues-are-deprecated-in-ios-8-0-and-later</a></li>
</ul>
<h4 id="1-10-Validate-Project-Settings"><a href="#1-10-Validate-Project-Settings" class="headerlink" title="1.10 Validate Project Settings"></a>1.10 Validate Project Settings</h4><ul>
<li>配置文件更新到ios8</li>
<li><a href="https://blog.csdn.net/isharestudio/article/details/20462737" target="_blank" rel="noopener">https://blog.csdn.net/isharestudio/article/details/20462737</a></li>
<li><a href="https://stackoverflow.com/questions/9612226/any-way-to-make-validate-project-settings-warning-go-away-in-xcode-4-3-4-3-1" target="_blank" rel="noopener">https://stackoverflow.com/questions/9612226/any-way-to-make-validate-project-settings-warning-go-away-in-xcode-4-3-4-3-1</a></li>
</ul>
<h3 id="2-屏蔽方法"><a href="#2-屏蔽方法" class="headerlink" title="2 屏蔽方法"></a>2 屏蔽方法</h3><h4 id="2-1-屏蔽某个警告"><a href="#2-1-屏蔽某个警告" class="headerlink" title="2.1 屏蔽某个警告"></a>2.1 屏蔽某个警告</h4><ul>
<li><p>相关命令获取方式：<br>run -&gt; 找到对应警告 -&gt; 右击 -&gt; reveal in log -&gt; 找到一些带框的标识 [-Wunused-variable]   [-Wenum-conversion]    [-Wbool-conversion]，[]之中的就是关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang diagnostic 是#pragma 第一个常用命令：</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;关键字&quot;</span><br><span class="line">// 你自己的代码</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
</li>
<li><p>参考：<a href="https://blog.csdn.net/zww1984774346/article/details/53409033" target="_blank" rel="noopener">https://blog.csdn.net/zww1984774346/article/details/53409033</a></p>
</li>
</ul>
<h4 id="2-2-屏蔽某个文件的所有警告（慎用）"><a href="#2-2-屏蔽某个文件的所有警告（慎用）" class="headerlink" title="2.2 屏蔽某个文件的所有警告（慎用）"></a>2.2 屏蔽某个文件的所有警告（慎用）</h4><ul>
<li>target -&gt; Build Phases -&gt; 搜到你要的文件 -&gt; compiler Flages -&gt; -w</li>
</ul>
<h4 id="2-3-屏蔽cocoapod的警告"><a href="#2-3-屏蔽cocoapod的警告" class="headerlink" title="2.3 屏蔽cocoapod的警告"></a>2.3 屏蔽cocoapod的警告</h4><ul>
<li>在Profile文件中添加如下代码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1. 先用 inhibit_all_warnings!标志位</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">// 2. 涉及雄兼容可用如下方法</span><br><span class="line">post_install do |installer|</span><br><span class="line">installer.pods_project.targets.each do |target|</span><br><span class="line">target.build_configurations.each do |config|</span><br><span class="line">if config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;].to_f &lt; 8.0</span><br><span class="line">config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;] = &apos;8.0&apos;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-把所有警告当做错误"><a href="#3-把所有警告当做错误" class="headerlink" title="3 把所有警告当做错误"></a>3 把所有警告当做错误</h3><ul>
<li>Build Setting -&gt; 搜treat -&gt; 把Treat Warning as Error的值为YES</li>
</ul>
<h3 id="4-监控？"><a href="#4-监控？" class="headerlink" title="4 监控？"></a>4 监控？</h3><p>&emsp;&emsp;说实话，我想来想去也没想到除了Treat Warning as Error有什么好的监控方案</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>清理XCode</title>
    <url>/2015/02/09/%E6%B8%85%E7%90%86XCode/</url>
    <content><![CDATA[<p>转载自<a href="http://www.cocoachina.com/bbs/read.php?tid=181211" target="_blank" rel="noopener">http://www.cocoachina.com/bbs/read.php?tid=181211</a></p>
<p>硬盘空间吃紧，清了两三次xcode，无奈没过多长时间又没空间了！最主要的是，查了两三次的清理路径，还是记不住！在此，摘抄下来，以便日后查阅</p>
<ol>
<li>移除对旧设备的支持</li>
</ol>
<ul>
<li>影响：可重新生成；再连接旧设备调试时，会重新自动生成。我移除了4.3.2, 5.0, 5.1等版本的设备支持。</li>
<li>路径：~/Library/Developer/Xcode/iOS DeviceSupport</li>
</ul>
<ol start="2">
<li>移除旧版本的模拟器支持</li>
</ol>
<ul>
<li>影响：不可恢复；如果需要旧版本的模拟器，就需要重新下载了。我移除了4.3.2, 5.0, 5.1等旧版本的模拟器。</li>
<li>路径：~/Library/Application Support/iPhone Simulator</li>
</ul>
<ol start="3">
<li>移除模拟器的临时文件</li>
</ol>
<ul>
<li>影响：可重新生成；如果需要保留较新版本的模拟器，但tmp文件夹很大。放心删吧，tmp文件夹里的内容是不重要的。在iOS Device中，存储空间不足时，tmp文件夹是可能被清空的。</li>
<li>路径：~/Library/Application Support/iPhone Simulator/6.1/tmp (以iOS Simulator 6.1为例)</li>
</ul>
<ol start="4">
<li>移除DerivedData</li>
</ol>
<ul>
<li>影响：可重新生成；会删除build生成的项目索引、build输出以及日志。重新打开项目时会重新生成，大的项目会耗费一些时间。</li>
<li>路径：~/Library/Developer/Xcode/DerivedData</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>生命之书365天的静心冥想</title>
    <url>/2018/02/17/%E7%94%9F%E5%91%BD%E4%B9%8B%E4%B9%A6365%E5%A4%A9%E7%9A%84%E9%9D%99%E5%BF%83%E5%86%A5%E6%83%B3/</url>
    <content><![CDATA[<ul>
<li>其实就是无欲则刚，学会淡定与从容！想要获得内心平静，就要正视自己所有的一切，既不否认、不肯定更不解释。</li>
<li>聆听需要心无杂念，不要以己度人，更不要武断猜疑！只是静心去听，听完之后自然会有相应的结论！</li>
<li>静心，需静坐！</li>
<li>己所不欲勿施于人，己所欲亦勿施于人</li>
<li>倾听需要放松自己，而不是压抑自己！不能做这个，必须做那个，当这个心态时，也许并不是倾听的好时机！</li>
<li>寻找自己，了解自己，接纳自己，顺势而为，点滴改变自己！切勿好高骛远，更勿自我放弃！</li>
<li>乐趣？现实就是有可为有不可为，坦然处之，摒弃杂念，学会接受，但不盲从，发现乐趣！我命由我不由天，就是如此吧</li>
<li>不要让过去的知识经验成为前进的阻碍，每日三省吾身，原来是这个意思</li>
<li>心若能完整的觉知，保持警醒和警觉。手段是工具</li>
<li>只有当心完全的寂静时，才有可能超越所有的经验！不要为了创造而创造，目标存在的意义是激励人不断地一步一步前行，而不是我达不到目标我就去死！</li>
<li>自我不是别人或自己打的一堆标签的集合。标签本身就是外在的，与自我无关！</li>
<li>只有当我们想逃避事实躲进幻想里的时候，才需要信仰！</li>
<li>面对现实和困难，人本能的会选择逃避，寻求依赖！无助和孤独是人生的必修课！</li>
<li>君子慎独，身体或心灵总的有一个在路上！强大的内心从点滴锻炼起来的！</li>
<li>对待欲望，既不否认也不抗拒，而是学会接受与忍受</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>番茄工作法图解</title>
    <url>/2017/01/12/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="一次只做一件事"><a href="#一次只做一件事" class="headerlink" title="一次只做一件事"></a>一次只做一件事</h3><ul>
<li>25分钟专注于任务，如果响铃却没完成任务，并不代表失败，相反这是对已经连续专注25分钟的喝彩</li>
<li>把事拆分或组合，通过仪式感告知自己要专注，番茄工作法一天结束前要做三件事：记录，处理和优化</li>
</ul>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>通过执行一套相同的动作和准备程序，可以使大脑自我调整，进入执行某类事务的最佳状态</li>
<li>通过训练大脑，可以一扭番茄钟马上集中注意力，听到声响就放松</li>
<li>注意力不集中时，要么运动，要么休息</li>
<li>环境或任务的频繁切换回降低生产力</li>
<li>回忆曲线证明时间越长记得越差</li>
<li>25分钟专注+5分钟休息和联想回忆能提高生产力，促进消化吸收</li>
<li>对未知不可预测的事情会导致焦虑，降低生产力，如果将其视为一连串的事件各个击破，生产力将会提高</li>
<li>短暂的定期的休息，能够促进融会贯通的能力</li>
<li>重复的手势和惯例将帮助大脑适应线程情况</li>
<li>极其专注的心流状态是很好的，5分钟休息有助于从战略角度做出调整</li>
<li>5分钟休息有助于保持情绪和精力，持续生产，降低长时间的枯燥和厌烦</li>
<li>细分的番茄钟有助于理清起点终点，有助于缓解拖延症</li>
<li>专注工作中应当只对相关指标做持续记录，定期的会议和回顾才是专门用来分析调整的场合，在分析过往数据的同时展望未来，改善自己</li>
<li>拥抱变化，频繁的提供和接受反馈，严格控制我们必须完成的内容，并经常性的重新评估，从长期和短期角度问自己“完成什么才是最重要的”</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>番茄工作者的一天具有以下5个阶段：A、计划：在一天开始的时候，从活动清单中提取最重要的活动，填写到今日待办表格，这就是自己对自己当天的承诺；B、跟踪：在每个番茄钟的时间段内，要收集一些过程指标，中断次数，注意力不集中…；C、在一天结束的时候，将当天收集的数据归档，写入记录表格；D、处理：从所记录的原始数据中提取有用的信息；E、可视化：最终你要将信息以某种方式组织起来，从中找出改进流程的思路</li>
<li>准备三张纸：A、“今日待办”表格：填写今天的日期、名字、列出打算今天进行的互动（要设置计划外紧急的栏目）。每天早上都要更新今日待办；B、“活动清单”表格：填写名字，列出最近要进行的活动，随想随填，不用排序。同一张“活动清单”表格可以用很多天，增加新的活动，划掉已完成的；C、“记录”表格：记录所采集样的流程指标，以便对流程进行改进。同一张“记录”表格可以用很多天，以便比较每天的跟踪记录</li>
<li>活动清单：随想随填，不要排序，不分轻重，不用写具体做法，只要写上要达成目标和deadLine就好。反正是给自己看，没什么不能写、不敢写的，能看懂知道是啥就行了。</li>
<li>感觉千头万绪的时候，把最重要的事放在第一位，开启番茄钟，全力以赴现在就做。在心目中将“必须的做完”变成“从哪里开始”，将“这个项目很大很重要”变成“我可以走出一小步”</li>
<li>要么做，要么不做！现在做的话，要么只有一件事可做，要么没事可做！学会选择，学会专注，当决定要做什么的时候，要有全局眼光，避免陷入琐事当中</li>
<li>使用番茄工作法，为刚才25分钟的工作打个好评，能让我们获得立即反馈</li>
<li>可以把当前要做的事情明确的写在一张纸上，放在眼前</li>
<li>钟响后，应立即在今日待办表格的相应活动旁边画上一个X，然后休息一下，个人觉得最好的休息，溜达、蹲起、冥想或者浅睡5分钟；在休息期间，思考上一个番茄钟或下一个番茄钟的工作是不允许的，重点应该放在放松！</li>
<li>将4个番茄钟作为一组，每组进行15~30分钟阶段性休息</li>
<li>快速睡眠：舒服的床 + 放松的姿势 + 闭眼 + 想象扫描仪扫描全身 + 跟着扫描放松全身肌肉，尤其是眼部肌肉</li>
<li>在番茄钟进行中不应该切换活动也不应该停止当前活动，关键不在于25分钟内是否做完，关键在于25分钟内尽可能的努力。番茄钟具有原子性，一旦切换或中断都不能算一个番茄钟了。</li>
</ul>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li>中断时常态，要学会记录，学会接受变化。针对内部中断，自己中断自己的情况：要接受它，记录它，然后接着进行手头的工作；处理外部中断，告知（番茄钟内），协商（等一下），计划（今日或以后），答复（中断在开启一个），前三项都要在简短的互动后全力以赴的继续番茄钟</li>
</ul>
<h3 id="预估"><a href="#预估" class="headerlink" title="预估"></a>预估</h3><ul>
<li>要经常回顾与反思，要写成功日记增强自信心</li>
<li>预估一个活动需要多个番茄钟，那最好把活动拆分为多个；如果一个活动用不了一个番茄钟，那最好多个任务组合成一个番茄钟</li>
<li>用不同标记记录超出或不足的番茄钟，作为思考与以后优化的依据</li>
</ul>
<h3 id="应变"><a href="#应变" class="headerlink" title="应变"></a>应变</h3><ul>
<li>循序渐进：经常中断或注意力不集中，那把25分钟缩短</li>
<li>建立一套自己的仪式方式，自己的时钟等，尽信书不如无书！</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>监听文件夹变化</title>
    <url>/2017/12/12/%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-timer-NSFileManager"><a href="#1-timer-NSFileManager" class="headerlink" title="1 timer+NSFileManager"></a>1 timer+NSFileManager</h3><p>&emsp;&emsp;这是我想到的第一个方案，方案很简单但效果非常不理想！轮询时间长了，可能会出现时间间隔内多次修改问题；轮询时间短了，太耗费性能，而且”短“的定义无法具象。具体代码不贴了</p>
<h3 id="2-GCD-source"><a href="#2-GCD-source" class="headerlink" title="2 GCD source"></a>2 GCD source</h3><p>&emsp;&emsp;必须得找一个让文件夹自己说话的方法，几经思索我想到了GCD，毕竟GCD可监控端口啥的，没准也可以监听文件夹！搜到一篇文章 <a href="http://ksnowlv.github.io/blog/2014/09/06/gcd-zhi-jian-ting-wen-jian/" target="_blank" rel="noopener">http://ksnowlv.github.io/blog/2014/09/06/gcd-zhi-jian-ting-wen-jian/</a> , 核心是创建读写权限的source通知！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,</span><br><span class="line">NSUserDomainMask, YES);</span><br><span class="line"></span><br><span class="line">if (paths.count == 0) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSString *ksnowDir =</span><br><span class="line">[[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;ksnow&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;ksnowdir = %@&quot;, ksnowDir);</span><br><span class="line"></span><br><span class="line">NSURL *directoryURL = [NSURL URLWithString:ksnowDir];</span><br><span class="line"></span><br><span class="line">int const fd =</span><br><span class="line">open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);</span><br><span class="line">if (fd &lt; 0) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;Unable to open the path = %@&quot;, [directoryURL path]);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">dispatch_source_t source =</span><br><span class="line">dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,</span><br><span class="line">DISPATCH_VNODE_WRITE | DISPATCH_VNODE_RENAME,</span><br><span class="line">DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">dispatch_source_set_event_handler(source, ^() &#123;</span><br><span class="line">unsigned long const type = dispatch_source_get_data(source);</span><br><span class="line"></span><br><span class="line">switch (type) &#123;</span><br><span class="line">case DISPATCH_VNODE_WRITE: &#123;</span><br><span class="line">NSLog(@&quot;目录内容改变!!!&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case DISPATCH_VNODE_RENAME: &#123;</span><br><span class="line">NSLog(@&quot;目录被重命名!!!&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_source_set_cancel_handler(source, ^() &#123; close(fd); &#125;);</span><br><span class="line">self.source = source;</span><br><span class="line">dispatch_resume(self.source);</span><br></pre></td></tr></table></figure></p>
<h3 id="3-官方"><a href="#3-官方" class="headerlink" title="3 官方"></a>3 官方</h3><p>&emsp;&emsp;在检索的时候无意中发现官方已经给了dome ： <a href="https://developer.apple.com/library/content/samplecode/DocInteraction/Listings/Classes_DirectoryWatcher_m.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/samplecode/DocInteraction/Listings/Classes_DirectoryWatcher_m.html</a> , 源码如下</p>
<p>&emsp;&emsp;核心思路是</p>
<ol>
<li>open打开文件夹，得到文件句柄。</li>
<li>创建kqueue队列来处理系统事件</li>
<li>创建kevent结构体，设置相关属性，并关联kqueue队列。</li>
<li>创建runloop source，设置回调函数并加到默认的runloopMode中。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- (void)kqueueFired</span><br><span class="line">&#123;</span><br><span class="line">assert(kq &gt;= 0);</span><br><span class="line"></span><br><span class="line">struct kevent   event;</span><br><span class="line">struct timespec timeout = &#123;0, 0&#125;;</span><br><span class="line">int             eventCount;</span><br><span class="line"></span><br><span class="line">eventCount = kevent(kq, NULL, 0, &amp;event, 1, &amp;timeout);</span><br><span class="line">assert((eventCount &gt;= 0) &amp;&amp; (eventCount &lt; 2));</span><br><span class="line"></span><br><span class="line">// call our delegate of the directory change</span><br><span class="line">[delegate directoryDidChange:self];</span><br><span class="line"></span><br><span class="line">CFFileDescriptorEnableCallBacks(dirKQRef, kCFFileDescriptorReadCallBack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void KQCallback(CFFileDescriptorRef kqRef, CFOptionFlags callBackTypes, void *info)</span><br><span class="line">&#123;</span><br><span class="line">DirectoryWatcher *obj;</span><br><span class="line"></span><br><span class="line">obj = (__bridge DirectoryWatcher *)info;</span><br><span class="line">assert([obj isKindOfClass:[DirectoryWatcher class]]);</span><br><span class="line">assert(kqRef == obj-&gt;dirKQRef);</span><br><span class="line">assert(callBackTypes == kCFFileDescriptorReadCallBack);</span><br><span class="line"></span><br><span class="line">[obj kqueueFired];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)startMonitoringDirectory:(NSString *)dirPath</span><br><span class="line">&#123;</span><br><span class="line">// Double initializing is not going to work...</span><br><span class="line">if ((dirKQRef == NULL) &amp;&amp; (dirFD == -1) &amp;&amp; (kq == -1))</span><br><span class="line">&#123;</span><br><span class="line">// Open the directory we&apos;re going to watch</span><br><span class="line">dirFD = open([dirPath fileSystemRepresentation], O_EVTONLY);</span><br><span class="line">if (dirFD &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">// Create a kqueue for our event messages...</span><br><span class="line">kq = kqueue();</span><br><span class="line">if (kq &gt;= 0)</span><br><span class="line">&#123;</span><br><span class="line">struct kevent eventToAdd;</span><br><span class="line">eventToAdd.ident  = dirFD;</span><br><span class="line">eventToAdd.filter = EVFILT_VNODE;</span><br><span class="line">eventToAdd.flags  = EV_ADD | EV_CLEAR;</span><br><span class="line">eventToAdd.fflags = NOTE_WRITE;</span><br><span class="line">eventToAdd.data   = 0;</span><br><span class="line">eventToAdd.udata  = NULL;</span><br><span class="line"></span><br><span class="line">int errNum = kevent(kq, &amp;eventToAdd, 1, NULL, 0, NULL);</span><br><span class="line">if (errNum == 0)</span><br><span class="line">&#123;</span><br><span class="line">CFFileDescriptorContext context = &#123; 0, (__bridge void *)(self), NULL, NULL, NULL &#125;;</span><br><span class="line">CFRunLoopSourceRef      rls;</span><br><span class="line"></span><br><span class="line">// Passing true in the third argument so CFFileDescriptorInvalidate will close kq.</span><br><span class="line">dirKQRef = CFFileDescriptorCreate(NULL, kq, true, KQCallback, &amp;context);</span><br><span class="line">if (dirKQRef != NULL)</span><br><span class="line">&#123;</span><br><span class="line">rls = CFFileDescriptorCreateRunLoopSource(NULL, dirKQRef, 0);</span><br><span class="line">if (rls != NULL)</span><br><span class="line">&#123;</span><br><span class="line">CFRunLoopAddSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode);</span><br><span class="line">CFRelease(rls);</span><br><span class="line">CFFileDescriptorEnableCallBacks(dirKQRef, kCFFileDescriptorReadCallBack);</span><br><span class="line"></span><br><span class="line">// If everything worked, return early and bypass shutting things down</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">// Couldn&apos;t create a runloop source, invalidate and release the CFFileDescriptorRef</span><br><span class="line">CFFileDescriptorInvalidate(dirKQRef);</span><br><span class="line">CFRelease(dirKQRef);</span><br><span class="line">dirKQRef = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// kq is active, but something failed, close the handle...</span><br><span class="line">close(kq);</span><br><span class="line">kq = -1;</span><br><span class="line">&#125;</span><br><span class="line">// file handle is open, but something failed, close the handle...</span><br><span class="line">close(dirFD);</span><br><span class="line">dirFD = -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>离屏渲染</title>
    <url>/2016/11/02/%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><h4 id="GPU渲染机制"><a href="#GPU渲染机制" class="headerlink" title="GPU渲染机制"></a>GPU渲染机制</h4><p>&emsp;&emsp;CPU 计算好显示内容提交到 GPU，GPU渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照VSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p>
<h4 id="为什么会卡顿掉帧"><a href="#为什么会卡顿掉帧" class="headerlink" title="为什么会卡顿掉帧"></a>为什么会卡顿掉帧</h4><p>&emsp;&emsp;垂直同步的机制，如果在一个VSync时间内，CPU或者GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。即卡顿原因：</p>
<ul>
<li>1，CPU没提交，即CPU没完成计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等工作</li>
<li>2，GPU没提交，即GPU没完成变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区等工作</li>
</ul>
<h4 id="GPU屏幕渲染的方式"><a href="#GPU屏幕渲染的方式" class="headerlink" title="GPU屏幕渲染的方式:"></a>GPU屏幕渲染的方式:</h4><ul>
<li>On-Screen Rendering (当前屏幕渲染) 指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。</li>
<li>Off-Screen Rendering (离屏渲染) 指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。代价很高：1，创建新缓冲区，要想进行离屏渲染，首先要创建一个新的缓冲区；2，上下文切换，离屏渲染的整个过程，需要多次切换上下文环境</li>
<li>CPU中的离屏渲染（特殊离屏渲染，即不在GPU中的渲染），如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染</li>
</ul>
<h4 id="如何检测离屏渲染"><a href="#如何检测离屏渲染" class="headerlink" title="如何检测离屏渲染"></a>如何检测离屏渲染</h4><ul>
<li>模拟器在工作栏上面的Debug -&gt; Color Off-Screen Rendered</li>
<li>真机在工作栏上面的Debug -&gt;  View Debugging -&gt; Rendering -&gt; Color Off-Screen Rendered Yellow</li>
<li>Core Animation工具检测离屏渲染</li>
<li>Color Blended Layers：红色的是layer透明的，绿色是layer不透明的。</li>
<li>Color Hits Green and Misses Red：红色没复用缓存，绿色复用缓存</li>
<li>Color Misaligned Images：缩放图片标记为黄色，像素没对齐则标记为紫色</li>
<li>Color Offscreen-Rendered Yellow：检测离屏渲染的，黄色表示有离屏渲染。</li>
<li>Flash Updated Regions：当对图层重绘的时候显示黄色，频繁重绘需加缓存。</li>
</ul>
<h4 id="引发离屏渲染因素"><a href="#引发离屏渲染因素" class="headerlink" title="引发离屏渲染因素"></a>引发离屏渲染因素</h4><ul>
<li>为图层设置遮罩（layer.mask）</li>
<li>将图层的layer.masksToBounds / view.clipsToBounds属性设置为true</li>
<li>将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0</li>
<li>为图层设置阴影（layer.shadow *）。</li>
<li>为图层设置layer.shouldRasterize=true</li>
<li>具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层</li>
<li>文本（任何种类，包括UILabel，CATextLayer，Core Text等）。</li>
<li>使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="圆角优化"><a href="#圆角优化" class="headerlink" title="圆角优化"></a>圆角优化</h4><ul>
<li>利用CAShapeLayer渲染是直接用的GPU，减少CPU对圆角的大量计算<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line">imageView.image = [UIImage imageNamed:@&quot;myImg&quot;];</span><br><span class="line">UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];</span><br><span class="line">CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init];</span><br><span class="line">//设置大小</span><br><span class="line">maskLayer.frame = imageView.bounds;</span><br><span class="line">//设置图形样子</span><br><span class="line">maskLayer.path = maskPath.CGPath;</span><br><span class="line">imageView.layer.mask = maskLayer;</span><br><span class="line">[self.view addSubview:imageView];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="阴影优化"><a href="#阴影优化" class="headerlink" title="阴影优化"></a>阴影优化</h4><ul>
<li>如果图层是个简单的几何图形或者圆角图形，我们可以通过设置shadowPath来优化性能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">imageView.layer.shadowColor = [UIColor grayColor].CGColor;</span><br><span class="line">imageView.layer.shadowOpacity = 1.0;</span><br><span class="line">imageView.layer.shadowRadius = 2.0;</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRect:imageView.frame];</span><br><span class="line">imageView.layer.shadowPath = path.CGPath;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其它建议"><a href="#其它建议" class="headerlink" title="其它建议"></a>其它建议</h4><ul>
<li>需要圆角效果时，可以使用一张中间透明图片蒙上去，这是效率最高的一种方案</li>
<li>尽量使用不包含透明（alpha）通道的图片资源</li>
<li>确保图片大小和frame一致，不要在滑动时缩放图片。</li>
<li>确保图片颜色格式被GPU支持，避免CPU转换。</li>
<li>确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明。如无特殊需要，不要设置低于1的alpha值。</li>
<li>尽量设置frame的大小值为整形值，避免CPU进行大量复杂计算</li>
<li>设置阴影效果时,使用ShadowPath指定layer阴影效果路径</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>耗电量优化</title>
    <url>/2017/04/21/%E8%80%97%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="1-测试"><a href="#1-测试" class="headerlink" title="1 测试"></a>1 测试</h3><h4 id="1-1-测试方法"><a href="#1-1-测试方法" class="headerlink" title="1.1 测试方法"></a>1.1 测试方法</h4><p>&emsp;&emsp;检测耗电量的方法还是比较多的，对于我们而言Instrument检测基本上已经满足我们的耗电量检测需求！具体方法可参考<a href="https://github.com/ChenYilong/iOSBlog/issues/10" target="_blank" rel="noopener">iOS 常见耗电量检测方案调研</a>！对于耗电浪有精准检测要求的，推荐阅读<a href="https://cloud.tencent.com/developer/article/1006222" target="_blank" rel="noopener">iOS 电量测试实践</a></p>
<h4 id="1-2-测试范围"><a href="#1-2-测试范围" class="headerlink" title="1.2 测试范围"></a>1.2 测试范围</h4><ul>
<li>机型：iphone se、iphone 6 Plus 和 iPhone X</li>
<li>系统：iOS9、iOS11、iOS12</li>
</ul>
<h3 id="2-实践"><a href="#2-实践" class="headerlink" title="2 实践"></a>2 实践</h3><h4 id="2-1-定位"><a href="#2-1-定位" class="headerlink" title="2.1 定位"></a>2.1 定位</h4><p>&emsp;&emsp;对于我们而言，定位服务甚至不是必须的！只是一些三方SDK要求提供定位服务，才不得不请求定位权限。鉴于我们的实际使用情况</p>
<ol>
<li>限制定位请求只请求一次：去掉后台定位请求、获取位置成功后保存位置并关闭定位</li>
<li>降低定位精度：设定位精度desiredAccuracy为kCLLocationAccuracyKilometer，距离过滤器distanceFilter为1000</li>
</ol>
<h4 id="2-2-陀螺仪"><a href="#2-2-陀螺仪" class="headerlink" title="2.2 陀螺仪"></a>2.2 陀螺仪</h4><p>&emsp;&emsp;很早之前做了一个摇一摇的摇钱树功能！检测用户摇晃几次之后可以抽奖！经沟通已取消相关功能，最主要是不摇晃，直接点击也能抽奖…</p>
<h4 id="2-3-网络"><a href="#2-3-网络" class="headerlink" title="2.3 网络"></a>2.3 网络</h4><p>&emsp;&emsp;默认网络硬件，比如蜂窝数据和Wi-Fi是不通电的。为了执行网络操作，这些资源必须通电，并持续一段时间保活。零散的网络传输会导致很高的间接能耗，迅速消耗电池电量</p>
<p>&emsp;&emsp;我们的APP存在的主要问题是频繁请求接口数据、每次请求接口都检测一下网络状态、缓存只在第一次启动时生效以及没有断点续传功能</p>
<h5 id="2-3-1-减少请求频次"><a href="#2-3-1-减少请求频次" class="headerlink" title="2.3.1 减少请求频次"></a>2.3.1 减少请求频次</h5><p>&emsp;&emsp;不得不吐槽PM对客户端请求频次一直耿耿于怀，恨不得所有接口都要加个轮训，甚至要求打点信息一条一条的发，以减少漏点情况；这么高频次的请求，已经严重影响到APP的耗电：解决方案主要有：</p>
<ol>
<li>在base库（对NSUrlsession的简单封装）里增加请求没回之前放弃本次请求（根据URL判断）的逻辑；</li>
<li>增加接口返回数据md5校验，如果两次接口返回数据相同，则延长相同接口请求的时间间隔，最长不超过1分钟！(现被放弃了，PM连1分钟都不能忍！让PM出白名单或接口分级，他们也不想做)</li>
<li>调整打点系统策略，将默认单条日志就post一下 + 无网写入文件的策略，调整为默认写入文件压缩后发送 + 单条日志发送开关控制</li>
</ol>
<h5 id="2-3-2-合并请求"><a href="#2-3-2-合并请求" class="headerlink" title="2.3.2 合并请求"></a>2.3.2 合并请求</h5><p>&emsp;&emsp;把普通广告弹窗和alert广告弹窗合并，这两个弹窗具有及其相似的请求频率和业务逻辑，完全可以合并！类似的还有一些配置小接口也合并成大接口</p>
<h5 id="2-3-3-减少网络监测"><a href="#2-3-3-减少网络监测" class="headerlink" title="2.3.3 减少网络监测"></a>2.3.3 减少网络监测</h5><p>&emsp;&emsp;原来每次请求接口时，都会调用一个类似Reachability的自己写的库，用于监测当前网络！这完全是不合理也不必要的，改用监听Reachability通知并设置标志位的方式来减少网络状态检测</p>
<h4 id="2-4-IO操作"><a href="#2-4-IO操作" class="headerlink" title="2.4 IO操作"></a>2.4 IO操作</h4><p>&emsp;&emsp;我们这高频IO操作主要集中在cache缓存、配置文件、日志、NSUserDefaults的滥用和Data方式取图片</p>
<h5 id="2-4-1-cache缓存"><a href="#2-4-1-cache缓存" class="headerlink" title="2.4.1 cache缓存"></a>2.4.1 cache缓存</h5><ul>
<li>读写在减少网络请求频次时已经得到了很好的解决，但还有优化空间！原来我们采用的是YYCache，但YYCache可能莫名其妙的缓存就清掉了，我们怀疑是sqlite没有正常关闭造成的，但我们没有证据，因为无论是断点还是打log都没抓到”现场“，无奈之下只能将一小部分核心缓存改成手动存储，但由于当时只是作为临时方：案每次接口返回都直接更新本地缓存，渐渐的变成了永久方案。因只是部分核心数据，数据量以及涉及面较小，此次方案为：内存保存当退出或内存警告时再写入硬盘</li>
</ul>
<h5 id="2-4-2-配置文件问题。"><a href="#2-4-2-配置文件问题。" class="headerlink" title="2.4.2 配置文件问题。"></a>2.4.2 配置文件问题。</h5><p>&emsp;&emsp;首先统计读写配置文件的频次将高频的筛选出来，然后根据配置文件的标签：只读或读写，进一步细分。</p>
<ul>
<li>高频只读文件比较简单：内存保存、收到内存警告再清除内存；</li>
<li>高频读写配置文件还要细分，</li>
<li>对于读少写多的文件：内存处理、集中保存；</li>
<li>对于读多写少的文件，我们没有处理!</li>
</ul>
<h5 id="2-4-3-打点日志"><a href="#2-4-3-打点日志" class="headerlink" title="2.4.3 打点日志"></a>2.4.3 打点日志</h5><p>&emsp;&emsp;流程：open file -&gt; 写入日志 -&gt; &gt;50条 -&gt; 关闭文件 -&gt; 取出文件Data -&gt; zip -&gt; 取出zip文件Data -&gt; ase加密 -&gt; 存储。通过流程我们可以发现：</p>
<ul>
<li>1、日志文件可以不创建，直接使用内存记录，转Data直接塞到zip里即可</li>
<li>2、压缩后的文件加密移至低级线程集中单独处理（这里原来有个大bug：竟然每写一条日志就检查一下当前文件夹里是否有未压缩的文件，如果有就压缩，压缩是否加密，没加密就加密）</li>
</ul>
<h5 id="2-4-4-NSUserDefaults的滥用"><a href="#2-4-4-NSUserDefaults的滥用" class="headerlink" title="2.4.4 NSUserDefaults的滥用"></a>2.4.4 NSUserDefaults的滥用</h5><p>&emsp;&emsp;主要体现在滥用synchronize，这个没啥可说的！NSUserDefault的数据不太敢动，只能在synchronize上做做文章了</p>
<h5 id="2-4-5-Data方式取图片"><a href="#2-4-5-Data方式取图片" class="headerlink" title="2.4.5 Data方式取图片"></a>2.4.5 Data方式取图片</h5><p>&emsp;&emsp;比较试用的是单独用一次的大图片！对于频繁实用的小图还是用imageNamed比较好，不过需要注意的是如果需要异步读取图片必须用Data方式</p>
<h4 id="2-5-定时器"><a href="#2-5-定时器" class="headerlink" title="2.5 定时器"></a>2.5 定时器</h4><p>&emsp;&emsp;定时器也是耗电大户，我们定时器问题主要是轮播组件以及轮训</p>
<ul>
<li>轮播组件：检测当前Cell是否在屏幕上，如果没在屏幕停止轮播，切换回屏幕再重新启动</li>
<li>轮训：合并轮训定时器，减少定时器数量</li>
</ul>
<h4 id="2-6-视图"><a href="#2-6-视图" class="headerlink" title="2.6 视图"></a>2.6 视图</h4><p>&emsp;&emsp;其实绝大多数视图问题都和流畅度、卡顿相关！以后可以专门写个卡顿的水文，这里就说跟耗电量相关的问题！</p>
<ul>
<li>1、使用局部刷新、避免频繁刷新！</li>
<li>2、减少图片拉伸</li>
<li>3、减少动画</li>
<li>4、布局时减少浮点数的计算</li>
</ul>
<h3 id="3-低电量模式"><a href="#3-低电量模式" class="headerlink" title="3 低电量模式"></a>3 低电量模式</h3><p>&emsp;&emsp;iOS9之后，iPhone增加了低电量模式，用户如果希望延长iPhone电池的寿命，可以在设置 &gt; 电池中开启该功能。开启该功能之后iOS会采取一些措施，比如：</p>
<ol>
<li>降低CPU和GPU性能</li>
<li>暂停随意的和后台的活动，包括网络</li>
<li>降低屏幕亮度</li>
<li>缩短自动锁屏时间</li>
<li>关闭邮件刷新</li>
<li>关闭视角缩放</li>
<li>关闭动态壁纸</li>
</ol>
<p>&emsp;&emsp;可以通过向NSNotificationCenter注册NSProcessInfoPowerStateDidChangeNotification通知监听低电量模式状态。我们APP在接收到低电量通知时就干了一件事：把内存数据存储到本地</p>
<h3 id="4-监控"><a href="#4-监控" class="headerlink" title="4 监控"></a>4 监控</h3><p>&emsp;&emsp;监控电池的状态有助于我们在不同电池状态下做更多的操作！据闻Uber就是检测到电池电量比较低时提高运单价格，因为手机快没电的还在叫车，那才叫真的刚需呀！其实监控电池状态对于我们而言只有两个作用：1、上文提到低电量存本地策略；2、生产和PM撕逼的证据：别老没事就说我们APP耗电，下载电影电视剧的耗电可不能算在我们头上</p>
<h4 id="4-1-方案"><a href="#4-1-方案" class="headerlink" title="4.1 方案"></a>4.1 方案</h4><p>&emsp;&emsp;我们采用的是UIDevice类batteryLevel接口，虽然采样只能精确到 1%，但已经足够满足我们的需求！<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma mark 电池</span><br><span class="line">// 电池电量，ios8前只能精确动5%，以后可精确到1%</span><br><span class="line">+ (float)batteryLevel &#123;</span><br><span class="line">UIDevice *device = [UIDevice currentDevice];</span><br><span class="line">device.batteryMonitoringEnabled = YES;</span><br><span class="line">if (device.batteryLevel &gt; 0.0f) &#123;</span><br><span class="line">return device.batteryLevel * 100 ;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电池状态：充电中、满电等</span><br><span class="line">+ (UIDeviceBatteryState)batteryState &#123;</span><br><span class="line">UIDevice *device = [UIDevice currentDevice];</span><br><span class="line">device.batteryMonitoringEnabled = YES;</span><br><span class="line">return device.batteryState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电池是否在充电</span><br><span class="line">+ (BOOL)isBatteryCharing &#123;</span><br><span class="line">UIDeviceBatteryState state = [[self class] batteryState];</span><br><span class="line">if (state == UIDeviceBatteryStateCharging) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 电池是否满电</span><br><span class="line">+ (BOOL)isBatteryFull &#123;</span><br><span class="line">UIDeviceBatteryState state = [[self class] batteryState];</span><br><span class="line">if (state == UIDeviceBatteryStateFull) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前电量是否大于给定阀值，耗电量优化时可用</span><br><span class="line">+ (BOOL)shouldProceedWithMinLevel:(NSUInteger)minLevel &#123;</span><br><span class="line">// 充电或满电</span><br><span class="line">if ([[self class] isBatteryCharing] || [[self class] isBatteryFull]) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">NSUInteger batteryLevel = (NSUInteger)[[self class] batteryLevel];</span><br><span class="line">if (batteryLevel &gt;= minLevel) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/9a5e94e7b7c3" target="_blank" rel="noopener">https://www.jianshu.com/p/9a5e94e7b7c3</a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>网络图片怎么适配</title>
    <url>/2015/10/19/%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<p>&emsp;&emsp;这两天UI给提了个bug，说网络下载的图片变小了？查了半天才才发现UI后端上传的图片是2x的，而客户端是按3x来处理的！这就比较坑了……所以就产生了这篇水文！</p>
<p>&emsp;&emsp; 我们采用的是如下（1.1）方案，但约定毕竟不靠谱呀！出现问题又是客户端背锅！</p>
<ul>
<li>1.1 跟后端约定只能穿3x图片，客户端下载图片之后直接绘制即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int scale = 3;</span><br><span class="line">UIImage *image = [UIImage imageWithCGImage:img.CGImage withScale:scale];</span><br><span class="line">CGFloat imageHeight = image.size.height / scale;</span><br><span class="line">CGFloat imageWidth = image.size.width / scale;</span><br><span class="line">imageView.frame = CGRectMake(0, 0, imageHeight, imageWidth);</span><br><span class="line">imageView.image = image;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp; 约定不靠谱，那就让服务端都传过来吧！</p>
<ul>
<li>1.2 增强型约定格式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">image:&#123;</span><br><span class="line">imgUrl:ttps://xxx.png,</span><br><span class="line">scale:3,</span><br><span class="line">width:100,</span><br><span class="line">height:100</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">UIImage *image = [UIImage imageWithCGImage:img.CGImage withScale:scale];</span><br><span class="line">imageView.frame = CGRectMake(0, 0, width, height);</span><br><span class="line">imageView.image = image;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;1.2的方案确实更好一点，但服务端的童鞋说这么多接口都这么改，怕要累死了……</p>
<p>&emsp;&emsp;那么怎么办？来看看SD怎么玩的吧</p>
<ul>
<li>1.3 SD怎么玩的？原来是通过url是否包含2x和3x来处理的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">CGFloat scale = 1;</span><br><span class="line">if (key.length &gt;= 8) &#123;</span><br><span class="line">NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">if (range.location != NSNotFound) &#123;</span><br><span class="line">scale = 2.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">if (range.location != NSNotFound) &#123;</span><br><span class="line">scale = 3.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (scale != image.scale) &#123;</span><br><span class="line">UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">scaledImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">image = scaledImage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return image;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;等等if (scale != image.scale)，那是不是直接用image.scale也可以呢？</p>
<ul>
<li>1.4 不行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体代码不写了，可以让后端给你传2x和3x图片分别测试，也可以自己设代理映射本地图片，结果都是一样的！无论2x还是3x，下载后的image，image.scale都是1！但通过imageNamed方式加载本地图片，image.scale却是正确的！！</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;综上所述，想要完美适配图片，只能通过约定的方式：要么约定只能穿3x图片，要么约定上传图片时带着2x或3x信息</p>
<p>&emsp;&emsp;至于jpg格式，jpg要什么适配！！</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义UIPickerView</title>
    <url>/2016/08/05/%E8%87%AA%E5%AE%9A%E4%B9%89UIPickerView/</url>
    <content><![CDATA[<p>&emsp;&emsp;为啥要写这篇文章？水肯定是必然的！更主要的原因是碰到了二逼UI，非说系统自带的3D效果滚轮不好看，非要做成安卓的样子（安卓用的三方库）！iOS没有现成的三方库（看到没，估计这UI大姐是设计界里第一个觉得iOS系统pickerview丑的“大神”，要不然怎么可能没有开源库！），UI又坚持就要安卓的样子，甚至闹到了老大那里…，老大问我能不能实现？呵呵！我能咋办…能实现！（其实我是想说不，但老大想息事宁人，还是不说了谁让自己是农民工呢…）</p>
<h3 id="自定义PickerView"><a href="#自定义PickerView" class="headerlink" title="自定义PickerView"></a>自定义PickerView</h3><h4 id="H文件"><a href="#H文件" class="headerlink" title="H文件"></a>H文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 自定义picker</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line"></span><br><span class="line">@class BFPickerView;</span><br><span class="line">@protocol BFPickerViewDataSource&lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">- (NSInteger)numberOfComponentsInPickerView:(BFPickerView *)pickerView;</span><br><span class="line">- (NSInteger)pickerView:(BFPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@protocol BFPickerViewDelegate&lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">- (NSString *)pickerView:(BFPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component;</span><br><span class="line">@optional</span><br><span class="line">- (CGFloat)pickerView:(BFPickerView *)pickerView widthForComponent:(NSInteger)component;</span><br><span class="line">- (CGFloat)pickerView:(BFPickerView *)pickerView rowHeightForComponent:(NSInteger)component;</span><br><span class="line">- (void)pickerView:(BFPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface BFPickerView : UIView&lt;NSCoding&gt;</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,weak) id&lt;BFPickerViewDataSource&gt; dataSource;</span><br><span class="line">@property(nullable,nonatomic,weak) id&lt;BFPickerViewDelegate&gt;   delegate;</span><br><span class="line"></span><br><span class="line">- (void)reloadAllComponents;</span><br><span class="line">- (void)reloadComponent:(NSInteger)component;</span><br><span class="line"></span><br><span class="line">- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component;</span><br><span class="line">- (NSInteger)selectedRowInComponent:(NSInteger)component;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="M文件"><a href="#M文件" class="headerlink" title="M文件"></a>M文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;BFPickerView.h&quot;</span><br><span class="line">#import &lt;Masonry.h&gt;</span><br><span class="line">#import &quot;UIColor+LicaiColor.h&quot;</span><br><span class="line">#import &quot;UIFont+Licai.h&quot;</span><br><span class="line"></span><br><span class="line">#define kPickerSubscrollViewTag 8486</span><br><span class="line"></span><br><span class="line">@interface BFPickerView ()&lt;UIScrollViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIImageView *upImageView;</span><br><span class="line">@property (nonatomic, strong) UIView *upLineView;</span><br><span class="line">@property (nonatomic, strong) UIImageView *downImageView;</span><br><span class="line">@property (nonatomic, strong) UIView *downLineView;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL isSubViewLayouted;</span><br><span class="line">@property (nonatomic, assign) NSInteger componentCount;</span><br><span class="line">@property (nonatomic, strong) NSMutableDictionary *selectDic;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BFPickerView</span><br><span class="line"></span><br><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">[self setUp];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component&#123;</span><br><span class="line">[self reloadComponent:component];</span><br><span class="line">CGFloat cellHeight = [self rowHeightForComponent:component];</span><br><span class="line">// UITableView存在复用机制，可能会闪或者消失</span><br><span class="line">UIScrollView *scrollView = [self scrollViewFromComponent:component];</span><br><span class="line">[scrollView setContentOffset:CGPointMake(0, cellHeight * row) animated:NO];</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">- (NSInteger)selectedRowInComponent:(NSInteger)component &#123;</span><br><span class="line">return [[self.selectDic objectForKey:@(component + kPickerSubscrollViewTag)] integerValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)verifyComponent:(NSInteger)component &#123;</span><br><span class="line">if (component &gt;= 0 &amp;&amp; component &lt; [self numberOfComponent]) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//</span><br><span class="line">- (BOOL)verifyrow:(NSInteger)row inComponent:(NSInteger)component &#123;</span><br><span class="line">if (row &gt;= 0 &amp;&amp; row &lt; [self numberOfRowsInComponent:component]) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark reload</span><br><span class="line"></span><br><span class="line">- (void)reloadAllComponents &#123;</span><br><span class="line">for (int i = 0; i &lt; [self numberOfComponent]; i++) &#123;</span><br><span class="line">[self reloadComponent:i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)reloadComponent:(NSInteger)component &#123;</span><br><span class="line">if (![self verifyComponent:component]) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UIScrollView *scrollView = [self scrollViewFromComponent:component];</span><br><span class="line">CGFloat width = [self widthForComponent:component];</span><br><span class="line">if (scrollView) &#123;</span><br><span class="line">[scrollView mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.width.equalTo(@(width));</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">scrollView = [self makescrollView];</span><br><span class="line">scrollView.tag = kPickerSubscrollViewTag + component;</span><br><span class="line">CGFloat cellHeight = [self rowHeightForComponent:component];</span><br><span class="line">[self addSubview:scrollView];</span><br><span class="line">if (component == 0) &#123;</span><br><span class="line">[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.centerY.equalTo(self.mas_centerY);</span><br><span class="line">make.left.equalTo(@0);</span><br><span class="line">make.width.equalTo(@(width));</span><br><span class="line">make.height.equalTo(@(cellHeight));</span><br><span class="line">&#125;];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">UIScrollView *prevscrollView = [self scrollViewFromComponent:component - 1];</span><br><span class="line">if (prevscrollView) &#123;</span><br><span class="line">[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.centerY.equalTo(self.mas_centerY);</span><br><span class="line">make.left.equalTo(prevscrollView.mas_right);</span><br><span class="line">make.width.equalTo(@(width));</span><br><span class="line">make.height.equalTo(@(cellHeight));</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[self refreshScrollView:scrollView inComponent:component];</span><br><span class="line">[self layoutIfNeeded];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)refreshScrollView:(UIScrollView *)scrollView inComponent:(NSInteger)component&#123;</span><br><span class="line">[scrollView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];</span><br><span class="line">NSInteger count = [self numberOfRowsInComponent:component];</span><br><span class="line">CGFloat totalHeight = 0.0;</span><br><span class="line">CGFloat width = [self widthForComponent:component];</span><br><span class="line">CGFloat height = [self rowHeightForComponent:component];</span><br><span class="line">for (int row = 0; row &lt; count; row++) &#123;</span><br><span class="line">UILabel *label = [self makeLabel];</span><br><span class="line">label.text = [self titleForRow:row forComponent:component];</span><br><span class="line">label.frame = CGRectMake(0, totalHeight, width, height);</span><br><span class="line">[scrollView addSubview:label];</span><br><span class="line">totalHeight += height;</span><br><span class="line">&#125;</span><br><span class="line">scrollView.contentSize = CGSizeMake(width, totalHeight);</span><br><span class="line">[scrollView layoutIfNeeded];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UILabel *)makeLabel &#123;</span><br><span class="line">UILabel *label = [[UILabel alloc] init];</span><br><span class="line">label.backgroundColor = [UIColor clearColor];</span><br><span class="line">label.textColor = [UIColor licaiColor_121C32];</span><br><span class="line">label.font = [UIFont licai_PFMediumOfSize:kScaledValueX(15)];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">return label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark scrollView</span><br><span class="line"></span><br><span class="line">- (UIScrollView *)makescrollView&#123;</span><br><span class="line">UIScrollView *scrollView = [[UIScrollView alloc] init];</span><br><span class="line">scrollView.backgroundColor = [UIColor clearColor];</span><br><span class="line">scrollView.delegate = self;</span><br><span class="line">scrollView.showsVerticalScrollIndicator = NO;</span><br><span class="line">scrollView.showsHorizontalScrollIndicator = NO;</span><br><span class="line">scrollView.pagingEnabled = YES;</span><br><span class="line">scrollView.layer.masksToBounds = NO;</span><br><span class="line">scrollView.clipsToBounds = NO;</span><br><span class="line">return scrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIScrollView *)scrollViewFromComponent:(NSInteger)component &#123;</span><br><span class="line">NSInteger tag = kPickerSubscrollViewTag + component;</span><br><span class="line">return (UIScrollView *)[self viewWithTag:tag];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)componentFromscrollView:(UIScrollView *)scrollView &#123;</span><br><span class="line">if (scrollView) &#123;</span><br><span class="line">NSInteger component = scrollView.tag - kPickerSubscrollViewTag;</span><br><span class="line">if ([self verifyComponent:component]) &#123;</span><br><span class="line">return component;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark BFPickerViewDelegate</span><br><span class="line"></span><br><span class="line">- (CGFloat)widthForComponent:(NSInteger)component &#123;</span><br><span class="line">if (self.delegate &amp;&amp; [self verifyComponent:component] &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:widthForComponent:)]) &#123;</span><br><span class="line">return [self.delegate pickerView:self widthForComponent:component];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if (self.componentCount &gt; 1) &#123;</span><br><span class="line">return (kScreenWidth - 20*2) / self.componentCount;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return kScreenWidth - 20*2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)rowHeightForComponent:(NSInteger)component &#123;</span><br><span class="line">if (self.delegate &amp;&amp; [self verifyComponent:component] &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:rowHeightForComponent:)]) &#123;</span><br><span class="line">CGFloat height = [self.delegate pickerView:self rowHeightForComponent:component];</span><br><span class="line">if (height &gt; 0) &#123;</span><br><span class="line">return height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 60.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123;</span><br><span class="line">if (self.delegate &amp;&amp; [self verifyComponent:component] &amp;&amp; [self verifyrow:row inComponent:component] &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:titleForRow:forComponent:)]) &#123;</span><br><span class="line">NSString *title = [self.delegate pickerView:self titleForRow:row forComponent:component];</span><br><span class="line">if (STRINGHASVALUE(title)) &#123;</span><br><span class="line">return title;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return @&quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark BFPickerViewDataSource</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfComponent &#123;</span><br><span class="line">if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(numberOfComponentsInPickerView:)]) &#123;</span><br><span class="line">return [self.dataSource numberOfComponentsInPickerView:self];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfRowsInComponent:(NSInteger)component &#123;</span><br><span class="line">if (self.dataSource &amp;&amp; [self verifyComponent:component] &amp;&amp; [self.dataSource respondsToSelector:@selector(pickerView:numberOfRowsInComponent:)]) &#123;</span><br><span class="line">return [self.dataSource pickerView:self numberOfRowsInComponent:component];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark scrollDelegate</span><br><span class="line"></span><br><span class="line">- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123;</span><br><span class="line">NSInteger component = [self componentFromscrollView:scrollView];</span><br><span class="line">CGFloat offsetY = targetContentOffset-&gt;y;</span><br><span class="line">CGFloat cellHeight = [self rowHeightForComponent:component];</span><br><span class="line">NSInteger index = offsetY / cellHeight;</span><br><span class="line">[self.selectDic setObject:@(index) forKey:@(kPickerSubscrollViewTag + component)];</span><br><span class="line">NSLog(@&quot;scrollViewWillEndDragging--jzk %ld&quot;,(long)index);</span><br><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:didSelectRow:inComponent:)]) &#123;</span><br><span class="line">[self.delegate pickerView:self didSelectRow:index inComponent:component];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark setUp</span><br><span class="line"></span><br><span class="line">- (void)setUp &#123;</span><br><span class="line">self.selectDic = [[NSMutableDictionary alloc] init];</span><br><span class="line">self.clipsToBounds = YES;</span><br><span class="line">self.layer.masksToBounds = YES;</span><br><span class="line"></span><br><span class="line">_upImageView = [[UIImageView alloc] init];</span><br><span class="line">_upImageView.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self addSubview:_upImageView];</span><br><span class="line">[_upImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.top.equalTo(@0);</span><br><span class="line">make.left.equalTo(@0);</span><br><span class="line">make.right.equalTo(@0);</span><br><span class="line">make.height.equalTo(@(kScaledValueX(120)));</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">_upLineView = [[UIView alloc] init];</span><br><span class="line">_upLineView.backgroundColor = [UIColor licaiColor_E1E4EB];</span><br><span class="line">[self addSubview:_upLineView];</span><br><span class="line">[_upLineView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.top.equalTo(self.upImageView.mas_bottom);</span><br><span class="line">make.left.equalTo(@20);</span><br><span class="line">make.right.equalTo(@(-20));</span><br><span class="line">make.height.equalTo(@0.5);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">_downImageView = [[UIImageView alloc] init];</span><br><span class="line">_downImageView.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self addSubview:_downImageView];</span><br><span class="line">[_downImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.bottom.equalTo(@0);</span><br><span class="line">make.left.equalTo(@0);</span><br><span class="line">make.right.equalTo(@0);</span><br><span class="line">make.height.equalTo(@(kScaledValueX(120)));</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">_downLineView = [[UIView alloc] init];</span><br><span class="line">_downLineView.backgroundColor = [UIColor licaiColor_E1E4EB];</span><br><span class="line">[self addSubview:_downLineView];</span><br><span class="line">[_downLineView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.bottom.equalTo(self.downImageView.mas_top);</span><br><span class="line">make.left.equalTo(@20);</span><br><span class="line">make.right.equalTo(@(-20));</span><br><span class="line">make.height.equalTo(@0.5);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="更改UIPickerView的上下两条线"><a href="#更改UIPickerView的上下两条线" class="headerlink" title="更改UIPickerView的上下两条线"></a>更改UIPickerView的上下两条线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123;</span><br><span class="line"></span><br><span class="line">UILabel *label = (UILabel*)view;</span><br><span class="line">if (label == nil) &#123;</span><br><span class="line">label = [[UILabel alloc] init];</span><br><span class="line">label.backgroundColor = [UIColor whiteColor];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">label.textColor = [UIColor licaiColor_121C32];</span><br><span class="line">label.font = [UIFont licai_PFMediumOfSize:kScaledValueX(15)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">label.text = [self pickerView:pickerView titleForRow:row forComponent:component];</span><br><span class="line">if (_pickerView.subviews.count &gt;= 3) &#123;</span><br><span class="line">[_pickerView.subviews objectAtIndex:1].backgroundColor = [UIColor licaiColor_E1E4EB];</span><br><span class="line">[_pickerView.subviews objectAtIndex:2].backgroundColor = [UIColor licaiColor_E1E4EB];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>观呼吸</title>
    <url>/2017/07/27/%E8%A7%82%E5%91%BC%E5%90%B8/</url>
    <content><![CDATA[<ul>
<li>前面三分之一都在讲禅修是什么！不是什么!总结三句话：1，管你屁事、管我屁事、有这屁事； 2， 既来之，则安之</li>
<li>一旦坐下，就不要任意改变姿势！盘腿是为了不抖腿！坐定之后，闭上眼睛，我们的心就好像一杯浑浊的水，装着浊水的杯子静置时间越久，泥沙就越能沉淀下来</li>
<li>没有对象，心就不可能集中。将心集中在呼吸之上，深呼吸三次，三次深呼吸之后，恢复正常的呼吸，让你的呼吸自由的进出，再轻松的将你的注意力集中在鼻孔边缘。单纯注意呼吸进出的感觉：在吸完气即将把期呼出之前，有一个短暂的停顿，注意它，并且注意呼气的开始。在呼完气即将吸气进来之前，又有另一个短暂的停顿，同样也注意这个短暂的停顿。别瞎想，别说话，别瞎听，只专注于呼吸。</li>
<li>当心跑开时，马上以正念拉回来，增长定力的措施：数息，呼气数数，吸气数数；</li>
<li>最重要的原则是：坐的时候背要挺直，脊椎要像一叠铜板一样，一个顶一个，让脊柱直立起来，但不应造成肌肉紧张，头则要与脊柱保持一条直线，身体的其余部位则松软的垂挂在脊柱上。这些都必须在放松的状态下进行，不要僵硬。</li>
<li>选择软硬适度的坐垫，选择舒服的衣服，选择舒适的坐姿(单盘，双盘或不盘)，双手重叠放于膝上，目标就是希望身体完全不动，但不能睡着</li>
<li>三次深呼吸之后是自然的呼吸，应该去感受呼吸，而不是控制呼吸，除非你在数息</li>
<li>别思考也别睡着，别着急也别放任</li>
<li>在禅修中，我们靠的是精进，而非蛮力。我们唯一能做到努力就是温和而耐心地保持注意力</li>
<li>必须熊排除自怨自艾与自责着手</li>
</ul>
<p>怎样处理禅修中的问题？<br>问题一：身体的疼痛<br>消除疼痛、治疗，或把疼痛作为禅修对象、检查坐垫、调整坐姿、松开衣物。</p>
<p>问题二：腿失去知觉<br>双腿发麻是由神经压迫而引起，你不会因为坐姿而伤害到腿部组织的。当腿失去知觉，你只要观察这个现象即可。禅修一段时间之后，麻痹感会逐渐消失。</p>
<p>问题三：奇特的感觉<br>当你达到放松时，神经系统只是开始更有效率地让感官信号通过。大量先前受阻的感官信号如今可以畅行无阻，因而引发各种独特的感受。它没有任何特别的意义，就只是感受而已，因此只要使用平常的技巧即可。看着它生起，再看着它消失，不要被牵扯进去。</p>
<p>问题四：昏沉<br>不要对睡眠让步。如果你很想睡就深吸气，憋得愈久愈好，然后再慢慢吐出来。接着再深吸一口气，然后尽量憋住，再慢慢吐出来。反复这么做，直到你的身体温暖起来，睡意全消为止。接着，再回到呼吸上。</p>
<p>问题五：无法专注<br>在禅修前解决手边的纷争。如果解决不了，坚持禅修，不去理会问题，放下自我中心。</p>
<p>问题六：无聊<br>1、重新建立真实的正念；<br>正念看每一刻就像是这世上的第一次与唯一的一次。因此，再看一次。<br>2、观察你的心态。<br>注意看你无聊的状态。什么是无聊？无聊在哪里？它感觉像什么？它的成分是什么？它有任何生理上的感受吗？它对你的思维过程有什么作用？重新检视无聊，就像你以前从来不曾经历过那种状态一样。</p>
<p>问题七：恐惧<br>你可能在潜意识里设定了一个“检查即将发生的事”的程序。因此，当一个令人害怕的幻想出现时，定力就会锁定它，而幻想就以你专注的能量为食，并且成长。不要对抗恐惧，置身事外，让它自来自去。它只是幻想。</p>
<p>问题八：太勉强<br>不要急于看到结果，不要有太强烈的期待。只要以稳定而平衡的努力进行禅修即可。享受禅修，不要让它变成一个苦差或负担。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>视图更新的几个方法</title>
    <url>/2016/01/01/%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="1-layoutSubviews"><a href="#1-layoutSubviews" class="headerlink" title="1 layoutSubviews"></a>1 layoutSubviews</h3><h4 id="1-1-官方介绍"><a href="#1-1-官方介绍" class="headerlink" title="1.1 官方介绍"></a>1.1 官方介绍</h4><p>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>
<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>
<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>
<h4 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a>1.2 分析</h4><ul>
<li>只能重写layoutSubviews，不能主动调用！只能系统调用</li>
<li>想要调layoutSubviews方法，需要调setNeedsLayout或layoutIfNeeded</li>
<li>此方法作用是更加精细的控制子视图frame</li>
</ul>
<h4 id="1-3系统调用layoutSubviews时机"><a href="#1-3系统调用layoutSubviews时机" class="headerlink" title="1.3系统调用layoutSubviews时机"></a>1.3系统调用layoutSubviews时机</h4><p>简单的说更新布局总会重新触发layoutSubviews方法，但注意：init初始化不会触发layoutSubviews</p>
<ul>
<li>调用 addSubview 方法时会执行该方法。</li>
<li>设置并改变子视图的frame属性时会触发该方法。</li>
<li>滑动UIScrollView及继承与UIScrollView的控件时会触发该方法。</li>
<li>旋转屏幕时，会触发父视图的layoutSubviews方法。</li>
<li>设置并改变视图的frame属性时会触发父视图的layoutSubviews方法。</li>
</ul>
<h3 id="2-layoutIfNeeded"><a href="#2-layoutIfNeeded" class="headerlink" title="2 layoutIfNeeded"></a>2 layoutIfNeeded</h3><h4 id="2-1-官方介绍"><a href="#2-1-官方介绍" class="headerlink" title="2.1 官方介绍"></a>2.1 官方介绍</h4><p>Use this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks.</p>
<h4 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a>2.2 分析</h4><ul>
<li>如果需要刷新的haul，立即强制刷新接受者和它的子视图！</li>
<li>也就是说layoutIfNeeded之后有可能不刷新不调用layoutSubviews，例如view的frame等状态没有变化</li>
</ul>
<h4 id="2-3-参考"><a href="#2-3-参考" class="headerlink" title="2.3 参考"></a>2.3 参考</h4><ul>
<li><a href="https://stackoverflow.com/questions/1182945/how-is-layoutifneeded-used" target="_blank" rel="noopener">How is layoutIfNeeded used?</a></li>
</ul>
<h3 id="3-setNeedsLayout"><a href="#3-setNeedsLayout" class="headerlink" title="3 setNeedsLayout"></a>3 setNeedsLayout</h3><h4 id="3-1-官方介绍"><a href="#3-1-官方介绍" class="headerlink" title="3.1 官方介绍"></a>3.1 官方介绍</h4><p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.</p>
<h4 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2 分析"></a>3.2 分析</h4><ul>
<li>当需要重新布局时，在主线程调用setNeedsLayout，将设置一个标志位并立即返回</li>
<li>调用setNeedsLayout并不会立即更新视图，而是下次runloop更新视图</li>
<li>可以将多个视图更新合并在一起，提高性能</li>
<li>layoutSubviews一定会被调用</li>
</ul>
<h3 id="4-setNeedsDisplay"><a href="#4-setNeedsDisplay" class="headerlink" title="4 setNeedsDisplay"></a>4 setNeedsDisplay</h3><h4 id="4-1-官方介绍"><a href="#4-1-官方介绍" class="headerlink" title="4.1 官方介绍"></a>4.1 官方介绍</h4><p>You can use this method or the setNeedsDisplayInRect: to notify the system that your view’s contents need to be redrawn. This method makes a note of the request and returns immediately. The view is not actually redrawn until the next drawing cycle, at which point all invalidated views are updated.</p>
<p>Note:If your view is backed by a CAEAGLLayer object, this method has no effect. It is intended for use only with views that use native drawing technologies (such as UIKit and Core Graphics) to render their content.</p>
<p>If your view is backed by a CAEAGLLayer object, this method has no effect. It is intended for use only with views that use native drawing technologies (such as UIKit and Core Graphics) to render their content.<br>You should use this method to request that a view be redrawn only when the content or appearance of the view change. If you simply change the geometry of the view, the view is typically not redrawn. Instead, its existing content is adjusted based on the value in the view’s contentMode property. Redisplaying the existing content improves performance by avoiding the need to redraw content that has not changed.</p>
<h4 id="4-2-分析"><a href="#4-2-分析" class="headerlink" title="4.2 分析"></a>4.2 分析</h4><ul>
<li>当需要重绘调用setNeedsDisplay，将设置一个标志位并立即返回</li>
<li>调用setNeedsDisplay并不会立即更新视图，而是下次runloop更新视图</li>
<li>setNeedsDisplay一定会调用drawRect:方法</li>
<li>如果视图由caeagllayer对象支持，则此方法无效</li>
<li>如果只更改视图的几何图形，需要通过ContentMode的值进行调整的</li>
</ul>
<h4 id="4-3-参考"><a href="#4-3-参考" class="headerlink" title="4.3 参考"></a>4.3 参考</h4><ul>
<li><a href="https://stackoverflow.com/questions/14506968/setneedslayout-and-setneedsdisplay?r=SearchResults" target="_blank" rel="noopener">setNeedsLayout and setNeedsDisplay</a></li>
</ul>
<h3 id="5-other-question"><a href="#5-other-question" class="headerlink" title="5 other question"></a>5 other question</h3><ul>
<li><p>更改约束怎么实现动画？参考：<a href="https://stackoverflow.com/questions/12622424/how-do-i-animate-constraint-changes?r=SearchResults" target="_blank" rel="noopener">How do I animate constraint changes?</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[UIView animateWithDuration:5</span><br><span class="line">animations:^&#123;</span><br><span class="line">self._addBannerDistanceFromBottomConstraint.constant = -32;</span><br><span class="line">[self.view layoutIfNeeded]; // Called on parent view</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra?r=SearchResults" target="_blank" rel="noopener">setNeedsLayout vs. setNeedsUpdateConstraints and layoutIfNeeded vs updateConstraintsIfNeeded</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setNeedsUpdateConstraints makes sure a future call to updateConstraintsIfNeeded calls updateConstraints.</span><br><span class="line"></span><br><span class="line">setNeedsLayout makes sure a future call to layoutIfNeeded calls layoutSubviews.</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>解决快速push的崩溃</title>
    <url>/2016/03/06/%E8%A7%A3%E5%86%B3%E5%BF%AB%E9%80%9Fpush%E7%9A%84%E5%B4%A9%E6%BA%83/</url>
    <content><![CDATA[<ul>
<li>Crash详情：Can’t add self as subview crash</li>
<li><p>原理就是当前有跳转动画就抛弃其它VC</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation NSObject (Hook)</span><br><span class="line"></span><br><span class="line">#pragma mark hook</span><br><span class="line"></span><br><span class="line">+ (void)hookWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">Class class = [self class];</span><br><span class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">originalSelector,</span><br><span class="line">method_getImplementation(swizzledMethod),</span><br><span class="line">method_getTypeEncoding(swizzledMethod));</span><br><span class="line">if (didAddMethod) &#123;</span><br><span class="line">class_replaceMethod(class,</span><br><span class="line">swizzledSelector,</span><br><span class="line">method_getImplementation(originalMethod),</span><br><span class="line">method_getTypeEncoding(originalMethod));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>UINavigationController &amp; UIViewController</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;UINavigationController+Safely.h&quot;</span><br><span class="line">#import &quot;NSObject+Hook.h&quot;</span><br><span class="line"></span><br><span class="line">static char const * const kViewTransitionInProgress = &quot;kViewTransitionInProgress&quot;;</span><br><span class="line"></span><br><span class="line">@implementation UINavigationController (Safely)</span><br><span class="line"></span><br><span class="line">- (void)setViewTransitionInProgress:(BOOL)property &#123;</span><br><span class="line">NSNumber *number = [NSNumber numberWithBool:property];</span><br><span class="line">objc_setAssociatedObject(self, kViewTransitionInProgress, number , OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)viewTransitionInProgress &#123;</span><br><span class="line">NSNumber *number = objc_getAssociatedObject(self, kViewTransitionInProgress);</span><br><span class="line">return [number boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(pushViewController:animated:) swizzledSelector:@selector(safe_PushViewController:animated:)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(popViewControllerAnimated:) swizzledSelector:@selector(safe_PopViewControllerAnimated:)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(popToViewController:animated:) swizzledSelector:@selector(safe_PopToViewController:animated:)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(popToRootViewControllerAnimated:) swizzledSelector:@selector(safe_PopToRootViewControllerAnimated:)];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - hookSelecter</span><br><span class="line"></span><br><span class="line">- (NSArray *)safe_PopToRootViewControllerAnimated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (animated) &#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">NSArray *VCArray = [self safe_PopToRootViewControllerAnimated:animated];</span><br><span class="line">if (VCArray.count == 0) &#123;</span><br><span class="line">self.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">return VCArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)safe_PopToViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (animated)&#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">NSArray *VCArray = [self safe_PopToViewController:viewController animated:animated];</span><br><span class="line">if (VCArray.count == 0) &#123;</span><br><span class="line">self.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">return VCArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIViewController *)safe_PopViewControllerAnimated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (animated) &#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">UIViewController *VC = [self safe_PopViewControllerAnimated:animated];</span><br><span class="line">if (VC == nil) &#123;</span><br><span class="line">self.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">return VC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safe_PushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress == NO) &#123;</span><br><span class="line">[self safe_PushViewController:viewController animated:animated];</span><br><span class="line">if (animated) &#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Safely)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">method_exchangeImplementations(class_getInstanceMethod(self, @selector(safe_ViewDidAppear:)),</span><br><span class="line">class_getInstanceMethod(self, @selector(viewDidAppear:)));</span><br><span class="line">method_exchangeImplementations(class_getInstanceMethod(self, @selector(safe_ViewDidDisappear:)),</span><br><span class="line">class_getInstanceMethod(self, @selector(viewDidDisappear:)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safe_ViewDidAppear:(BOOL)animated &#123;</span><br><span class="line">if (self.navigationController) &#123;</span><br><span class="line">self.navigationController.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">[self safe_ViewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safe_ViewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">if (self.navigationController) &#123;</span><br><span class="line">self.navigationController.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">[self safe_ViewDidDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设备标识符</title>
    <url>/2017/01/24/%E8%AE%BE%E5%A4%87%E6%A0%87%E8%AF%86%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="利用keyChain和UUID永久获得设备的唯一标识"><a href="#利用keyChain和UUID永久获得设备的唯一标识" class="headerlink" title="利用keyChain和UUID永久获得设备的唯一标识"></a>利用keyChain和UUID永久获得设备的唯一标识</h4><p>&emsp;&emsp;将获取的UUID永久存储在设备的KeyChain中, 这个方法在应用第一次启动时, 将获取的UUID存储进KeyChain中, 每次取的时候, 检查本地钥匙串中有没有, 如果没有则需要将获取的UUID存储进去。当你重启设备, 卸载应用再次安装,都不影响, 只是当设备刷机时, KeyChain会清空, 才会消失, 才会失效。<br><br>&emsp;&emsp;PS：KeyChain使用工具 <a href="https://github.com/stoneros/SFHFKeychainUtils" target="_blank" rel="noopener">SFHFKeychainUtils</a><br></p>
<h3 id="其他方案介绍"><a href="#其他方案介绍" class="headerlink" title="其他方案介绍"></a>其他方案介绍</h3><h4 id="IDFA-广告标识符"><a href="#IDFA-广告标识符" class="headerlink" title="IDFA 广告标识符,"></a>IDFA 广告标识符,</h4><ul>
<li>由于广告是要赚钱的，所以广告标识符是唯一的。</li>
<li>iOS 10之后，如果用户手动限制广告跟踪（通用-&gt;隐私-&gt;广告-&gt;限制广告跟踪）的话，IDFA返回的都是0<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#import &lt;AdSupport/AdSupport.h&gt;</span><br><span class="line"></span><br><span class="line">NSString *IDFA = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</span><br><span class="line">//判断IDFA是否为空</span><br><span class="line">BOOL isEmpty = [[IDFA stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;] stringByReplacingOccurrencesOfString:@&quot;0&quot; withString:@&quot;&quot;].length;</span><br><span class="line">if (isEmpty) &#123;</span><br><span class="line">NSLog(@&quot;广告标识不为空：%@&quot;,IDFA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用MAC地址来识别设备，因为MAC地址也唯一的识别了一台设备并且不会被修改，不知道以后苹果会对此如何操作。"><a href="#使用MAC地址来识别设备，因为MAC地址也唯一的识别了一台设备并且不会被修改，不知道以后苹果会对此如何操作。" class="headerlink" title="使用MAC地址来识别设备，因为MAC地址也唯一的识别了一台设备并且不会被修改，不知道以后苹果会对此如何操作。"></a>使用MAC地址来识别设备，因为MAC地址也唯一的识别了一台设备并且不会被修改，不知道以后苹果会对此如何操作。</h4><h4 id="IDFV-identifierForVendor"><a href="#IDFV-identifierForVendor" class="headerlink" title="IDFV(identifierForVendor)"></a>IDFV(identifierForVendor)</h4><ul>
<li>identifierForVendor 应用开发商标识符, </li>
<li>一种应用加设备绑定产生的标识符，相当于是：Z(identifierForVendor) = X(某应用开发商) + Y(某设备)。</li>
<li>同一个应用开发商(com.yourcompany.)下所有的APP（例com.yourcompany.a 和 com.yourcompany.b）的IDFV是一样的，a UUID that may be used to uniquely identify the device, same across apps from a single vendor.</li>
<li>如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[UIDevice currentDevice] identifierForVendor] UUIDString];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><ul>
<li>Universally Unique Identifier,翻译过来就是通用唯一标识符。</li>
<li>是变化的，只是表示当前时间点这个设备的标识符！</li>
<li><a href="https://forums.developer.apple.com/thread/70837" target="_blank" rel="noopener">UUID could be changed ??</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 5 ;i++) &#123;</span><br><span class="line">NSLog(@&quot;time:%i , uuid: %@&quot;,i ,[[NSUUID UUID] UUIDString]);</span><br><span class="line">&#125;</span><br><span class="line">//time:0 , uuid: EBA63BC1-E9B2-4E01-B27F-1A28EF3E305C</span><br><span class="line">//time:1 , uuid: AD799085-ABAB-48D1-86BB-4C7444E40220</span><br><span class="line">//time:2 , uuid: BAA893A3-FC77-4E98-8523-9AC77E66503D</span><br><span class="line">//time:3 , uuid: 78FBB61A-E93A-44EC-BB25-85DF5B96FD71</span><br><span class="line">//time:4 , uuid: 4E1E419A-938A-474D-AE7B-88A865FC5930</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="UDID"><a href="#UDID" class="headerlink" title="UDID"></a>UDID</h4><ul>
<li>UDID的全名为 Unique Device Identifier :设备唯一标识符</li>
<li>UDID 已经被禁止了，上不了AppStore<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//[[UIDevice cuurrent] uniqueIdenfier]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="MAC-Address"><a href="#MAC-Address" class="headerlink" title="MAC Address"></a>MAC Address</h4><ul>
<li>被禁了</li>
</ul>
<h4 id="OpenUDID"><a href="#OpenUDID" class="headerlink" title="OpenUDID"></a>OpenUDID</h4><ul>
<li>被禁了</li>
<li>UDID是系统生成的，OpenUDID是通过第一个带有OpenUDID SDK包的App生成的</li>
</ul>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><a href="https://www.jianshu.com/p/b810d7e007ad" target="_blank" rel="noopener">iOS-理解 : UDID、UUID、IDFA、IDFV</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>防抓包策略</title>
    <url>/2017/08/13/%E9%98%B2%E6%8A%93%E5%8C%85%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="charles抓包原理简介"><a href="#charles抓包原理简介" class="headerlink" title="charles抓包原理简介"></a>charles抓包原理简介</h3><p>&emsp;&emsp;简单的理解是charles是中间商赚差价！没有中间商的时候，client是和server进行三次握手，握手成功，确认了眼神就可以通信了！有charles代理时，变成了client和charles三次握手，charles拿着client的随机数，自己选个算法那给client一个假证书！client为啥认这个假证书？因为开始代理前会让用户下载并信任一个根证书，charles颁发的其他证书,默认都会被系统所信任；所以clent就和charles愉快的聊了起来；charles这个中间商又怎么和server聊上的呢？也是三次握手，charlse拿着client给的认证信息和伪造的随机数信息，跟服务器说：我就是client，跟我聊吧！服务器看到证件齐全就把数据给charlse了，charlse再通过算法和随机数就能获取到服务器的真实数据</p>
<h3 id="几种方案"><a href="#几种方案" class="headerlink" title="几种方案"></a>几种方案</h3><h4 id="1-检测是否设置代理"><a href="#1-检测是否设置代理" class="headerlink" title="1. 检测是否设置代理"></a>1. 检测是否设置代理</h4><ul>
<li><p>原理是一般抓包是通过设置手机代理的方式进行的。因此可以通过CFNetwork获取系统代理信息，如果有代理就不发请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可参照 ASI源码ASIHTTPRequest的 configureProxies方法</span><br><span class="line">+ (BOOL)configureProxiesWithUrl:(NSURL *)url &#123;</span><br><span class="line">NSArray *proxies = nil;</span><br><span class="line">#if TARGET_OS_IPHONE</span><br><span class="line">NSDictionary *proxySettings = [NSMakeCollectable(CFNetworkCopySystemProxySettings()) autorelease];</span><br><span class="line">#else</span><br><span class="line">NSDictionary *proxySettings = [NSMakeCollectable(SCDynamicStoreCopyProxies(NULL)) autorelease];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">proxies = [NSMakeCollectable(CFNetworkCopyProxiesForURL((CFURLRef)url, (CFDictionaryRef)proxySettings)) autorelease];</span><br><span class="line"></span><br><span class="line">if (!proxies) &#123;</span><br><span class="line">// @&quot;Unable to obtain information on proxy servers needed for request&quot;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ([proxies count] &gt; 0) &#123;</span><br><span class="line">NSDictionary *settings = [proxies objectAtIndex:0];</span><br><span class="line">if ([settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]) &#123;</span><br><span class="line">// PAC 暂不考虑</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:(NSString *)kCFProxyTypeNone]) &#123;</span><br><span class="line">//没有设置代理</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
</li>
<li>简单，核心代码就两行</li>
<li>可靠，虽然ASI已经被废弃很长时间了，但据我所知依然有部分APP（xxx金融）无法彻底摆脱对ASI的依赖，所以代码稳定性还是有保证的。</li>
<li>检测频率低，由于设置手机代理，必然离开当前APP，即当APP在前台时检测一次，网络变化时检测一次即可满足大部分需求（ASI是通过设置request的标志位类降低请求频率的）</li>
<li>缺点</li>
<li>只能检测手机是否设置代理，如果路由器也设置代理则检测不到</li>
<li>用户使用VPN和PAC自动代理，也将被认为设置代理，无法请求网络</li>
<li>检测到代理就不发送请求的处理方式，过于强势；但我没想出来更好的方案</li>
<li>有人评论相关博客说没设置代理也会提示设置了代理，<a href="https://www.jianshu.com/p/4682aecf162d?open_source=weibo_search" target="_blank" rel="noopener">链接</a>，但此博客未校验PAC文件情况（ASI检测了PAC），所以这里是个潜在风险点</li>
</ul>
<h4 id="2-https-公钥认证"><a href="#2-https-公钥认证" class="headerlink" title="2. https + 公钥认证"></a>2. https + 公钥认证</h4><ul>
<li><p>内置公钥证书，不仅校验域名,也将证书中的公钥及其他信息也进行校验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+(AFSecurityPolicy*)customSecurityPolicy &#123;</span><br><span class="line">// 导入证书</span><br><span class="line">NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;cer&quot;];//证书的路径</span><br><span class="line">NSData *certData = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">/*</span><br><span class="line">AFSSLPinningModeCertificate //证书所有字段都一样才通过认证，</span><br><span class="line">AFSSLPinningModePublicKey   //只认证公钥那一段</span><br><span class="line">AFSSLPinningModeCertificate //更安全。但是单向认证不能防止“中间人攻击”</span><br><span class="line">*/</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span><br><span class="line">// 如果是需要验证自建证书，需要设置为YES</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line"></span><br><span class="line">//validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span><br><span class="line"></span><br><span class="line">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span><br><span class="line">//如置为NO，建议自己添加对应域名的校验逻辑。</span><br><span class="line">securityPolicy.validatesDomainName = YES;</span><br><span class="line">NSSet&lt;NSData*&gt; * set = [[NSSet alloc]initWithObjects:certData  , nil];</span><br><span class="line">securityPolicy.pinnedCertificates = set;</span><br><span class="line"></span><br><span class="line">return securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
</li>
<li>安全级别最高</li>
<li>相对简单，AFN都已经封装好了</li>
<li>频率低</li>
<li>缺点</li>
<li>运维和安全团队给不给公钥证书？</li>
<li>证书过期怎么办？预留接口？</li>
<li>多域名怎么处理？</li>
</ul>
<h4 id="3-CONNECT-请求方式-（无效）"><a href="#3-CONNECT-请求方式-（无效）" class="headerlink" title="3. CONNECT 请求方式 （无效）"></a>3. CONNECT 请求方式 （无效）</h4><ul>
<li>原理：把服务器作为跳板，先验证用户名和密码等信息，再让服务器代替用户去访问其它网页，之后把数据返回给用户</li>
<li>破解方法：charlse -&gt; Proxy Settings -&gt; Proxies HTTP Proxy中勾选Enable transparent HTTP proxying 来查看CONNECT请求</li>
</ul>
<h4 id="4-connectionProxyDictionary-无效"><a href="#4-connectionProxyDictionary-无效" class="headerlink" title="4. connectionProxyDictionary (无效)"></a>4. connectionProxyDictionary (无效)</h4><ul>
<li>使用NSURLSessionConfiguration的connectionProxyDictionary<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 无效</span><br><span class="line">NSURLSessionConfiguration *conf = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">conf.connectionProxyDictionary = @&#123;&#125;;</span><br><span class="line">// 网上还有提出hook方案来设置connectionProxyDictionary，但也无效</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://stackoverflow.com/questions/1598109/iphone-programmatically-read-proxy-settings?r=SearchResults" target="_blank" rel="noopener">iphone programmatically read proxy settings</a></li>
<li><a href="https://segmentfault.com/q/1010000010544277" target="_blank" rel="noopener">iOS上如何防止他人抓包获取信息</a></li>
<li><a href="https://www.jianshu.com/p/4682aecf162d?open_source=weibo_search" target="_blank" rel="noopener">iOS 如何防止https抓包(中间人攻击),及charles抓包原理</a></li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>超级快速阅读</title>
    <url>/2015/03/30/%E8%B6%85%E7%BA%A7%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<ol>
<li>梳理逻辑脉络，明确宏观定位</li>
<li>面对任何改变，缘脑都是拒绝的，因此万事开头难！除非亲身经历新的行为模式对自己有益无害，缘脑才会做出积极反应！而且当跑步跑到最愉悦的时候放弃，下次更能激发自己去跑步</li>
<li>制作思维导图，梳理出清晰的脉络！制作脑图的那点时间是非常值得，所以一定要做！</li>
<li>花5分钟快速浏览全书！得到的粗略印象有助于让缘脑感觉更加安全，也能大概知道哪些东西在哪里！在快速浏览过程中，我们的注意力主要集中在标题、副标题、插图、表格以及被加粗或斜体的关键字上</li>
<li>只有同时调动自己的左脑（左脑思维指的是分析思维）与右脑（右脑思维指的是有想象力和创造性的空间与形象思维），激活两种思维模式的时候，才能达到最佳的学习效果！</li>
<li>主动阅读再思考，学习新知识之前先激活既有的知识网络（即先想想以前的知识有什么用），要记住一条信息，必须将其与既有的知识网络结合在一起，与其从头开始纠结于细节问题，还不如从整体下手，由宏观到微观逐步深入学习。</li>
<li>最关键最难熬的其实是在同一水平层次上停滞不前的那段时间，即平台期。这段时间正是大脑建立神经连接的关键期，即平台期的坚持也是一直在进步的！</li>
<li>每个人从头开始学习新技能，都要经历4个阶段：A，虽无能力，却也尚未萌生明确的意识，即“不知己不能”；B，意识到自己某种能力的缺乏，即“知己不能之”；C，有能力，即“知己己能之”；D，意识不到自己有能力，即“不知己能之”</li>
<li>只要我们不断练习，总有一天这种新的技能会习惯成自然，变成我们潜意识下的行为方式。</li>
<li>阅读时候一定要学会提问，提问方向很多，例：A，5W1H；B，段落层面，结构；C，主体，矛盾利益，换位思考；D，SWOT；E，内因外因；F，和我关系，有什么用 等等</li>
<li>知道什么时候用速读，什么时候用精读，这个需要慢慢的练习！分块阅读，每块设定目标，当然要通读。。。</li>
<li>无聊的，没有插图和重点的密密麻麻的书，是练习速读的好材料！</li>
<li>可以计算自己的阅读速读，但仅仅有助于控制自己的阅读速读。</li>
<li>逐字逐句阅读法常见问题：A，低效阅读，越是读的慢的越是理解不充分，捕捉几个关键字就好；B,无法集中注意力，非常慢的逐字逐句阅读中其实在潜意识中开过的小差数不胜数，例：晃脑袋，伸懒腰，揉眼睛等等，大脑处理东西很快，当阅读速度赶不上大脑处理速度时就会开小差；C，视线的下意识游移，双眼天生就善于捕捉动态的东西，而我们自己是感觉不到的，就像眨眼绝大多数是感觉不到的，段落划分最好让眼睛一下就能看完一整行最高效，换行时间占到了整个阅读的三分之一；、</li>
<li>一种非常有效的辅助阅读方法：用铅笔或指尖辅助阅读，还记得眼睛会不自觉地捕捉运动的东西吧，而文字是静态的。而且用手介入了阅读，从感官上就感觉到了自己在读书，也就是仪式感。。。</li>
<li>逐步扩宽视线范围，首先，把视线聚焦到一行的第一个字，然后对焦第二个字，看看能否看清第一个字，然后聚焦第三个字，再看第一个字。。。。练习方法：用手指辅助时，试着从每行的第二个，三个字开始指引，而且提前一两个字把手指挪到第二行，这样为了读入剩余的信息，你的视线范围自然也会随之扩展。</li>
<li>一目十行的3-2-1练习：平时阅读的速度，阅读三分钟，做个标记，然后重复阅读直到2分钟阅读完这段篇幅，在重复阅读直到1分钟阅读完这段篇幅。这个练习要点在于速度，理解是次要的，但平时阅读正好相反！这个练习就是让大脑逐渐适应越来越快的阅读速度，当你以后以充分理解为前提而阅读时，你的大脑对速度的的感知就有了一个新的基准。</li>
<li>整行阅读练习，不透明白纸完全掩盖住某一行内容，然后快速向下拖动一行，紧接着马上遮回去，如此反复几次，越开越好，几次之后闭上眼睛尝试回放看到的画面，尝试回放整行内容</li>
<li>三级跳练习：是3-2-1练习的辅助方法，画几条线，在阅读的时候有意识的让自己的视线停留在这三条竖线上面，熟练以后可以只画两条</li>
<li>一定要画思维导图，思维导图符合大脑神经原理，其实作者把自己的思维转化为线性的文字，而读者从线性的文字中抽象出负责的思维导图，这才是有效的沟通呀！传统的类似这样的记笔记，其实是按照书中的顺序记录作者的观点，而制作思维导图则更具有调整性，文章脉络，提炼文字关键字等等都在主动思考，更能理解与记忆！最主要是省时间，在传统的线性笔记里面90%的文字都是多余的，还不如直接画图省事！！！！！</li>
<li>分类，按照一定节奏重复复习，组织关键词，产生联想更有助于记忆由于理解！一张图等于100个文字，且更容易理解！对特殊符号，颜色，大脑更容易集中注意力记忆</li>
<li>制作视觉卡牌的三个步骤：A，把握整体行文结构，记住任何一种设计都没有对错之分；B，抽取关键词，尽量避免摘抄大量完整的句子</li>
<li>画出要点间的逻辑关系。脑图不只是树形的，还可能是网状的，这就麻烦了，意味着叶子与叶子之间也会有逻辑问题，看来非得用专业的思维导图才行，脑图一定要横版</li>
<li>释放压力的技巧：自我暗示训练和渐进式肌肉放松；运动疗法；慢慢的深呼吸，慢慢调整节奏和摒气；倾听轻音乐；</li>
<li>3-2-1升级版：3分钟阅读，2分钟总结层次要点；2分钟阅读，1分钟总结层次要点</li>
<li>倒S曲线式快速浏览，慢慢读不一定懂得更多，简单的说就是一次读一行变成一次读两行，读三行等等，阅读完一定要记得弄脑图</li>
<li>第一天适应阅读，第二天拓宽视线范围，第三天练习3-2-1。。。第二周开始使用脑图再练习一周</li>
<li>理解是记忆的重要前提，联想建立在知识网络基础上，想要记住某些东西，一定要充分调动自己的五官，每个人都有自己的主导感官，我是听力，不过多多练习总是能调动更多的感官的</li>
<li>在学习总不断中断又继续的过程中消耗的精力是惊人的。学习控制自己的感官渠道:GEWAR , G：积极的心态；E，放松的状态；W，充足的动力；R：及时复习；A，集中注意力，需要随时随地的训练自己的感官；最好把枯燥的知识改编成有趣的故事</li>
<li>自律分成三部分：明确目标，坚持不懈和自我控制</li>
<li>避免一字一句默念的习惯</li>
<li>合理安排学习时间，学习时间越长获得知识越少！真正的学习理解并非与记忆同步，而是在休息的时候完成的，也就是连续学习40~50分钟以后，大脑已饱和，用一分钟快速总结消化吸收，快速梳理结构，然后休息5分钟，！所谓休息就是让大脑彻底放松，而不是换一个学科，换一个知识！一切关键在于不要给大脑输入新的东西！5分钟后只要稍微回忆一下，就可以开始继续学习了！</li>
<li>突发情况，例如：如果手头正在写文章，突然来了电话，怎么办？最好是先稍微总结梳理一下做到哪一步了，然后在接电话处理电话的事情！最好写个便签，随时注意切换工作状态，免得太忙的时候忘了</li>
<li>时间管理：A，订立具体明确的目标！都说谁知道5年以后世界是什么样子，但总是要想好自己怎么过的，我们一路奋战不是为了改变世界，只是不让世界改变我们！任何一段都是要有 短 中 长 期目标，不要急功近利！把自己的想法一字一句的记下来，把目标放在眼前，否则内心的惰性就会逐渐占据上风！不断地自我心理暗示目标，身体就会随之而动！设定目标原则：SMART,具体，可衡量，积极，现实和有时间限制； B，记录时间日记，抓住时间窃贼！先记录一下每天都做什么？花多长时间？先认清楚自己是什么样子再说，一定要真实，不管做的是应该还是不应该，浪费不浪费，现在要做的事情就是每天花多少时间都在干啥，而不是要马上立即开始做什么！   C，制定每日计划，利用前一天晚上睡觉前制定计划。大脑预演一遍，创造心理的潜在安全感，从而提高睡眠质量！D，列出重要的事务，每个任务都要问能不能朝目标更进一步，如果不能，尽量不做，即便必须要做也要尽量少的花费时间；E,分清事务轻重缓急，谨记28定律，只要一开始就完成最重要最麻烦的事情，剩下的事情就很简单了！四象限法则，而且一定要预留足够的时间，每天最后要检查完成状态，并总结！</li>
<li>前进，前进，不择手段的前进！</li>
<li>系统复习法打造超级记忆！第一次复习，10分钟；第二次，一天；第三次，一个星期；第四次复习，一个月；第五次复习，6个月；而且最好学习当天晚上复习一遍，至少4分之一的时间用来复习，脑图能提高复习效率！记忆文件夹复习法，例：周一1，周一2，周二1，周二2等，所有标记为1的都是前一天复习的内容（第二次复习），所有标记为2的都对应下一周复习内容（第三次复习）</li>
</ol>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能的ios应用开发</title>
    <url>/2016/10/07/%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84ios%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="1-移动应用的性能"><a href="#1-移动应用的性能" class="headerlink" title="1 移动应用的性能"></a>1 移动应用的性能</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><ol>
<li>内存RAM：平均值、泄漏和峰值</li>
<li>耗电量：CPU、硬件(位置等)</li>
<li>初始化时间：mian前和main后</li>
<li>执行速度：</li>
<li>响应速读：</li>
<li>本地存储：更新频率、异常、清除策略</li>
<li>互操作性：</li>
<li>网络环境：</li>
<li>带宽</li>
<li>数据刷新：刷新频率*数据量，流量</li>
<li>多用户支持：切换迅速、数据隔离</li>
<li>单点登录：数据共享和同步</li>
<li>安全：</li>
</ol>
<h2 id="应用性能分析"><a href="#应用性能分析" class="headerlink" title="应用性能分析"></a>应用性能分析</h2><ol>
<li>采样</li>
<li>埋点</li>
</ol>
<h2 id="测量"><a href="#测量" class="headerlink" title="测量"></a>测量</h2><ol>
<li>构建和发布：一键打包</li>
<li>可测试性：单元测试、功能测试</li>
<li>设置崩溃报告：</li>
<li>对应用埋点：</li>
<li>日志：日志贯穿生命周期，埋点应只在开发特定阶段</li>
</ol>
<h1 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h1><h2 id="内存消耗"><a href="#内存消耗" class="headerlink" title="内存消耗"></a>内存消耗</h2><h3 id="栈大小"><a href="#栈大小" class="headerlink" title="栈大小"></a>栈大小</h3><p>每个线程都有专属栈空间，栈大小影响因素：</p>
<ol>
<li>方法数，每个方法调用其它方法都会入栈，<a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">Tail Call</a></li>
<li>一个方法中最多可用变量数</li>
<li>视图层级深度</li>
</ol>
<h3 id="堆大小"><a href="#堆大小" class="headerlink" title="堆大小"></a>堆大小</h3><ul>
<li>每个进程的所有线程共享一个堆。</li>
<li>从栈复制到堆，和从堆复制到栈，都是代价昂贵的操作</li>
<li>不要忽视 didReceiveMemoryWarning信号</li>
</ul>
<h2 id="内存管理模式"><a href="#内存管理模式" class="headerlink" title="内存管理模式"></a>内存管理模式</h2><ul>
<li>引用计数：MRC 和 ARC</li>
<li>自动释放： @autoreleasepool</li>
<li>引用类型：assign，retain，copy，atomic，nonatomic，readonly，readwrite以及strong，weak</li>
<li>僵尸对象：scheme -》 edit sheme -》 enable zombie objects</li>
<li>循环引用： delegate（例如animation）和block，解决办法：临时变量，手动置nil 和 weak处理；使用NSTimer和NSThread总应该通过间接层（WeakProxy）实现销毁</li>
<li>观察者：addObserver方法不会持有观察、被观察对象的强引用。想想<a href="https://www.jianshu.com/p/e59bb8f59302" target="_blank" rel="noopener">KVO原理</a>？再想想为啥没移除为crash？ 和通知中心一样，避免的方法就是中间加层</li>
<li>某方法接收NSError*<em>参数时，必须写成 NSError </em> __autoreleasing *error</li>
<li>警惕id类型</li>
<li>合理时候用全局变量：没有被其它对象持有、不是常量、整个应用只有一个而不是每个组件一个</li>
<li>单例：<a href="https://objccn.io/issue-13-2/" target="_blank" rel="noopener">避免滥用单例</a></li>
<li><a href="https://blog.csdn.net/linshaolie/article/details/47037941" target="_blank" rel="noopener">iOS依赖注入</a></li>
<li>禁用ARC，使用retain找到神秘持有者<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if !__has_feature(objc_arc)</span><br><span class="line">-(id) retain &#123;</span><br><span class="line">NSLog(@&quot;%s  %@&quot;, __PRETTY_FUNCTION__, [NSThread callStackSymbols]);</span><br><span class="line">return [super retain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码感知"><a href="#代码感知" class="headerlink" title="代码感知"></a>代码感知</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 已用内存</span><br><span class="line">vm_size_t getUsedMemory() &#123;</span><br><span class="line">task_basic_info_data_t info;</span><br><span class="line">mach_msg_type_number_t size = sizeof(info);</span><br><span class="line">kern_return_t kerr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br><span class="line">if (kerr == KERN_SUCCESS) &#123;</span><br><span class="line">return info.resident_size;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 可用内存</span><br><span class="line">vm_size_t getFreeMemory() &#123;</span><br><span class="line">mach_port_t host = mach_host_self();</span><br><span class="line">mach_msg_type_number_t size = sizeof(vm_statistics_data_t) / sizeof(integer_t) ;</span><br><span class="line">vm_size_t pagesize;</span><br><span class="line">vm_statistics_data_t vmstat;</span><br><span class="line">host_page_size(host, &amp;pagesize);</span><br><span class="line">host_statistics(host, HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;size);</span><br><span class="line">return vmstat.free_count * pagesize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-能耗"><a href="#3-能耗" class="headerlink" title="3 能耗"></a>3 能耗</h1><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><ul>
<li>尽量少的，快的处理数据</li>
<li>优化静态编译处理，例如tableview设备上可渲染N条数据，则处理3N数据而不是全部数据，快速滑动时等速度降下来再处理等</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li>蜂窝网络耗电高于wifi，因蜂窝数据连接会定期扫描以寻找更强信号。</li>
<li>无网时，应推迟后续网络请求，知道网络恢复。实现方案：待定,但感觉没有直接返回错误，网络恢复重要接口再请求好</li>
<li>减少Reachability网络状态检查频次。</li>
<li>数据源更新频率低时，减少重复请求频次：最简单的算法：数据相同，请求间隔累加</li>
<li>应定期集中短暂的使用网络，而不是持续的保持活动的数据流，只有这样，网络硬件才有机会关闭</li>
</ul>
<h2 id="定位管理器和GPS"><a href="#定位管理器和GPS" class="headerlink" title="定位管理器和GPS"></a>定位管理器和GPS</h2><ul>
<li>distanceFilter 移动最小距离，不会减少GPS接收器使用，但会影响CPU的使用</li>
<li>desiredAccuracy 影响使用天线个数，精度高用的天线多，更耗能</li>
<li>尽量关闭位置跟踪。在需要跟踪时调用startUpdatingLocation，不需要时调stopUpdatingLocation</li>
<li>后台长距离持续跟踪用 startMonitoringSignificantLocationChanges，精度跟desiredAccuracy和distanceFilter无关。比较好的办法是，前台用startUpdatingLocation，后台用startMonitoringSignificantLocationChanges</li>
<li>因缺乏资源，后台应用被关闭。此状况下一旦发生位置变化，应用会重启，因为需要重新初始化位置监听<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">if (launchOptions[UIApplicationLaunchOptionsLocationKey]) &#123;</span><br><span class="line">// 重启</span><br><span class="line">[LocaitonManager startMonitoringSignificantLocationChanges];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="屏幕"><a href="#屏幕" class="headerlink" title="屏幕"></a>屏幕</h2><ul>
<li>前台使用动画，一旦程序进入后台应立即暂停动画</li>
<li>视频播放，使用UIApplication对象的idleTimerDisabled = YES 实现常亮，当前也可根据前后台切换来设置是否获取锁</li>
<li>多屏幕，当外部屏幕播放电影等时手机屏幕可保留最基本控制，以减少屏幕更新，延长电池使用</li>
</ul>
<h2 id="其它硬件"><a href="#其它硬件" class="headerlink" title="其它硬件"></a>其它硬件</h2><ul>
<li>蓝牙、相机、扬声器、麦克风等，原则是当应用处于前台才与这些硬件交互，应用处于后台应停止交互</li>
</ul>
<h2 id="分析电量使用"><a href="#分析电量使用" class="headerlink" title="分析电量使用"></a>分析电量使用</h2><ul>
<li>instruments</li>
<li>精准电量：monsoon solutions 工具</li>
</ul>
<h2 id="代码感知-1"><a href="#代码感知-1" class="headerlink" title="代码感知"></a>代码感知</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 电池感知，ios8前只能精确动5%，以后可精确到1%</span><br><span class="line">- (BOOL)shouldProceedWithMinLevel:(NSUInteger)minLevel &#123;</span><br><span class="line">UIDevice *device = [UIDevice currentDevice];</span><br><span class="line">device.batteryMonitoringEnabled = YES;</span><br><span class="line">UIDeviceBatteryState state = device.batteryState;</span><br><span class="line">// 充电或满电</span><br><span class="line">if (state == UIDeviceBatteryStateCharging || state == UIDeviceBatteryStateFull) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">NSUInteger batteryLevel = (NSUInteger)(device.batteryLevel * 100);</span><br><span class="line">if (batteryLevel &gt;= minLevel) &#123;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// cpu利用率</span><br><span class="line">- (float)appCPUUsage &#123;</span><br><span class="line">kern_return_t kr;</span><br><span class="line">task_info_data_t info;</span><br><span class="line">mach_msg_type_number_t infoCount = TASK_INFO_MAX;</span><br><span class="line">kr = task_info(mach_host_self(), TASK_BASIC_INFO, (task_info_t)info, &amp;infoCount);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">thread_array_t thread_list;</span><br><span class="line">mach_msg_type_number_t thread_count;</span><br><span class="line">thread_info_data_t thinfo;</span><br><span class="line">mach_msg_type_number_t thread_info_count;</span><br><span class="line">thread_basic_info_t basic_info_th;</span><br><span class="line">kr = task_threads(mach_host_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">long total_time = 0;</span><br><span class="line">long total_userTime = 0;</span><br><span class="line">CGFloat total_cpu = 0;</span><br><span class="line">int j;</span><br><span class="line">for (j = 0; j &lt; (int)thread_count; j++) &#123;</span><br><span class="line">thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">kr = thread_info(thread_list[j], THREAD_BASIC_INFO, (thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line">if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">total_time = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">total_cpu = total_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vm_deallocate(mach_host_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">return total_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-并发编程"><a href="#4-并发编程" class="headerlink" title="4 并发编程"></a>4 并发编程</h1><h2 id="线程开销"><a href="#线程开销" class="headerlink" title="线程开销"></a>线程开销</h2><ul>
<li>主线程栈空间1M，二级线程默认分配512K的栈空间（可改），但某个时间点的实际使用栈空间要小的多</li>
<li>创建线程很耗时，平局在30毫秒左右，因多次上下文切换</li>
<li>dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层线程池上限是64个，如果线程池满了，那么后续的任务会被阻塞，有可能crash</li>
</ul>
<h2 id="操作和队列"><a href="#操作和队列" class="headerlink" title="操作和队列"></a>操作和队列</h2><ul>
<li><a href="http://www.cocoachina.com/ios/20140520/8485.html" target="_blank" rel="noopener">GCD、NSOperationQueue 和 NSthread简介</a></li>
<li>锁的应用</li>
<li>GCD可以设置优先级，也可以cancel</li>
<li>cancel都是设置标志位，对已开始的无效</li>
</ul>
<h2 id="线程安全的代码"><a href="#线程安全的代码" class="headerlink" title="线程安全的代码"></a>线程安全的代码</h2><ul>
<li>原子性 atomic 默认的，但会增加开销</li>
<li>@synchronized 同步块，可以创建信号量并进入临界区，过度使用@synchronized会拖慢运行速度，因为任何时间都只有一个线程在临界区内执行。</li>
<li>锁：NSLock，NSRecursiveLock，NSCondition</li>
<li>将读写锁应用于并发读写 dispatch_barrier 阻塞操作用于写</li>
<li>使用不可变实体，不只是NSArray等，也包括怎么保证自定义类的不可变性？使用建造者模式</li>
<li>使用集中的状态更新服务</li>
<li>swift中尽量不使用类。</li>
<li>冰棒不可变实体：即使用一个frozen的bool属性标记此对象是否可变，所有属性setter方法均检查frozen来判断是否可更改。</li>
<li>状态观察与通知：RAC</li>
<li>异步优于同步，使用promise是最好的方式</li>
</ul>
<h1 id="应用的生命周期"><a href="#应用的生命周期" class="headerlink" title="应用的生命周期"></a>应用的生命周期</h1><h2 id="AppDelegate"><a href="#AppDelegate" class="headerlink" title="AppDelegate"></a>AppDelegate</h2><h2 id="应用启动"><a href="#应用启动" class="headerlink" title="应用启动"></a>应用启动</h2><ul>
<li>第一次安装使用，反复拆解任务原则：确定在展示UI前必须执行的任务，按顺序执行，将任务分为必须在main执行和可在其它线程执行，其它任务可以在加载UI后执行或异步执行</li>
<li>冷启动：尽可能少的请求和展示数据，适当增加提示</li>
<li>热启动：</li>
<li>升级后启动：注意缓存问题</li>
</ul>
<h2 id="推送通知"><a href="#推送通知" class="headerlink" title="推送通知"></a>推送通知</h2><ul>
<li>远程通知：静默更新，富文本样式，通知调用顺序，当前app状态</li>
<li>先静默下载更新，在本地通知用户打开，可以更快显示内容</li>
</ul>
<h2 id="后台拉取"><a href="#后台拉取" class="headerlink" title="后台拉取"></a>后台拉取</h2><ul>
<li>application：performFetchWith</li>
<li>任务必须在30秒内完成，尽量少拉取没用的东西，使用NSURLSession</li>
<li>后台拉取时其它挂起的队列也可能恢复，如果其它队列超时可能crash</li>
<li>后台拉取间隔受系统因素影响，不要过分依赖起规律</li>
</ul>
<h1 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h1><h2 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h2><ul>
<li>VC生命周期：init—&gt;loadView—&gt;viewDidLoad—&gt;viewWillApper—&gt;viewDidApper—&gt;viewWillDisapper—&gt;viewDidDisapper—&gt;viewWillUnload-&gt;viewDidUnload—&gt;dealloc</li>
<li>保持VC轻量：只是纽带，不是存放所有逻辑的地方</li>
<li>不要在VC中写动画：独立动画类，VC作为参数</li>
<li>使用数据源和委托协议，将代码按照数据检索、数据更新和其它业务逻辑进行分离，VC只能用来选择正确的视图，并将他们链接到供应源。</li>
<li>VC响应来自视图的事件，然后链接到数据接收器</li>
<li>VC响应系统级UI相关事件，例如方向和低内存等</li>
<li>不要编写自定义的init代码</li>
<li>VC中不要代码布局UI，也不要把所有布局都放到VC里</li>
<li>创建BaseVC</li>
<li>也可使用category创建可复用代码</li>
<li>如果载入时间过长，可加入等待动画，减少用户焦虑</li>
</ul>
<h3 id="视图加载"><a href="#视图加载" class="headerlink" title="视图加载"></a>视图加载</h3><ul>
<li>loadView 自定义UI的注意事项：将view属性设置到视图层级的根上，确保视图正被其它VC共享；不要调用super loadView</li>
<li>尽量不要重写loadView</li>
<li>viewDidLoad要尽可能短</li>
</ul>
<h3 id="视图层级"><a href="#视图层级" class="headerlink" title="视图层级"></a>视图层级</h3><ul>
<li>视图结构和渲染步骤：1，构造子视图；2，计算并提供约束；3，为子视图递归执行步骤1和2；4，递归渲染</li>
<li>减少层级，异步计算</li>
</ul>
<h3 id="视图可见性"><a href="#视图可见性" class="headerlink" title="视图可见性"></a>视图可见性</h3><ul>
<li>viewWillAppear 过渡动画未开始，不要启动任何视图动画</li>
<li>viewDidAppear VC展示且过渡动画结束，启动视图动画</li>
<li><p>viewWillDisappear 判断出栈还是入栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated &#123;</span><br><span class="line">NSInteger index = [self.navigationController.viewControllers indexOfObject:self];</span><br><span class="line">if (index == NSNotFound) &#123;</span><br><span class="line">// 出栈，销毁</span><br><span class="line">&#125;else &#123;</span><br><span class="line">// 入栈，保存，暂停</span><br><span class="line">&#125;</span><br><span class="line">[super viewWillDisappear:animated];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>viewDidAppear</p>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul>
<li>尽量减少在mian线程中所做的工作</li>
<li>避免较大的nib或故事板，拆分成小的，按需加载</li>
<li>避免多层嵌套，保持扁平化</li>
<li>延迟加载和重用</li>
<li>对于复杂的UI而言，最好使用自定义绘图，drawrect</li>
<li>减少cleanColor使用，减少透明度使用，减少圆角使用</li>
</ul>
<h3 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h3><ul>
<li>自定义字体，检查宽度或高度等都是很费时的任务</li>
<li>纯文本可以使用自定义绘图</li>
</ul>
<h3 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h3><h3 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h3><ul>
<li>使用 imageName：加载已知图像</li>
<li>小图，复用，使用资源包 .xcassets</li>
<li>一次性大图用完就扔，使用imageWithContentsOfFile</li>
<li>使用SDWebImage,不要使用硬编码</li>
<li>尽量不要压缩或拉伸图像，图像多大显示多大性能最高</li>
<li>处理图像最好在一个单独的专用队列中进行。</li>
</ul>
<h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><ul>
<li>使用cell的重用机制</li>
<li>尽量避免动态高度单元格，如果必须使用动态高度，标记哪些是脏的，减少不必要渲染</li>
<li>使用自定义视图重用cell是避免调用 layoutIfNeeded每次都布局</li>
<li>避免透明子视图</li>
<li>快速滚动使用外壳cell（即模糊效果的cell），滚动快结束再刷新可视范围cell</li>
<li>避免渐变、图像缩放以及任何屏幕外的绘制。</li>
</ul>
<h3 id="自定义视图"><a href="#自定义视图" class="headerlink" title="自定义视图"></a>自定义视图</h3><ul>
<li>drawRect方法不但可以使用CoreGraphics，也可以初始化再子视图调drawInRect方法绘制</li>
</ul>
<h3 id="自动布局"><a href="#自动布局" class="headerlink" title="自动布局"></a>自动布局</h3><ul>
<li>尽量用</li>
</ul>
<h1 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h1><h2 id="指标和测量"><a href="#指标和测量" class="headerlink" title="指标和测量"></a>指标和测量</h2><h3 id="DNS查找时间"><a href="#DNS查找时间" class="headerlink" title="DNS查找时间"></a>DNS查找时间</h3><ul>
<li>发起链接得第一步是DNS查找</li>
<li>减少查找时间：减少专有域名数量，启动时只链接关键域名，</li>
</ul>
<h3 id="SSL握手时间"><a href="#SSL握手时间" class="headerlink" title="SSL握手时间"></a>SSL握手时间</h3><ul>
<li>减少应用发起的连接数；为所有的https请求添加头Connection:keep-alive; 使用域分片</li>
</ul>
<h3 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h3><ul>
<li>Wifi，4G,3G,2G</li>
<li>设计时考虑不同网络的可用性；出现失败时，在随机的、以指数增长的延迟后进行重试，并设置最多重试次数；设定强制刷新之间的最短时间；监控网络状态变化但不要缓存网络状态；基于网络类型下载内容；预下载预缓存；</li>
</ul>
<h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><ul>
<li>延迟 = 请求总时间 - 服务器话费时间</li>
</ul>
<h2 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><ul>
<li>不要为每个操作都进行一次请求，使用批量请求</li>
<li>使用http缓存头设置正确的缓存级别</li>
<li>减少不必要的请求，如果有必要可限定请求间隔，请求重复数据可延长间隔，请求失败以指数增长延长重试间隔</li>
</ul>
<h3 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h3><ul>
<li>压缩</li>
<li>PB？</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="网络链接调节器"><a href="#网络链接调节器" class="headerlink" title="网络链接调节器"></a>网络链接调节器</h3><h3 id="AT-amp-T应用资源优化器"><a href="#AT-amp-T应用资源优化器" class="headerlink" title="AT&amp;T应用资源优化器"></a>AT&amp;T应用资源优化器</h3><h3 id="charles-whistle"><a href="#charles-whistle" class="headerlink" title="charles || whistle"></a>charles || whistle</h3><h1 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h1><h2 id="深层链接"><a href="#深层链接" class="headerlink" title="深层链接"></a>深层链接</h2><ul>
<li>使用统一资源标识符，其链接到应用内的特定位置</li>
</ul>
<h2 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h2><ul>
<li>不可控：传递不重要的消息</li>
<li>避免大数据，</li>
<li>进入后台后最好清除剪切板</li>
</ul>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><ul>
<li>匿名用户设备id || 用户认证单点登录</li>
<li>使用https</li>
<li>本地敏感数据加密</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>高效程序员的45个习惯</title>
    <url>/2016/07/31/%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<h4 id="态度决定一切"><a href="#态度决定一切" class="headerlink" title="态度决定一切"></a>态度决定一切</h4><ol>
<li>做事，把矛头对准问题的解决办法，而不是人，这是真正有用处的正面效应</li>
<li>欲速则不达，要投入时间和精力保持代码的整洁、敞亮</li>
<li>对事不对人，让我们骄傲的应该是解决了问题，而不是比较出谁的主意更好</li>
<li>排除万难，奋勇前进，要诚实有勇气去说出实情，有时候这样做很困难，所以我们需要有足够的勇气</li>
</ol>
<h4 id="学无止境"><a href="#学无止境" class="headerlink" title="学无止境"></a>学无止境</h4><ol start="5">
<li>跟踪变化，不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯</li>
<li>对团队投资，通过午餐会议可以增进每个人的知识和技能，并帮助大家聚集在一起进行沟通交流。唤起人们对技术和技巧的激情，将会对项目大有裨益。</li>
<li>懂得丢弃，在学习一门新技术的时候，要丢去会阻止你前进的旧习惯。毕竟，汽车要比马车强得多。</li>
<li>打破沙锅问到底，不能只满足与别人告诉你的表面现象。要不停地提问直到你明白问题的根源。</li>
<li>把握开发节奏，保持时间之间稳定重复的间隔，更容易解决常见的重复任务</li>
</ol>
<h4 id="交付用户想要的软件"><a href="#交付用户想要的软件" class="headerlink" title="交付用户想要的软件"></a>交付用户想要的软件</h4><ol start="10">
<li>让客户做决定，开发者、经理或者业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。</li>
<li>让设计指导而不是操纵开发，设计指引你向正确的方向前进，它不是殖民地，它不应该标识具体的路线。你不要被设计（或者设计师）操控。</li>
<li>首先决定什么是你需要的，接着为这些具体的问题评估使用技术，对任何要使用的技术，多问一些挑剔的问题，并真实地作出回答。新技术就应该像是新的工具，可以帮助你更好地工作，她自己不应该是成为你的工作。</li>
<li>保持可以发布，保证你的系统随时可以编译、运行、测试并立即部署。</li>
<li>提早集成，频繁集成，代码集成式主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。</li>
<li>提早实现自动化部署，使用部署系统安装你的应用，在不同的机器上用不同的配置文件测试依赖问题。质量保证人员要像测试应用一样测试部署。</li>
<li>使用演示获得频繁反馈，在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有客户，给他们演示最新完成的功能，积极获得他们的反馈。</li>
<li>使用短迭代，增量发布，发布带有最小却可用功能块的产品。每个增量开发中，使用1~4周左右的迭代周期。</li>
<li>固定的价格就意味着背叛承诺，让团队和客户一起，真正地在当前项目中工作，做具体实际的评估。由客户控制他们要的功能和预算。</li>
</ol>
<h4 id="敏捷反馈"><a href="#敏捷反馈" class="headerlink" title="敏捷反馈"></a>敏捷反馈</h4><ol start="19">
<li>守护天使，好的单元测试能够为你的代码问题提供及时的警报。如果没有到位的单元测试，不要进行任何的设计和代码修改。</li>
<li>先用它再实现它，使用测试驱动开发作为设计工具，它会为你带来更简单更实效的设计。</li>
<li>环境中运行单元测试。要积极地寻找问题，为不是等问题来找你。</li>
<li>自动验收测试，为核心的业务逻辑创建测试，让你的客户单独验证这些测试，要让它们像一般的测试一样可以自动运行。</li>
<li>度量真实的进度，不要用不恰当的度量来欺骗自己或者团队。要评估那些需要完成的待办事项。</li>
<li>倾听用户的声音，每一个抱怨的背后都隐藏了一个事实，找出真相，修复真正的问题。</li>
</ol>
<h4 id="敏捷编码"><a href="#敏捷编码" class="headerlink" title="敏捷编码"></a>敏捷编码</h4><ol start="25">
<li>代码要清晰地表达意图，向代码阅读者明确表明你的意图。可读性差的代码一点也不聪明。</li>
<li>用代码沟通，使用细心选择的、有意义的命名。用注释描述代码意图和约束。注释不能替代优秀的代码。</li>
<li>动态评估取舍，考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。</li>
<li>增量式编程，在很短的编辑/构建/测试循环中编写代码，这要比花费长时间仅仅做编写代码的工作好得多。可以创建更加清晰、简单、易于维护的代码。</li>
<li>保持简单，除非有不可辩驳的原因，否则不要使用模式、原则和高难度技术之类的东西。</li>
<li>编写内聚的代码，让类的功能尽量集中，让组件尽量小。要避免创建很大的类或组件，也不要创建无所不包的大杂烩类。</li>
<li>告知，不要询问，不要抢别的对象或者是组件的工作。告诉它做什么，然后盯着你自己的指责就好了。</li>
<li>根据契约进行替换，通过替换遵循接口契约的类，来添加并改进功能特性。要使用更多的委托而不是继承。</li>
</ol>
<h4 id="敏捷调试"><a href="#敏捷调试" class="headerlink" title="敏捷调试"></a>敏捷调试</h4><ol start="33">
<li>记录问题解决日志，保留解决方案是修复问题过程的一部分，以后发生相同或类似问题时，就可以很快找到并使用了。</li>
<li>警告就是错误，签入带有警告的代码，就跟签入有错误或者没有通过测试的代码一样，都是极差的做法。签入构建工具中的代码不应该产生任何警告信息。</li>
<li>对问题各个击破，在解决问题时，要将问题域与周边隔离开。特别是在大型应用中。</li>
<li>报告所有的异常，不要将它们压制不管，就算是临时这样做也不行，在写代码时要估计到会发生的问题。</li>
<li>提供有用的错误信息，提供更多易于查找错误细节的方式，发生问题时，要展示出尽量多的支持细节，不过别让用户陷入其中。</li>
</ol>
<h4 id="敏捷协作"><a href="#敏捷协作" class="headerlink" title="敏捷协作"></a>敏捷协作</h4><ol start="38">
<li>定期安排会面时间。使用立会(站着开的会议)可以让团队达成共识。保证会议短小精悍不跑题。</li>
<li>架构师必须写代码。优秀的设计从积极的程序员那里开始演化。积极的编程可以带来深入的理解。不要使用不愿意编程的架构师——不知道系统的真实情况。是无法展开设计的。</li>
<li>实行代码集体所有制。让开发人员轮换完成系统不同领域中不同模块的不同任务。</li>
<li>成为指导者。分享自己的知识很有趣——付出的同时便有收获。还可以激励别人获得更好的成果，而且提升了整个团队的实力。</li>
<li>允许大家自己想办法。指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西。</li>
<li>准备好后再共享代码。绝对不要提交尚未完成的代码。故意签入编译未通过或是没有通过单元测试的代码，对项目来说，应该被视作为玩忽职守的犯罪行为。</li>
<li>做代码复查。对于提升代码质量和降低错误率来说，代码复查是无价之宝。如果以正确的方式进行，复查可以产生非常实用而高效的成果。要让不同的开发人员在每个任务完成后复查代码。</li>
<li>及时通报进展与问题。发布进展状况，新的想法和目前正在关注的主题。不要等着别人来问项目状态如何。</li>
</ol>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
</search>
