<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[曾国藩家书]]></title>
    <url>%2F2019%2F07%2F31%2F%E6%9B%BE%E5%9B%BD%E8%97%A9%E5%AE%B6%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[每夜早眠，起亦渐早 节劳，节欲，节饮食，谨当时时省记 君子之立志也，有民胞物与之量，有内圣外王之业，而后不忝于父母之所生，不愧为天地之完人 明德新民止至善，皆我分内事也 格物，致知之事也。诚意，力行之事也 倭艮峰先生则诚意工夫极严，每日有日课册。一日之中，一念之差，一事之失，一言一默，皆笔之于书，书皆楷字。三月则订一本，自乙未年起，今三十本矣。 盖明师益友，重重夹持，能进不能退也。 大抵第一要除骄傲气习，中无所有，而夜郎自大，此最坏事 须有志有恒，乃有成就耳 进德，则孝弟仁义是也；修业，则诗文作字是也。此二者由我作主，得尺则我之尺也，得寸则我之寸也。今日进一分德，便算积了一升谷；明日修一分业，又算馀了一文钱；德业并增，则家私日起 吾人为学，最要虚心 故吾人用功，力除傲气，力戒自满，毋为人所冷笑，乃有进步也 凡遇牢骚欲发之时，则反躬自思，吾果有何不足，而蓄此不平之气，猛然内省，决然去之 不宜露头角于外 劝宜息心忍耐 弟性褊急似余，恐拂郁或生肝疾，幸息心忍耐为要 古之成大事者，规模远大与综理密微，二者阙一不可 等差不紊，行之可久，斯则器局宏大，无有流弊者耳。 保养身体，肝郁最伤人 凡人作一事，便须全副精神往在此一事，首尾不懈。不可见异思迁，做这样想那样，坐这山望那山。人而无恒①，终身一无所成 带勇之法，以体察人才为第一，整顿营规、讲求战守次之 身体虽弱，却不宜过于爱惜。精神愈用则愈出，阳气愈提则愈盛。每日作事愈多，则夜间临睡愈快活。若存一爱惜精神的意思，将前将却，奄奄无气，决难成事 古来言凶德致败者约有二端：曰长傲，曰多言 凡心中不可有所恃，心有所恃则达于面貌 注意平和二字 大抵胸中抑郁，怨天尤人，不特不可以涉世，亦非所以养德，不待无以养德，亦非所以保身。中年以后，则肝肾交受其苟，尽郁而不畅则伤木，心火站烁则伤水 故于两弟时时以平和二字相勖③，幸勿视为老生常谈，至嘱至嘱！ 家中后辈子弟，体弱学射，最足保养，起早尤千金妙方，长寿金丹也 早起乃健身之妙方 骄矜之气，兹为可虑 宜平骄矜之气 婉陈而切谏之 总以除傲字为第一义， 须戒傲惰二字 力戒傲字，以儆无恒之弊，近来又力戒惰字。 非傲即惰，二者必居其一。 保养之法，亦惟在慎饮食，节嗜欲，断不在多服药也 凡畏人不敢妄议论者，谨慎者也。凡好讥评人短者，骄傲者也 志得意满，毫无畏忌，开口议人短长，即是极骄傲耳 言戒骄字，以不轻非笑人①为第一义 日中则昃，月盈则亏， 管子云：“斗斜满则人概③之，人满则天概之。”余谓天概之无形，仍假手于人以概之。 从古帝王将相，无人不由自强自立做出 近来见得天地之道，刚柔互用，不用偏废，太柔则靡①，太刚则折，刚非暴戾之谓也，强矫而已。柔非卑弱之谓也，谦退而已。趋事赴公，则当强矫，争名逐利，则当谦退，开创家业，则当强矫，守成安乐，则当谦退。出与人物应接，则当强矫，入与妻即享受，则当谦退 有则改之，无则加勉 名望所在，是非于是乎出，赏罚于是乎人， 有才者仇疑谤之无因，因悍然不顾，则谤且日腾。有筏者畏疑谤之无因，而抑然自修，则谤亦日息 吾在外日久，阅事日多，每劝人以不服药为上策。 治心以广大二字为药，治身以不药二字为药。 余阅历已久，觉有病时，断不可吃药，无病时，可偶服补剂调理，亦不可多。 家训，惟早起务农疏医远巫四者，尤为切要 盛时常作衰时想，上场念下场时， 总宜奖其所长，而兼规其短， 吾家于本县父母官，不必力赞其贤，不可力低其非，与之相处，宜在若远若近，不亲不疏之间。渠子侄若与官相见，总以谦谨二字为主。 宜刻刻勤劳，早作夜思，以求有济 吾兄弟但在积劳二字上着力，成名二字，则不必问及，享福二字，则更不必问矣。 将万事看空，毋恼毋怒 心肝两家之病，究以自养自医为主，非药物所能为力 凡郁怒最易伤人， 宜于平日请求养身之法，不可于临时乱投药剂。 内疾外症，果然好了几分。凡属抑郁发怒，最伤身体。我有过错，弟弟尽可一一直说。忌嫉 养身之法，约有一事：一曰眠食有恒①。二曰惩忿，三曰节欲，四曰每夜临睡洗脚，五曰每日两饭后，各行三千步。惩忿即余篇中所谓养生以少恼怒为本也 凡家道所以可久者，不恃一时之官爵，而恃长远之家规，不恃一二人之骤发，而恃大众之维持 望吾弟专在作田上用工，辅之以书蔬鱼猪、早扫考宝八字，任凭家中如何贵盛、切莫全改道光初年之规模 吾辈在自修处求强则可，在胜人处求强则不可。若专在胜人处求强，其能强到底与否，尚未可知，即使终身强横安稳，亦君子所不屑道也。 大悔大悟之后，乃知自己全无本领，凡事都见得人家有几分是处 大约以能立能达为体，以不怨不尤为用。立者，发奋自强，站得住也。达者，办事圆融，行得通也 吾九年以来，痛戒无恒之弊，看书写字，从未间断，选将练兵，亦常留心，此皆自强能立工夫。奏疏公牍，再三斟酌，无一过当之语，自夸之辞，此皆圆融能达工夫。至于怨天本有所不敢，尤人则尚不能免，亦皆随时强制而克去之 惟有处处泰然，行所无事，申甫所谓好汉打脱牙和血吞，星冈公所谓有福之人善退财，真处逆境者之良法也。 只有逆来顺受之法 朱子尝言：“悔字如春，万物蕴蓄初发。吉字如夏，万物茂盛已极。吝字如秋，万物如落。凶字如冬，万物初调。”又尝以元字配春，享字配夏，利字配秋，贞字配冬，兄意贞字即硬字诀也 写字养神。 些小得失不足患，特患业之不精耳。 然科名有无迟早，总由前定，丝毫不能勉强。吾辈读书，只有两事，一者进德之事，讲求乎诚正修齐⑤之道，以图无忝⑥所生，一者修业之事，操习乎记诵词章之术，以图自卫其身。 吾辈读书，只有两事，一者进德之事，讲求乎诚正修齐⑤之道，以图无忝⑥所生，一者修业之事，操习乎记诵词章之术，以图自卫其身。 求业之精，别无他法，曰专而已矣。谚曰：“艺多不养身，谓不专也。”吾掘井多而无泉可饮，不专之咎也！ 凡专一业之人，必有心得，亦必有疑义。诸 诸弟每日自立课程，必须有日日不断之功，虽行船走路，须带在身边 要皆有志之上，不甘居于庸碌者也。 天下有益之事，即有足损者寓乎其中，不可不辨。 有志则断不敢为下流，有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识也。有恒则断无不成之事，此三者，缺一不可 附课程表 一、主敬、整齐严肃、无时不俱，无事时心在腔子里，应事时专一不杂。 二、静坐、每日不拘何时，静坐一会，体验静极生阳来复之仁心，正位凝命，如鼎之锁。 三、早起、黎明即起，醒后勿沾恋。 四、读书不二、一书未点完，断不看他书，东翻西阅，都是徇外⑦为人。 五、读史、廿三史每日读十页，虽有事，不间断。 六、写日记、须端谐，凡日问过恶，身过，心过，口过，皆己出，终身不间断。 七、日知其所亡⑧、每日记茶余偶谈一则，分德行门，学问门，经济门，艺术门。 八、月无忘所能、每月作诗文数首，以验积理之金寡，气之盛否。 九、谨言、刻刻留心。 十、养气、无不可对人言之事，气藏丹田。 十一、保身、谨遵大人手谕，节欲，节劳，节饮食。 十二、作字、早饭后作字，凡笔墨应酬，当作自己功课。 十三、夜不出门、旷功疲神，切戒切戒！ 为人子者，若使父母见得我好些，谓诸兄弟俱不及我，这便是不孝，若使族党称道我好些，谓诸兄弟俱不如我，这便是不梯①，何也？盖使父母心中有贤愚之分，使族党②口中有贤愚之分，则必其平日有讨好底意思，暗用机计，使自己得好名声，而使兄弟得坏名声，必其后日之嫌隙，由此而生也 取明师之益，无受损友之损也 无恒者见异思迁 穷经必专一经，不可泛骛 有一耐字诀，一句不通，不看下句，今日不通，明日再读，今年不通，明年再读，此所谓耐 读经以研寻义理为本，考据名物为末，读至有一耐字诀，一句不通，不看下句，今日不通，明日再读，今年不通，明年再读，此所谓耐也 读史之法，莫妙于设身处地，每看一处，如我便与当时之人，酬酢笑语于其间。不必人人皆能记也。但记一人，则恍如接其人，不必事事皆能记也。但记一事，则恍如亲其事，经以穷理，史以考事，舍此二者。更别无学矣。 此一集未读完，断断不换他集，亦专字诀也 读经读史读专集，讲义理之学，此有志者万不可易者也 于兄弟出直达其隐，父子祖孙间，不得不曲致其情。 若果威仪可则，淳实宏通，师之可也。若仅博雅能文，友之可也。或师或友，皆宜常存敬畏之心，不宜视为等夷，渐至慢亵，则不复能受其益矣 无论何书，总须从首至尾，通看一遍 先须看一家集，不要东翻两阅，先须学一体，不可各体同学，盖明一体，则皆明也 有困心衡虑郁积思通之象。此事断不可求速效 愈欲速则愈锢蔽矣， 绝大学问，即在家庭日用之间 无日不看书，虽万事业忙，亦不废正业。 日月逝矣，再过数年，则满三十，不能不趁三十以前，立志猛进也。 若自己不立志，则虽日与尧舜禹汤同住，亦彼自彼，我自我矣，何与于我哉 学问之道无穷，而总以有恒为主， 虽极忙，亦须了本日功课，不以昨日耽搁，而今日补做，不以明日有事，而今日预做。 切勿以家中有事，而间断看书之事，又勿以考试将近，而间断看书之课 若事事勤思善问，何患不一日千里 读书宜选一明师 一家之中，未能家长晏而子弟能早者也 家中读书事，弟宜常常留心，如甲五科三等，皆须读书，不失在家子弟风范，不可太疏忽也， 俭字工夫。日来稍有长进否？ 用功，不求太猛，但求有恒 吾不望代代得富贵，但愿代代有秀才。 奋勉加功，为人与为学并进，切戒骄奢二字，则家中风气日厚 一曰看生书宜求速，不多读则太陋。一曰温旧书宜求熟，不背诵则易忘。一曰习字宜有恒，不善写则如身之无衣，山之无木。一曰作文宜苦思，不善作则如人之哑不能言，马之肢不能行。四者缺一不可， 和气蒸帮而家不兴者，未之有也 兄弟和，虽穷氓不户必兴，兄弟不和，虽世家宦族必败。 兄弟之情实以和睦兄弟为第一。 言忠信，行笃敬，虽蛮貊①之邦行矣。 只要有恒，不必贪多 澄弟亦须常看《五种遗规》及《呻吟语》，洗尽浮华，朴实谙练，上承祖父，下型子弟，吾于澄弟实有厚望焉 若非道义可得者，则不可轻易受此。要做好人，第一要在此处下手，能令鬼服神钦，则自然识日进，气日刚。否则不觉坠入卑污一流，必有被人看不起之日，不可不慎 受人恩情，当为将来报答之地，不可多求人也。 凡一家之中，勤敬二字，能守得几分，未有不兴，若全无一分，无有不败，和字能守得几分，未有不兴。不和未有不败者1123. 诸弟不好收拾洁净，比我尤甚，此是败家气明，嗣后务宜细心收拾，即一纸一缕，竹头木屑，皆宜检拾，以为儿侄之榜样，一代疏懒，二代淫佚，则必有昼睡夜坐，吸食鸦片之渐矣 子侄除读书外，教之扫屋抹桌凳，收粪锄草，是极好之事，切不可以为有损架子而不为也。 我有美名，则人必有受不美之名者，相形之际，盖难为情；兄惟谨慎谦虚，时时省惕①而已 勿使子侄骄奢淫佚 古人云：“劳则善心生，佚则淫心生。”孟子曰：“生于忧患，死于安乐。 一刻千金，切不可浪掷光 余在军中，不废学问，读书写字，未甚间断，惜年老眼蒙无甚长进，尔今未弱冠，一刻千金，切不可浪掷光阴 须以勤敏行之，每日至少亦须看二十页*。不必惑于在精不在多之说 纪泽看汉书，须以勤敏行之，每日至少亦须看二十页*。不必惑于在精不在多之说，须速点速读，不必一一求熟，恐因求熟之一字，而终身未能读完经书 靡不有初，鲜克有终 然祸福由天主之，善恶由人主之，由天主者，无可如何，只得听之。由人主者，尽得一分算一分，沙得一日算一日。吾兄弟断不可不洗心涤虑，以求力挽家运 第一贵兄弟和睦；第二贵体孝道；第三要实行勤俭二字 勤者，生动之气，俭者，收敛之气，有此二字，家运断无不兴之理。 “家庭不可说利害话，”此言精当之至，足抵万金 书蔬鱼猪，早扫考宝也！早者，起早也。扫者，扫屋也。考者，祖先祭祀；宝者，亲族邻里，时时周旋，贺喜吊丧，问疾济急。 照料家事，总以俭字为主，情意宜厚，用度宜俭，此居家乡之要诀也 总当以勤苦为体，谦逊为用，以药骄佚之积习 总怕子侄习于骄奢佚三字，家败离不得个奢字，人败离不得个佚字，讨人谦离不得个骄字。弟切戒之！总以谦勤二字为主，戒傲惰， 天地间惟谦谨是载福之道。骄则满，满则倾矣。凡动口动笔，厌人之俗，嫌人之鄙，议人之短，发人之覆①，皆骄也。无论所指未必果当，即使一一切当已为天道所不许 欲去骄字，总以不轻非笑人为第一义，欲去惰字，总以不晏起②为第一义 家中兄弟子侄，惟当记祖父这八个字，曰考宝早扫，书蔬鱼猪。又谨记祖父之三不信，曰不信地师，不信医药，不信僧巫。余日记册中，又有八本之说，曰读书以训诂为本，作诗文以声调为本，事亲以得欢心为本，养身以戒恼怒为本，立身以不妄语为本，居家以不晏起为本，作官以不要钱为本，行军以不扰民为本。此八本者，皆余阅历而确有把握之论，弟亦当教诸子侄谨记之。无论世之治乱，家之贫富，但能守星冈之公八字，与余之八本，总不失为上等人家。 俭以养廉，直而能忍 未有钱多而子弟不骄者也，吾兄弟欲为先人留遗泽，为后人惜余福，除去勤俭二字，别无做法 余教儿女辈，惟以勤俭谦三字为主。 盛名之下，其实难副，弟须慎之又慎 一则我家气运太盛，不可不格外小心，以为持盈保泰之道，旧债尽清，则好处太全，恐盈极生亏，留债不清，则好中不足，亦处乐之法 其舅之心，我弟以为可乎？兰姊蕙妹，家运皆 治军总须脚踏实地，克勤小物，乃可日起而有功，凡与人晋接①周旋，若无真意则不足以感人，然徒有真意，而无文饰以将之，则真意亦无所托之以出，礼所称“无文不行”也 书蔬猪鱼，考早扫宝，常设常行，八者都好，地命医理，僧巫祈祷，留客欠住，六者俱恼 凡事皆贵专，求师不专，则受益也不入，求友不专，则博爱而不亲，心有所专宗，而博观他涂以扩其只，亦无不可，无所专宗，而见异思迁，此眩彼夺①，则大不可 必须亲近良友，殷勤亲近，亲近愈久，获益愈多 交友须勤加来往 以后凡事不可占人半点便益，不可轻取人财，切记切记 贤弟从事多躁而少静，以后尚期三思 居官以耐烦为第一要义 此已露出不耐烦之端倪，将来恐不免于龃龉 余生平于朋友中，负人甚少，惟负次青实甚，两弟为我设法，有可挽回之处，余不惮改过也 进谏言戒除骄矜 吾惟以一勤字报吾君，以爱民二字书报吾亲， 凡有一长一技者，兄断不敢轻视 中庸学问思辨行五者，其要归于思必明，柔必强]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter入门学习步骤]]></title>
    <url>%2F2019%2F01%2F01%2FFlutter%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;新年新气象，但…我却不知道水啥！Flutter上次看到还是0.3这次再看已经1.0了，必须的拿出时间好好学习学习，但现在也仅仅是刚靠近Flutter门槛，远远没达到入门的标准：知识要形成体系！构建简单页面这种也没啥可水的，毕竟Flutter中文网上讲的非常详细, github也有大量的问题解决方案。于是就把前段时间的学习步骤发出来吧 1 安装&emsp;&emsp;按Flutter中文网 安装环境，可能遇到问题下面列举 安装过程中如果需要关闭SIP，如果电脑启用了SIP（System Integrity Protection），增加了rootless机制 1.1，重启，过程中按住 command+R，进入保护模式 1.2，打开terminal终端，输入 csrutil disable 1.3，再次重启，即可对 usr/bin 目录下文件进行修改 1.4，如果要恢复保护机制，重新进入保护模式，输入 csrutil enable Android studio 找不到 Flutter &emsp;&emsp;Android studio -&gt; Preferences -&gt; System Setting -&gt; updates -&gt; 去掉 use secure connection PATH环境未生效 &emsp;&emsp;user目录 -&gt; command+shift+. 打开隐藏文件 -&gt; 打开 .bash_profile 文件，添加相应PATH -&gt; 保存 -&gt; 重启 运行flutter就卡死 &emsp;&emsp;偶然发现其实根本原因是mac限制了单进程最大线程个数为64，超过64就卡死了！验证方法：活动监视器 -&gt; 双击android studio -&gt; 取样 -&gt; 查看卡死信息！ &emsp;&emsp;几经周折找到修改内核的方法：vim /etc/sysctl.conf 添加如下代码 kern.wq_max_constrained_threads=128 修改保存后调用 sysctl -p 加载新配置，将单个进程最大线程数提升至128个。 &emsp;&emsp;PS:kern.wq_max_constrained_threads这个参数是通过全局搜64搜出来的然后慢慢试出来的，同志们修改前记得备份 Dart SDK is not configured, android Studio -&gt; perference -&gt; framewoek -&gt; flutter 2 Flutter的State类&emsp;&emsp;重点，响应式编程核心。先记住如下两张图，参考 &emsp;&emsp;State 生命周期 1234567891011121314151617181920graph TBA[开始]--&gt;B[构造函数]subgraph 构建B--&gt;C[initState]C--&gt;D[didChangeDependencies]D--&gt;E[build]endE--&gt;F&#123;显示在RenderTree&#125;subgraph 改变F--&gt;G[组件状态改变]G--&gt;H[didUpdateWidget]H--&gt;I[build]I--&gt;Fendsubgraph 销毁F--&gt;J[移除掉]J--&gt;K[deactivate]K--&gt;L[dispose]L--&gt;M[结束]end &emsp;&emsp;Stateless VS Stateful1234567891011graph TBsubgraph StatelessWidgetsA[constructor func]--&gt;B[build]endsubgraph StatefulWidgetsC[constructor func]--&gt;D[initState]D--&gt;F[build]F--&gt;E[setState]E--&gt;G[didUpdateWidget]G--&gt;H[build]end 3 Dart语法预览&emsp;&emsp;Dart 语法对学过swift或者学过JS的同学，我建议直接速读Dart 语法预览1234567891011121314151617181920212223242526class Spacecraft &#123;String name;DateTime launchDate;int launchYear;// Constructor, including syntactic sugar for assignment to members.Spacecraft(this.name, this.launchDate) &#123;// Pretend the following is something you&apos;d actually want to run in// a constructor.launchYear = launchDate?.year;&#125;// Named constructor that forwards to the default one.Spacecraft.unlaunched(String name) : this(name, null);// Method.void describe() &#123;print(&apos;Spacecraft: $name&apos;);if (launchDate != null) &#123;int years = new DateTime.now().difference(launchDate).inDays ~/ 365;print(&apos;Launched: $launchYear ($years years ago)&apos;);&#125; else &#123;print(&apos;Unlaunched&apos;);&#125;&#125;&#125; 4 Flutter中文网 编写第一个Flutter应用 了解更多 5 先抄几个demo 自带示例 flutter/examples 其它dome https://github.com/iampawan/FlutterExampleApps 资料汇总 https://github.com/Solido/awesome-flutter 6 按部就班&emsp;&emsp;按中文网目录往下琢磨就好了 7 了解更好 Flutter for iOS 开发 速读即可 Flutter中文网-常见问题 Flutter右上角的《Flutter实战》快速浏览即可。附上我画的思维导图 链接:https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg 提取码: 9w7a 8 Hot reload （热重载）Not Hot fix （热修复）9 add flutter to App 官网 https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps 官方dome（不能用） https://github.com/flutter/ios_add2app ，稍微改了改 链接:https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg 提取码: 9w7a 10 我遇到的小问题 android studio 断点调试和高级调试 Flutter视图基础简介–Widget、Element、RenderObject Widget是类定义，Element是实例对象，rednerObject负责实例对象的布局 What is the difference between Material and MaterialApp in Flutter? MaterialApp定义包含appbar之类的app，Scaffold帮助构建对应的appbar TapboxA({Key key}) : super(key: key); 是什么意思 Flutter Engine线程管理与Dart Isolate机制 Dart - Isolate 并发 Flutter常用widget “Expanded”，“Flexible” Flutter Container 参数详解 Dart学习之方法函数 How do getters and setters change properties in Dart? Dart循环引用？Java的垃圾回收可采用引用计数和寻根两种算法，即java虚拟机循环引用不用管！Dart也是垃圾回收，应该也不用管，没找到关于Dart循环引用的资料 Dart中实现单例模式 rerturn (); 用分号，其它的情况用 , 逗号 Dart：并不支持函数的重载 “static”, “final”, and “const” in Dart lutter的ValueChanged 如果有多个不同的值都需要监听怎么办？ Category ？ runtime ？]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛克菲勒留给儿子的38封信]]></title>
    <url>%2F2018%2F11%2F22%2F%E6%B4%9B%E5%85%8B%E8%8F%B2%E5%8B%92%E7%95%99%E7%BB%99%E5%84%BF%E5%AD%90%E7%9A%8438%E5%B0%81%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[我们的命运由我们的行动决定，而并非完全由我们的出身决定 要知道没有完美，只有趋近于完美！ 我们的命运由我们的行动决定，而绝非完全由我们的出身决定，机会永远都会不平等，但结果却可能平等。 一个真正快乐的人，是能够享受他的创造的人。那些像海绵一样，只取不予的人，只会失去快乐。 起点可能影响结果，但不会决定结果。能力、态度、性格、抱负、手段、经验和运气之类的因素，在人生和商业世界里扮演着极为重要的角色。 每个人都是他自己命运的设计者和建筑师。 我们创造自己的运气，要想有所作为就不能等待运气光顾 我相信好的计划会左右运气，甚至在任何情况下，都能成功地影响运气。 要在获取利益的猎场上成为好猎手，你需要勤于思考、做事小心，能够看到事物中一切可能存在的危险和机遇，同时又要像一个棋手那样研究所有可能危及你霸主地位的各种战略。 富有远见的商人总善于从每次灾难中寻找机会 世界上什么事都可以发生，就是不会发生不劳而获的事 那些随波逐流、墨守成规的人，我不屑一顾 要想让我们的好运连连，我们必须要精心策划运气，而策划运气，需要好的计划，好的计划一定是好的设计，好的设计一定能够发挥作用。 在构思好的设计时，要首先考虑两个基本的先决条件，第一个条件是知道自己的目标，譬如你要做什么，甚至你要成为什么样的人；第二个条件是知道自己拥有什么资源，譬如地位、金钱、人际关系，乃至能力。 任何行业中往上爬的人都是完全投入正在做的事情，且专心致志。衷心喜爱从事的工作，自然也就成功了 工作越是困难或不愉快，越要立刻去做 只将加薪与升迁机会留给那些格外努力、格外忠心、格外热心、花更多的时间做事的雇员，因为公司在经营生意，而不是在做慈善事业 如果你赋予工作意义，不论工作大小，你都会感到快乐，自我设定的成绩不论高低，都会使人对工作产生乐趣 只要肯积极行动，你就会越来越接近成功。 缺乏行动的人，都有一个坏习惯：喜欢维持现状，拒绝改变 并非所有的行动都会产生好的结果，只有明智的行动才能带来有意义的结果， 我们追求完美，但是人类的事情没有一件绝对完美，只有接近完美 时时想到现在，从现在就开始做。诸如“明天”、“下礼拜”、“将来”之类的句子，跟“永远不可能做到”意义相同。 告诉自己每个人都有失败的时候，有失败得很惨的时候，会告诉自己不论事前做了多少准备、思考多久，真正着手做的时候，都有难免会犯错误。 在我们这个世界上从来不缺少有想法有主意的人，但懂得成功地将一个好主意付诸实现比在家空想出一千个好主意要有价值得多的人却很少。 任何竞争都不是一场轻松的游戏，而是活力十足、需要密切注意、不断做出决定的游戏， 我从来没有想到会输，但是即使输了，惟一该做的就是光明磊落地去输。 我们一定要讲究规矩，因为规矩可以创造关系，关系会带来长久的业务，好的交易会创造更多的交易 要想在竞争中获胜，勇气只是赢得胜利的一方面，还要有实力 战争既已不可避免，那就让它来吧！ 不论是要赢得财富，还是要赢得人生，优秀的人在竞技中想的不是输了我会怎样，而是要成为胜利者我应该做什么 借钱不是件坏事，把它看成是一种有力的工具，你就可以用它来开创机会 付出诚实的回报是巨大的，诚实是一种方法，一种策略。 如果静止不动，就是退步，但要前进，必须乐于做决定和冒险 人人都厌恶失败，然而，一旦避免失败变成你做事的动机，你就走上了怠惰无力之路。这非常可怕，甚至是种灾难我们生活在弱肉强食的丛林之中，在这里你不是吃人就是补被别人吃掉，逃避风险几乎就是保证破产；而你利用了机会，就是在剥夺别人的机会，保证着自己。 害怕失败就不敢冒险，不敢冒险就会错失眼前的机会。 乐观的人在苦难中会看到机会，悲观的人在机会中会看到苦难 梦想 + 失败 + 挑战 = 成功之道 没有挑战就没有成功，不要因为一次失败就停下脚步，战胜自己，你就是最大的胜者 每个人都有历尽沧桑和饱受无情打击的时候，却很少有人能像林肯那样百折不回。 除非你放弃，否则你就不会被打垮。 功成名就是一连串的奋斗 有太多人高估他们所欠缺的，却又低估他们所拥有的，以至丧失了成为胜利者的机会。这 重要的是不要因失败而变成一位懦夫。如果我们尽了最大努力仍然不达目的，我们所应做的就是汲取教训，力求在接下来的努力中表现得更好就行了。 每当你相信“我能做到”时，自然就会想出“如何解决”的方法，成功就诞生在成功解决问题之中 采取“我暂且试试看，但我想还是不会有什么结果”的态度，最后一定会招致失败 当你心中不以为然或产生怀疑时，你就会想出各种理由来支持你的“不信”。心中存疑，就会失败。相信会胜利，就必定成功。 相信自己，要相信自己一定能够成功 你比你想象的还要好。成功的人并不是超人。成功不需要超人的智力，不是看运气，也没有什么神秘之处。成功的人只是相信自己、肯定自己所作所为的平凡人。永远不要、绝对不要廉价出售自己。 检验我们人性的试金石：利益。在它面前，一切与道德、伦理有关的本质都将现形，且一览无余。 我可以欺骗敌人，但决不欺骗自己。回击正在射杀我的敌人，永远不会让我的良心不安。 这个世界有太多太多的欺骗，提防是我们不可或缺的生存技能。 我只有在对自己有利无害的情况下，才表现自己的感情；我可以让对手教导我，但我永远不教导对手，无论我对那件事了解有多深；凡事三思而决，不管别人如何催促，不考虑周全决不行动；我有自己的真理，只对自己负责；小心那些要求我以诚相待的人，他们是想在我这里捞到好处。 在人的本性中早就潜藏着一种力量就是嫉妒。 没有一个社会不是建立在贪心之上，虚伪的人总是那些多。如果你不贪心，或许你就会被别人贪掉，毕竟可口的甜点不是很多。 贪心没有什么不好，我认为贪心是件好事，人人都可以贪心。从贪心开始，才会有希望！” 命运要由自己去开创，真心希望的东西一定要想方设法去得到，抢在别人之前达到目的 在这个世界上能出人头地的人，都是那些懂得去寻找自己理想环境的人，如果他们不能如愿，就会自己创造出来。 当猪开始独立的时候，都会变得强悍和聪明了。而不劳而获的习惯使它们毫无顾虑的走进围栏 如果你想使一个人残废，只要给他一对拐杖再等上几个月就能达到目的； 当你施舍一个人时，你就否定了他尊严，你否定了他的尊严，你就抢走了他的命运 天下没有白吃的午餐！白吃午餐的人，迟早会连本带利付出代价。 走过艰难之路——布满艰辛、不幸、失败和困难的道路，不仅会铸就我们坚强的性格，我们赖以成就大事的实行能力亦将应运而生！没有不幸体验的人，反而不幸 做好小事是做成大事的基石，你必须从做小事开始，才会了解当部属的心情，等你有一天走上更高的职位，你就知道如何让他们贡献出全部的工作热情了 世界上只有两种人头脑聪明：一种是活用自己的聪明人，例如艺术艺术家、学者、演员；一种是活用别人的聪明人，例如经营者、领导者 一头猪好好被夸奖一番，它就能爬到树上去。善于驱使别人的经营者、领导者或大有作为的人，一向宽宏大量，他们懂得高看别人和赞美他人的艺术没有知识的人终无大用，但有知识的人很可能成为知识的奴隶 一切的知识都会转化为先入为主的观念，结果是形成一边倒的保守心理！每一次说不懂的机会，都会成为我们人生的转折点。 自作聪明的人是傻瓜，懂得装傻的人才是真聪明 摆低姿态，变得谦虚！越是聪明的人越有装傻的必要 让我等等再说”，是我在经商中始终奉行的格言 每个目标的达成都来自于勤奋的思考与勤奋的行动，机会只留给勤奋的人 一切尊贵和荣誉都必须靠自己的创造去获取，这样的尊贵和荣誉才能长久 勤奋能修炼人的品质，更能培养人的能力。 结束生命最快捷的方式就是什么也不做。 人生奋斗的目标就是求胜，但赢本身并不代表一切，而努力去赢的做法才是最重要的 借口是一种思想病，而染有这种严重病症的人，无一例外的都是失败者 失败者为自己料理“后事”的第一个举动，就是为自己的失败找出各种理由。 累坏自己总比放着朽坏要好。 起初，他还能自知他的借口多少是在撒谎，但是在不断重复使用后，他就会越来越相信那完全是真的，相信这个借口就是他无法成功的真正原因，结果他的大脑就开始怠惰、僵化，让努力想方设法要赢的动力化为零。但他们从不愿意承认自己是个爱找借口的人 如果有一个人根本不考虑才智的问题，而勇于一试，就能够胜任得很好 不要太低估自己的脑力，更不要太高估别人的脑力 兴趣和热心是决定成败的重要因素。 热心就是“这是很了不起的！”那种热情和干劲而已。 专注与执着占了一个人百分之九十五的能力。 知识只是一种潜在的力量，只有将知识付诸应用，而且是建设性地应用，才会显出它的威力。 引导我们发挥聪明才智的思考方式，远比我们才智的高低重要 很多人都迷信所谓的知识就是力量。真正重要的不在他有多少才智，而在于他如何使用现有的才智，和要善用自己的脑力 防止自己找借口。 我就是我最大的资本。你要锻炼信念，不停地探究迟疑的原因，直到信念取代了怀疑。你要知道，你自己不相信的事，你无法达成；信念是带你前进的力 我之所以是我，都是我过去的信念创造出来的 要让金钱当我的奴隶，而不能让我当金钱的奴隶 没有野心的人不会成就大事 人被创造出来是有目的的，一个人不是在计划成功，就是在计划失败财富与目标成正比 不要做小计划，因为它不能激励心灵，我经常这样提醒自己。伟大的目标能使你发挥全部的力量，也才会有刺激。 我相信为自己勤奋会致富，但不相信努力为别人工作就一定成功，我一直视“努力工作定会致富”为谎言，从不把为别人工作当作积累可观财富和上策，相反，我非常笃信为自己工作才能富有 没人能阻止你前进的道路，阻碍你前进最大的人就是你自己，你是惟一永久能做下去的人 愚蠢的努力工作很可能在百般辛苦之后仍一无所获 对我来说，第二名跟最后一名没有什么两样 好奇才能发现机会，冒险才能利用机会。 风险越高，收益越大 想获胜必须了解冒险的价值，而且必须有自己创造运气的远见 安全第一不能让我们致富，要想获得报酬，总是要接受随之而来的必要的风险 没有维持现状这回事，不进则退 如果你想知道既冒险而又不招致失败的技巧，你只需要记住一句话：大胆筹划，小心实施。 善于思考与善于行动的人，都知道必须祛除傲慢与偏见，都知道永远不能让自己的个人偏见妨碍自己的成功， 蒙辱不是件坏事，如果你是一个知道冷静反思的人，或许就会认为侮辱是测量能力的标尺 如果你要拥有实质性的优势，你必须知道： 第一，整体环境：市场状况如何，景气状况如何 第二，你的资源：你有哪些优势（优点）和弱势（弱点），你有哪些资本。 第三，对手的资源：对手的资产状况如何，他的优势、劣势在哪里。在任何竞争中，谋划大策略的重要因素之一，就是了解对手的优势。 第四，你的目标和态度：太阳神阿波罗的座右铭只有短短的一句话：“人贵自知。”你要知道自己在干什么、有什么目标，实现目标的决心有多坚决，认为自己像个赢家还是怀疑自己，在精神与态 度上有什么优点和缺点。约翰，你要记住我的一句话：越是认为自己行，你就会变得越高明，积极的心态会创造成功。 第五，对手的目标和态度：要尽量判断对手的目标，同样重要的是，要设法深入对手的内心，了解他的想法的感觉。毫 预防胜于治疗！主动、预期性的措施几乎总比被动反应有效，且更有力量 在做生意时，你绝对不能想把钱赚得一干二净，要留一点给别人赚。 做交易的秘诀在于，你要知道不能交易什么和可以交易什么 交易的真谛是交换价值，用别人想要的东西来换取你想要的东西。 完成一笔好交易，最好的方法是强调其价值。 谈判中，当涉及金钱的时候，你绝对不要先提金额，要提供他宝贵的价值，强调他从你这里能够买到什么。 合作永远是聪明的选择，前提是只要对我有利。 合作并不等同于友谊、爱情和婚姻，合作的目的不是去捞取情感，而是要捞到利益和好处建立在生意上的友谊远胜过建立在友谊上的生意 己所不欲，勿施于人 往上爬的时候要对别人好一点，因为你走下坡的时候会碰到他们 耐心、温和对待下属和同事的价值——有利于实现目标。 合作不是做好人的问题，而是好处和利益的问题。没有任何结盟是永远持久的，合作只是一种获利战术。当环境发生变化的时候 ，战术将随之改变，否则，你就输了我们要看重自己，克服人类最大 的弱点——自贬，千万不要廉价出卖自己 如果一个人自己觉得比不上别人，他就会表现出“真”的比不上别人的各种行动；那些相信自己具有“承担重责大任的能力”的人，就真的会变成一个“很重要”的人物。原则：你怎么思想将会决定你怎么行动，你怎么行动将决定别人对你的看法 越敬重自己，别人也会越敬重你们。 那些不觉得自己重要的人，都是自暴自弃的普通人 要专注自己的长处，告诉自己我比我想象的还要好。要有远见，看到未来的发展性，而不单看现况，对自己要有远大的期望。要随时记住这个问题：“重要人物会不会这么做呢 每一分钱都要让它物有所值！ 世界上有两种人永远不会富有:第一种是及时行乐者; 第二种人，喜欢存钱的 我没有理由浪费生命，浪费生命就等于糟蹋自己，世界上没有比糟蹋自己更大的悲剧了。我也不把安逸和享乐看作是生活目的的本身，因为我称其为猪的理想 一个胸怀大志的人而言，保持必要的屈从与忍耐 忍耐不是盲目的容忍，你需要冷静地考量情势，要知道你的决定是否会偏离或加害你的目标。 忍耐并非忍气吞声、也绝非卑躬屈膝，忍耐是一种策略，同时也是一种性格磨练，它所孕育出的是好胜之心 超过他，你的强大是对他最好的羞辱，是打在他脸上最响的耳光。 在任何时候冲动都是我们最大的敌人 要修炼自己管理情绪和控制感情的能力，要注意在做决策时不要受感情左右，而是完全根据需要来做决定，要永远知道自己想要什么 不能靠运气活着，尤其不能靠运气来建立事业生涯。 大胆果决的人，能完成最好的交易，能吸引他人的支持，结成最有力的盟约。 作为领袖，面对悲观送出的应该永远是希望而不是哀叹，我告诉那些惶恐中的人们：上帝会赐予我们一切。 态度有助于创造运气，而机运就在你的选择之中。如果你有百分之五十一的时间做对了，那么你就会变成英雄。 被委以重任者是能找出把事情做得更好的方法的人 相信某一件事可以做成，就会为我们提供创造性的解决之道 ，将我们各种创造性的能力发挥出来 各种计划都不可能达到绝对的完美，这意味着一切事物的改良可以无止境地进行 要丢弃“ 不可行”、“办不到”、“没有用”、“那很愚蠢”等思想的渣滓； 集中心思于怎样才可以做得更多。如此，许多富有创造性的答案都会不期而至 很多人总喜欢追求最好的东西，而放弃好的东西。这样做不是聪明的策略，因为好总是胜过不好。 从一开始你就要千方百计地掌握优势：第一个策略：一开始就要下决心，关注竞争状况和竞争者的资源；第二个策略：研究和检讨对手的情况，然后善用这种知识，来形成自己的优势；第三个策略：你必须拥有正确的心态。从一开始，你必须下定决心，追求胜利，这表示你必须在道德的限制下，表现得积极无情，因为这种态度直接来自残忍无情的目标 一个人的个性与野心，目前的身分与地位，同与什么人交往有关 拒绝同两种人交往：第一种人是那些完全投降、安于现状的人；第二种人是不能将挑战进行到底的人；这两种人身上有着共同的思想毒素，极易感染他人的思想毒素，那就是消极 我要挑战令人厌恶的逆境，因为智者告诉我，那是通往成功最明智的方向 要有所成就就要避免落入各式各样的陷阱或圈套。 说你办不到的人，本身都是无法成功的人多接近积极成功的人，少同消极的人来往。每一件事情都要做得尽善尽美。你付不起贪小失大所累积的种种额外负担。千万不要从长舌妇那里征求意见，因为这种人 一辈子都没有出息。目的就是一切需要毫无保留地向你的部属陈述你的目的当你勇于将目的开诚布公之后，你将收获情感上的忠诚。要知道忠诚是甘心效命的开 始。杰出的领导者都善于动用两种无形的力量：信任和尊重目的就如同钻石：如果要它有价值，它必须是真实的，到达地狱的路，是由善意铺成的亮出你的目的，热情地对待每个人，就能实现你所要的那种精神的，难道是金钱的力量？” 我告诉他，金钱的力量当然不可低估，但责任的力量更是巨大。金钱的力量当然不可低估，但责任的力量更是巨大。拒绝为了任何理由，去责难任何一个人或任何一 件事责难就如同一片沼泽，一旦失足跌落进去，你便失去责难结果只有一个：失去手下的尊重与支当坏事降临在我们身上时，我会先停下来问自己一个问题：“我的职责是什么？但是，分析“我的职责是什么”并不意味着自责。在标准石油公司没有责难、没有藉口所有的 事都需要摊在阳光下来讨论。责难是摧毁领导力的头号敌人自责是一种最阴险狡猾的责难陷阱但是，分析“我的职责是什么”并不意味着自责。自责是一种最阴险狡猾的责难陷阱，诸如“那真是一个愚蠢的错误！”等自我责难但是，分析“我的职责是什么”并不意味着自责。自责是一种最阴险狡猾的责难陷阱做你喜欢做的事，而其他的事，就交由喜欢做这件事的人去做。最能创造价值的人就是那彻底投身于自己 最喜欢的活动的人策略的本质是弹性的、长远的、多面向的、大格局的。策略所提供的是一个大方向，而非达到成功的惟一方式。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习swift：Swift tips & tricks笔记下]]></title>
    <url>%2F2018%2F10%2F28%2F%E5%A4%8D%E4%B9%A0swift%EF%BC%9ASwift-tips-tricks%E7%AC%94%E8%AE%B0%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;上篇学习了前50个，本文学习剩下的。拆成2篇是因为有道同步太坑了，上篇前50个就一直同步失败！ &emsp;&emsp;想看全部的自己看大神的Swift tips &amp; tricks， UIView bounds and transforms 123456let view = UIView()view.frame.size = CGSize(width: 100, height: 100)view.transform = CGAffineTransform(scaleX: 2, y: 2)print(view.frame) // (-50.0, -50.0, 200.0, 200.0)print(view.bounds) // (0.0, 0.0, 100.0, 100.0) 扩展equatable实现 多值命中 1234567extension Equatable &#123;func isAny(of candidates: Self...) -&gt; Bool &#123;return candidates.contains(self)&#125;&#125;let isHorizontal = direction.isAny(of: .left, .right) 限制该协议只适用于class类型 1234// 通过将AnyObject协议添加到协议的继承列表中，来限制该协议只适用于class类型，而不适用于枚举和结构体。protocol DataContainer: AnyObject &#123;var data: Data? &#123; get set &#125;&#125; 把实例方法当做static方法调用! 好牛逼 123456789101112131415161718192021In Swift, you can call any instance method as a static function and it will return a closure representing that method. This is how running tests using SPM on Linux works.More about this topic in my blog post &quot;https://www.swiftbysundell.com/posts/first-class-functions-in-swiftt&quot;.// This produces a &apos;() -&gt; Void&apos; closure which is a reference to the// given view&apos;s &apos;removeFromSuperview&apos; method.let closure = UIView.removeFromSuperview(view)// We can now call it just like we would any other closure, and it// will run &apos;view.removeFromSuperview()&apos;closure()// This is how running tests using the Swift Package Manager on Linux// works, you return your test functions as closures:extension UserManagerTests &#123;static var allTests = [(&quot;testLoggingIn&quot;, testLoggingIn),(&quot;testLoggingOut&quot;, testLoggingOut),(&quot;testUserPermissions&quot;, testUserPermissions)]&#125; where子句和associated关联类型提供更多自由 12345678910111213public protocol PathFinderMap &#123;associatedtype Node// Using the &apos;where&apos; clause for associated types, we can// ensure that a type meets certain requirements (in this// case that it&apos;s a sequence with Node elements).associatedtype NodeSequence: Sequence where NodeSequence.Element == Node// Instead of using a concrete type (like [Node]) here, we// give implementors of this protocol more freedom while// still meeting our requirements. For example, one// implementation might use Set&lt;Node&gt;.func neighbors(of node: Node) -&gt; NodeSequence&#125; 定义option sets，即OC的NS_OPTIONS 12345678// 必须是实现OptionSet协议struct Options: OptionSet &#123;static let saveToDisk = Options(rawValue: 1)static let clearOnMemoryWarning = Options(rawValue: 1 &lt;&lt; 1)static let clearDaily = Options(rawValue: 1 &lt;&lt; 2)let rawValue: Int&#125; 可用ChildViewController，它们会自动调整大小以匹配其父视图 使用元组来设置view状态，其实就是代替model，但不建议这么搞！因为没有规范，使用Class可明确含义，使用struct还能实现MVVM，元祖是最差的选择了，除非用于快速测试 swift访问剪贴板 123import Cocoalet clipboard = NSPasteboard.general.string(forType: .string) 巧用self来实现链式…额不知道叫什么！不过，其实可以实现链式编程 1234567891011121314151617181920212223// Extension adding builder pattern-like properties that return// a new sequence value with the given configuration appliedextension FileSequence &#123;var recursive: FileSequence &#123;var sequence = selfsequence.isRecursive = truereturn sequence&#125;var includingHidden: FileSequence &#123;var sequence = selfsequence.includeHidden = truereturn sequence&#125;&#125;// BEFORElet files = folder.makeFileSequence(recursive: true, includeHidden: true)// AFTERlet files = folder.files.recursive.includingHidden 使用&amp; 来合成协议 UIViewController &amp; LoadableFromURL 、 protocolA &amp; protocolB Parsing command line arguments using UserDefaults 1234567A really cool &quot;hidden&quot; feature of UserDefaults is that it contains any arguments that were passed to the app at launch!Super useful both in Swift command line tools &amp; scripts, but also to temporarily override a value when debugging iOS apps.let defaults = UserDefaults.standardlet query = defaults.string(forKey: &quot;query&quot;)let resultCount = defaults.integer(forKey: &quot;results&quot;) 泛型 1234567typealias Pair&lt;T&gt; = (T, T)extension Game &#123;func calculateScore(for players: Pair&lt;Player&gt;) -&gt; Int &#123;...&#125;&#125; associatedtype的使用,typealias 重命名RawValue是关键 12345678910111213protocol UnboxTransformable &#123;associatedtype RawValuestatic func transform(_ value: RawValue) throws -&gt; Self?&#125;extension Array: UnboxTransformable where Element: UnboxTransformable &#123;typealias RawValue = [Element.RawValue]static func transform(_ value: RawValue) throws -&gt; [Element]? &#123;return try value.compactMap(Element.transform)&#125;&#125; throw是本函数异常，rethrow是本函数没事但本函数的闭包异常（即闭包有throw） 联类型的默认值 1234567891011121314151617protocol Identifiable &#123;associatedtype RawIdentifier: Codable = Stringvar id: Identifier&lt;Self&gt; &#123; get &#125;&#125;struct User: Identifiable &#123;let id: Identifier&lt;User&gt;let name: String&#125;struct Group: Identifiable &#123;typealias RawIdentifier = Intlet id: Identifier&lt;Group&gt;let name: String&#125; Encodable &amp; Decodable的扩展 12345678910111213141516171819202122extension Encodable &#123;func encoded() throws -&gt; Data &#123;return try JSONEncoder().encode(self)&#125;&#125;extension Data &#123;func decoded&lt;T: Decodable&gt;() throws -&gt; T &#123;return try JSONDecoder().decode(T.self, from: self)&#125;&#125;let data = try user.encoded()// By using a generic type in the decoded() method, the// compiler can often infer the type we want to decode// from the current context.try userDidLogin(data.decoded())// And if not, we can always supply the type, still making// the call site read very nicely.let otherUser = try data.decoded() as User Matching multiple enum cases with associated values 1234567891011121314151617enum DownloadState &#123;case inProgress(progress: Double)case paused(progress: Double)case cancelledcase finished(Data)&#125;func downloadStateDidChange(to state: DownloadState) &#123;switch state &#123;case .inProgress(let progress), .paused(let progress):updateProgressView(with: progress)case .cancelled:showCancelledMessage()case .finished(let data):process(data)&#125;&#125; 展开可选值或抛出错误 123456789101112extension Optional &#123;func orThrow(_ errorExpression: @autoclosure () -&gt; Error) throws -&gt; Wrapped &#123;switch self &#123;case .some(let value):return valuecase .none:throw errorExpression()&#125;&#125;&#125;let file = try loadFile(at: path).orThrow(MissingFileError()) 使用associatedtype约束protocol 1234567891011121314151617protocol Component &#123;associatedtype Containerfunc add(to container: Container)&#125;// Protocols that inherit from other protocols can include// constraints to further specialize them.protocol ViewComponent: Component where Container == UIView &#123;associatedtype View: UIViewvar view: View &#123; get &#125;&#125;extension ViewComponent &#123;func add(to container: UIView) &#123;container.addSubview(view)&#125;&#125; &emsp;&emsp;最后:下篇其实干货不是很多，而且写这个的大神非常推崇元组，光元祖就写了一大堆]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习swift：Swift tips & tricks笔记上]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%A4%8D%E4%B9%A0swift%EF%BC%9ASwift-tips-tricks%E7%AC%94%E8%AE%B0%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本文只摘抄了自己觉得有用的tip并加了点自己的理解，并不是全部tips。想看全部的自己看大神的Swift tips &amp; tricks 嵌套类型，好处大大滴！权限控制、结构划分等等 自动闭包，能使用自动闭包类型是是这样的() -&gt; T 123456789101112131415161718192021func logIfTure(_ predicate: ()-&gt;Bool)&#123;if predicate() &#123;print(&quot;jzk&quot;)&#125;&#125;logIfTure(&#123; () -&gt; Bool inreturn 2 &gt; 1&#125;)logIfTure(&#123;return 3 &gt; 2&#125;)logIfTure(&#123;4&gt;3&#125;)logIfTure&#123;5&gt;4&#125;// 自动闭包写起来就优雅多了func logIfTure2(_ predicate:@autoclosure ()-&gt;Bool)&#123;if predicate() &#123;print(&quot;jzk&quot;)&#125;&#125;logIfTure2(6&gt;5) 使用typealiases减少长度 12typealias DownSuccess = (json: NSURLResponse, filePath: String?) -&gt; ()func Post(url:String? ,success: DownSuccess)&#123;&#125; 使用与库同名的类、结构体…，慎用！还是不重复的好 123456extension Command &#123;enum Error: Swift.Error &#123;case missingcase invalid(String)&#125;&#125; 使用#function来保证UserDefault的key不重复! 慎用，思路不错，但不严谨 123456extension UserDefaults &#123;var onboardingCompleted: Bool &#123;get &#123; return bool(forKey: #function) &#125;set &#123; set(newValue, forKey: #function) &#125;&#125;&#125; 把func和操作符当做闭包传递 12let array = [3, 9, 1, 4, 6, 2]let sorted = array.sorted(by: &lt;) 使用guard拆分条件判断 12guard maxObjectDepth &gt; 0 else &#123; return &#125;guard maxObjectDepth &lt; 100 else &#123; return &#125; 不要使用swith的default，目的强制编译器检查case是否完全 使用 .语法和闭包来初始化 123456789101112131415161718class Logger &#123;public func logSomething(_ str: String = &quot;&quot;) &#123;print(&quot;----\(str)&quot;)&#125;&#125;// 第一个比较好理解，参数默认值func test(log: Logger = .init())&#123;log.logSomething(&quot;1&quot;);&#125;test();/*但这个我就理解不了了，注意Logger.init后面没有括号*/func test2(log:@escaping () -&gt; Logger = Logger.init) &#123;let log2 = log();log2.logSomething(&quot;2&quot;);&#125;test2(); 使用 === 比较内存相等 枚举可有关联值 1234public enum JSONKey &#123;case index(Int)case key(String)&#125; 可变参数 12345extension Canvas &#123;func add(_ shapes: Shape...) &#123;shapes.forEach(add)&#125;&#125; Avoiding mocking UserDefaults! mocking啥呀，建新的！ 12345678910111213class LoginTests: XCTestCase &#123;private var userDefaults: UserDefaults!private var manager: LoginManager!override func setUp() &#123;super.setup()userDefaults = UserDefaults(suiteName: #file)userDefaults.removePersistentDomain(forName: #file)manager = LoginManager(userDefaults: userDefaults)&#125;&#125; 加速包测试速度 1swift test --parallel 使用闭包创建lazy属性 123456789101112class Logger &#123;private lazy var str: String = &#123;print(&quot;lazy str init&quot;)return &quot;jzk&quot;&#125;()public func log()&#123;print(&quot;my name is \(str)&quot;)&#125;&#125;let log1 = Logger();log1.log(); 组合函数序列! 12345678internal func +&lt;A, B, C&gt;(lhs: @escaping (A) throws -&gt; B,rhs: @escaping (B) throws -&gt; C) -&gt; (A) throws -&gt; C &#123;return &#123; try rhs(lhs($0)) &#125;&#125;public func run() throws &#123;try (determineTarget + build + analyze + output)()&#125; Using DispatchWorkItem， OC用dispatch_block_t 123456789let workItem = DispatchWorkItem &#123;// Your async code goes in here&#125;// 注意没括号// Execute the work item after 1 secondDispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: workItem)// You can cancel the work item if you no longer need itworkItem.cancel() 使用weak或o避免循环引用 12345678// Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned ，如果存在被释放的可能，那就选择用 weakdataLoader.loadData(from: url) &#123; [weak self] result in// 这句检查self基本是定式了guard let self = self else &#123; return &#125;self.cache(result) 异步返回的尽量用enum 使用关联的枚举值以避免特定于状态的选项 12345678910111213141516171819202122// BEFORE: Lots of state-specific, optional propertiesclass Player &#123;var isWaitingForMatchMaking: Boolvar invitingUser: User?var numberOfLives: Intvar playerDefeatedBy: Player?var roundDefeatedIn: Int?&#125;// AFTER: All state-specific information is encapsulated in enum casesclass Player &#123;enum State &#123;case waitingForMatchMakingcase waitingForInviteResponse(from: User)case active(numberOfLives: Int)case defeated(by: Player, roundNumber: Int)&#125;var state: State&#125; 泛型约束中使用闭包 1234567891011121314extension Sequence where Element == () -&gt; Void &#123;func callAll() &#123;forEach &#123; $0() &#125;&#125;&#125;extension Sequence where Element == () -&gt; String &#123;func joinedResults(separator: String) -&gt; String &#123;return map &#123; $0() &#125;.joined(separator: separator)&#125;&#125;callbacks.callAll()let names = nameProviders.joinedResults(separator: &quot;, &quot;) 使用静态定义url 1let url: URL = &quot;https://www.swiftbysundell.com&quot; weak或lazy属性应该设置readoonly 123456789class Node &#123;private(set) weak var parent: Node?private(set) lazy var children = [Node]()func add(child: Node) &#123;children.append(child)child.parent = self&#125;&#125; Passing self to required Objective-C dependencies 1234567891011121314151617// Using lazy properties in Swift, you can pass self to required Objective-C dependencies without having to use force-unwrapped optionals.class DataLoader: NSObject &#123;lazy var urlSession: URLSession = self.makeURLSession()private func makeURLSession() -&gt; URLSession &#123;return URLSession(configuration: .default, delegate: self, delegateQueue: .main)&#125;&#125;class Renderer &#123;lazy var displayLink: CADisplayLink = self.makeDisplayLink()private func makeDisplayLink() -&gt; CADisplayLink &#123;return CADisplayLink(target: self, selector: #selector(screenDidRefresh))&#125;&#125; 结构体初始化时可设置self值，但其他方法修改self需要添加mutabling 12345678910extension Bool: AnswerConvertible &#123;public init(input: String) throws &#123;switch input.lowercased() &#123;case &quot;y&quot;, &quot;yes&quot;, &quot;👍&quot;:self = truedefault:self = false&#125;&#125;&#125; 使用extension来组织代码 使用set减少枚举时的if/else if使用! 高，真高！ 1234567891011121314class RoadTile: Tile &#123;var connectedDirections = Set&lt;Direction&gt;()func render() &#123;switch connectedDirections &#123;case [.up, .down]:image = UIImage(named: &quot;road-vertical&quot;)case [.left, .right]:image = UIImage(named: &quot;road-horizontal&quot;)default:image = UIImage(named: &quot;road&quot;)&#125;&#125;&#125; 协议可继承、可扩展！自然也就可重载、覆盖，然后就可以干点事情了 12345678910111213141516171819// Declare a public protocol that acts as your immutable APIpublic protocol ModelHolder &#123;associatedtype Modelvar model: Model &#123; get &#125;&#125;// Declare an extended, internal protocol that provides a mutable APIinternal protocol MutableModelHolder: ModelHolder &#123;var model: Model &#123; get set &#125;&#125;// You can now implement the requirements using &apos;public internal(set)&apos;public class UserHolder: MutableModelHolder &#123;public internal(set) var model: Userinternal init(model: User) &#123;self.model = model&#125;&#125; Converting Swift errors to NSError 12case .some(let error as NSError) where error.code == NSURLErrorNotConnectedToInternet:presenter.showOfflineView() lazy属性最好加上类型，外部调用最好加上self ！同时swift4也支持lazy的自动类型推断 静态依赖注入! 参数默认值的妙用 1234567891011121314151617181920212223// Before: Almost impossible to test due to the use of singletonsclass Analytics &#123;static func log(_ event: Event) &#123;Database.shared.save(event)let dictionary = event.serialize()NetworkManager.shared.post(dictionary, to: eventURL)&#125;&#125;// After: Much easier to test, since we can inject mocks as argumentsclass Analytics &#123;static func log(_ event: Event,database: Database = .shared,networkManager: NetworkManager = .shared) &#123;database.save(event)let dictionary = event.serialize()networkManager.post(dictionary, to: eventURL)&#125;&#125; 以元组作为闭包的参数！好处：简单、可扩展且命名更规范 任何静态方法或属性都可以与点语法一起使用 12345678910111213141516public enum RepeatMode &#123;case times(Int)case forever&#125;public extension RepeatMode &#123;static var never: RepeatMode &#123;return .times(0)&#125;static var once: RepeatMode &#123;return .times(1)&#125;&#125;view.perform(animation, repeated: .once) 参数的本地拷贝，swift中除了类是引用，其他都是值类型，即当做参数都是copy进入的let常量，这时候在函数内部使用，最好拷贝一下 123init(repeatMode: RepeatMode, closure: @escaping () -&gt; UpdateOutcome) &#123;// Shadow the argument with a local, mutable copyvar repeatMode = repeatMode 强大的where，可用于 协议、for in、case、catch、泛型 等，但if let、guard和while中被去掉了，使用 ，逗号分割不同条件 Extending optionals12345678910111213141516171819202122232425262728293031323334353637func validateTextFields() -&gt; Bool &#123;guard !usernameTextField.text.isNilOrEmpty else &#123;return false&#125;...return true&#125;// Since all optionals are actual enum values in Swift, we can easily// extend them for certain types, to add our own convenience APIsextension Optional where Wrapped == String &#123;var isNilOrEmpty: Bool &#123;switch self &#123;case let string?:return string.isEmptycase nil:return true&#125;&#125;&#125;// Since strings are now Collections in Swift 4, you can even// add this property to all optional collections:extension Optional where Wrapped: Collection &#123;var isNilOrEmpty: Bool &#123;switch self &#123;case let collection?:return collection.isEmptycase nil:return true&#125;&#125;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift开发者必备Tips]]></title>
    <url>%2F2018%2F10%2F10%2FSwift%E5%BC%80%E5%8F%91%E8%80%85%E5%BF%85%E5%A4%87Tips%2F</url>
    <content type="text"><![CDATA[柯里化: 通过模板来批量生成方法 123456func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;return &#123; $0 &gt; comparer&#125;&#125;let greaterThan10 = greaterThan(10)greaterThan10(13) // truegreaterThan10(0) // false 将protocol的方法声明为mutating：mutating关键字是为了能在该方法里修改struct或enum变量，另外使用class实现protocol时，可以不用加mutating，因class可随意改变量，mutating对于class时完全透明的 1234567891011import UIKitprotocol Vehicle &#123;var color: UIColor &#123;get set&#125;mutating func changeColor()&#125;struct MyCar: Vehicle &#123;var color = UIColor.bluemutating func changeColor() &#123;color = .red&#125;&#125; for循环可用于实现了Sequence的类型上，要实现Sequence需要先实现IteratorProtocol协议 1234567891011121314151617181920212223242526272829303132class ReverseIterator&lt;T&gt;: IteratorProtocol &#123;typealias Element = Tvar array:[Element]var currentIndex = 0init(array:[Element]) &#123;self.array = arraycurrentIndex = array.count - 1&#125;func next() -&gt; Element? &#123;if currentIndex &lt; 0 &#123;return nil&#125;else &#123;let element = array[currentIndex]currentIndex -= 1return element&#125;&#125;&#125;struct ReverseSequence&lt;T&gt;: Sequence &#123;var array:[T]init(array:[T]) &#123;self.array = array&#125;typealias Iterator = ReverseIterator&lt;T&gt;func makeIterator() -&gt; ReverseIterator&lt;T&gt; &#123;return ReverseIterator(array: self.array)&#125;&#125;let arr = [2,3,4,5,7,6]for (index, value) in ReverseSequence(array: arr).enumerated() &#123;print(&quot;index is \(index) value is \(value)&quot;)&#125; 多元组 1234567func swap&lt;T&gt;(a: inout T, b: inout T) &#123;(a, b) = (b, a)&#125;var a = 2var b = 3swap(&amp;a, &amp;b)print(&quot;a is \(a) b is \(b)&quot;) @autoclosure 是把形如 ()-&gt;T 的一句表达式（无参数，就一句）自动封装成闭包，var c = a ?? b,表示a非nil时c=a，nil时c=b，其实跟连着写的?: 是一样的 123456789101112131415161718192021func logIfTure(_ predicate: ()-&gt; Bool)&#123;if predicate() &#123;print(&quot;value is true!&quot;)&#125;&#125;logIfTure (&#123; () -&gt; Bool inreturn 2 &gt; 1&#125;)logIfTure (&#123;return 3 &gt; 2&#125;)logIfTure(&#123; 4 &gt; 3 &#125;)logIfTure &#123; 5 &gt; 4 &#125;func logIfTureAutoclosure(_ predicate:@autoclosure ()-&gt; Bool)&#123;if predicate() &#123;print(&quot;value is true!&quot;)&#125;&#125;// 注意是小括号logIfTureAutoclosure(6&gt;5) @escaping逃逸闭包，异步回调那种函数执行完了闭包还需要执行，注意循环引用使用weak self unowned self； 1234567891011121314151617181920212223242526// 逃逸闭包func testEscapingFunc(printNum: @escaping (_ num: Int) -&gt; ())&#123;print(&quot;testEscapingFunc begin&quot;)DispatchQueue.global().async &#123;DispatchQueue.main.async &#123;printNum(66)&#125;&#125;print(&quot;testEscapingFunc end&quot;)&#125;testEscapingFunc &#123; (num) inprint(&quot;Escaping colsure begin&quot;)print(&quot;Escaping num is \(num)&quot;)print(&quot;Escaping colsure end&quot;)&#125;// 非逃逸闭包func testNoescapeFunc(printNum: (_ num: Int) -&gt; ()) &#123;print(&quot;testNoescapeFunc begin&quot;)printNum(77)print(&quot;testNoescapeFunc end&quot;)&#125;testNoescapeFunc &#123; (num) inprint(&quot;Noescape colsure begin&quot;)print(&quot;Noescape num is \(num)&quot;)print(&quot;Noescape colsure end&quot;)&#125; optional chaining ，返回的都是最后一个的可选类型 1234567891011121314151617181920class Pet &#123;let name: Stringinit(name: String) &#123;self.name = name&#125;func play() -&gt; (String) &#123;return &quot;playing&quot;&#125;&#125;class Child &#123;var pet: Pet?&#125;var xiaoming = Child()xiaoming.pet = Pet(name: &quot;dog&quot;)if let petName = xiaoming.pet?.name &#123;print(&quot;xiaoming pet name is \(petName)&quot;)&#125;if let p = xiaoming.pet?.play() &#123;print(&quot;xiaoming pet is \(p)&quot;)&#125; 重载操作符，慎用避免冲突，应该是公开的 1234567891011struct Vector2D &#123;var x = 0var y = 0&#125;func +(left:Vector2D, right:Vector2D) -&gt; Vector2D&#123;return Vector2D(x: left.x + right.x, y: left.y + right.y)&#125;let v1 = Vector2D(x: 1, y: 2)let v2 = Vector2D(x: 3, y: 4)let v3 = v1 + v2print(&quot;v3 is \(v3)&quot;) func的参数修饰，默认参数都是copy的，inout关键字可以直接修改参数值 1234567891011func incrementor1(x: Int) -&gt; Int &#123;x + 1return x&#125;print(&quot;参数不可变 \(incrementor1(x: 1))&quot;)func incrementor2(x: inout Int) &#123;x = x + 1&#125;var x = 1incrementor2(x: &amp;x)print(&quot;参数可变 \(x)&quot;) 字面量表达式，实现类似ExpressibleByBooleanLiteral的协议 123// 以下就是字面量表达式，思考为啥写个true编译器就知道是BOOL类型的var aBool = truevar aString = &quot;this is a string&quot; 下标，数组下标注意越界，字典下标返回可选类型。可以重写数组或字典下标，也可以自定义下标,实现subscript方法，延伸阅读窥探Swift之数组安全索引与数组切片 方法嵌套，更清晰不用在别的地方调用一堆小方法了都在函数里面呢，访问权限更易管理 12345678910func makeIncrementer(add: Int) -&gt; (inout Int) -&gt; Void &#123;func incrementer(x : inout Int) -&gt; Void &#123;x = x + add&#125;return incrementer;&#125;let incrementer2 = makeIncrementer(add: 2)var y = 3incrementer2(&amp;y)print(&quot;\(y)&quot;) 命名空间。基于module的而不是直接再代码中显示指明的，进行app开发时，默认添加app的主target里的内容都在同一命名空间里，即同一target里名称不能相同。 typealias，指定类型重命名。当实现多个协议时，也可以用 &amp; 连接多协议，用typealias重命名 1234567protocol Dog &#123;func watch() -&gt; Void&#125;protocol Cat &#123;func sleep() -&gt; Void&#125;typealias Pet = Dog &amp; Cat associatedtype 如果有多个协议，它们的方法和属性都一样，只有协议中用到的类型不同，则可合并为一个使用关联类型(associatedtype)进行区分。实现时自定义typealias相应类型即可。延伸阅读Swift—–协议Protocol 可变参数OC的可变参数123456789101112131415161718// 注意可变参数必须是最后一个参数，且name后面有一个英文逗号- (void)testMultiplePramar:(NSString *)name, ... &#123;// 一个字符类型的指针，指针指向当前的参数，需要通过这个指针取参数。va_list arg_list;// 初始化字符指针的函数，将把arg_list指针指向name这个可变形参的第一个位置va_start(arg_list, name);NSLog(@&quot;第一个 ： %@&quot;, name);while(YES)&#123;// 这是一个取参数的函数，这个函数需要两个参数，第一个参数是字符指针va_list，第二个参数是我们需要取的可变参数的数据类型// 这个函数需要做两件事：1：取到指定数据类型的参数。2：将指针ap指向下一个可变参数的地址。NSString * obj=va_arg(arg_list,NSString *);// 取完所有参数之后，跳出循环if(obj==nil)break;NSLog(@&quot;--- %@&quot;,obj);&#125;// 最后要将指针ap指向NULL。避免野指针。和va_start成对使用。va_end(arg_list);&#125; Swift版可变参数12345678// 只能有一个可变参数，位置不限类型相同func myFunc(numbers:Int..., str: String) &#123;numbers.forEach &#123; (i) inprint(&quot;\(str)，第\(i)个&quot;)&#125;&#125;myFunc(numbers: 1,2,3,4,5, str: &quot;hello&quot;)Swift版的stringformat方法 init(format:NSString, _ args: CVarArgType...) 初始化方法顺序明确一个问题不要在init初始化方法里使用self.property A，OC是先初始化父类在初始化子类成员变量B，1，先初始化子类成员变量，2调用父类初始化，（若没第3步，可不写编译器自己加）3对父类中需要改变的成员进行设定 123456789101112131415161718192021class ClassA &#123;let numA: Int// Designated 指定的 init初始化方法// 也可以加上required关键字以确保子类对其实现init(num: Int) &#123;numA = num; //可对let的实例常量赋值&#125;// 所有的便利构造器都必须调同一类中Designated初始化完成设置，且不能被子类重写或从子类中以super的方式调用convenience init(bigNum: Bool) &#123;self.init(num: bigNum ? 1000 : 1)&#125;&#125;class ClassB: ClassA &#123;let numB: Intoverride init(num: Int) &#123;numB = num + 2super.init(num: num)&#125;&#125;let bObj = ClassB(bigNum: true) 初始化返回nilOC初始化失败可以返回nil，但swift没有return，因此swif中用 init? 表示返回可选值，即可能失败 static 和 class， 注意cpoy on write 容器(Array, Dictionary, Set)只能放同一类型元素，如果想放不同类型怎么办？A。类型转换，信息损失十分危险，最好不要用！1234import UIKitlet mixed: [Any] = [1, &quot;Two&quot;,3]; // Any类型可以隐式转换// 转换为[NSObject]let objectArray = [1 as NSObject, &quot;two&quot; as NSObject, 3 as NSObject] B。如果有共同特征，可以添加实现同一协议的类型的对象12345import Foundationlet mixed2 : [CustomStringConvertible] = [1, &quot;two&quot;, 3]for obj in mixed2 &#123;print(obj.description)&#125; C。将类型信息封装到enum中1234567891011121314import Foundationenum IntOrString &#123;case IntValue(Int)case StringValue(String)&#125;let mixed = [IntOrString.IntValue(1), IntOrString.StringValue(&quot;two&quot;), IntOrString.IntValue(3)]for value in mixed &#123;switch value &#123;case let .IntValue(i):print(i)case let .StringValue(str):print(str)&#125;&#125; default参数 12345func hello(name:String = &quot;JZK&quot;, str:String)&#123;print(name+&quot; &quot;+str)&#125;hello(str: &quot;hello world&quot;)hello(name: &quot;dxm&quot;, str: &quot;hello world&quot;) 正则表达式。自定义符号还是麻烦，其实用OC的是最省事的，正则表达式30分钟入门教程，8个常用正则 模式匹配,没看懂好像就是switch的使用而已呀，重载~/ 跟switch有啥子关系。。。 … 和 ..&lt; 12345678910// 包含3，即输出0 1 2 3for i in 0...3 &#123;print(&quot;\(i)&quot;)&#125;// 小于3（不含3），即输出0 1 2for i in 0..&lt;3 &#123;print(&quot;\(i)&quot;)&#125;// 还可以通过 ... 或 ..&lt; 来连接两个字符串// 但经过试验发现很难用，例&quot;0&quot;...&quot;10&quot; 包含&quot;1&quot;但不包含&quot;2&quot;, 还有校验ASCII码 \0...~ 确实正确的 AnyClass, 元类型和 .self 1234567891011121314151617// swift中能够表示“任意”这个概念的除了 Any 和 AnyObject 外，还有AnyClass , AnyClass = AnyObject.Type// .Type 表示的是某个类型的元类型。.Protocol表示某个协议的元类型// 类型.self 表示获得该类型Class， 实例.self表示获得该实例对象import UIKitclass AVC: UIViewController &#123;&#125;class BVC: UIViewController &#123;&#125;// 强转成AnyClass，类似工厂方法let VCTypes : [AnyClass] = [AVC.self, BVC.self]for type in VCTypes &#123;if type is UIViewController.Type &#123;// 想想为什么可以调init 类方法？let vc = (type as! UIViewController.Type).init()print(&quot;vc实例类型为：\(vc)&quot;)&#125;&#125; 协议和类方法中的Self 1// 协议没自己的上下文信息，也不知道谁实现。当我们希望在协议中使用的就是实现这个协议本身的类型的话，就需要使用Self（注意首字母大写）进行指代，此时Self不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。 动态类型和多方法dynamicType废除，用type(of:)代替 属性观察存储型属性 willSet 和 didSet 方法中newValue表示将要设定的，oldValue表示已经设定的。注意初始化时不会调属性观察。计算形型属性只有get和set方法 final 表示不允许继承或重写。 lazy修饰符和lazy方法 123456789101112131415class ClassA &#123;// class或struct 的变量属性，且需指明类型lazy var str : String = &quot;hello&quot;&#125;// lazy 也能修饰方法,对于可能提前退出情况，性能优化明显let arr = 1...3let result = arr.lazy.map &#123; (i: Int) -&gt; Int inprint(&quot;map \(i)&quot;)return i * 2&#125;print(&quot;begin&quot;)for i in result &#123;print(&quot;result \(i)&quot;)&#125;print(&quot;end&quot;) refection 和 mirror , 知道有反射就行了，最好不用 强制解包，少用才好，多用可选链！ 多重optional 12345678910var aNil : String? = nilvar anotherNil : String?? = aNilvar literalNil : String?? = nilif anotherNil != nil &#123;print(&quot;anotherNil&quot;) // 输出&#125;if literalNil != nil &#123;print(&quot;literalNil&quot;) //&#125;// 但用po输出时，anotherNil和literalNil 都是nil，因lldb已经将optional展开了 optional map ，没啥用 协议扩展 protocol extension， 可以为协议中定义的方法提供一个默认的实现 where 和模式匹配 indirect 和嵌套enum swift的#selector 和OC的@selector一样，swift4中默认所有的swift方法在OC中都不可见，所以需要在方法前加上@objc 关键字。使用#selector时，swift的同名方法需要强制转化 实例方法动态调用，挺好玩的，虽然我也没想到有什么用 12345678910class MyClass &#123;func method(num: Int) -&gt; Int &#123;return num + 2&#125;&#125;// 实例化MyClass对象，再调用method方法就限定死了类型// 但swift中可直接用 Type.instanceMethod的语法生成一个可以柯里化的方法，只适用于实例方法，对getter或setter无效,同名方法需对 f 加上类型加以区别let f = MyClass.methodlet object = MyClass()let result = f(object)(1) 单例 1234567891011121314// 设置init方法为private来覆盖默认public的方法，保证其他地方不能init实例//方法一class AppShared &#123;private static let _sharedInstance = AppShared()class func sharedInstance() -&gt;AppShared&#123;return _sharedInstance&#125;private init() &#123;&#125;&#125;//方法二class AppShared2 &#123;static let sharedInstance = AppShared2()private init() &#123;&#125;&#125; 条件编译 123// swift中没有宏，实质上是一些全局常量和函数//#if condition //注意condition大小写敏感//#endif 延伸阅读Swift中如何使用 #if DEBUGcondition | 可选参数—|—os() | macOS,iOS,tvOS,watchOS,Linuxarch() | x86_64, arm, arm64, i386swift() | &gt;= 某个版本 编译标记OC的#param，在swift中用 // MARK:- 代替（注意大写），此外还有// TODO: 和 // FIXME: , 但没有#warning的替代品 @UIApplicationMain， 和OC的main函数是一样的，如果我们想使用UIApplicaiton的子类(例如监听所有的点击事件)，就可以创建main.swift @objc 和 dynamic，swift写的类继承自NSObject的话，swift会自动为所有非private的类和成员加上@objc，但@objc并不意味着会变成动态派发，动态派发需用dynamic关键字。延伸阅读iOS OC与Swift混编，注意和OC的@dynamic没任何关系，@dynamic表示不用编译器自动生成getter和setter方法 可选协议和协议扩展 内存管理，weak和unowned，如果再在访问时不会被释放的话，尽量用unowned，如果存在被释放的课鞥呢，那就用weak @autoreleasepool在swift中已经没有了, swift提倡用初始化方法而不是用类方法来生成对象 值类型和引用类型，swift中所有的内建类型都是值类型，甚至String，array以及Dictionary都是值类型，值类型复制值发生在内容发生改变时 String 还是 NSString？能用String尽量用String，但使用Range时还是NSString更好用 UnsafePointer, 用于对C语言的指针进行转换，C中的基本类型在swift中对应的类型都有统一的命名规则：前面加上 C 且首字母大写，例如int 对应的类型为 CInt，int的指针转换到swift中对应的就是UnsafePointer, C的指针不可变用UnsafePointer,可变指针用UnsafeMutablePointer C指针的内存管理，无法使用ARC，deallocate与deinitialize应该要和allocate与initialize成对出现。malloc和calloc要与free匹配 C中指向函数的指针可转为闭包，不过需要加上@convention标注 GCD和延时调用, OC多线程 和 swift的GCD 获取对象类型 type(of:) OC的 isKindOfClass 和 isMemberOfClass 在swift中继承自NSObject的依然可以使用，swift还有 is 关键字等同于isKindOfClass，但也可以用于struct或enum进行类型判断。as 关键字向上转型；as！向下转型；as？向下转型，如果失败返回nil swift中的KVO实现, 延伸：可用属性观察自己实现，也可参考 1234567891011121314151617181920212223import UIKit// 继承自NSObjectclass MyClass: NSObject &#123;// 要检测的属性必须标注 @objc dynamic@objc dynamic var date = Date()&#125;class KvoClass: NSObject &#123;var myObject : MyClass!var observation: NSKeyValueObservation?override init() &#123;myObject = MyClass()print(&quot;初始化时间：\(Date())&quot;)observation = myObject.observe(\MyClass.date, options: [.new], changeHandler: &#123; (_, change) inif let newDate = change.newValue &#123;print(&quot;变化时间：\(Date())&quot;)&#125;&#125;)&#125;&#125;var kvoObject = KvoClass()DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123;kvoObject.myObject.date = Date()&#125; 局部scope，隔离代码的好方法 1234567891011121314151617181920212223242526272829// OC中使用方法- (void)viewDidLoad &#123;[super viewDidLoad];// 局部scope&#123;UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 100, 44)];label1.text = @&quot;first label&quot;;[self.view addSubview:label1];&#125;// GNU C的声明扩展UILabel *label2 = (&#123;UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 200, 100, 44)];tempLabel.text = @&quot;second label&quot;;tempLabel; // 注意没有return&#125;);[self.view addSubview:label2];&#125;// swift不允许直接使用大括号，和闭包冲突。而且没有GNU C的声明扩展// 但可以使用匿名闭包override func viewDidLoad() &#123;super.viewDidLoad()// Do any additional setup after loading the view, typically from a nib.let titleLabel : UILabel = &#123;let label = UILabel(frame: CGRect(x: 0, y: 100, width: 100, height: 44))label.text = &quot;匿名闭包&quot;return label&#125;()self.view.addSubview(titleLabel)&#125; OC中==表示判断两个对象是否指向同一块内存，在swift中对应为 === ，而swift中的 == 是一个操作符声明，在 Equatable 协议里声明，可重载，没重载的话就是 isEqual 哈希 类簇，swift中使用工厂方法模式来实现，因swift中初始化方法只能得到完成所有配置的当前类实例，即不可能在公共类中返回子类信息 swift中直接使用C代码或库是不可能的，因此使用C库最好的办法是使用OC文件封装，通过 工程名-Bridging-Header.h 桥接文件来调OC的代码 输出格式化 12345import UIKitvar b = 1.234567890print(&quot;b is \(b)&quot;)let formatB = String(format: &quot;%.2f&quot;, b)print(&quot;保留两位小数 b is \(formatB)&quot;) OC的NS_ENUM对应swift的enum，OC的NS_OPTIONS被映射为满足OptionSet协议的struct类型，以及一组静态的get属性，对不需要选项的可以用[]空集合表示，可以参照 AnimationOptions 数组的enumerated 123for (index, item) in [2,4,1,4,5].enumerated() &#123;print(&quot;index is \(index) value is \(item)&quot;)&#125; OC中可以通过@encode来获取类型编码，swift中可以通过转换为NSValue类型，使用objCType获取类型编码。类型编码这个运行时还是比较有用的 @asmname可直接将C函数映射为swift函数，但可能会有命名冲突，慎用 swift的protocol可以被class，struct，enum等类型遵守。而想要在swift中声明weak delegate，就最要将protocol限制在class内 12345678910// 将protocol限制在class内// 1,在protocol声明前加上@objc@objc protocol MyClassDelegate &#123;func method()&#125;// 更好的办法// 2，在protocol声明后加上classprotocol ClassDelegate : class &#123;func method()&#125; associated object 1234567891011private var key : Void?extension AppDelegate &#123;&apos;var associatedObject: String? &#123;get &#123;return objc_getAssociatedObject(self, &amp;key) as? String&#125;set &#123;objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_COPY)&#125;&#125;&#125; swift中没有 @synchronized ，但可以自己实现一个 123456// OC的@synchronized，也是调objc_sync_enter和objc_sync_exit，外加异常判断func syncchronized(_ lock: AnyObject, closure:()-&gt;())&#123;objc_sync_enter(lock) closure()objc_sync_exit(lock)&#125; OC与CoreFoundation的转化规则：bridge转换OC和CF，不涉及内存；bridge_retained或CFBridgingRetain 将OC转换到CF，需要手动调用CFRelease来释放对象内存；__bridge_transfer或CFBridgingRelease将CF转化为OC，ARC负责释放对象。对于CF系API，如果API名字中含有Create，Copy或Retain的话，使用完成后要手动调CFRelease来释放内存。但在swift中，与CF的转化可以省掉了，也不用调CFRelease释放内存了，一个字：爽 swift命令号工具 随机数 1234// let num = Int(arc4random()) % 5 + 1 ; iphone4，5上可能crash// 因swift的Int和CPU架构有关，在32位CPU上是Int32，64位CPU上是Int64，而arc4random不论什么平台上都是UInt32，故可能越界crash// 可用arc4random_uniform 实现相同效果let num = Int(arc4random_uniform()) % 5 + 1 ; CustomStringConvertible 和 CustomDebugStringConvertible 协议可以格式化print样式 要throws另一个throws时，应将前者改为rethrows。Swift异常处理 和 swift的defer 123456do &#123;//try? 抛出异常则返回nil,没抛出正常返回；try！肯定不会抛异常。但抛出异常就crash，慎用 //try somthing//try somthing&#125; catch let err as NSError &#123;&#125; OC的NSAssert宏 在swift中对应为assert函数 fatalError可以在release和debug下终止程序，类似于Debug下NSAssert(NO, @”说明”);的作用 代码组织和Framework 安全的资源组织方式，OC时经常将资源名称定义为宏，这样可相对集中的管理和修改。swift可以用enum和extension来处理资源，原理如下。SwiftGen 和 R.swift 可扫描文件自动生成对应的enum或struct文件 123456789enum ImageName: String &#123;case myImage = &quot;my_image&quot;&#125;extension UIImage &#123;convenience init?(imageName: ImageName)&#123;self.init(named: imageName.rawValue)&#125;&#125;let image = UIImage(imageName: .myImage) Playground延时运行有问题，需要引入PlaygroundSupport框架 Playground与项目协作 Playground的可视化开发 NaN 是not a number的意思，很特殊，但好像没啥用！ isNaN 判断是否是NaN swift4以后可以用Codable协议进行json解析，序列化和反序列化操作 swift中NSNull会默认通过可选链转化为nil 在方法或属性上面使用快捷键（ alt+cmd+/ ）快速生成注释。也可使用jazzy swift由于类型安全，性能比较高！ log输出 1234// #file 文件路径，#line 行号，#function 方法名func Log&lt;T&gt;(_ message: T, file: String = #file, method:String = #function, line:Int = #line)&#123;print(&quot;\((file as NSString).lastPathComponent)[\(line)],\(method): \(message)&quot;)&#125; swift中可以通过 &amp;+，&amp;-，&amp;*，&amp;/, &amp;% 来忽略溢出的错误 swift中没有宏定义，使用let 或 get属性来替代宏定义 属性访问控制：open (跨模块) &gt; public（本模块） &gt; interal（本模块内部用） &gt; fileprivate（本文件可用） &gt; private（本类可用） swift中的测试 swift的CoreData使用 闭包很好用，最好写全了，别用乱七八糟的简写]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mach-O文件]]></title>
    <url>%2F2018%2F09%2F29%2FMach-O%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[简介&emsp;&emsp;大家都知道iOS编译到最后是Mach-O文件，其实就是iOS或OS X的可执行文件！ 结构&emsp;&emsp;最后给大家安利两个工具：1、MachOView:mach-o文件解析器可直接查看mach-o文件；2、OSX系统自带的otool可以分析Mach-O可执行文件 1 Header&emsp;&emsp;下载源码 -&gt; EXTERNAL_HEADERS -&gt; mach-o文件夹 -&gt; loader.h 查看相关源码，32位和64位区别不大，这里只贴了64位的结构123456789101112131415161718/** The 64-bit mach header appears at the very beginning of object files for* 64-bit architectures.*/struct mach_header_64 &#123;uint32_t magic; /* mach magic number identifier */cpu_type_t cputype; /* cpu specifier */cpu_subtype_t cpusubtype; /* machine specifier */uint32_t filetype; /* type of file */uint32_t ncmds; /* number of load commands */uint32_t sizeofcmds; /* the size of all the load commands */uint32_t flags; /* flags */uint32_t reserved; /* reserved */&#125;;/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ &emsp;&emsp;简单解释 magic 用于判断程序的平台版本 cputype 和 cpusubtype 用于判断cpu型号和cpu子型号 filetype 文件类型,决定了文件布局方式 1234567* Constants for the filetype field of the mach_header*/#define MH_OBJECT 0x1 /* relocatable object file */#define MH_EXECUTE 0x2 /* demand paged executable file */#define MH_FVMLIB 0x3 /* fixed VM shared library file */等... ncmds代表Load Command的个数 sizeofcmds代表ncmds段Load Command的总字节数 flags表示dyld加载标志位 123456/* Constants for the flags field of the mach_header */#define MH_NOUNDEFS 0x1 /* the object file has no undefinedreferences */#define MH_INCRLINK 0x2 /* the object file is the output of an等... reserved是x64的保留位 2 Load Command&emsp;&emsp;先看源码1234struct load_command &#123;uint32_t cmd;uint32_t cmdsize;&#125;; &emsp;&emsp;每一个command前两个字段必须是CMD和CMDSIZE，且每一个都是一个特殊的结构体，所以除了cmd之外还需要cmdsize12345* Constants for the cmd field of all load commands, the type */#define LC_SEGMENT 0x1 /* segment of this file to be mapped */#define LC_SYMTAB 0x2 /* link-edit stab symbol table info */等... 3 segment_command&emsp;&emsp;直接使用LC_xxx搜索就能搜到相应的cmd数据结构，直接搜索LC_SEGMENT ，查看segment的结构12345678910111213141516171819/** The 64-bit segment load command indicates that a part of this file is to be* mapped into a 64-bit task&apos;s address space. If the 64-bit segment has* sections then section_64 structures directly follow the 64-bit segment* command and their size is reflected in cmdsize.*/struct segment_command_64 &#123; /* for 64-bit architectures */uint32_t cmd; /* LC_SEGMENT_64 */uint32_t cmdsize; /* includes sizeof section_64 structs */char segname[16]; /* segment name */uint64_t vmaddr; /* memory address of this segment */uint64_t vmsize; /* memory size of this segment */uint64_t fileoff; /* file offset of this segment */uint64_t filesize; /* amount to map from the file */vm_prot_t maxprot; /* maximum VM protection */vm_prot_t initprot; /* initial VM protection */uint32_t nsects; /* number of sections in segment */uint32_t flags; /* flags */&#125;; &emsp;&emsp;注意问题（大小写敏感） __TEXT segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。 __DATA segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。 4 section&emsp;&emsp;源码1234567891011121314struct section_64 &#123; /* for 64-bit architectures */char sectname[16]; /* name of this section */char segname[16]; /* segment this section goes in */uint64_t addr; /* memory address of this section */uint64_t size; /* size in bytes of this section */uint32_t offset; /* file offset of this section */uint32_t align; /* section alignment (power of 2) */uint32_t reloff; /* file offset of relocation entries */uint32_t nreloc; /* number of relocation entries */uint32_t flags; /* flags (section type and attributes)*/uint32_t reserved1; /* reserved (for offset or index) */uint32_t reserved2; /* reserved (for count or sizeof) */uint32_t reserved3; /* reserved */&#125;; &emsp;&emsp;常见的Section，更多 Section 解释 TEXT.text 主程序代码 TEXT.cstring C 语言字符串 TEXT.const const 关键字修饰的常量 TEXT.stubs 用于 Stub 的占位代码，很多地方称之为桩代码。 TEXT.stubs_helper 当 Stub 无法找到真正的符号地址后的最终指向 TEXT.objc_methname Objective-C 方法名称 TEXT.objc_methtype Objective-C 方法类型 TEXT.objc_classname Objective-C 类名称 DATA.data 初始化过的可变数据 DATA.la_symbol_ptr lazy binding 的指针表，表中的指针一开始都指向 __stub_helper __DATA.nl_symbol_ptr 非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号 DATA.const 没有初始化过的常量 DATA.cfstring 程序中使用的 Core Foundation 字符串（CFStringRefs） DATA.bss BSS，存放为初始化的全局变量，即常说的静态内存分配 DATA.common 没有初始化过的符号声明 DATA.objc_classlist Objective-C 类列表 DATA.objc_protolist Objective-C 原型 DATA.objc_imginfo Objective-C 镜像信息 DATA.objc_selfrefs Objective-C self 引用 DATA.objc_protorefs Objective-C 原型引用 DATA.objc_superrefs Objective-C 超类引用 参考 objc中国 Mach-O 可执行文件 趣探 Mach-O：文件格式分析 趣探 Mach-O：加载过程]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习swift：SwiftyJSON]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%A4%8D%E4%B9%A0swift%EF%BC%9ASwiftyJSON%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;继续复习swift，就平时写dome那点代码量，swift还是会忘光的，反正也不知道水啥！开始复习 SwiftyJSON内部通过枚举和私有属性将Data转为具体类型 1234567891011121314151617public enum Type: Int &#123;case numbercase stringcase boolcase arraycase dictionarycase nullcase unknown&#125;/// Private objectfileprivate var rawArray: [Any] = []fileprivate var rawDictionary: [String: Any] = [:]fileprivate var rawString: String = &quot;&quot;fileprivate var rawNumber: NSNumber = 0fileprivate var rawNull: NSNull = NSNull()fileprivate var rawBool: Bool = false init的核心方法 1234567891011121314151617181920/// Private method to unwarp an object recursively// 递归的拆解object对象，拆成数组、字典或基本类型private func unwrap(_ object: Any) -&gt; Any &#123;switch object &#123;case let json as JSON:return unwrap(json.object)case let array as [Any]:return array.map(unwrap)case let dictionary as [String: Any]:// 小细节，dictionary是let常量var d = dictionary// 小细节2，手动命名元祖pair，命名更清晰dictionary.forEach &#123; pair ind[pair.key] = unwrap(pair.value)&#125;return ddefault:return object&#125;&#125; merge的核心方法 123456789101112131415161718192021222324/**Private woker function which does the actual mergingTypecheck is set to true for the first recursion level to prevent total override of the source JSON*/fileprivate mutating func merge(with other: JSON, typecheck: Bool) throws &#123;if type == other.type &#123;switch type &#123;case .dictionary:for (key, _) in other &#123;try self[key].merge(with: other[key], typecheck: false)&#125;case .array:self = JSON(arrayValue + other.arrayValue)default:self = other&#125;&#125; else &#123;if typecheck &#123;throw SwiftyJSONError.wrongType&#125; else &#123;self = other&#125;&#125;&#125; 厉害的枚举 123456789101112131415161718192021222324252627/*这个枚举定义的好，支持泛型对子类型进行包装！又是实现协议，间接让JSON有了Collection的能力*/public enum Index&lt;T: Any&gt;: Comparable &#123;case array(Int)case dictionary(DictionaryIndex&lt;String, T&gt;)case null// 实现协议static public func == (lhs: Index, rhs: Index) -&gt; Bool &#123;switch (lhs, rhs) &#123;case (.array(let left), .array(let right)): return left == rightcase (.dictionary(let left), .dictionary(let right)): return left == rightcase (.null, .null): return truedefault: return false&#125;&#125;static public func &lt; (lhs: Index, rhs: Index) -&gt; Bool &#123;switch (lhs, rhs) &#123;case (.array(let left), .array(let right)): return left &lt; rightcase (.dictionary(let left), .dictionary(let right)): return left &lt; rightdefault: return false&#125;&#125;&#125; 厉害的数组path取值 1234567891011121314151617181920212223242526272829303132333435363738394041// Int从数组中取，string从字典中取fileprivate subscript(sub sub: JSONSubscriptType) -&gt; JSON &#123;get &#123;switch sub.jsonKey &#123;/*第一次看到self[index: index]差点就绕进去了，后来才反应过来调用上面的fileprivate subscript(index index: Int) -&gt; JSON*/ case .index(let index): return self[index: index]case .key(let key): return self[key: key]&#125;&#125;set &#123;switch sub.jsonKey &#123;case .index(let index): self[index: index] = newValuecase .key(let key): self[key: key] = newValue&#125;&#125;&#125;public subscript(path: [JSONSubscriptType]) -&gt; JSON &#123;get &#123;// 越来越喜欢swift了，OC最起码10行起!// 友情提示：self起始参数、$0[sub: $1]下标取值return path.reduce(self) &#123; $0[sub: $1] &#125;&#125;set &#123;switch path.count &#123;case 0: returncase 1: self[sub:path[0]].object = newValue.objectdefault:var nextJSON = self[sub: path[0]]// 这里是递归，前提必须用下标语法var aPath = pathaPath.remove(at: 0)nextJSON[aPath] = newValueself[sub: path[0]] = nextJSON&#125;&#125;&#125; 吐槽OC的可变参数 12345678910// 摘抄这段是因为swift的可变参数比OC的强太多了// OC的可变参数取值麻烦还是次要的，主要是第一个参数很多人容易忘了取，具体见我很早前写的博客public subscript(path: JSONSubscriptType...) -&gt; JSON &#123;get &#123;return self[path]&#125;set &#123;self[path] = newValue&#125;&#125; 重载标识符 12345678910111213141516// MARK: - Comparableextension JSON: Swift.Comparable &#123;&#125;public func == (lhs: JSON, rhs: JSON) -&gt; Bool &#123;switch (lhs.type, rhs.type) &#123;case (.number, .number): return lhs.rawNumber == rhs.rawNumbercase (.string, .string): return lhs.rawString == rhs.rawStringcase (.bool, .bool): return lhs.rawBool == rhs.rawBoolcase (.array, .array): return lhs.rawArray as NSArray == rhs.rawArray as NSArraycase (.dictionary, .dictionary): return lhs.rawDictionary as NSDictionary == rhs.rawDictionary as NSDictionarycase (.null, .null): return truedefault: return false&#125;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习swift：IQKeyboardManager]]></title>
    <url>%2F2018%2F09%2F17%2F%E5%A4%8D%E4%B9%A0swift%EF%BC%9AIQKeyboardManager%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于IQKeyboardManager的原理，自己去github上看吧，有完整的流程图（在最下面），我就写我自己感兴趣的，觉得好玩的东西 大家都在用viewTag，但一般都是正数！其实是integer类型，可以是负数！另外tag值较小的，如0-100为苹果保留使用，自己用最好1000以上 1234/**Default tag for toolbar with Done button -1002.*/private static let kIQDoneButtonToolbarTag = -1002 为什要保留通知 _kbShowNotification ? 看过源码发现，其实就是个标志位… 12/** To save keyboardWillShowNotification. Needed for enable keyboard functionality. */private var _kbShowNotification: Notification? as ad? as! 1234is 用于类型检查as 向上转型as？ 尝试向下转型，可选值as！ 强制向下转型 .self到底是啥? 12345678910111213141516171819/*self可以用在类型后面取得类型本身，也可以用在实例后面取得这个实例本身Self表示特定类型，并且只能用在协议中或者作为某个类的方法的返回值类型, &apos;Self&apos; is only available in a protocol or as the result of a method in a class*/let classNameString = NSStringFromClass(type(of: textFieldViewController.self))/*元类型用 .Type 表示。比如 Int.Type 就是 Int 的元类型，是类型不是实例值AnyClass 其实就是一个元类型 typealias AnyClass = AnyObject.Type扩展1：Any vs AnyObjectAnyObject 可以代表任何 class 类型的实例Any 可以表示任意类型，甚至包括方法（func）类型。参考：https://swifter.tips/any-anyobject/扩展2：type(of:) vs .self通过 type(of:) 和 .self都可以获得元类型的值,但.self取到的是静态的元类型，声明的时候是什么类型就是什么类型。type(of:) 取的是运行时候的元类型，也就是这个实例 的类型*/ private var registeredClasses = [UIView.Type]() 关联对象 123456789101112131415161718import Foundationimport UIKitpublic let kIQUseDefaultKeyboardDistance = CGFloat.greatestFiniteMagnitudeprivate var kIQKeyboardDistanceFromTextField = &quot;kIQKeyboardDistanceFromTextField&quot;@objc var keyboardDistanceFromTextField: CGFloat &#123;get &#123;if let aValue = objc_getAssociatedObject(self, &amp;kIQKeyboardDistanceFromTextField) as? CGFloat &#123;return aValue&#125; else &#123;return kIQUseDefaultKeyboardDistance&#125;&#125;set(newValue) &#123;objc_setAssociatedObject(self, &amp;kIQKeyboardDistanceFromTextField, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)&#125;&#125; animate 123456789101112131415/*a.union(b) //并集a.intersection(b)//交集a.subtracting(b) //取差值a.symmetricDifference(b)//去掉相同值*//*swift版NSOption是 struct实现OptionSet协议 public struct AnimationOptions : OptionSet*/ UIView.animate(withDuration: _animationDuration, delay: 0, options: _animationCurve.union(.beginFromCurrentState), animations: &#123; () -&gt; Void in// 逃逸闭包，dosomething&#125;) &#123; _ in// 尾随闭包，dosomething&#125; 多线程 1234OperationQueue.main.addOperation &#123;self.adjustPosition()self._privateHasPendingAdjustRequest = false&#125; 单例 123456789101112131415161718192021222324252627282930// 写法1/* Automatically called from the `+(void)load` method. */+ (IQKeyboardManager*)sharedManager&#123;//Singleton instancestatic IQKeyboardManager *kbManager;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;kbManager = [[self alloc] init];&#125;);return kbManager;&#125;// 写法2@objc public class var shared: IQKeyboardManager &#123;struct Static &#123;//Singleton instance. Initializing keyboard manger.static let kbManager = IQKeyboardManager()&#125;/** @return Returns the default singleton instance. */return Static.kbManager&#125;// 写法3static let sharedInstance = IQKeyboardManager() #selector 123// #selector() 的好处是不再需要使用字符串来构造// 但使用属性时，需要getter、setter前缀if textField.responds(to: #selector(setter: UITextField.inputAccessoryView)) &#123;&#125; 协议 1234// 实现多个协议方法大家都知道class ExampleTableViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UIPopoverPresentationControllerDelegate &#123;&#125;// 要求一个类型同时遵循多个协议，用协议合成@objc public weak var delegate: (UITextFieldDelegate &amp; UITextViewDelegate)?]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell复习]]></title>
    <url>%2F2018%2F09%2F10%2FShell%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[1 基础复习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# 声明变量，注意不能有空格your_name=&quot;jzk&quot;# 使用变量，最好有大括号echo $&#123;your_name&#125;# 单引号，不转义也不能嵌套，一般用于常量字符串str1=&apos;http://www.baidu.com&apos;# 双引号，能转义也能嵌套，推荐使用str2=&quot;Hello, I know \&quot;you\&quot; are $&#123;your_name&#125;! \n&quot;# 拼接字符串，注意使用双引号！单引号不转义是个坑str3=&quot;hello, &quot;$your_name&quot; !&quot;# 字符串长度echo $&#123;#str2&#125;# 字符串截断。从第2个开始截取4个echo $&#123;str2:1:4&#125;# #、## 表示从左边开始删除。一个 # 表示从左边删除到第一个指定的字符；两个 # 表示从左边删除到最后一个指定的字符。# %、%% 表示从右边开始删除。一个 % 表示从右边删除到第一个指定的字符；两个 % 表示从左边删除到最后一个指定的字符。str=&quot;www.runoob.com/linux/linux-shell-variable.html&quot;echo &quot;str : $&#123;str&#125;&quot;echo &quot;str#*/ : $&#123;str#*/&#125;&quot; # 从 字符串开头 删除到 左数第一个&apos;/&apos;echo &quot;str##*/ : $&#123;str##*/&#125;&quot; # 从 字符串开头 删除到 左数最后一个&apos;/&apos;echo &quot;str%/* : $&#123;str%/*&#125;&quot; # 从 字符串末尾 删除到 右数第一个&apos;/&apos;echo &quot;str%%/* : $&#123;str%%/*&#125;&quot; # 从 字符串末尾 删除到 右数最后一个&apos;/&apos;# 一般自己写脚本都会注明使用方式 # usage: sh xxx.sh [参数1含义] [参数2含义] [参数3含义]# 获取执行shell脚本时参数方法如下echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;;# 数组，不常用my_arry=(a b &quot;c&quot;,&quot;d&quot; abc)for i in $&#123;my_arry[@]&#125;;doecho $idone# expr 是一款表达式计算工具，使用它能完成表达式的求值操作。# 注意使用的是反引号 ` 而不是单引号 &apos;,此外推荐用 $() 代替 ``# 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。# 注意：最好使用[[....]]的结构，尽量不用[....]# 算术运算符 +、-、*、/、%、=、==、！=# 关系运算符 -eq、-ne、-gt、-lt、-ge、-le #等同于C的==、!=、&gt;、&lt;、&gt;=、&lt;=# 布尔运算符 ！、-o、-a# 逻辑运算符 &amp;&amp;、||# 字符串运算符 =、!=、-z、-n、$val1=`expr 10 + 20`val2=$(expr 10 + 20)# if判断a=10b=20if [ $a == $b ]thenecho &quot;a 等于 b&quot;elif [ $a -gt $b ]thenecho &quot;a 大于 b&quot;elif [ $a -lt $b ]thenecho &quot;a 小于 b&quot;elseecho &quot;没有符合的条件&quot;fi# forfor loop in 1 2 3 4 5doecho &quot;The value is: $loop&quot;done# whileint=1while(( $int&lt;=5 ))doecho $intlet &quot;int++&quot;done# case# 注意每一个value后面需要一个 ），;;表示C里面的break，最后结尾用esac，echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in1) echo &apos;你选择了 1&apos;;;2) echo &apos;你选择了 2&apos;;;3) echo &apos;你选择了 3&apos;;;4) echo &apos;你选择了 4&apos;;;*) echo &apos;你没有输入 1 到 4 之间的数字&apos;;;esac# break命令允许跳出所有循环，continue仅仅跳出当前循环。# 函数, return返回值，$1第一个参数、$2第二个参数fun1()&#123;return $(($1+$2))&#125;fun1 1 2# 文件包含. ./function.sh# 如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh. $real_path 2 常用linux命令2.1 帮助 老规矩，先看帮助命令！help 1234These shell commands are defined internally. Type `help&apos; to see this list.Type `help name&apos; to find out more about the function `name&apos;.Use `info bash&apos; to find out more about the shell in general.Use `man -k&apos; or `info&apos; to find out more about commands not in this list. 更强大的帮助指令是man，使用man时可以指定不同的section来浏览，各个section意义如下： 123456781 - commands // 普通的命令2 - system calls // 系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)3 - library calls // 库函数,如printf,fread4 - special files // 特殊文件,也就是/dev下的各种设备文件5 - file formats and convertions // 指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义6 - games for linux // 给游戏留的,由各个游戏自己定义7 - macro packages and conventions // 附件还有一些变量,比如向environ这种全局变量在这里就有说明8 - system management commands // 系统管理用的命令,这些命令只能由root使用,如ifconfig 2.2 目录 命令 解释 ls 全拼list，功能是列出目录的内容及其内容属性信息。 cd 全拼change directory，功能是从当前工作目录切换到指定的工作目录。 cp 全拼copy，其功能为复制文件或目录。 mkdir 全拼make directories，其功能是创建目录。 mv 全拼move，其功能是移动或重命名文件。 pwd 全拼print working directory，其功能是显示当前工作目录的绝对路径。 rename 用于重命名文件。 rm 全拼remove，其功能是删除一个或多个文件或目录。 rmdir 全拼remove empty directories，功能是删除空目录。 touch 创建新的空文件，改变已有文件的时间戳属性。 which 查找二进制命令，按环境变量PATH路径查找。 find 从磁盘遍历查找文件或目录。 whereis 查找二进制命令，按环境变量PATH路径查找。 locate 从数据库(/var/lib/mlocate/mlocate.db)查找命令，使用updatedb更新库。 2.3 查看文件 命令 解释 cat 查看文件内容,若文件不存在，创建对应文件： more 分页显示文件内容。 head 显示文件内容的头部。 iconv 转换文件的编码格式。 diff 全拼difference，比较文件的差异，常用于文本文件。 grep/egrep 过滤字符串 join 按两个文件的相同字段合并。 tr 替换或删除字符。 vi/vim 命令行文本编辑器。 2.4 其它 命令 解释 sudo 以root执行命令 ping 测试主机之间网络的连通性。 chmod 改变文件或目录权限 chown 改变文件或目录的属主和属组。 echo 打印变量，或直接输出指定的字符串 rpm 管理rpm包 history 查看命令执行的历史纪录。 参考 https://www.runoob.com/linux/linux-shell-variable.html]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习swift：Reachability]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%A4%8D%E4%B9%A0swift%EF%BC%9AReachability%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;刚转行的时候正好赶上Swift横空出世，但当时API非常不稳定，外加项目都是用OC写的就学了OC！对于Swift也是持观望态度！16年学习一段时间的Swift，后来来百度后发现都是用OC写的，而且还专门讨论过要不要引入Swift混编，结论自然是不行的：1、引入后编译变慢，包体积变大；2、其它同学都不会；再后来就不了了之了！ &emsp;&emsp;但现在已经8102年了，作为一个iOS开发你再说你不会Swift，那就真有点说不过去了！所以我决定下半年就从水Swift开始吧！至于为什么选择Reachability？因为权威和简单，好长时间不用Swift了，这次就当复习！作为复习资料，自然要找权威的、简单的！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304// import Foundation.NSThreadimport SystemConfigurationimport Foundation// 实现Error协议public enum ReachabilityError: Error &#123;// 枚举关联值，个人认为最NB的特性，其实理解成元组就好理解多了case failedToCreateWithAddress(sockaddr, Int32)case failedToCreateWithHostname(String, Int32)case unableToSetCallback(Int32)case unableToSetDispatchQueue(Int32)case unableToGetFlags(Int32)&#125;/*@available 放在函数（方法），类或者协议前面,声明这些的生命周期依赖于特定的平台和操作系统版本。而#available用在判断语句中（if, guard, while等），在不同的平台上做不同的逻辑*/@available(*, unavailable, renamed: &quot;Notification.Name.reachabilityChanged&quot;)public let ReachabilityChangedNotification = NSNotification.Name(&quot;ReachabilityChangedNotification&quot;)// 基本已经成为通知命名的固定写法了public extension Notification.Name &#123;static let reachabilityChanged = Notification.Name(&quot;reachabilityChanged&quot;)&#125;public class Reachability &#123;// 定义两个函数类型，入参Reachability，无返回值public typealias NetworkReachable = (Reachability) -&gt; ()public typealias NetworkUnreachable = (Reachability) -&gt; ()@available(*, unavailable, renamed: &quot;Connection&quot;)public enum NetworkStatus: CustomStringConvertible &#123;case notReachable, reachableViaWiFi, reachableViaWWANpublic var description: String &#123;switch self &#123;case .reachableViaWWAN: return &quot;Cellular&quot;case .reachableViaWiFi: return &quot;WiFi&quot;case .notReachable: return &quot;No Connection&quot;&#125;&#125;&#125;// CustomStringConvertible协议就是用来输出的public enum Connection: CustomStringConvertible &#123;@available(*, deprecated, renamed: &quot;unavailable&quot;)case nonecase unavailable, wifi, cellularpublic var description: String &#123;switch self &#123;case .cellular: return &quot;Cellular&quot;case .wifi: return &quot;WiFi&quot;case .unavailable: return &quot;No Connection&quot;case .none: return &quot;unavailable&quot;&#125;&#125;&#125;//public var whenReachable: NetworkReachable?public var whenUnreachable: NetworkUnreachable?@available(*, deprecated, renamed: &quot;allowsCellularConnection&quot;)public let reachableOnWWAN: Bool = true/// Set to `false` to force Reachability.connection to .none when on cellular connection (default value `true`)public var allowsCellularConnection: Bool// The notification center on which &quot;reachability changed&quot; events are being postedpublic var notificationCenter: NotificationCenter = NotificationCenter.default@available(*, deprecated, renamed: &quot;connection.description&quot;)public var currentReachabilityString: String &#123;return &quot;\(connection)&quot;&#125;@available(*, unavailable, renamed: &quot;connection&quot;)public var currentReachabilityStatus: Connection &#123;return connection&#125;// 计算型属性public var connection: Connection &#123;// 习惯于OC的 _flags需要适应一下，swift里除非重名，都可以直接用相关属性if flags == nil &#123;/*Swift 中有 4 种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用 do-catch 语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生显然这里啥也没干，上层调用者不关心*/try? setReachabilityFlags()&#125;switch flags?.connection &#123;case .unavailable?, nil: return .unavailablecase .none?: return .unavailablecase .cellular?: return allowsCellularConnection ? .cellular : .unavailablecase .wifi?: return .wifi&#125;&#125;/*private 真正私有fileprivate 文件内私有Internal 默认，可以访问自己module或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体public 可以被任何人访问。但其他module中不可以被override和继承，而在module内可以被override和继承。open 可以被任何人使用，包括override和继承。*/fileprivate var isRunningOnDevice: Bool = &#123;#if targetEnvironment(simulator)return false#elsereturn true#endif&#125;()// 只有set是fileprivatefileprivate(set) var notifierRunning = false// let 常量不可修改，但可init时赋值fileprivate let reachabilityRef: SCNetworkReachabilityfileprivate let reachabilitySerialQueue: DispatchQueue// 可选常量，因init是指定了默认值 .mainfileprivate let notificationQueue: DispatchQueue?fileprivate(set) var flags: SCNetworkReachabilityFlags? &#123;// 属性观察器willSet和didSet使swift天然具备MVVM模式, 注意不要和set、get一起写没有意义didSet &#123;// 一开始我也不理解guard的作用，写起来感觉和if没什么区别，直到我遇到if嵌套// 当然下面这个写法我个人觉得还不如ifguard flags != oldValue else &#123; return &#125;notifyReachabilityChanged()&#125;&#125;// 必要构造器，入参默认值是个好东西required public init(reachabilityRef: SCNetworkReachability,queueQoS: DispatchQoS = .default,targetQueue: DispatchQueue? = nil,notificationQueue: DispatchQueue? = .main) &#123;self.allowsCellularConnection = trueself.reachabilityRef = reachabilityRef// C语言的GCD，在swift中被整成了class，不过使用方式没变// 为什么 DispatchQueue就一个class声明，所有的属性方法都在extension里？self.reachabilitySerialQueue = DispatchQueue(label: &quot;uk.co.ashleymills.reachability&quot;, qos: queueQoS, target: targetQueue)self.notificationQueue = notificationQueue&#125;// 便利构造器public convenience init(hostname: String,queueQoS: DispatchQoS = .default,targetQueue: DispatchQueue? = nil,notificationQueue: DispatchQueue? = .main) throws &#123;guard let ref = SCNetworkReachabilityCreateWithName(nil, hostname) else &#123;throw ReachabilityError.failedToCreateWithHostname(hostname, SCError())&#125;self.init(reachabilityRef: ref, queueQoS: queueQoS, targetQueue: targetQueue, notificationQueue: notificationQueue)&#125;public convenience init(queueQoS: DispatchQoS = .default,targetQueue: DispatchQueue? = nil,notificationQueue: DispatchQueue? = .main) throws &#123;var zeroAddress = sockaddr()zeroAddress.sa_len = UInt8(MemoryLayout&lt;sockaddr&gt;.size)zeroAddress.sa_family = sa_family_t(AF_INET)guard let ref = SCNetworkReachabilityCreateWithAddress(nil, &amp;zeroAddress) else &#123;throw ReachabilityError.failedToCreateWithAddress(zeroAddress, SCError())&#125;self.init(reachabilityRef: ref, queueQoS: queueQoS, targetQueue: targetQueue, notificationQueue: notificationQueue)&#125;// 析构，跟dealloc一样deinit &#123;stopNotifier()&#125;&#125;public extension Reachability &#123;// MARK: - *** Notifier methods ***func startNotifier() throws &#123;guard !notifierRunning else &#123; return &#125;let callback: SCNetworkReachabilityCallBack = &#123; (reachability, flags, info) inguard let info = info else &#123; return &#125;// `weakifiedReachability` is guaranteed to exist by virtue of our// retain/release callbacks which we provided to the `SCNetworkReachabilityContext`./*OC对于 CF 系的 API，如果 API 的名字中含有 Create，Copy 或者 Retain的话，在使用完成后，我们需要调用 CFRelease 来进行释放Swift 中我们不再需要显式地去释放带有这些关键字的内容了。也就是说，CF 现在也在 ARC 的管辖范围之内了但是有一点例外（极少会用到），那就是对于非系统的CF的API(比如你自己写的或者是第三方的),将这些返回CF对象的API导入Swift时，它们的类型会被对对应为 Unmanaged&lt;T&gt;。这意味着在使用时我们需要手动进行内存管理，takeUnretainedValue 将保持原来的引用计数不变，在你明白你没有义务去释放原来的内存时，应该使用这个方法。而如果你需要释放得到的 CF 的对象的内存时，应该使用 takeRetainedValue 来让引用计数加一，然后在使用完后对原来的 Unmanaged 进行手动释放。为了能手动操作 Unmanaged 的引用计数，Unmanaged 中还提供了 retain，release 和 autorelease 这样的 &quot;老朋友&quot; 供我们使用*/let weakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info).takeUnretainedValue()// The weak `reachability` _may_ no longer exist if the `Reachability`// object has since been deallocated but a callback was already in flight.weakifiedReachability.reachability?.flags = flags&#125;let weakifiedReachability = ReachabilityWeakifier(reachability: self)let opaqueWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.passUnretained(weakifiedReachability).toOpaque()var context = SCNetworkReachabilityContext(version: 0,info: UnsafeMutableRawPointer(opaqueWeakifiedReachability),retain: &#123; (info: UnsafeRawPointer) -&gt; UnsafeRawPointer inlet unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)_ = unmanagedWeakifiedReachability.retain()return UnsafeRawPointer(unmanagedWeakifiedReachability.toOpaque())&#125;,release: &#123; (info: UnsafeRawPointer) -&gt; Void inlet unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)unmanagedWeakifiedReachability.release()&#125;,copyDescription: &#123; (info: UnsafeRawPointer) -&gt; Unmanaged&lt;CFString&gt; inlet unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)let weakifiedReachability = unmanagedWeakifiedReachability.takeUnretainedValue()let description = weakifiedReachability.reachability?.description ?? &quot;nil&quot;return Unmanaged.passRetained(description as CFString)&#125;)if !SCNetworkReachabilitySetCallback(reachabilityRef, callback, &amp;context) &#123;stopNotifier()throw ReachabilityError.unableToSetCallback(SCError())&#125;if !SCNetworkReachabilitySetDispatchQueue(reachabilityRef, reachabilitySerialQueue) &#123;stopNotifier()throw ReachabilityError.unableToSetDispatchQueue(SCError())&#125;// Perform an initial checktry setReachabilityFlags()notifierRunning = true&#125;func stopNotifier() &#123;// defer的作用就是函数结束前会调，无论函数是怎么结束的！defer &#123; notifierRunning = false &#125;SCNetworkReachabilitySetCallback(reachabilityRef, nil, nil)SCNetworkReachabilitySetDispatchQueue(reachabilityRef, nil)&#125;// MARK: - *** Connection test methods ***@available(*, deprecated, message: &quot;Please use `connection != .none`&quot;)var isReachable: Bool &#123;return connection != .unavailable&#125;@available(*, deprecated, message: &quot;Please use `connection == .cellular`&quot;)var isReachableViaWWAN: Bool &#123;// Check we&apos;re not on the simulator, we&apos;re REACHABLE and check we&apos;re on WWANreturn connection == .cellular&#125;@available(*, deprecated, message: &quot;Please use `connection == .wifi`&quot;)var isReachableViaWiFi: Bool &#123;return connection == .wifi&#125;var description: String &#123;return flags?.description ?? &quot;unavailable flags&quot;&#125;&#125;fileprivate extension Reachability &#123;// 上抛错误func setReachabilityFlags() throws &#123;try reachabilitySerialQueue.sync &#123; [unowned self] invar flags = SCNetworkReachabilityFlags()if !SCNetworkReachabilityGetFlags(self.reachabilityRef, &amp;flags) &#123;self.stopNotifier()throw ReachabilityError.unableToGetFlags(SCError())&#125;self.flags = flags&#125;&#125;// 发通知func notifyReachabilityChanged() &#123;/*swift中所有的class类型变量都默认采用strong修饰Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned ，如果存在被释放的可能，那就选择用 weak*/let notify = &#123; [weak self] in// 保证self存在guard let self = self else &#123; return &#125;// (Reachability) -&gt; ()类型的可选属性self.connection != .unavailable ? self.whenReachable?(self) : self.whenUnreachable?(self)// @escaping 逃逸闭包必须在闭包中显式地引用 selfself.notificationCenter.post(name: .reachabilityChanged, object: self)&#125;// notify on the configured `notificationQueue`, or the caller&apos;s (i.e. `reachabilitySerialQueue`)// ?? 可选可用用可选，可选不能用用后面notificationQueue?.async(execute: notify) ?? notify()&#125;&#125; &emsp;&emsp;此外还有一个class，比较好玩！注释的很清楚了，思路挺好,其实就是weakproxy的作用12345678910111213141516171819202122232425262728293031323334353637383940/**`ReachabilityWeakifier` weakly wraps the `Reachability` classin order to break retain cycles when interacting with CoreFoundation.CoreFoundation callbacks expect a pair of retain/release whenever anopaque `info` parameter is provided. These callbacks exist to guardagainst memory management race conditions when invoking the callbacks.#### Race ConditionIf we passed `SCNetworkReachabilitySetCallback` a direct reference to our`Reachability` class without also providing corresponding retain/releasecallbacks, then a race condition can lead to crashes when:- `Reachability` is deallocated on thread X- A `SCNetworkReachability` callback(s) is already in flight on thread Y#### Retain CycleIf we pass `Reachability` to CoreFoundtion while also providing retain/release callbacks, we would create a retain cycle once CoreFoundationretains our `Reachability` class. This fixes the crashes and his howCoreFoundation expects the API to be used, but doesn&apos;t play nicely withSwift/ARC. This cycle would only be broken after manually calling`stopNotifier()` — `deinit` would never be called.#### ReachabilityWeakifierBy providing both retain/release callbacks and wrapping `Reachability` ina weak wrapper, we:- interact correctly with CoreFoundation, thereby avoiding a crash.See &quot;Memory Management Programming Guide for Core Foundation&quot;.- don&apos;t alter the public API of `Reachability.swift` in any way- still allow for automatic stopping of the notifier on `deinit`.*/private class ReachabilityWeakifier &#123;weak var reachability: Reachability?init(reachability: Reachability) &#123;self.reachability = reachability&#125;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22条商规]]></title>
    <url>%2F2018%2F08%2F31%2F22%E6%9D%A1%E5%95%86%E8%A7%84%2F</url>
    <content type="text"><![CDATA[定位 定位和聚焦定位非常重要，反其道而行之也许就是机会。 定位不是一成不变的，应把握分化趋势，适时重定位。 每个人只能为每个品类留下两个品牌空间，即就能记住俩品牌！例如空调，就记住了格力和美的 定位4步法： 第一步，分析整个外部环境，确定我们的竞争对手是谁，竞争对手的价值是什么 第二步，避开竞争对手在顾客心智中的强势，或是利用其强势中蕴含的弱点，确立品牌的优势位置：定位 第三步，为这一定位寻求一个可靠的证明：信任状 第四步，将这一定位整合进企业内部运营的方方面面，特别是传播上要有足够的资源，以将这定位植入顾客心智 夺取心智资源。每个人精力时间都优先，第一时间想到什么品牌，就很可能用什么品牌 定位激发品牌生产力。 定位提升运营绩效。更聚焦有效的，剔除无效的 定位客观存在，要么在正确、精准的定位上，要么在错误、模糊的定位上 所有组织和个人都需要定位 美国企业哲学就是聚焦、狭窄而深入，中国企业哲学是宽泛而浅显 企业很难仅仅通过满足客户需求的方式在营销中获得成功。更应该聚焦 商规领先定律 成为第一胜过做的最好，第一能占领客户心智，最好却无法界定。 创造一个你能成为第一的新领域。 时机很重要，天时地利人和。 首创品牌通常能保持自己的领先地位，甚至成为品类的代名词 品类定律 如果你不能第一个进入某品类，那么就创造一个品类使自己成为第一。 首先要问并不是“与竞争对手相比，这个产品有哪些优势”，而是“这个产品能在哪个品类成为第一”。 几乎每个人都会对新品类产生兴趣，很少有人会对更好的产品产生兴趣 心智定律 市场营销是一场争夺认知而不是产品的战争，在进入市场之前应该率先进入心智。 在市场营销中最为徒劳的就是试图改变人们的认知。 应采用迅猛而非渐进的方式给别人留下一个深刻印象，不要想着逐渐影响别人以博得好感！ 认知定律 市场营销领域并不存在客观现实性，也不存在事实，更不存在最好的产品。 存在的只是顾客心智中的认知，其他都是幻觉！ 大多数人都认为自己的认知能力比别人强，认为自己总是正确的。 人们总是相信自己愿意相信的东西。 另外一点就是从众效应，认同的人越多，认同的人越多 聚焦定律 市场营销的要点就是聚焦，收缩经营范围将使你更强大，追逐所有目标将使你一事无成。 最有效的代名词应该是简洁、能体现优势的词语。 光环效应，专注于某一优势，用户会带来更多优势。 你不能讲其他公司的代名词据为己有，避免正面战斗选择迂回战术。 你不能讲焦点集中在质量或是诸如如此类不存在对立面的概念上。 有了自己的代名词要进行专利注册，但允许别人使用。要全力保护自己概念在市场上地位。 专有定律 当你的竞争对手已经在潜在顾客心智中拥有一个代名词或定位时，你若再想拥有同一个代名词将是徒劳无益的。 花更多的钱去抢别人的代名词不但抢不到，而且会提升对手的影响力。 用户想要什么，和我们在广告中强调什么没关系，强调的应该是自己的代名词。 阶梯定律 产品都非生来平等，潜在顾客在做购买决定时总会对各品牌进行排序，对于每一个品类，顾客的心智中都会形成一个选购顺序阶梯，每个品牌占有一层阶梯。你的营销战略应该根据你的品牌占据了心智阶梯的位置来决定。 通常人们只接受与自己认知相一致的新信息，其他的都会被置之不理。 有时候在大品类的阶梯上屈居第三要胜过在小品类的阶梯上独占鳌头 在营销中，心智决定市场；品牌的心智地位决定市场地位；心智份额决定市场份额 二元定律 从总体和长远角度来看，你会发现市场往往演化成两大品牌竞争的局面。 当你处于第三的位置，你无法通过直接攻击两个强大的领先者来获得更大发展，而他们却可能从中渔利。 明确自己的定位，采用符合自己定位的手段 顾客相信市场营销是一场产品的较量，因为他们相信领先品牌总是更好一些，他们开始购买领先品牌 对立定律 若想成为市场第二，那么你的战略应由第一决定。知己知彼，任何第二都有机会干掉第一 必须发现领导者强大的本质，然后以与其相对立的定位出现在潜在顾客面前！不要试图变得更好，但要试图变得不同 模仿领先者是徒劳的 不要一味地打击你的竞争对手。要求你不断宣传竞争对手的弱点（必须以事实为根据），是你的潜在顾客很快就能意识到这个问题，接着迅速调转矛头 分化定律 每个品类总是始于某一个单一的品类，但在一段时间之后，这个品类开始分化成几个小品类 是领先者保持其对市场已有统治的方法之一，是给新产品起新名字 长效定律 短期内，促销能够增加公司的销售额；但从长期来看，促销只会减少公司销售额。因为它教会顾客不要在”正常“价格是买东西 延伸定律 产品越多，市场越大，阵线越长，赚的钱反而越少 我宁愿在某一方面强，也不愿在所有方面都弱 误区：虽然长期来看品牌延伸是一个失败的战略，但就短期而言，它却可以让你成功 牺牲定律 你如果想取得成功，就应该牺牲一些东西。有三样东西是你需要牺牲的：产品线、目标市场和不断的变化 市场营销是一场心智之战，它是认知的竞争，而不是产品或服务的竞争 集中产品焦点，深化产品内容 更大的网可以捕捉更多的顾客，但事实恰恰相反 你所明确的市场营销目标并不就是实际上购买你的产品的那些人。尽管百事可乐的营销目标是青少年，但市场却包括所有人 如果你视图追随市场的每一个潮流与风头，你将注定要被淘汰出局。保持稳固地位的最好方法是从一开始就不要改变你的战略 特性定律 必须有自己独特的认识或特性，并以此为中心展开营销 必须努力拥有最为重要的特性 你无法估量具有新特征的产品开拓市场的潜力，因此绝不要嘲笑它 坦诚定律 慎用，很容易玩砸了！ 是自己的产品深入人心最有效的方法是首先承认自己的不足（广泛被人们认为的缺点），当人们开始关注你时，在转向正面的宣传 承认自己的弱点是违背公司和个人本性的 最重要的是坦诚可以解除顾客的戒备心理 如果你的名字不好，那么你将面临两个选择：换一个名字或调侃它，但不要轻视它 唯一定律 在大多数情况下，你的竞争者只有一个容易被攻破的薄弱环节，正是这个环境应该成为你全力攻击的焦点 在市场营销中，更努力的工作并不一定是成功的秘诀 在市场营销中能够凑效的战略与在军事上的战略相同：出其不意 营销人员必须亲临市场竞争第一线，知道什么能做什么不能做 莫测定律 未来不可准确预测，只能着眼于未来趋势 意想不到的事总会发生，但我们必须努力 预见未来和对未来下注是两码事 成功定律 成功往往会导致 盲目 贸然 延伸产品线！容易骄傲和自大 民众关于现实情况的真实看法才是最主要的！ 失败定律 尽早发现错误并及时采取措施以停止损失。补救、 放弃 试验不可怕，失败不可怕，可怕的是没复盘同一个地方失败两次 炒作定律 炒作就是炒作。事情进展顺利，不需要宣传炒作，当它需要炒作时，一般意味着它遇到了麻烦。 炒作的本质并不是这个新产品正在走向成功，而是宣告现有的产品要过时 真正的革命会在午夜悄无声息的到来 趋势定律 如果你面对一个正在迅速崛起的行业，具有时尚的一切特征，那么你最好能够淡化时尚。通过淡化时尚，你就能使之流行的时间延长，从而使它更像一种趋势 资源定律 一分钱难倒英雄汉！ 平时，一毛钱不赚就是赔]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防抓包策略]]></title>
    <url>%2F2018%2F08%2F13%2F%E9%98%B2%E6%8A%93%E5%8C%85%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[charles抓包原理简介&emsp;&emsp;简单的理解是charles是中间商赚差价！没有中间商的时候，client是和server进行三次握手，握手成功，确认了眼神就可以通信了！有charles代理时，变成了client和charles三次握手，charles拿着client的随机数，自己选个算法那给client一个假证书！client为啥认这个假证书？因为开始代理前会让用户下载并信任一个根证书，charles颁发的其他证书,默认都会被系统所信任；所以clent就和charles愉快的聊了起来；charles这个中间商又怎么和server聊上的呢？也是三次握手，charlse拿着client给的认证信息和伪造的随机数信息，跟服务器说：我就是client，跟我聊吧！服务器看到证件齐全就把数据给charlse了，charlse再通过算法和随机数就能获取到服务器的真实数据 几种方案1. 检测是否设置代理 原理是一般抓包是通过设置手机代理的方式进行的。因此可以通过CFNetwork获取系统代理信息，如果有代理就不发请求 1234567891011121314151617181920212223242526272829// 可参照 ASI源码ASIHTTPRequest的 configureProxies方法+ (BOOL)configureProxiesWithUrl:(NSURL *)url &#123;NSArray *proxies = nil;#if TARGET_OS_IPHONENSDictionary *proxySettings = [NSMakeCollectable(CFNetworkCopySystemProxySettings()) autorelease];#elseNSDictionary *proxySettings = [NSMakeCollectable(SCDynamicStoreCopyProxies(NULL)) autorelease];#endifproxies = [NSMakeCollectable(CFNetworkCopyProxiesForURL((CFURLRef)url, (CFDictionaryRef)proxySettings)) autorelease];if (!proxies) &#123;// @&quot;Unable to obtain information on proxy servers needed for request&quot;return NO;&#125;if ([proxies count] &gt; 0) &#123;NSDictionary *settings = [proxies objectAtIndex:0];if ([settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]) &#123;// PAC 暂不考虑return NO;&#125;if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:(NSString *)kCFProxyTypeNone]) &#123;//没有设置代理return NO;&#125;&#125;return YES;&#125; 优点 简单，核心代码就两行 可靠，虽然ASI已经被废弃很长时间了，但据我所知依然有部分APP（xxx金融）无法彻底摆脱对ASI的依赖，所以代码稳定性还是有保证的。 检测频率低，由于设置手机代理，必然离开当前APP，即当APP在前台时检测一次，网络变化时检测一次即可满足大部分需求（ASI是通过设置request的标志位类降低请求频率的） 缺点 只能检测手机是否设置代理，如果路由器也设置代理则检测不到 用户使用VPN和PAC自动代理，也将被认为设置代理，无法请求网络 检测到代理就不发送请求的处理方式，过于强势；但我没想出来更好的方案 有人评论相关博客说没设置代理也会提示设置了代理，链接，但此博客未校验PAC文件情况（ASI检测了PAC），所以这里是个潜在风险点 2. https + 公钥认证 内置公钥证书，不仅校验域名,也将证书中的公钥及其他信息也进行校验 12345678910111213141516171819202122232425+(AFSecurityPolicy*)customSecurityPolicy &#123;// 导入证书NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;cer&quot;];//证书的路径NSData *certData = [NSData dataWithContentsOfFile:cerPath];/*AFSSLPinningModeCertificate //证书所有字段都一样才通过认证，AFSSLPinningModePublicKey //只认证公钥那一段AFSSLPinningModeCertificate //更安全。但是单向认证不能防止“中间人攻击”*/AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO// 如果是需要验证自建证书，需要设置为YESsecurityPolicy.allowInvalidCertificates = YES;//validatesDomainName 是否需要验证域名，默认为YES；//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。//如置为NO，建议自己添加对应域名的校验逻辑。securityPolicy.validatesDomainName = YES;NSSet&lt;NSData*&gt; * set = [[NSSet alloc]initWithObjects:certData , nil];securityPolicy.pinnedCertificates = set;return securityPolicy;&#125; 优点 安全级别最高 相对简单，AFN都已经封装好了 频率低 缺点 运维和安全团队给不给公钥证书？ 证书过期怎么办？预留接口？ 多域名怎么处理？ 3. CONNECT 请求方式 （无效） 原理：把服务器作为跳板，先验证用户名和密码等信息，再让服务器代替用户去访问其它网页，之后把数据返回给用户 破解方法：charlse -&gt; Proxy Settings -&gt; Proxies HTTP Proxy中勾选Enable transparent HTTP proxying 来查看CONNECT请求 4. connectionProxyDictionary (无效) 使用NSURLSessionConfiguration的connectionProxyDictionary1234// 无效NSURLSessionConfiguration *conf = [NSURLSessionConfiguration ephemeralSessionConfiguration];conf.connectionProxyDictionary = @&#123;&#125;;// 网上还有提出hook方案来设置connectionProxyDictionary，但也无效 参考： iphone programmatically read proxy settings iOS上如何防止他人抓包获取信息 iOS 如何防止https抓包(中间人攻击),及charles抓包原理]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡顿优化]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;iOS卡顿优化其实已经烂大街了，网上全都是各种各样的文章！所有操作无非就两件事：降低主线程工作和降低CPU工作。常用策略： 少创建、更改对象 少用图层混合、透明、阴影、裁切 少用图片拉伸 能让小弟（子线程）干的让小弟干 缓存、缓存和缓存，让下一次更快速 提前、提前和提前，让这一次更快速 &emsp;&emsp;等等等等… &emsp;&emsp;但实际开发中确实：WC这个clearColor需保留，NM那个阴影不能改，神马鬼缓存更新不及时、shit提前计算有偏差…到最后就变成了：管它合适不合适，用Time Profiler查出来的耗时高就改改!其它…真的不是不想改，而是不敢改、不能改甚至不愿意改 1 优化记录&emsp;&emsp;好了，吐槽吐完了！该来的总会来，该改的也总的改，逃是逃不过去的！先水水为期2期的卡顿优化我们都干了啥 1 推动Crab平台升级&emsp;&emsp;如果我告诉你我们一半以上的卡顿都是监控卡顿的三方库造成的，你会不会很惊讶？我们也很惊讶！怪不得手百要自研APM(刚开始真的推不动以至于我们也想造轮子，但领导不同意)！因为CrabSDK集成了plcrashreporter直接在卡顿时进行符号化，结果就是本来是卡顿，经过plcrashreporter变成了卡死！！！当然推动SDK更新也没啥好办法，只能每天”打卡“式催进度… &emsp;&emsp;其实还有BPush的SDK也很卡（想不明白一个pushSDK为啥要卡主线程）也是推动升级来解决的… &emsp;&emsp;催进度过程中倒学了点经验，最最主要”别把这事当个事，也别把这事不当事！“ 放平心态：谁都知道能动手码代码就别废话，但这次你需要废话！所以一定要放平心态：就当是做销售练习吧 要有礼貌：都说理工男情商低，程序员就更不用说了！但催进度时，你不是程序员，你有求于人，所以一定要有礼貌！什么谢谢、好的、能不能、稍微啥的该上就得上！就当你社会课没上完，进行再教育呢 要有耐心：程序员都追求效率，恨不得能让机器干的都让机器干！这次，不好意思，你对面那个是”大爷“不是机器，你除了供着就只能等着！着急也没用 2 等比缩放&emsp;&emsp;这个就是一个超级大坑，之前UI就推行了一套所谓的等比缩放方案，举个例子：在iphone5上展示要等比例缩放iphone6上！如果所有的都等比例缩放也许还比较好处理一点，但UI又要求左右两边间距必须是40px，只有中间内容缩放、1像素横线边框线不缩放等等，到最后的实现方案布局约束都是一个计算函数和一个找补函数。这样就带来了一堆问题 频繁函数计算，特别是浮点数实时计算！ 大量的”找补“方法，神奇数字！ 层级复杂，为了正确显示效果，不得不增加无用图层 频繁刷新，layoutIfNeed满大街都是 复用率低，很多cell刷新是都会将subview都刷一下，防止”对不齐“ 开发效率低 &emsp;&emsp;结合以上问题，试验了几种方法 2.1 异步渲染内容到图片&emsp;&emsp;参考：VVeboTableViewDemo注意Dome中可能会出现几十个线程卡顿问题，那是因为global最多也就64个线程，超了就卡了 好处：1、充分利用GPU和CPU； 2、减少view层级 坏处：1、代码较多； 2、预先计算，增加VM层； 结论：被弃！修改起来成本较高，后续新增可考虑 2.2 类似微信读配置文件 好处：1、灵活，以后可以做调整字体需求；2、避免复杂实时计算 坏处：1、配置文件和view的映射关系复杂；2、复杂约束难以表达；3、调试麻烦 结论：被弃！因为开发调试实在是太麻烦了，重构一个简单的小页面都累死个人 2.3 折中方案 绝大多数model因打点需求都包含id字段，可重写isEqual来判断model是否改变来减少刷新次数 将cell刷新方法拆分refreshContent和refreshFrame两个，将cell分类，对更新数据源只调整显示不调整frame的cell高度进行缓存并只调动refreshContent 将大部分的layoutIfNeed替换成setNeedsLayout 小部分cell采用异步渲染到图片的方案：例如公告轮播、导航条 3 局部刷新&emsp;&emsp;简单的说就几条 tablview等只刷新标记需要刷新的cell。我们采用的方式是通过新旧数据源isEqual来判断哪些cell需要刷新，另外允许cell改变自身数据源时回调tableview刷新自己 基金排行等类似页面巧用childViewController来延迟加载延迟刷新 hidden VS 懒加载，我个人认为不涉及到约束改变使用懒加载，涉及到约束更改用hidden！例如登录和未登录的头部信息，完全互斥，以前代码是都加载通过hidden来处理，现在改成了懒加载！毕竟一般人不会来回登录着玩，登录了十几天也不一定退一次 4 按需加载被废弃&emsp;&emsp;废弃原因：PM和领导觉得一共也没多少数据还显示默认图不能接受！而且没有上拉加载更多，这个功能比较鸡肋… &emsp;&emsp;一样可参考：VVeboTableViewDemo，核心原理就是检测滑动状态，只加载用户可见范围的cell 可见cell的定义，需根据手机屏幕大小进行自定义，但这会增加代码复杂度 快速滑动可能出现白屏，建议用”默认图“代替 像首页这种多接口内容拼接而成并且支持服务端排序的页面不合适 5 资源同步改异步 竟然在mian使用dataWithContentsOfURL方法同步下载头像！着实吓了我一跳，犹豫半天问了好几圈才敢改代码 使用imageNamed方法批量加载小图片（48个），imageNamed方法一般情况下还是很好用的，但像这种批量加载小图片还是建议异步使用imageWithContentsOfFile方法然后NSArray内存缓存的方式实现 6 少用@synchronized，少在主线程深拷贝&emsp;&emsp;在使用Time Profiler检查耗时时，无意中发现项目里大量用了@synchronized锁，甚至很多锁都是不必要的，例如明显上下文都在主线程里也要加上@synchronized锁来确保安全。这个问题我在例会上提出来之后，也没人能解释为什么，估计就是历史遗留问题了！当然处理起来比较麻烦，因为不知道为什么，降级措施也不好处理，最终我也只去掉了3个锁的使用 &emsp;&emsp;几乎伴随着锁的就是在主线程中进行深拷贝，而且是整个页面数据的深拷贝！也许是为了安全，但确实有些烂用了，没必要addObject之类的操作都要深拷贝一份再操作 7 减少图层混合&emsp;&emsp;推荐策略 设opaque为YES、 设backgroundColor和父视图颜色一致且不透明、 不设 &lt;1 的alpha值 确保UIImage没有alpha通道 &emsp;&emsp;怎么检测图层混合 模拟器debug中color blended layers红色区域表示图层发生了混合 真机上Instrument-选中Core Animation-勾选Color Blended Layers &emsp;&emsp;注意事项：这个确实是体力活，更是个细心活，一定要注意上下文环境 8 图片的使用&emsp;&emsp;最麻烦的其实是找UI要图…提前准备好挨批的准备 图片缩放问题，对于高频图片采用重绘方式避免重复拉伸。对低频拉伸图片争取让UI给合适大小的图 阴影和圆角都尽可能找图片代替 尽量使用png 尽量使用SD下载网络图片，因为SD已经在子线程解码图片 2 监控&emsp;&emsp;其实一开始不想写这个的！卡顿监控方案已经烂大街了，而且这种重复造轮子的算不得KPI（虽然crab这个破轮子卡的都快不能跑了）！但是PM说没感觉有什么太大效果，这个就不能忍了！ 1 runloop&emsp;&emsp;这个算上市面上最通用的方案了，参考：iOS实时卡顿监控，里面写的非常详细！核心思路：主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.123456789101112131415161718192021222324252627282930313233343536373839404142434445static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123;MyClass *object = (__bridge MyClass*)info;// 记录状态值object-&gt;activity = activity;// 发送信号dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;dispatch_semaphore_signal(semaphore);&#125;- (void)registerObserver&#123;CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,kCFRunLoopAllActivities,YES,0,&amp;runLoopObserverCallBack,&amp;context);CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);// 创建信号semaphore = dispatch_semaphore_create(0);// 在子线程监控时长dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;while (YES)&#123;// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));if (st != 0)&#123;if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)&#123;if (++timeoutCount &lt; 5)continue;NSLog(@&quot;好像有点儿卡哦&quot;);&#125;&#125;timeoutCount = 0;&#125;&#125;);&#125; &emsp;&emsp;需要注意的 dome里使用PLCrashReporter进行符号化会很卡 卡顿只dump主线程调用栈就可以了 调用栈也许有”延迟“ 2 子线程&emsp;&emsp;这个思路及很有意思，简单的说就是不断的用子线程去主线程去撞：我打你一拳，你踢我一脚。过段时间你没踢我，你有问题！可参考：iOS应用UI线程卡顿监控 , PS: 获取调用栈我觉得直接用plcrashreporter就好，plcrashreporter的核心原理：新期一个线程A，挂起除A外的所有线程，dump调用栈！另外对符号化感兴趣的，请阅读获取任意线程调用栈的那些事 和 iOS Crash 捕获及堆栈符号化思路剖析 &emsp;&emsp;一个swift版的三方库可做参考：ANREye 3 组合拳&emsp;&esmp;参考微信iOS卡顿监控系统，微信这个思路很全面，runloop、CPU、FPS都监控，[代码]https://aozhimin.github.io/iOS-Monitor-Platform/)如下： CPU1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#pragma mark CPU// cpu利用率+ (CGFloat)cpuUsage &#123;kern_return_t kr;task_info_data_t tinfo;mach_msg_type_number_t task_info_count;task_info_count = TASK_INFO_MAX;kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);if (kr != KERN_SUCCESS) &#123;return -1;&#125;thread_array_t thread_list;mach_msg_type_number_t thread_count;thread_info_data_t thinfo;mach_msg_type_number_t thread_info_count;thread_basic_info_t basic_info_th;// get threads in the taskkr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);if (kr != KERN_SUCCESS) &#123;return -1;&#125;long total_time = 0;long total_userTime = 0;CGFloat total_cpu = 0;int j;// for each threadfor (j = 0; j &lt; (int)thread_count; j++) &#123;thread_info_count = THREAD_INFO_MAX;kr = thread_info(thread_list[j], THREAD_BASIC_INFO,(thread_info_t)thinfo, &amp;thread_info_count);if (kr != KERN_SUCCESS) &#123;return -1;&#125;basic_info_th = (thread_basic_info_t)thinfo;if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;total_time = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;total_cpu = total_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;&#125;&#125;kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));assert(kr == KERN_SUCCESS);return total_cpu;&#125;// CPU核数+ (NSUInteger)cpuNumber &#123;return [NSProcessInfo processInfo].processorCount;&#125;//// CPU类型//+ (NSString *)cpuType &#123;// host_basic_info_data_t hostInfo;// mach_msg_type_number_t infoCount;// infoCount = HOST_BASIC_INFO_COUNT;// host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&amp;hostInfo, &amp;infoCount);// switch (hostInfo.cpu_type) &#123;// case CPU_TYPE_ARM64:// return @&quot;ARM64&quot;;// break;// // default:// return @&quot;unknown&quot;;// break;// &#125;//&#125; 内存1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#pragma mark 内存相关// 当前进程内存+ (long long)appUsedMemory &#123;struct mach_task_basic_info info;mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;int r = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp; info, &amp; count);if (r == KERN_SUCCESS)&#123;return info.resident_size/MBSize;&#125;else&#123;return -1;&#125;&#125;// 物理内存+ (long long)physicalMemory &#123;return [NSProcessInfo processInfo].physicalMemory/MBSize;&#125;// 当前设备已用内存+ (long long)deviceUsedMemory&#123;size_t length = 0;int mib[6] = &#123;0&#125;;int pagesize = 0;mib[0] = CTL_HW;mib[1] = HW_PAGESIZE;length = sizeof(pagesize);if (sysctl(mib, 2, &amp;pagesize, &amp;length, NULL, 0) &lt; 0)&#123;return 0;&#125;mach_msg_type_number_t count = HOST_VM_INFO_COUNT;vm_statistics64_data_t vmstat;if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)&#123;return 0;&#125;int wireMem = vmstat.wire_count * pagesize;int activeMem = vmstat.active_count * pagesize;return (wireMem + activeMem)/MBSize;&#125;// 当前设备可用内存+ (long long)deviceFreeMemory &#123;size_t length = 0;int mib[6] = &#123;0&#125;;int pagesize = 0;mib[0] = CTL_HW;mib[1] = HW_PAGESIZE;length = sizeof(pagesize);if (sysctl(mib, 2, &amp;pagesize, &amp;length, NULL, 0) &lt; 0) &#123;return 0;&#125;mach_msg_type_number_t count = HOST_VM_INFO_COUNT;vm_statistics64_data_t vmstat;if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)&#123;return 0;&#125;int freeMem = vmstat.free_count * pagesize;int inactiveMem = vmstat.inactive_count * pagesize;return (freeMem + inactiveMem)/MBSize;&#125; FPS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263- (id)init &#123;self = [super init];if( self )&#123;[self setup];&#125;return self;&#125;#pragma mark FPS- (void)setup &#123;_updateInterval = 0.5f;_historyCount = 0;_historySum = 0;[[NSNotificationCenter defaultCenter] addObserver: selfselector: @selector(applicationWillResignActiveNotification)name: UIApplicationWillResignActiveNotificationobject: nil];[[NSNotificationCenter defaultCenter] addObserver: selfselector: @selector(applicationDidBecomeActiveNotification)name: UIApplicationDidBecomeActiveNotificationobject: nil];&#125;- (void)startDisplayLink &#123;_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkProc)];[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)stopDisplayLink &#123;[_displayLink setPaused:YES];[_displayLink removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];[_displayLink invalidate];_displayLink = nil;&#125;- (void)applicationDidBecomeActiveNotification &#123;[self.displayLink setPaused:NO];&#125;- (void)applicationWillResignActiveNotification &#123;[self.displayLink setPaused:YES];&#125;// 不准有延迟- (void)displayLinkProc &#123;_historyCount += _displayLink.frameInterval;CFTimeInterval interval = _displayLink.timestamp - _lastTime;if( interval &gt;= _updateInterval ) &#123;_lastTime = _displayLink.timestamp;// 回调上层刷新展示NSUInteger fps = (NSUInteger)(_historyCount / interval);if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(frezingCheker:currentFPS:)]) &#123;[self.delegate frezingCheker:self currentFPS:fps];&#125;_fps = fps;_historyCount = 0;&#125;&#125;- (void)dealloc &#123;[self stopDisplayLink];&#125; 参考 iOS 保持界面流畅的技巧 https://aozhimin.github.io/iOS-Monitor-Platform/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观呼吸]]></title>
    <url>%2F2018%2F07%2F27%2F%E8%A7%82%E5%91%BC%E5%90%B8%2F</url>
    <content type="text"><![CDATA[前面三分之一都在讲禅修是什么！不是什么!总结三句话：1，管你屁事、管我屁事、有这屁事； 2， 既来之，则安之 一旦坐下，就不要任意改变姿势！盘腿是为了不抖腿！坐定之后，闭上眼睛，我们的心就好像一杯浑浊的水，装着浊水的杯子静置时间越久，泥沙就越能沉淀下来 没有对象，心就不可能集中。将心集中在呼吸之上，深呼吸三次，三次深呼吸之后，恢复正常的呼吸，让你的呼吸自由的进出，再轻松的将你的注意力集中在鼻孔边缘。单纯注意呼吸进出的感觉：在吸完气即将把期呼出之前，有一个短暂的停顿，注意它，并且注意呼气的开始。在呼完气即将吸气进来之前，又有另一个短暂的停顿，同样也注意这个短暂的停顿。别瞎想，别说话，别瞎听，只专注于呼吸。 当心跑开时，马上以正念拉回来，增长定力的措施：数息，呼气数数，吸气数数； 最重要的原则是：坐的时候背要挺直，脊椎要像一叠铜板一样，一个顶一个，让脊柱直立起来，但不应造成肌肉紧张，头则要与脊柱保持一条直线，身体的其余部位则松软的垂挂在脊柱上。这些都必须在放松的状态下进行，不要僵硬。 选择软硬适度的坐垫，选择舒服的衣服，选择舒适的坐姿(单盘，双盘或不盘)，双手重叠放于膝上，目标就是希望身体完全不动，但不能睡着 三次深呼吸之后是自然的呼吸，应该去感受呼吸，而不是控制呼吸，除非你在数息 别思考也别睡着，别着急也别放任 在禅修中，我们靠的是精进，而非蛮力。我们唯一能做到努力就是温和而耐心地保持注意力 必须熊排除自怨自艾与自责着手 怎样处理禅修中的问题？问题一：身体的疼痛消除疼痛、治疗，或把疼痛作为禅修对象、检查坐垫、调整坐姿、松开衣物。 问题二：腿失去知觉双腿发麻是由神经压迫而引起，你不会因为坐姿而伤害到腿部组织的。当腿失去知觉，你只要观察这个现象即可。禅修一段时间之后，麻痹感会逐渐消失。 问题三：奇特的感觉当你达到放松时，神经系统只是开始更有效率地让感官信号通过。大量先前受阻的感官信号如今可以畅行无阻，因而引发各种独特的感受。它没有任何特别的意义，就只是感受而已，因此只要使用平常的技巧即可。看着它生起，再看着它消失，不要被牵扯进去。 问题四：昏沉不要对睡眠让步。如果你很想睡就深吸气，憋得愈久愈好，然后再慢慢吐出来。接着再深吸一口气，然后尽量憋住，再慢慢吐出来。反复这么做，直到你的身体温暖起来，睡意全消为止。接着，再回到呼吸上。 问题五：无法专注在禅修前解决手边的纷争。如果解决不了，坚持禅修，不去理会问题，放下自我中心。 问题六：无聊1、重新建立真实的正念；正念看每一刻就像是这世上的第一次与唯一的一次。因此，再看一次。2、观察你的心态。注意看你无聊的状态。什么是无聊？无聊在哪里？它感觉像什么？它的成分是什么？它有任何生理上的感受吗？它对你的思维过程有什么作用？重新检视无聊，就像你以前从来不曾经历过那种状态一样。 问题七：恐惧你可能在潜意识里设定了一个“检查即将发生的事”的程序。因此，当一个令人害怕的幻想出现时，定力就会锁定它，而幻想就以你专注的能量为食，并且成长。不要对抗恐惧，置身事外，让它自来自去。它只是幻想。 问题八：太勉强不要急于看到结果，不要有太强烈的期待。只要以稳定而平衡的努力进行禅修即可。享受禅修，不要让它变成一个苦差或负担。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冷启动优化]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%86%B7%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;关于APP运行理论，百度知道上有一篇不错的文章：App 运行理论。 启动过程1 preMain阶段加载过程 解析info.plist 加载可执行文件（自身App的所有 .o 文件） 加载dyld，以便递归加载所有依赖的动态链接库 加载动态链接库：分析并找到库的mach-o文件、验证并注册文件、把动态库的每个segment映射到内存 rebase/bind：由于ASLR需要这两步修复镜像中的资源指针 注册Objc类、插入category initializers 测量方式&emsp;&emsp;在Xcode的菜单中选择Project→Scheme→Edit Scheme…，然后找到 Run → Environment Variables →+，添加name为DYLD_PRINT_STATISTICSvalue为1的环境变量 可做事情 减少不必要的framework，因为动态链接比较耗时 check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查 合理设置pod库权限，例如只在debug用到的，可标记为 :configurations =&gt; [‘Debug’] 合并或者删减一些OC类，关于清理项目中没用到的类，使用工具AppCode代码检查功能 删减没有被调用到或者已经废弃的方法，参考 http://stackoverflow.com/questions/35233564/how-to-find-unused-code-in-xcode-7 将不必须在+load方法中做的事情延迟到+initialize中 2 main阶段 int main(int argc, char * argv[])开始 (BOOL)application:(UIApplication )application didFinishLaunchingWithOptions:(NSDictionary )launchOptions 结束 测量方式&emsp;&emsp;打点，输出log！不建议使用Time Profiler，因为很容易陷到模块初始化的细节里面去 可做事情&emsp;&emsp;集中在didFinishLaunchingWithOptions方法内，这是大头也是重点，核心就是延迟处理，推荐原则：一次只修改一部分、写好测试用例、设置降级措施 将三方SDK分类，将部分SDK延后，例如ShareSDK、PushSDK等 选择性加载，提供几个维度：版本角度、用户角度、依赖关系等 延后部分模块或单例的初始化工作，例如，本地化模块、广告模块等 延后大部分的网络请求至home阶段 3 home阶段 tabbar home viewdidload 和 viewDidAppear 测量方式&emsp;&emsp;打点log 或 Time Profiler 可做事情 严查tabbar，我们在tabbar和4个tab初始化时竟然做了非常多的业务逻辑，这些完全可以延后 尽量使用缓存且尽量只加载第一屏缓存 尽量避免批量加载图片，如果必须加载使用异步 使用懒加载，尽量只处理第一屏内容 如果条件允许，使用占位符 尽量减少view层级、减少布局时浮点数的使用 其它优化措施 使用闪屏广告（倒计时 3 2 1 那种） 使用部分动画，降低用户焦虑 参考 今日头条iOS客户端启动速度优化 iOS App 启动性能优化 https://zhidao.baidu.com/question/1370352051634002499.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流量监控]]></title>
    <url>%2F2018%2F04%2F30%2F%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[why&emsp;&emsp;流量监控？怎么也得整个网络优化才靠谱吧！其实一开始我的想法就是网络优化！但经过大家开会讨论过后，发现大家（领导）只认为两个数据有用：流量和网络错误率！ &emsp;&emsp;既然是开会讨论的结果，那自然有必要水一下为什么！会上大佬们认为移动网络很复杂，WIFI、4G、3G等，用户可能过个天桥网络都要切换好几次。在DNS 解析慢、失败率高（解决1：开源版HttpDNS方案详解,也可直接用Mars）基础上讨论”时间“问题不靠谱！服务端什么样还不知道，单纯客户端统计”时间“意义不大！最主要APP内本身有数据缓存，用户进来看到的是缓存数据，请求慢一点没关系！网络安全问题大佬们倒是比较重视，但不在本次讨论范围之内… &emsp;&emsp;而网络错误率这个实在是太简单了：request是现成，response是现成的，唯一要加的就一个总请求数！上报到接口就结束了，实在是没法水… 这次就水水流量监控吧！ 流量统计方案1 App流量&emsp;&emsp;毫无疑问NSURLProtocol（关于NSURLProtocol）是最简单的实现方案，Apple允许的合法的中间人！而且选用NSURLProtocol还有一个原因：我们现在另外一个正在筹备项目也要用NSURLProtocol，就当先踩坑了！ &emsp;&emsp;直接用Wedjat Network的代码吧，因为核心代码跟这个差不多！只是业务逻辑多了些，例如url分类、header处理等123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//为了避免 canInitWithRequest 和 canonicalRequestForRequest 出现死循环static NSString * const HJHTTPHandledIdentifier = @&quot;hujiang_http_handled&quot;;@interface HJURLProtocol () &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate&gt;@property (nonatomic, strong) NSURLSessionDataTask *dataTask;@property (nonatomic, strong) NSOperationQueue *sessionDelegateQueue;@property (nonatomic, strong) NSURLResponse *response;@property (nonatomic, strong) NSMutableData *data;@property (nonatomic, strong) NSDate *startDate;@property (nonatomic, strong) HJHTTPModel *httpModel;@end+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;if (![request.URL.scheme isEqualToString:@&quot;http&quot;] &amp;&amp;![request.URL.scheme isEqualToString:@&quot;https&quot;]) &#123;return NO;&#125;if ([NSURLProtocol propertyForKey:HJHTTPHandledIdentifier inRequest:request] ) &#123;return NO;&#125;return YES;&#125;+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request &#123;NSMutableURLRequest *mutableReqeust = [request mutableCopy];[NSURLProtocol setProperty:@YESforKey:HJHTTPHandledIdentifierinRequest:mutableReqeust];return [mutableReqeust copy];&#125;- (void)startLoading &#123;self.startDate = [NSDate date];self.data = [NSMutableData data];NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];self.sessionDelegateQueue = [[NSOperationQueue alloc] init];self.sessionDelegateQueue.maxConcurrentOperationCount = 1;self.sessionDelegateQueue.name = @&quot;com.hujiang.wedjat.session.queue&quot;;NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:self.sessionDelegateQueue];self.dataTask = [session dataTaskWithRequest:self.request];[self.dataTask resume];httpModel = [[NEHTTPModel alloc] init];httpModel.request = self.request;httpModel.startDateString = [self stringWithDate:[NSDate date]];NSTimeInterval myID = [[NSDate date] timeIntervalSince1970];double randomNum = ((double)(arc4random() % 100))/10000;httpModel.myID = myID+randomNum;&#125;- (void)stopLoading &#123;[self.dataTask cancel];self.dataTask = nil;httpModel.response = (NSHTTPURLResponse *)self.response;httpModel.endDateString = [self stringWithDate:[NSDate date]];NSString *mimeType = self.response.MIMEType;// 解析 response，流量统计等&#125;#pragma mark - NSURLSessionTaskDelegate- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;if (!error) &#123;[self.client URLProtocolDidFinishLoading:self];&#125; else if ([error.domain isEqualToString:NSURLErrorDomain] &amp;&amp; error.code == NSURLErrorCancelled) &#123;&#125; else &#123;[self.client URLProtocol:self didFailWithError:error];&#125;self.dataTask = nil;&#125;#pragma mark - NSURLSessionDataDelegate- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveData:(NSData *)data &#123;[self.client URLProtocol:self didLoadData:data];&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler &#123;[[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageAllowed];completionHandler(NSURLSessionResponseAllow);self.response = response;&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task willPerformHTTPRedirection:(NSHTTPURLResponse *)response newRequest:(NSURLRequest *)request completionHandler:(void (^)(NSURLRequest * _Nullable))completionHandler &#123;if (response != nil)&#123;self.response = response;[[self client] URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];&#125;&#125; &emsp;&emsp;另外我们现在已经有部分页面转向WKWebview，而没有公开API可以注册NSURLProtocol，不过倒有私有API可用，参考 NSURLProtocol对WKWebView的处理。还有WKWebview不支持post拦截但这个真无解 2 设备流量&emsp;&emsp;获得整个设备的流量也有一定的参考意义！因为现在流量其实不太值钱，如果监控到用户流量非常大，那是不是可以更高频刷新页面？更高质量的图片？更高分辨率的视频（我们接了一个三方库，用于视频认证）?12345678910111213141516171819202122232425262728293031323334353637383940// 上行、下行流量- (NSArray *)getDataCounters&#123;BOOL success;struct ifaddrs *addrs;struct ifaddrs *cursor;struct if_data *networkStatisc;long WiFiSent = 0;long WiFiReceived = 0;long WWANSent = 0;long WWANReceived = 0;NSString *name=[[NSString alloc]init];success = getifaddrs(&amp;addrs) == 0;if (success)&#123;cursor = addrs;while (cursor != NULL)&#123;name=[NSString stringWithFormat:@&quot;%s&quot;,cursor-&gt;ifa_name];if (cursor-&gt;ifa_addr-&gt;sa_family == AF_LINK)&#123;if ([name hasPrefix:@&quot;en&quot;])&#123;networkStatisc = (struct if_data *) cursor-&gt;ifa_data;WiFiSent+=networkStatisc-&gt;ifi_obytes;WiFiReceived+=networkStatisc-&gt;ifi_ibytes;&#125;if ([name hasPrefix:@&quot;pdp_ip&quot;])&#123;networkStatisc = (struct if_data *) cursor-&gt;ifa_data;WWANSent+=networkStatisc-&gt;ifi_obytes;WWANReceived+=networkStatisc-&gt;ifi_ibytes;&#125;&#125;cursor = cursor-&gt;ifa_next;&#125;freeifaddrs(addrs);&#125;return [NSArray arrayWithObjects:[NSNumber numberWithInt:WiFiSent/1024], [NSNumber numberWithInt:WiFiReceived/1024],[NSNumber numberWithInt:WWANSent/1024],[NSNumber numberWithInt:WWANReceived/1024], nil];&#125; 3 其它方案 Hook NSURLConnection 和 NSURLSession进行统计！ iOS9可用VPN方式 https://developer.apple.com/documentation/networkextension?language=objc iOS10的NSURLSessionTaskMetrics 参考 https://github.com/aozhimin/iOS-Monitor-Platform/blob/master/iOS-Monitor-Platform_Network.md 移动 APP 网络优化概述 NSURLProtocol对WKWebView的处理]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[耗电量优化]]></title>
    <url>%2F2018%2F04%2F21%2F%E8%80%97%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1 测试1.1 测试方法&emsp;&emsp;检测耗电量的方法还是比较多的，对于我们而言Instrument检测基本上已经满足我们的耗电量检测需求！具体方法可参考iOS 常见耗电量检测方案调研！对于耗电浪有精准检测要求的，推荐阅读iOS 电量测试实践 1.2 测试范围 机型：iphone se、iphone 6 Plus 和 iPhone X 系统：iOS9、iOS11、iOS12 2 实践2.1 定位&emsp;&emsp;对于我们而言，定位服务甚至不是必须的！只是一些三方SDK要求提供定位服务，才不得不请求定位权限。鉴于我们的实际使用情况 限制定位请求只请求一次：去掉后台定位请求、获取位置成功后保存位置并关闭定位 降低定位精度：设定位精度desiredAccuracy为kCLLocationAccuracyKilometer，距离过滤器distanceFilter为1000 2.2 陀螺仪&emsp;&emsp;很早之前做了一个摇一摇的摇钱树功能！检测用户摇晃几次之后可以抽奖！经沟通已取消相关功能，最主要是不摇晃，直接点击也能抽奖… 2.3 网络&emsp;&emsp;默认网络硬件，比如蜂窝数据和Wi-Fi是不通电的。为了执行网络操作，这些资源必须通电，并持续一段时间保活。零散的网络传输会导致很高的间接能耗，迅速消耗电池电量 &emsp;&emsp;我们的APP存在的主要问题是频繁请求接口数据、每次请求接口都检测一下网络状态、缓存只在第一次启动时生效以及没有断点续传功能 2.3.1 减少请求频次&emsp;&emsp;不得不吐槽PM对客户端请求频次一直耿耿于怀，恨不得所有接口都要加个轮训，甚至要求打点信息一条一条的发，以减少漏点情况；这么高频次的请求，已经严重影响到APP的耗电：解决方案主要有： 在base库（对NSUrlsession的简单封装）里增加请求没回之前放弃本次请求（根据URL判断）的逻辑； 增加接口返回数据md5校验，如果两次接口返回数据相同，则延长相同接口请求的时间间隔，最长不超过1分钟！(现被放弃了，PM连1分钟都不能忍！让PM出白名单或接口分级，他们也不想做) 调整打点系统策略，将默认单条日志就post一下 + 无网写入文件的策略，调整为默认写入文件压缩后发送 + 单条日志发送开关控制 2.3.2 合并请求&emsp;&emsp;把普通广告弹窗和alert广告弹窗合并，这两个弹窗具有及其相似的请求频率和业务逻辑，完全可以合并！类似的还有一些配置小接口也合并成大接口 2.3.3 减少网络监测&emsp;&emsp;原来每次请求接口时，都会调用一个类似Reachability的自己写的库，用于监测当前网络！这完全是不合理也不必要的，改用监听Reachability通知并设置标志位的方式来减少网络状态检测 2.4 IO操作&emsp;&emsp;我们这高频IO操作主要集中在cache缓存、配置文件、日志、NSUserDefaults的滥用和Data方式取图片 2.4.1 cache缓存 读写在减少网络请求频次时已经得到了很好的解决，但还有优化空间！原来我们采用的是YYCache，但YYCache可能莫名其妙的缓存就清掉了，我们怀疑是sqlite没有正常关闭造成的，但我们没有证据，因为无论是断点还是打log都没抓到”现场“，无奈之下只能将一小部分核心缓存改成手动存储，但由于当时只是作为临时方：案每次接口返回都直接更新本地缓存，渐渐的变成了永久方案。因只是部分核心数据，数据量以及涉及面较小，此次方案为：内存保存当退出或内存警告时再写入硬盘 2.4.2 配置文件问题。&emsp;&emsp;首先统计读写配置文件的频次将高频的筛选出来，然后根据配置文件的标签：只读或读写，进一步细分。 高频只读文件比较简单：内存保存、收到内存警告再清除内存； 高频读写配置文件还要细分， 对于读少写多的文件：内存处理、集中保存； 对于读多写少的文件，我们没有处理! 2.4.3 打点日志&emsp;&emsp;流程：open file -&gt; 写入日志 -&gt; &gt;50条 -&gt; 关闭文件 -&gt; 取出文件Data -&gt; zip -&gt; 取出zip文件Data -&gt; ase加密 -&gt; 存储。通过流程我们可以发现： 1、日志文件可以不创建，直接使用内存记录，转Data直接塞到zip里即可 2、压缩后的文件加密移至低级线程集中单独处理（这里原来有个大bug：竟然每写一条日志就检查一下当前文件夹里是否有未压缩的文件，如果有就压缩，压缩是否加密，没加密就加密） 2.4.4 NSUserDefaults的滥用&emsp;&emsp;主要体现在滥用synchronize，这个没啥可说的！NSUserDefault的数据不太敢动，只能在synchronize上做做文章了 2.4.5 Data方式取图片&emsp;&emsp;比较试用的是单独用一次的大图片！对于频繁实用的小图还是用imageNamed比较好，不过需要注意的是如果需要异步读取图片必须用Data方式 2.5 定时器&emsp;&emsp;定时器也是耗电大户，我们定时器问题主要是轮播组件以及轮训 轮播组件：检测当前Cell是否在屏幕上，如果没在屏幕停止轮播，切换回屏幕再重新启动 轮训：合并轮训定时器，减少定时器数量 2.6 视图&emsp;&emsp;其实绝大多数视图问题都和流畅度、卡顿相关！以后可以专门写个卡顿的水文，这里就说跟耗电量相关的问题！ 1、使用局部刷新、避免频繁刷新！ 2、减少图片拉伸 3、减少动画 4、布局时减少浮点数的计算 3 低电量模式&emsp;&emsp;iOS9之后，iPhone增加了低电量模式，用户如果希望延长iPhone电池的寿命，可以在设置 &gt; 电池中开启该功能。开启该功能之后iOS会采取一些措施，比如： 降低CPU和GPU性能 暂停随意的和后台的活动，包括网络 降低屏幕亮度 缩短自动锁屏时间 关闭邮件刷新 关闭视角缩放 关闭动态壁纸 &emsp;&emsp;可以通过向NSNotificationCenter注册NSProcessInfoPowerStateDidChangeNotification通知监听低电量模式状态。我们APP在接收到低电量通知时就干了一件事：把内存数据存储到本地 4 监控&emsp;&emsp;监控电池的状态有助于我们在不同电池状态下做更多的操作！据闻Uber就是检测到电池电量比较低时提高运单价格，因为手机快没电的还在叫车，那才叫真的刚需呀！其实监控电池状态对于我们而言只有两个作用：1、上文提到低电量存本地策略；2、生产和PM撕逼的证据：别老没事就说我们APP耗电，下载电影电视剧的耗电可不能算在我们头上 4.1 方案&emsp;&emsp;我们采用的是UIDevice类batteryLevel接口，虽然采样只能精确到 1%，但已经足够满足我们的需求！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#pragma mark 电池// 电池电量，ios8前只能精确动5%，以后可精确到1%+ (float)batteryLevel &#123;UIDevice *device = [UIDevice currentDevice];device.batteryMonitoringEnabled = YES;if (device.batteryLevel &gt; 0.0f) &#123;return device.batteryLevel * 100 ;&#125;return -1;&#125;// 电池状态：充电中、满电等+ (UIDeviceBatteryState)batteryState &#123;UIDevice *device = [UIDevice currentDevice];device.batteryMonitoringEnabled = YES;return device.batteryState;&#125;// 电池是否在充电+ (BOOL)isBatteryCharing &#123;UIDeviceBatteryState state = [[self class] batteryState];if (state == UIDeviceBatteryStateCharging) &#123;return YES;&#125;return NO;&#125;// 电池是否满电+ (BOOL)isBatteryFull &#123;UIDeviceBatteryState state = [[self class] batteryState];if (state == UIDeviceBatteryStateFull) &#123;return YES;&#125;return NO;&#125;// 当前电量是否大于给定阀值，耗电量优化时可用+ (BOOL)shouldProceedWithMinLevel:(NSUInteger)minLevel &#123;// 充电或满电if ([[self class] isBatteryCharing] || [[self class] isBatteryFull]) &#123;return YES;&#125;NSUInteger batteryLevel = (NSUInteger)[[self class] batteryLevel];if (batteryLevel &gt;= minLevel) &#123;return YES;&#125;return NO;&#125; 参考 https://www.jianshu.com/p/9a5e94e7b7c3 https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装包瘦身]]></title>
    <url>%2F2018%2F03%2F25%2F%E5%AE%89%E8%A3%85%E5%8C%85%E7%98%A6%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[1、编译选项 参考：https://www.jianshu.com/p/11710e7ab661 或 https://stackoverflow.com/questions/17650138/ios-ipa-file-size-xcode-archive-vs-xcodebuild-command 1，做SDK最好设置Generate Debug Symbols为NO，防止泄露源代码，但APP最好设置Generate Debug Symbols为YES,因为需要dysm文件 2，xcode-archive打包，xcode会默认把Deployment Postprocessing设为YES，但xcodebuild-command不会 2、资源瘦身2.1 压缩图片 PNG压缩参考： https://tinypng.com/ 暂不考虑webP格式，iOS使用webp需引入WebP-iOS-example , 安卓有webP瘦身计划，可等他们一起做 &emsp;&emsp;其它图片压缩工具 1、pngquant 官网 github 2、IconFont技术：用字体显示图标来减小包体积，参考,例RN的使用 12345678910111213function test()&#123;NSURL *fontUrl = [NSURL fileURLWithPath:path];if (!fontUrl) return nil;if (![[NSFileManager defaultManager] fileExistsAtPath:path]) return nil;CGDataProviderRef fontDataProvider = CGDataProviderCreateWithURL((__bridge CFURLRef)fontUrl);CGFontRef fontRef = CGFontCreateWithDataProvider(fontDataProvider);CGDataProviderRelease(fontDataProvider);CTFontManagerUnregisterGraphicsFont(fontRef, NULL);CTFontManagerRegisterGraphicsFont(fontRef, NULL);NSString *fontName = CFBridgingRelease(CGFontCopyPostScriptName(fontRef));CGFontRelease(fontRef);return fontName;&#125; 3、pngcrush 一款开源的png压缩工具，Xcode自带pngcrush，默认目录为/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/pngcrush ，参考 12345678910pngcrush使用命令为：pngcrush [options] infile.png outfile.png其中：infile.png：输入的原始图片；outfile.png：压缩后的输出图片；[options]：参数，支持如下设置-rem allb ：移除所有多余的数据；-brute ：将尝试所有可能的优化方法；-reduce ：删除无用颜色及减少表示颜色的位大小；图片的最大压缩方式为：pngcrush -rem allb -brute -reduce original.png optimized.png 2.2 使用Asset Catalog管理图片 使用方法: https://blog.csdn.net/lihuiqwertyuiop/article/details/51286219 特殊说明：只有使用了imageNamed：方式加载的图片才能使用Asset catalog管理，其他形式加载的图片依然使用bundle管理。 Asset Catalog中图片需要供2X和3X两种尺寸图片，发布包可根据发布的机型进行图片资源的裁剪，若仅提供某一尺寸图片时，表现如下： 1、若仅提供1x图，假设图片100100 px，2x、3x机型上都可以读取图片，图片尺寸均为100100 pt，推荐设备无关的图片使用该尺寸； 2、若仅提供2x图，假设图片100100 px，2x、3x机型上都可以读取图片，图片尺寸均为5050 pt，该方式会造成3x设备图片清晰度降低，推荐分别提供2x、3x图片； 3、若仅提供3x图，假设图片150150 px，2x、3x机型上都可以读取图片，图片尺寸均为5050 pt，该方式会造成2x设备图片资源体积浪费，推荐分别提供2x、3x图片； Xcode Help - WORK WITH ASSETS Analysing Assets.car file in iOS 2.3 音视频压缩2.4 清理重复资源或文件 先下载最新版的fudpes并解压，https://github.com/adrianlopezroche/fdupes 进入解压后目录，执行下面的命令安装fdupes：123make fdupessu rootmake install 2.5 无用的类 fui PS:需要手动检查并删除，注意有些类以前删除时只删除了引用 2.6 删除无用的图片 LSUnusedResources PS：需要手动检查并删除 3、代码瘦身3.1 静态库瘦身 xcode默认支持，无须手动处理 123456789xcode的Architectures setting默认支持armv7（如果以后不支持4和4s机型，可考虑移除armv7架构支持，减少ipa体积达8M多）、armv7s和arm64架构，release打包时xcode将默认剔除i386和x86_64等模拟器架构，无须手动处理！release打包默认剔除i386和x86_64，构验证如下：验证工具：lipo 使用方法https://blog.csdn.net/yepiaouang/article/details/79353377A、libZXingObjC-iOS.a ，大小为20.2M， 默认支持架构如下默认打包后ipa大小为34.9MB、libZXingObjC-iOS.a 经过lipo去除i386和x86_64架构支持后，为10.4M，支持架构如下打包后大小也为34.9M即证明设置xcode的Architectures setting后打包xcode会剔除i386和x86_64等模拟器架构，无须手动处理！ 关于Xcode “Build Setting”中的Architectures详解 3.2 无用的方法 可用APPCode(收费) 或 MCheckProject 由于OC的动态性，还是慎用！可作为重构参考 3.3 查找相似代码并封装4 监控&emsp;&emsp;主要通过自动打包平台每次打包时统计包大小，针对突然增加的情况给客户端组发邮件！有一定的参考意义，但意义不大！因为经常因为分支合入而误报！ 其它参考 iOS可执行文件瘦身方法 干货不多 iOS微信安装包瘦身 ,获取linkmap文件 1，累加每个obj文件计算大小； 2，通过正则表达式([+|-][.+\s(.+)])过滤LinkMap文件的TEXT.text提取所有的方法SelectorsAll，再使用otool命令otool -v -s DATA objc_selrefs逆向DATA.objc_selrefs段提取使用到的方法（UsedSelectorsAll），来计算没用到的方法（SelectorsAll-UsedSelectorsAll），但注意，系统API的Protocol可能被列入无用方法名单里； 3，通过otool命令逆向DATA.objc_classlist段和DATA.objc_classrefs段来获取当前所有oc类和被引用的oc类，两个集合相减就是无用oc类，但无法判断是否被使用 iOS APP安装包瘦身实践 干货不多，基础建议 Reducing the size of my App 官方文档，干货不多 基于clang插件的一种iOS包大小瘦身方案 怎么通过clang这种静态分析去查找无用的类和方法]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生命之书365天的静心冥想]]></title>
    <url>%2F2018%2F02%2F17%2F%E7%94%9F%E5%91%BD%E4%B9%8B%E4%B9%A6365%E5%A4%A9%E7%9A%84%E9%9D%99%E5%BF%83%E5%86%A5%E6%83%B3%2F</url>
    <content type="text"><![CDATA[其实就是无欲则刚，学会淡定与从容！想要获得内心平静，就要正视自己所有的一切，既不否认、不肯定更不解释。 聆听需要心无杂念，不要以己度人，更不要武断猜疑！只是静心去听，听完之后自然会有相应的结论！ 静心，需静坐！ 己所不欲勿施于人，己所欲亦勿施于人 倾听需要放松自己，而不是压抑自己！不能做这个，必须做那个，当这个心态时，也许并不是倾听的好时机！ 寻找自己，了解自己，接纳自己，顺势而为，点滴改变自己！切勿好高骛远，更勿自我放弃！ 乐趣？现实就是有可为有不可为，坦然处之，摒弃杂念，学会接受，但不盲从，发现乐趣！我命由我不由天，就是如此吧 不要让过去的知识经验成为前进的阻碍，每日三省吾身，原来是这个意思 心若能完整的觉知，保持警醒和警觉。手段是工具 只有当心完全的寂静时，才有可能超越所有的经验！不要为了创造而创造，目标存在的意义是激励人不断地一步一步前行，而不是我达不到目标我就去死！ 自我不是别人或自己打的一堆标签的集合。标签本身就是外在的，与自我无关！ 只有当我们想逃避事实躲进幻想里的时候，才需要信仰！ 面对现实和困难，人本能的会选择逃避，寻求依赖！无助和孤独是人生的必修课！ 君子慎独，身体或心灵总的有一个在路上！强大的内心从点滴锻炼起来的！ 对待欲望，既不否认也不抗拒，而是学会接受与忍受]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[晨间日记的奇迹]]></title>
    <url>%2F2018%2F01%2F31%2F%E6%99%A8%E9%97%B4%E6%97%A5%E8%AE%B0%E7%9A%84%E5%A5%87%E8%BF%B9%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;话说前些天啃内核知识啃得头疼，今天正好换换脑子！本来想看会小说的，发现这本书也就跟小说一样，一目十行都嫌慢的那种！正好放松一下脑子 早上写日记的好处：1，可做一天的准备（计划性）；2，可以正确的写出昨天所发生的事情（效率性和忠实性）；3，冷静思考昨天的事（中立性）；4，早上比较自由（持续性）；5，可以将过去的宝贵经验应用于当天（灵活运用性） 累了一天到晚上写的日记大多情绪是负面的，潦草的，激进的，而反省是缺乏独立思考的 早上写日记能真实客观的正视问题，反省自己，并根据变化做出更好的改善意见 趁着昨天的记忆还在，可以在段时间内留下正确的记录。 注意写日记不是写流水账，也要写情绪，问题与方法，重要的有趣的好玩的别人重要的事等等 早上懒床就是借口。早起方法很多，最最主要的是梦想：我想进阿里，去做闲鱼 早上健身和沐浴让你身心精神百倍 写日记的5大好处：1，提升写作能力；2，谈话题材源源不断；3，提高贵人运；4，发现自我肉体与精神的状态和模式；5，在自己身上挖宝，彻底改变人生； 人过了30岁以后剩下的只有习惯 平常心，不骄不躁不急不惰]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS内核推荐博文]]></title>
    <url>%2F2018%2F01%2F23%2FiOS%E5%86%85%E6%A0%B8%E6%8E%A8%E8%8D%90%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[1 Mac OS X 和 iOS架构 用户体验层：主要有SpringBoard、Spotlight、Accessibility选项等等 应用框架层：主要有 Cocoa Touch、Java 核心框架层：主要有 OpenGL、Quartz等图形、多媒体组件 Darwin：操作系统核心，包括XNU内核(kernel)和UNIX shell 1.1 iOS 和 OS X的不同点： iOS 内核和二进制文件编译的目标架构是ARM架构， OS X基于Intel i386 和 x86_64。 iOS 的内核闭源，OS X内核是开源的 iOS 的内存管理要紧凑的多。 iOS系统不支持虚拟内存，OS X通过内存映射获得额外的内存，几乎有无穷的交换空间可以使用。 iOS app不允许访问底层的Darwin，也没有root访问权限，并且只能访问自己目录内的数据。 2 Darwin架构&emsp;&emsp;盗图OS X Darwin，iOS和OS X的Darwin架构差不多，我觉的这个更清晰易懂一些 &emsp;&emsp;Darwin的内核是XNU，XNU is Not Unix的缩写。XNU是由Mach微内核和BSD（伯克利软件套件）组合而成。 2.1 Mach微内核&emsp;&emsp;Mach是一个微内核轻量级操作系统，仅处理最核心的任务， 进程和线程 虚拟内存管理 任务调度 进程通信 2.2 BSD&emsp;&emsp;BSD层在Mach之上，提供了更高层次的功能，包括： 文件系统 网络（硬件设备级别除外） UNIX安全模型 syscall 支持 BSD过程模型，包括过程ID和信号 FreeBSD内核API 许多POSIX API 内核支持pthreads（POSIX线程） 2.3 File Systems&emsp;&emsp;iOS 的文件系统和 OS X 非常类似，但是有以下区别： iOS文件系统（HFSX）是大小写敏感的, OS X 的 HFS+是不敏感 iOS文件系统是部分加密的。 没有/Users 目录，只有一个/User 目录 没有/Volumes目录, 没有必要进行磁盘仲裁 2.4 I/O Kit&emsp;&emsp;开发者可以使用C ++快速创建设备驱动程序。但内核是C语言或汇编写的，因此需要libKern库支持C ++运行时并提供所需要的基类。I/O Kit的功能： 真正的即插即用 动态设备管理 动态（“按需”）加载驱动程序 桌面系统和便携式设备的电源管理 多处理器功能 3 系统调用3.1 POSIX系统调用&emsp;&emsp;POSIX 兼容性是由XNU中BSD层提供的。所有的POSIX 系统调用不论底层实现如何都有相同的原型，也就是说具有相同的参数和返回值。&emsp;&emsp;系统调用编号：除了固定的原型之外，POSIX还完整定义了系统调用的编号。 3.2 Mach 系统调用&emsp;&emsp;BSD层是对Mach内核的包装，但是Mach系统调用仍然可以在用户态访问。需要借助mach trap实现用户态到内核态的转换。&emsp;&emsp;在32位系统上，Mach系统调用的编号都为负数，POSIX调用编号为非负。&emsp;&emsp;在64位系统上，Mach系统调用为正数，但是以0x2000000开头，而POSIX调用编号以0x1000000开头。 博文推荐：&emsp;&emsp;最近在啃《深入解析Mac OS X &amp; iOS 操作系统》啃了一个多星期，我自以为我现在已经比上学的时候好多了，能看点书了！但还是啃不动了：太厚了造成我比较烦躁、没有试验机会、过时（市面上已经绝版了）！熬了一个多星期实在熬不住了！给大家推荐一个系列博客吧，博主应该是上学时啃的（估计工作也没时间）：https://www.jianshu.com/p/95acba84bfef &emsp;&emsp;其实我觉得如果不考虑细微差别直接看OS X的官方文档反而是最舒服的 https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/About/About.html#//apple_ref/doc/uid/TP30000905-CH204-TPXREF101]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你的灯亮着吗]]></title>
    <url>%2F2017%2F12%2F27%2F%E4%BD%A0%E7%9A%84%E7%81%AF%E4%BA%AE%E7%9D%80%E5%90%97%2F</url>
    <content type="text"><![CDATA[遇到问题不必着急去寻找解决办法，应该先明确问题 谁有问题：我们要取悦于谁，利益相关者！ 要想的全面，针对每 种 利益相关者，问一下问题的本质是什么？ 努力让别人接受观点，没有对错之分，不要反驳，不要争执，也不要放弃，最好诉诸于利益，告诉别人他的观点是可以代替的！ 激化矛盾，或不着手处理问题，很可能会带来新的大问题，甚至忘记最开始的问题是什么！！！ 问题其实就是你期望的东西和你体验的东西之间的差别。从这个角度看，要解决问题，要么改变期望，要么改变体验 对于那些没有幽默感的人，帮他们解决问题简直是自寻烦恼？ 不要把他们的解决办法误认为是问题的定义–特别是你使用自己的解决方案时。 如果你太轻易的解决了他们的问题，他们永远都不会相信你真的解决了他们的问题。 关于真正解决问题的看法是：你永远不能肯定你已经某个问题有一个正确的定义，即使在这个问题已经解决之后。但永远不要放弃追寻正确定义的努力！ 不要过早的下结论，但是也不要忽略你的第一印象。 如果问题是重要的，那么答案也一定是重要的吗？不！！！ 每种解决问的办法都会带来新的问题。我们永远不可能消灭问题，只能不那么棘手了 问题最难以处理的部分恰恰是意识到它们的存在！ 如果在对问题的理解中，你想不出至少3种可能出错的地方，那么你并没有真正的理解这个问题！ 生活中有很多很不爽但你却自然去接受的地方！这就是对不相称的忽视，其实这里面有很多问题，都可以变得好一点和更好一点！很多东西都可以通过用一个从来没有见过它的“外国人”的观点来“看待”它！ 每一种新的观点都会带来新的不相称，在实现这些“解决办法”前，最好多思考一下！ 我们要怎样改变问题的表达方式才能获得不同的解决办法？ 在特定层面上考虑问题。 当你在寻找问题的道路上疲倦的游荡时，不要忘记随时回头看看，看看你是不是迷路了 试着换过来指责自己–即使只有一秒钟 如果灯亮着，一个小小的提醒，可能比复杂的解决方案更有效！ 问题的根源也许根本就不存在！]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听文件夹变化]]></title>
    <url>%2F2017%2F12%2F12%2F%E7%9B%91%E5%90%AC%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1 timer+NSFileManager&emsp;&emsp;这是我想到的第一个方案，方案很简单但效果非常不理想！轮询时间长了，可能会出现时间间隔内多次修改问题；轮询时间短了，太耗费性能，而且”短“的定义无法具象。具体代码不贴了 2 GCD source&emsp;&emsp;必须得找一个让文件夹自己说话的方法，几经思索我想到了GCD，毕竟GCD可监控端口啥的，没准也可以监听文件夹！搜到一篇文章 http://ksnowlv.github.io/blog/2014/09/06/gcd-zhi-jian-ting-wen-jian/ , 核心是创建读写权限的source通知！123456789101112131415161718192021222324252627282930313233343536373839404142434445NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);if (paths.count == 0) &#123;return;&#125;NSString *ksnowDir =[[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;ksnow&quot;];NSLog(@&quot;ksnowdir = %@&quot;, ksnowDir);NSURL *directoryURL = [NSURL URLWithString:ksnowDir];int const fd =open([[directoryURL path] fileSystemRepresentation], O_EVTONLY);if (fd &lt; 0) &#123;NSLog(@&quot;Unable to open the path = %@&quot;, [directoryURL path]);return;&#125;dispatch_source_t source =dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd,DISPATCH_VNODE_WRITE | DISPATCH_VNODE_RENAME,DISPATCH_TARGET_QUEUE_DEFAULT);dispatch_source_set_event_handler(source, ^() &#123;unsigned long const type = dispatch_source_get_data(source);switch (type) &#123;case DISPATCH_VNODE_WRITE: &#123;NSLog(@&quot;目录内容改变!!!&quot;);break;&#125;case DISPATCH_VNODE_RENAME: &#123;NSLog(@&quot;目录被重命名!!!&quot;);break;&#125;default:break;&#125;&#125;);dispatch_source_set_cancel_handler(source, ^() &#123; close(fd); &#125;);self.source = source;dispatch_resume(self.source); 3 官方&emsp;&emsp;在检索的时候无意中发现官方已经给了dome ： https://developer.apple.com/library/content/samplecode/DocInteraction/Listings/Classes_DirectoryWatcher_m.html , 源码如下 &emsp;&emsp;核心思路是 open打开文件夹，得到文件句柄。 创建kqueue队列来处理系统事件 创建kevent结构体，设置相关属性，并关联kqueue队列。 创建runloop source，设置回调函数并加到默认的runloopMode中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788- (void)kqueueFired&#123;assert(kq &gt;= 0);struct kevent event;struct timespec timeout = &#123;0, 0&#125;;int eventCount;eventCount = kevent(kq, NULL, 0, &amp;event, 1, &amp;timeout);assert((eventCount &gt;= 0) &amp;&amp; (eventCount &lt; 2));// call our delegate of the directory change[delegate directoryDidChange:self];CFFileDescriptorEnableCallBacks(dirKQRef, kCFFileDescriptorReadCallBack);&#125;static void KQCallback(CFFileDescriptorRef kqRef, CFOptionFlags callBackTypes, void *info)&#123;DirectoryWatcher *obj;obj = (__bridge DirectoryWatcher *)info;assert([obj isKindOfClass:[DirectoryWatcher class]]);assert(kqRef == obj-&gt;dirKQRef);assert(callBackTypes == kCFFileDescriptorReadCallBack);[obj kqueueFired];&#125;- (BOOL)startMonitoringDirectory:(NSString *)dirPath&#123;// Double initializing is not going to work...if ((dirKQRef == NULL) &amp;&amp; (dirFD == -1) &amp;&amp; (kq == -1))&#123;// Open the directory we&apos;re going to watchdirFD = open([dirPath fileSystemRepresentation], O_EVTONLY);if (dirFD &gt;= 0)&#123;// Create a kqueue for our event messages...kq = kqueue();if (kq &gt;= 0)&#123;struct kevent eventToAdd;eventToAdd.ident = dirFD;eventToAdd.filter = EVFILT_VNODE;eventToAdd.flags = EV_ADD | EV_CLEAR;eventToAdd.fflags = NOTE_WRITE;eventToAdd.data = 0;eventToAdd.udata = NULL;int errNum = kevent(kq, &amp;eventToAdd, 1, NULL, 0, NULL);if (errNum == 0)&#123;CFFileDescriptorContext context = &#123; 0, (__bridge void *)(self), NULL, NULL, NULL &#125;;CFRunLoopSourceRef rls;// Passing true in the third argument so CFFileDescriptorInvalidate will close kq.dirKQRef = CFFileDescriptorCreate(NULL, kq, true, KQCallback, &amp;context);if (dirKQRef != NULL)&#123;rls = CFFileDescriptorCreateRunLoopSource(NULL, dirKQRef, 0);if (rls != NULL)&#123;CFRunLoopAddSource(CFRunLoopGetCurrent(), rls, kCFRunLoopDefaultMode);CFRelease(rls);CFFileDescriptorEnableCallBacks(dirKQRef, kCFFileDescriptorReadCallBack);// If everything worked, return early and bypass shutting things downreturn YES;&#125;// Couldn&apos;t create a runloop source, invalidate and release the CFFileDescriptorRefCFFileDescriptorInvalidate(dirKQRef);CFRelease(dirKQRef);dirKQRef = NULL;&#125;&#125;// kq is active, but something failed, close the handle...close(kq);kq = -1;&#125;// file handle is open, but something failed, close the handle...close(dirFD);dirFD = -1;&#125;&#125;return NO;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把时间当做朋友]]></title>
    <url>%2F2017%2F11%2F30%2F%E6%8A%8A%E6%97%B6%E9%97%B4%E5%BD%93%E5%81%9A%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[时间是不可能被管理的。必须开启心智，看清楚，想明白：问题出在我们自己身上。而我们所面临的问题，与时间、管理或时间管理都没有多大的关系。解决方案只有一个，那就是“一切都靠积累”。深信积累的力量，时间就是你的朋友，否则它就是你的敌人。 不要再让自己成为自己大脑的奴隶，而是选择翻身做主人 管它呢，学呗，学了总有用处 告诉自己：我有不足，我需要时间，我没办法一蹴而就。就这样。 每个人的起点不同，有些人的地板是另外一些人的天花板。但起点就是起点，尽管不同，每个人都要从起点开始往前走。 拿出一张纸将其划分为左右两个部分，左边标题是“我有的”，右边标题是“我要的”。逐一罗列。而后尽量客观地判断，“我要的”那些有哪些是用“我有的”无法换取的—划掉。再仔细判断剩下的能用“我有的”换取的那些“我要的”之中究竟哪些是必须的、必要的、重要的、不可或缺的—加上重点标记，比如星号。 想到“我要什么”的时候，马上提醒自己要花上三倍的时间去想想“我有什么”。 做任何事情的时候，都需要时时刻刻忍受各种各样的不完美 为了进步，我们必须忍受一定的未知。 必须接受这个现实：未知永远存在。而后只能开始不断地尝试着去适应“在未知中不断前行”。 有问题解决不了时，暂时先把它记下来，而后继续前行。注意，一定要记下来 对现状不满，急于摆脱现状，往往是常人最常不知不觉就掉进去的陷阱 尽管现实总是如此难以接受，坚强的你却应该坦然 最好时常把自己的一些念头记录下来 不仅要接受，还要牢记；不仅要牢记，还要坚信，不容得半点动摇。 完成任何一个任务，往往都需要三倍于计划的时间—即便，从一开始就考虑到这个因素。 想要出类拔萃，就要努力至少一万小时。 开始越好”更好的答案是“现在就开始”。所谓做事拖拉，不是拖拖拉拉地做事，而是拖拖拉拉地就是不开始做正事。- 拖拉的人最本质的原因在于恐惧—无论是来自内部的（“不求有功，但求无过”），还是来自外部的（过分在意外界的评价）。 做事的时候，肯定会遇到困难，越是有价值的事情，困难越多越大。 没有人从一开始就能做对，没有人从一开始就能做好！只要做事，就一定会出问题。 简单的部分要迅速做完，而后把节约出来的时间投放在处理困难的部分上。 任务没有完整完成，所以，根本谈不上效率（相当于分子等于零）。 为了提高效率，我们必须把自己的大脑打造成一个“多任务操作系统，试着把一个复杂而又有机的任务与一个简单而又机械的任务搭配起来一起做。尽量并行两个任务，重要前提是：这两个任务之所以并行是因为你对自己了解所以才主动如此安排的 在做任何事情之前，通过关注HOW而反复拆分任务，最终确认每个子任务都是可完成的 “20分钟工作+5分钟休息”作为一个时间片，然后就开始像CPU一样处理任务 “没时间了”，其可怕程度几乎无异于死亡。也许有的时候，发现自己已经晚了，唯一的策略依然是“现在就开始”，否则更待何时？ 很多的时候，“跟着感觉走”肯定是要吃亏的。 期望速成，从基本的层面上来看，有两个主要的原因。第一个是人希望自己的欲望马上得到满足的天性；另外一个期望速成的原因，也是浮躁的根源，是不懂得有些阶段就是无法跨越 无论对谁来讲，想进入自己的梦想职业都是成本高昂的 接受现状才是最优策略 不要常常觉得苦，而是要想办法在任何情况下找到情趣—快乐是一种本事 事情是否正确？看它是否现实。几乎一切愚蠢的行为都来自于否定现实逃避现实。 接受惩罚往往是积累经验的起点 很多人实际上根本不知道自己所谓的“喜欢做某件事情”实际上更可能只不过是因为那件事情相对简单、容易获得奖励而已 对于逃避困难的人来讲，最为关键的实际上不是WHAT，也不是WHY，而是HOW。 减少这种令人恼火的情况：被其他人的错误耽误自己的时间 先坐下来制定一个工作列表，把任务都罗列下来，而后把自己的时间切片。 基于过程的“事件-时间日志”记录可以调整我对时间的感觉，在估算任何工作量的时候，都更容易确定“真正现实可行的目标”。 既然“管理时间”是不可能的，那么解决方法就只能是：想尽一切办法真正了解自己，真正了解时间、精确地感知时间；而后再想尽一切办法使自己以及自己的行为与时间“合拍”，就是我的说法—“与时间做朋友”。 每天记录你的时间开销，每天都要制作你的时间预算。制作一个列表，把你今天需要做的事情罗列出来。给列表中的每项任务标上权重值—比如，你可以用1~5分进行标记 不要害怕修改。相信我，完成任何一项任务的过程中，修改都是不可或缺的内容。你在修改，就说明你在进步 判断每项任务的真实属性。然后选择“真的重要的”或者“显得不重要的”。“真的重要”，其实只需要一个标准：就是看这项任务的完成是否对你的目标达成确实有益 对像我这样的普通人来讲，证明我的目标现实可行的方法比较简单：1.已经有人做到了；2.我与那人没有太大的差距。 往往只有开始行动了之后，才可以做出正确的判断。在行动过程中，发现既定的目标确实是不现实的、不可行的，那么，半途而废不仅并不意味着失败，还意味着该决策者是无比理智的。 时间的浪费，往往是因为a.目标不现实或者目前暂时尚不可行；b.为了达到目标而制定的实施策略有误。 计划总是被变化打乱，更深层次的原因在于计划过于长远。 越是短期的目标，越容易清晰。越是清晰的目标越容易实现 乐观是靠努力和挣扎才可以获得的经验。 生活本身充满了意外，并且，总是意外到无以复加的地步。 做计划的时候，要知道这样一件事：做长期计划显然是正确的并且是必需的，但是，需要挣扎，需要努力，需要从一点一滴开始。不要一上来就开始制定过分长期的计划。 我知道那只不过是我的大脑的想法，而不应该是我的想法 没必要做计划的原因有两个：1.大多数计划其实非常简单”；2.“初始状态下，我们往往实际上并没有能力去制定合理有效的计划”。 大多数情况下，我的建议是这样的：如果你想改变你自己，或者你目前的处境并不令人满意，那就一切从简—找一个你觉得该给你带来改变的行动，然后去做就是了。不要怕碰壁，不要怕失败，那是必须经历的一个过程。还是那句话，失败并不可怕，因为你总是要失败许多次才会有结果，并且全天下又不是只有你一个人失败，怕什么？关键在于在每次挫折之后能否汲取教训。只要能汲取教训，然后自我调整，那就是进步了。 制作一个列表，往往会使自己做事井井有条，并保证自己不会没必要地浪费时间，列表没必要工整。关键在于要随时可以看到，随时可以书写和标记。真正最重要的任务永远只有一个—那个真正对你的目标实现有帮助的任务。真正紧急的事儿少之又少，除非万不得已，千万不要在整个任务完成之前中途更改列表中的项目。 有了什么新鲜主意，启用另外一个新的列表，标题是“下一阶段任务列表”，把你的新鲜主意记录在那里，然后马上回到当前的这个任务列表，专注在当前应该完成的任务上。 先判断你的这个列表所代表的那个任务是不是现实的，如果你真的觉得你能够、也应该完成这个任务，那就开始去做；并且一定要做到底。 我们所面临的大多数任务其实都是“重复性”的。只要遇到重复性任务，就要在做过一次之后，马上总结整理，将其流程梳理清楚，而后经过后来的实践把它变成“闭着眼睛也能做好”的事情。这是提高效率、减少失误的最根本手段。 为常见任务制定流程，是必须养成的习惯。在梳理流程的过程中，会不由自主地思考个中的细节， 在做任何事情之前，我都会尝试着把将要做的事情的整个过程在头脑中预演一遍甚至很多遍。执行的任务越重要，这种预演就越发不可或缺。学习的过程就是如此，它往往给你带来意想 遇到任何任务，都应该认真审视该任务，问自己一个问题并想办法回答清楚：“怎样才算做好？ 学习是投资回报率最高的行为。 除了“试错”、“观察”、“阅读”之外，“思考”，准确地说，“正确地思考”，才是获取真正意义上的知识的主要手段。 每个人内心都充满了恐惧，所有的恐惧其实都源自于我们害怕未知。于是，恐惧是永恒的，因为我们永远不可能什么都知道。 知识传递过程中最大的障碍—“经验主义” 把那些目前暂时无法理解的、或者支持的、或者反对的，或者无所谓的论点观点记录下来。无法理解的，写下自己当时的疑惑究竟在什么地方；支持的，记录下几个自己的支持理由或者实例；反对的，也一样可以记录下几个自己的反对理由或者实例；甚至那些无所谓的，也可以写下为什么自己觉得这完全是无所谓的 在任何一个阶段，总是有一段时间进展缓慢，许久过后，所谓量变到质变的效果才会出现，才可能有突飞猛进的感觉 独立思考的钥匙之一是这样的：首先要了解：权威不一定等于正确。进一步要明白：就算权威正确，也只不过是权威表达了正确，而正确并不属于权威。最后要清楚：更准确地来说，权威只是权威、正确就是正确，它们俩什么时候都不是一回事儿。 接到任何任务之后，都勤于琢磨，去思考该任务的目标、实质、意义，而后再根据其目标、实质、意义去思考该任务的完成方法。于是，他们为了完成任务，实现目标，会去做很多领导原本甚至未曾想象过要交代的事情，最终，不仅完成任务，还常常有很多意外收获…… 导致人们常常犯这些逻辑错误之中的最重要根源只有两个：概念不清和拒绝接受不确定性。 学习任何知识的时候，搞清楚所有它的基础概念是最重要的 “反过来不一定成立”这句话，值得牢记。 爱迪生是否是一个特别努力的人，本质上与我们没什么关系，我们该努力还得努力，不应该仅仅因为别人努力或者不努力，我们就放弃努力。 抱怨“上司的愚蠢”的人只有一个共同特征：他们只不过是把“上司很愚蠢”作为自己偷懒的借口而已 要么想办法帮助上司解决问题，要么就在爱莫能助的时候选择离开去自行其是。 人类拥有的普遍的认知偏差之一就是：把成功揽到自己身上，把失败归咎于别人或者坏运气。 努力从失败者身上汲取经验。有些时候，“成功者”的经验根本没有用，因为那些经验根本就是错误的。 人家说什么你就信什么，挺傻的。 强与弱才是自然界中真正存在的本质，善与恶更多的时候只不过是弱者一厢情愿的定义。 作为注定会老去死去的物种之一，人性中天生就充满了恐惧 过去的事情是无法更改的，现在的烦恼是无济于事的。但是，将来的尴尬也许是可以避免的—如果现在的行动没有出错的话 当脑子里闪出类似“要是……就好了！”的念头的时候，要马上提醒自己，“停！这个念头最耽误事儿了！” 人们只能听到自己想听到的，只能看到自己想看到的。 日积月累的过程中，要尽量有效甄别自己大脑中所存储的“已知信息”（大多是A类）的有效性。 为了真正做到有效倾听，最需要克制的就是“过早质疑”。就算需要质疑也一定要等到对方说完。 一旦决定倾听，就要主动帮助讲者进入“倾诉”状态。 为了避免在讨论的过程中出现不必要的麻烦，浪费不必要的时间[75]，我们必须深刻理解以下三个原则。 A，有意义之讨论的前提是双方不仅要“相互竞争”更重要的是还要“相互合作”。如果你在任何讨论中发现参与者里面有“自以为是”者存在，你其实只有一个选择，退出讨论 B：事实、真相、真理、道理（即所谓的“Truth”；下文中全部使用“Truth”这个英文单词指代）是独立存在的，从来不会依附于任何个人或者集体存在。 C：Truth不变，也不会因任何人而变；不停变化的只是人们对Truth的解释或者理解 避免自以为是地认为自己肯定理解对了，不妨套用以下这个句式，进行验证、反馈：“你的意思是……，是么？” 或者 “你的意思是……，你看我理解的对么？” 摆脱经验主义的局限，不仅需要对道理本身的了解，最终还需要勇气 深刻了解了经验之局限之后，所需要做的就是时时刻刻保持警惕 观察与阅读是扩充有限的自我经验的最好手段。 绝大多数人仅因为自己的态度而失去积累、成长的可能 类比思考几乎是跨越已知与未知之间的鸿沟的唯一手段。 一定要问清楚自己这个问题：我不喜欢做这件事情有没有可能仅仅是因为这件事儿我并没有做好？做好这件事情究竟对自己有没有意义？ 并不是对正在做的事情没有兴趣，而是没能力把目前正在做的事情做好，最终没有人喜欢自己做不好的事情。 往往并不是有兴趣才能做好，而是做好了才有兴趣。 成功，都只靠两件事：策略和坚持，而坚持本身就是最重要的策略方法固然重要，但是比起“用功”来说，方法几乎可以忽略不计。说 所谓的“好的方法”实际上是因人而异的。适合这个人的方法放到另外一个人身上很可能适得其反，适合所有人的方法可能根本不存在。与其不停地找更好的方法，还不如马上开始行动，省得虚度更多的时间。 自己所面临的痛苦并没有所感受到的那么强烈，第一种办法是当你面临尴尬的时候，记得一定要拿出纸笔来，把你所遇到的尴尬记录下来；另一个办法是，在面临尴尬的时候，尽量弱化你的痛苦。 尽管情绪有很多种，但最需要控制的大抵上只有一种：痛苦 很多的时候，比较是个坑，大坑。再干脆点，比较就是陷阱比成功更重要的是成长。 一定要想清楚并记住这件事儿：相信运气其实是缺乏自制力的表现。 浪费时间、虚度年华的人，有个共同的特征—他们拼命想控制自己完全不能控制的，却在自己真正能掌控的地方彻底失控。 弱者相信运气，强者只究因果 努力往往真的会改变一个人的运气 千万不要相信“机不可失，时不再来”。当你没有准备好的时候，对你来讲，不存在任何机会。 承认自己能力有限，是心理健康的前提 “量力而行”是如此高难度的行为模式—a.承认自己能力有限；b.不怕在别人面前露怯；c.敢于不去证明自己是“好人” 生活的智慧就在于，集中精力改变那些能够改变的，而把那些不能改变的暂时忽略掉。专心打造自己，把自己打造成一个优秀的人，一个有用的人，一个独立的人，比什么都重要。打造自己，就等于打造人脉，因为只有优秀的人才拥有有效的人脉。 专心做可以提升自己的事情，学习并拥有更多更好的技能，成为一个值得交往的人。 停止嘲弄他人，己所不欲，勿施于人” 素材积累固然非常重要，然而，如果提前确定一个方向或者目标，那么就甚至可以积累很多原本不可能想象的素材—惊喜连连。 永远鼓励身边的人，哪怕多少有些盲目。 当你不停地鼓励所有人的时候，最大的受益者其实是你自己，因为最终你会发现你开始进入一种他人无法想象的状态：你成了一个不需要他人鼓励的人。 记住，你不可能百分之百地有效率，至少不可能总是百分之百地有效率 在做时间预算的时候，一定要留有空间。a.你必须清楚肯定会有意外事件发生，b.你必须用适当的方法休息、放松 “累”这个事实，造成一种幻觉“我一直在努力”。 凡是值得做的事情，都值得慢慢做—做很久很久。 要想办法提前预知自己需要怎样的技能，然后确定那是一个自己可以通过练习真正熟练掌握的技能，而后制定长期计划，一点一点地执行该计划 不要盲目地试图减少睡眠时间。 尽量不要减少与家庭成员和亲属交流的时间。 最好不要放弃你的社交时间 “证明自己给别人看”恰恰是最浪费生命的一种行为。 任何积累都需要时间，并且必然需要漫长的时间。 “出来混的，早晚要还”]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程和链式编程]]></title>
    <url>%2F2017%2F11%2F12%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%92%8C%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;简单说下函数式编程和链式编程的理解 函数式编程概念&emsp;&emsp;函数式编程所强调的函数，上述两点可翻译为：1、不依赖外部状态；2、不改变外部状态 理想状态下的纯函数 变量作用域在函数内，如果需要外部变量需要当做函数的参数传入 不会产生副作用，不能改变被转入数据或其他数据 相同入参，返回值必然相同 函数作为一等公民，跟swift一样理解即可 高阶函数：可以把函数作为参数传递给另一个函数 优化技术：尾调用优化技术，即最后一个return返回一个函数，减少压栈次数，参考：尾调用优化 OC实现，代表RAC12345678910111213141516171819202122232425262728293031@interface Person : NSObject- (Person *)walk:(NSString * (^)(void))hotel;- (Person *)eat:(NSString * (^)(NSArray *))food;- (Person *)sayGood;@end@implementation Person- (Person *)walk:(NSString * (^)(void))hotel &#123;NSLog(@&quot;go to %@&quot;,hotel());return self;&#125;- (Person *)eat:(NSString * (^)(NSArray *))food &#123;NSString *someFood = food(@[@&quot;apple&quot;,@&quot;banner&quot;,@&quot;potato&quot;]);NSLog(@&quot;eat %@&quot;,someFood);return self;&#125;- (Person *)sayGood &#123;NSLog(@&quot;the food is vear good!&quot;);return self;&#125;@end// 使用Person *person = [[Person alloc] init];[[[person walk:^NSString * _Nonnull&#123;return @&quot;my home&quot;;&#125;] eat:^NSString * _Nonnull(NSArray * _Nonnull foods) &#123;return foods[1];&#125;] sayGood ]; 链式编程&emsp;&emsp;多个方法使用点语法链接起来，让代码更加简洁，可读性更强 OC实现，代表Masonry12345678910111213141516171819202122232425262728293031323334353637383940414243@class Person;typedef Person *_Nonnull(^actionBlock)(NSString *);@interface Person : NSObject@property (nonatomic, strong) NSMutableString *log;@property (nonatomic, copy) actionBlock walk;@property (nonatomic, copy) actionBlock eat;@property (nonatomic, copy) actionBlock sayGood;@end@implementation Person- (instancetype)init &#123;self = [super init];if (self) &#123;_log = [[NSMutableString alloc] init];&#125;return self;&#125;- (actionBlock)walk &#123;__block NSMutableString *log = _log;return ^(NSString *str)&#123;[log appendString:[NSString stringWithFormat:@&quot;go to %@&quot;,str]];return self;&#125;;&#125;- (actionBlock)eat &#123;__block NSMutableString *log = _log;return ^(NSString *str)&#123;[log appendString:[NSString stringWithFormat:@&quot; eat %@&quot;,str]];return self;&#125;;&#125;- (actionBlock)sayGood &#123;__block NSMutableString *log = _log;return ^(NSString *str)&#123;[log appendString:[NSString stringWithFormat:@&quot; the %@ is vear good!&quot;,str]];return self;&#125;;&#125;@endPerson *p = [[Person alloc] init];p.walk(@&quot;my home&quot;).eat(@&quot;apple&quot;).sayGood(@&quot;apple&quot;);NSLog(@&quot;%@&quot;,p.log); 参考 https://www.cnblogs.com/zy1987/p/3788670.html http://mrpeak.cn/blog/functional/ https://blog.csdn.net/sinat_27706697/article/details/48946485 更新参考 https://mp.weixin.qq.com/s/0gErQ3tjDLZuD1bYOhi0mQ https://www.liaoxuefeng.com/article/1260118907809920]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xib与代码颜色偏差问题]]></title>
    <url>%2F2017%2F10%2F20%2Fxib%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%A2%9C%E8%89%B2%E5%81%8F%E5%B7%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天视觉走查时发现一个问题，视觉给的stech文件给出了颜色值，正常流程是拿到颜色值直接扔过去就不管了！但今天踩雷了，UI的火眼金睛竟然发下颜色不一样，代码里数值明明都是一样的，但仔细观察的话，确实有一点点的区别。这是为什么？ &emsp;&emsp;经过仔细排查，没发现任何程序上的问题，且发现纯代码设置的颜色是正确的，只有xib/SB设置的颜色不正确，那是不是xib自己的坑？ &emsp;&emsp;新建一个xib，随便选个颜色，保存，右键查看xml，得到源码如下：12345&lt;view contentMode=&quot;scaleToFill&quot; id=&quot;iN0-l3-epB&quot;&gt;&lt;rect key=&quot;frame&quot; x=&quot;0.0&quot; y=&quot;0.0&quot; width=&quot;414&quot; height=&quot;896&quot;/&gt;&lt;autoresizingMask key=&quot;autoresizingMask&quot; widthSizable=&quot;YES&quot; heightSizable=&quot;YES&quot;/&gt;&lt;color key=&quot;backgroundColor&quot; red=&quot;0.0&quot; green=&quot;0.97680455450000003&quot; blue=&quot;0.0&quot; alpha=&quot;1&quot; colorSpace=&quot;custom&quot; customColorSpace=&quot;sRGB&quot;/&gt;&lt;/view&gt; &emsp;&emsp;代码设置颜色的方法如下：123UIColor *colorFromRGB(float r, float g, float b, float alpha) &#123;return [UIColor colorWithRed:r/255.f green:g/255.f blue:b/255.f alpha:alpha];&#125; &emsp;&emsp;对比发现xib多了一个colorSpace，即颜色空间！很有可能是这个问题，再次查阅官方文档，发现如下解释123+ (UIColor *)colorWithRed:(CGFloat)red green:(CGFloat)green blue:(CGFloat)blue alpha:(CGFloat)alpha;The color object. The color information represented by this object is in an RGB colorspace. On applications linked for iOS 10 or later, the color is specified in an extended range sRGB color space. On earlier versions of iOS, the color is specified in a device RGB colorspace. &emsp;&emsp;简单翻译就是iOS10之后使用sRGB颜色空间，iOS10之前跟随系统颜色空间设置 &emsp;&emsp;那iOS10之前的颜色空间是什么？查阅到.Xcode Interface Builder 指定顏色與實際有出入 Xib/Storyboard默认用的是sRGB。 Sketch用的是sRGB。 PhotoShop默认用的是Generic RGB。 代码中的UIColor赋值，用的是Generic RGB。 &emsp;&emsp;很明显了！修改方式也比较简单了，把颜色空间改成sRGB即可 &emsp;&emsp;本来到这为止！我已经水完了！已经完成了水一篇的任务！ &emsp;&emsp;但是我们的 .clr文件里有一百多个颜色值，我怎么改才行？ 最理想：写算法批量转化！但我不懂颜色空间的知识，而且这个是一次性操作，专门去学习成本太高！失败 退而次之：直接在xib里修改颜色值的colorspace！不行，因为xib里直接修改颜色值，xcode为了保证颜色一致，修改了Red，Green和Blue的值，而我们的需求是Red，Green和Blue的值是正确的 再次之：手动输入Red，Green和Blue的值，再选择colorspace！可以做，但工作量比较大，而且步骤较多，以后新增颜色出问题的可能性比较大！.clr文件是共享的，维护成本较高 &emsp;&emsp;经过数次试验发现：在xib里使用吸管来取颜色值，能够正确的取到了Red，Green和Blue的值，并正确设置colorspace！ &emsp;&emsp;==结论：使用吸管来吸颜色最靠谱，团队维护成本也较低==]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[otool命令]]></title>
    <url>%2F2017%2F10%2F09%2Fotool%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1 简介&emsp;&emsp;Otool可以提取并显示ios下目标文件的相关信息，包括头部、加载命令、各个段、共享库、动态库等。Otool拥有大量的命令选项，是一个功能强大的分析工具，也可以反汇编！常用于逆向工程，这里不写逆向工程，就写点otool命令 &emsp;&emsp;第一个命令永远是help，但刚开头就卡壳了！无论otool -h，还是otool -help，都会提示错误。1error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool: at least one file must be specified &emsp;&emsp;我想破脑袋也没想明白怎么会这样？典型的反人类设计！不过还是可以看到相关的命令解释的！更新：otool+回车，才是正确的help命令123456789101112131415161718192021222324252627282930313233Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [--version] &lt;object file&gt; ...-f print the fat headers-a print the archive header-h print the mach header-l print the load commands-L print shared libraries used-D print shared library id name-t print the text section (disassemble with -v)-p &lt;routine name&gt; start dissassemble from routine name-s &lt;segname&gt; &lt;sectname&gt; print contents of section-d print the data section-o print the Objective-C segment-r print the relocation entries-S print the table of contents of a library (obsolete)-T print the table of contents of a dynamic shared library (obsolete)-M print the module table of a dynamic shared library (obsolete)-R print the reference table of a dynamic shared library (obsolete)-I print the indirect symbol table-H print the two-level hints table (obsolete)-G print the data in code table-v print verbosely (symbolically) when possible-V print disassembled operands symbolically-c print argument strings of a core file-X print no leading addresses or headers-m don&apos;t use archive(member) syntax-B force Thumb disassembly (ARM objects only)-q use llvm&apos;s disassembler (the default)-Q use otool(1)&apos;s disassembler-mcpu=arg use `arg&apos; as the cpu for disassembly-j print opcode bytes-P print the info plist section as strings-C print linker optimization hints--version print the version of /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool &emsp;&emsp;由上可知 otool地址：/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/otool 前往bin目录得知otool其实是llvm-otool。bin目录下还有很多工具，我似乎看到了好多水文在向我招手，嘿嘿… 使用方式： otool [-arch arch_type] [-fahlLDtdorSTMRIHGvVcXmqQjCP] [-mcpu=arg] [–version] … 2 常用命令 查看Mach-O头结构 12otool -v -h a.outotool -h xxx.app/xxx 查看load commands 12otool -v -l a.outotool -l xxx.app/xxx 查看Objective-C segment 1otool -o xxx.app/xxx 查看Section中的内容 1234// 查看__TEXT segname的 __text段otool -s __TEXT __text a.out // 由于 -s __TEXT __text 很常见，otool 对其设置了一个缩写 -totool -t a.out 添加 -v 来查看反汇编代码 12// 查看反汇编之后的__TEXT segname的 __text段otool -v -t xxx.app/xxx 获取所有方法名称 1otool -v -s __TEXT __objc_methname xxx.app/xxx 查看依赖的动态库 1otool -L xxx.app/xxx 查看支持的框架 1otool -D xxx.app/xxx 查看该应用是否加壳 12otool -l xxx.app/xxx | grep -B 2 crypt// cryptid 0（砸壳） 1（未砸壳） 3 常见的Section&emsp;&emsp;更多Section介绍 Section 解释 TEXT.text 主程序代码 TEXT.cstring C 语言字符串 TEXT.const const 关键字修饰的常量 TEXT.stubs 用于 Stub 的占位代码，很多地方称之为桩代码。 TEXT.stubs_helper 当 Stub 无法找到真正的符号地址后的最终指向 TEXT.objc_methname Objective-C 方法名称 TEXT.objc_methtype Objective-C 方法类型 TEXT.objc_classname Objective-C 类名称 DATA.data 初始化过的可变数据 DATA.la_symbol_ptr lazy binding 的指针表，表中的指针一开始都指向 __stub_helper __DATA.nl_symbol_ptr 非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号 DATA.const 没有初始化过的常量 DATA.cfstring 程序中使用的 Core Foundation 字符串（CFStringRefs） DATA.bss BSS，存放为初始化的全局变量，即常说的静态内存分配 DATA.common 没有初始化过的符号声明 DATA.objc_classlist Objective-C 类列表 DATA.objc_protolist Objective-C 原型 DATA.objc_imginfo Objective-C 镜像信息 DATA.objc_selfrefs Objective-C self 引用 DATA.objc_protorefs Objective-C 原型引用 DATA.objc_superrefs Objective-C 超类引用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dyld笔记]]></title>
    <url>%2F2017%2F09%2F23%2Fdyld%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前一段时间整理了下iOS的编译过程，对整体流程有了个大概印象！但在点击 Run 之后发生了什么？里提到了APP启动中dyld的作用，对此了解不是很多，只是知道dyld是用来加载的，正好看到大神的相关文章，这次就水一水dyld笔记吧 &emsp;&emsp;先下载dyld源码 1 __dyld_start&emsp;&emsp;load方法打个断点，调用栈第一个就是我们要观察的__dyld_start的方法。汇编看不懂(虽然LLVM -dis可以反汇编，但IR文件更不好理解，而且没必要)，但有注释呀1234567...# call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)...# clean up stack and jump to &quot;start&quot; in main executable...# LC_MAIN case, set up stack for call to main()... &emsp;&emsp;扩展：执行__dyld_start之前执行了什么？参考:_dyld_start之前12345678910▼ execve // 用户点击了app, 用户态会发送一个系统调用 execve 到内核▼ __mac_execve // 创建线程▼ exec_activate_image // 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法▼ exec_mach_imgact▼ load_machfile▶︎ parse_machfile //解析主二进制macho▼ load_dylinker // 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld▼ parse_machfile // 解析 dyld 这个mach-o文件，这个过程中会解析出entry_point▼ activate_exec_state▶︎ thread_setentrypoint // 设置entry_point。 2 dyldbootstrap::start 方法1234567891011//// This is code to bootstrap dyld. This work in normally done for a program by dyld and crt. // 就是启动dyld的// In dyld we have to do this manually.//uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader,uintptr_t* startGlue) &#123;// 中间主要是重绑定判断、参数转化等// 最后调用return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);&#125; 3 dyld::_main&emsp;&emsp;有将近500行代码,说实话没太看懂，还是直接贴大神的总结吧！另外写一点我感兴趣的函数123456789101. 设置运行环境，环境变量2. 加载共享缓存3. 实例化Image4. 动态库的版本化重载5. 加载插入的动态库6. link主程序7. link插入的动态库8. weakBind9. initialize10.main 3.1 加载dyld image 和 main image，&emsp;&emsp;不看代码我一直以为dyldbootstrap::start阶段就已经加载dyld image123456// Trace dyld&apos;s loadnotifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, &quot;dyld_file&quot;));#if !TARGET_IPHONE_SIMULATOR// Trace the main executable&apos;s loadnotifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &quot;executable_file&quot;));#endif 3.2 奇怪的注释&emsp;&emsp; 突然间出现 // could not use closure info, launch old way 注释，也没找到return或else处理，这个注释是啥意思？怎么launch old way？1234567// load shared cachecheckSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);// 接下来校验closure是否需要支持，以及一些措施// 问题在这，// could not use closure info, launch old way 3.3 instantiateFromLoadedImage&emsp;&emsp; isCompatibleMachO 是检查mach-o的subtype是否是当前cpu可以支持； instantiateMainExecutable 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； addImage 添加到 allImages中。1234567891011static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)&#123;// try mach-o loaderif ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);addImage(image);return image;&#125;throw &quot;main executable not a known format&quot;;&#125; 3.4 load libraries&emsp;&emsp; inserted 环境 libraries, then main, then others.1234567891011121314151617181920212223242526272829303132333435363738394041// load any inserted librariesif ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib);&#125;// record count of inserted libraries so that a flat search will look at // inserted libraries, then main, then others.sInsertedDylibCount = sAllImages.size()-1;// link main executablegLinkContext.linkingMainExecutable = true;#if SUPPORT_ACCELERATE_TABLESif ( mainExcutableAlreadyRebased ) &#123;// previous link() on main executable has already adjusted its internal pointers for ASLR// work around that by rebasing by inverse amountsMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);&#125;#endiflink(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);sMainExecutable-&gt;setNeverUnloadRecursive();if ( sMainExecutable-&gt;forceFlat() ) &#123;gLinkContext.bindFlat = true;gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;&#125;// link any inserted libraries// do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program usesif ( sInsertedDylibCount &gt; 0 ) &#123;for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;ImageLoader* image = sAllImages[i+1];link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);image-&gt;setNeverUnloadRecursive();&#125;// only INSERTED libraries can interpose// register interposing info after all inserted libraries are bound so chaining worksfor(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;ImageLoader* image = sAllImages[i+1];image-&gt;registerInterposing(gLinkContext);&#125;&#125; 3.5 weakBind&emsp;&emsp; 强符号：函数和已经初始化的全局变量;弱符号：未初始化的全局变量！弱符号对于库来说十分有用，我们在开发库时，可以将某些符号定义为弱符号，这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，增加了很大的灵活性。1sMainExecutable-&gt;weakBind(gLinkContext); 总结：dyld 作用顺序的概括 从 kernel 留下的原始调用栈引导和启动自己 将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制 non-lazy 符号立即 link 到可执行文件，lazy 的存表里 Runs static initializers for the executable 找到可执行文件的 main 函数，准备参数并调用 程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口 程序main函数 return 后执行 static terminator 某些场景下 main 函数结束后调 libSystem 的 _exit 函数 其它： objc的启动&emsp;&emsp; _objc_init源码12345678910111213141516void _objc_init(void)&#123;static bool initialized = false;if (initialized) return;initialized = true;// 各种初始化environ_init();tls_init();static_init();lock_init();// 看了一下exception_init是空实现！！就是说objc的异常是完全采用c++那一套的。exception_init();// 注册dyld事件的监听_dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);&#125; dyld 开始将程序二进制文件初始化 交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号 再由libsystem 中的一个initialize方法 libsystem_initializer中初始化了 libdispatch 然后libdispatch调用了_os_object_int, 最终调用了 _objc_init，并绑定runtime回调 由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理 runtime 接手后调用 map_images 做解析和处理，接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法 参考 iOS 程序 main 函数之前发生了什么 dyld与ObjC Dyld系列之一：_dyld_start之前 Dyld之二: 动态链接过程 dyld 加载 Mach-O iOS中的dyld缓存是什么？]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS编译过程]]></title>
    <url>%2F2017%2F09%2F16%2FiOS%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1 编译简介1.1 编译&emsp;&emsp;把高级语言翻译成机器语言或汇编语言，叫编译！ &emsp;&emsp;语言翻译的两种基本形态: 编译器与解释器 编译器采用先翻译后执行. 例如C语言 .c -&gt; .o -&gt; 再运行！特点：工作效率高,可移植性差，时间换空间 解释器采用边翻译边执行. 例如shell 边写边执行！特点：工作效率低,可移植性好，空间换时间 &emsp;&emsp;一般编译器有以下工作步骤： 词法分析（lexical analysis）：此阶段的任务是从左到右一个字符一个字符地读入源程序，使用词法分析器（扫描器）对构成源程序的字符流进行扫描然后根据语言的词法规则识别单词（Token），至少分以下几类：关键字(保留字)、标识符、字面量、特殊符号 1.1 识别记号并交给语法分析器(根据模式识别记号) 1.2 滤掉源程序中的无用成分,如注释、空格和回车等 1.3 处理与具体平台有关的输入(如文件结束符的不同表示等) 语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser） 语义分析（Syntax analysis）：根据语义规则对语法树中的语法单元进行静态语义检查,如类型检查和转换等,目的是保证语法和语义都正确，因为一个语法上正确的句子，它所代表的意义并不一定正确. 中间码生成（可选）：生成一种既接近目标语言,又与具体机器无关的表示,便于代码优化与代码生成.好处是前后分离，便于扩展 中间代码优化(可选)：优化后功能相同，但在占用的空间上和程序执行的时间上都更省、更有效 目标代码生成：一般分为三种形式目标代码，A 汇编；B 可重定位二进制；C 内存形式 目标代码 &emsp;&emsp;编译过程 1 至 6 阶段，都会管理符号表，便于各个阶段的查找\填写等工作；另外各个阶段都会有出错处理 &emsp;&emsp;编译器和解释器的区别往往是在第4步(中间代码)之后开始的.编译型语言的可执行程序产生的是直接执行机器指令，而解释型语言的每一句源代码都要经过解释器解释为可以执行的机器指令 &emsp;&emsp;最后，编译器完成编译后，由链接器（Linker）将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。 1.2 链接&emsp;&emsp;静态链接：在编译链接期间发挥作用，把目标文件和静态库一起链接形成可执行文件 &emsp;&emsp;链接器需要对源代码进行的处理： 对各个目标文件中没有定义的变量，在其他目标文件中寻找到相关的定义。 把不同目标文件中生成的同类型的段进行合并。 对不同目标文件中的变量进行地址重定位。 1.3 装载&emsp;&emsp;动态链接库需要编译器做的最基本的事情： 链接库在将目标文件链接成可执行文件的时候如果发现某一个变量或者函数在目标文件中找不到，会按预定义的动态库寻找路径寻找动态库中定义的变量或者函数。 如果链接库在某一个动态链接库中找到了该变量或者函数定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理 symbol. 在_GLOBAL_OFFSET_TABLE_代码中生成真正的动态跳转指令，并且在库函数（比如strncpy,printf）代理symbol中跳转到_GLOBAL_OFFSET_TABLE_中相应的偏移位置。 2 iOS编译&emsp;&emsp;iOS的编译工具是LLVM, Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，可用如下命令查看编译源文件有几个阶段1Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器 2.1 预编译&emsp;&emsp;主要用来处理那些源文件中以#开头的预编译命令，比如宏、#include等1clang -E main.m 2.2 词法分析1clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m 2.3 语法分析1clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 2.4 语义分析2.5 生成中间代码 LLVM IR1clang -S -fobjc-arc -emit-llvm main.m -o main.ll 2.6 中间代码优化(可选)12// 在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0sclang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll 2.7 目标代码生成 汇编代码1clang -S -fobjc-arc main.m -o main.s 2.8 目标代码1clang -fmodules -c main.m -o main.o 2.9 汇编器&emsp;&emsp;汇编器把汇编代码转换为机器代码，但大神说iOS没用汇编器 2.9 链接&emsp;&emsp;连接器把编译产生的.o文件合并成一个mach-o文件。1通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果 2.10 签名&emsp;&emsp;程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名 总结完整步骤： 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 例如Foundation.framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 &emsp;&emsp;最后安利一本书程序员的自我修养：链接、装载与库 参考： objc中国：编译器 iOS编译过程的原理和应用 编译原理之词法分析简介 高级语言的编译：链接及装载过程介绍 点击 Run 之后发生了什么？ 深入剖析 iOS 编译 Clang LLVM 更新一篇比较好的文章 深入浅出iOS编译]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clang笔记]]></title>
    <url>%2F2017%2F08%2F31%2FClang%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前一段时间学了下LLVM的知识，LLVM非常强大，确实很好玩！但学起来确实挺多挺枯燥的，也没发现有什么用处（其实就是啃不动英文文档了），过了刚开始的冲劲也就停滞不前了，平时开发还是Clang用的稍微多一点，今天就水水clang吧 1 简介&emsp;&emsp;Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。官方入门,详细内容参考：官网 &emsp;&emsp;Clang是基于库的，在Clang的官方文档“Clang” CFE Internals Manual中，对Clang内部的介绍也是依据库来进行分类的。 1.1 AST&emsp;&emsp;一般编译器有以下工作步骤： 词法分析（Lexical analysis）：此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符流进行扫描然后根据构词规则识别 单词（Token），完成这个任务的组件是 词法分析器（Lexical analyzer，简称Lexer），也叫 扫描器（Scanner）； 语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser）； 目标码生成： 此阶段编译器会遍历上一步生成的抽象语法树，然后为每个节点生成 机器 / 字节码。 编译器完成编译后，由链接器（Linker）将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。 &emsp;&emsp;关于Clang AST，有一个官方文档 。基于AST可以进行程序转换，现在Clang下面已经有一些额外的工具：比如clang-modernize实现的就是对C+ +程序中可以使用C ++ 11的地方进行转换，转换成在这些地方使用C++11特性的程序，等于直接在程序上进行的修改，是一个source-to-source的转换工具。 1.2 libclang&emsp;&emsp;现在的Clang，不仅仅是一个编译器前端，同时也可以作为一个库使用。作为一个库使用的时候，可以用它去分析C/C++/ObjectC语言代码，可以分析源码得到AST，也可以获取已经分析好的AST，也可以遍历AST，还可以获取AST中基本元素的物理源码位置。这就是libclang。 &emsp;&emsp;其它库介绍： LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。 The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。 The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。 Precompiled Headers - Clang 支持预编译 headers 的两个实现。 The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。 The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。 The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。 The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。 1.3 Clang driver&emsp;&emsp;Clang driver是一个驱动，一个包含编译全部阶段的驱动，不同于前端Clang，也不同于编译器Clang。命令行使用的“clang”其实并不是前端Clang，而是指的是Clang driver；在命令行使用的“Clang cc1”也指的不是前端Clang，而指的是Clang编译器，这其中不仅包含了前端Clang，还包含了LLVM Core部分等。Clang driver不仅仅调用了前端Clang，同时还调用了LLVM Core Clang命令（大小写敏感）命令解释&emsp;&emsp;最重要的命令是什么？我个人认为，无论什么脚本语言，最重要的命令永远是帮助：clang –help。Clang命令高达700+，这里仅介绍常用的123456789101112131415161718192021222324252627282930USAGE: clang [options] &lt;inputs&gt;OPTIONS:-### Print (but do not run) the commands to run for this compilation 查看操作内部命令，一般用于分析流程--analyze Run the static analyzer 运行静态代码检查器-B &lt;dir&gt; Add &lt;dir&gt; to search path for binaries and object files used implicitly 将&lt;dir&gt;添加到搜索路径-CC Include comments from within macros in preprocessed output 在预处理的输出中包含宏在内的注释，非常重要--config &lt;value&gt; Specifies configuration file 配置文件-C Include comments in preprocessed output 在预处理的输出中包含注释，非常重要-c Only run preprocess, compile, and assemble steps 仅运行预处理、编译和组装步骤-emit-ast Emit Clang AST files for source inputs-E Only run the preprocessor 只运行预处理-fblocks Enable the &apos;blocks&apos; language feature-fcolor-diagnostics Use colors in diagnostics 诊断中可以使用颜色-fcxx-exceptions Enable C++ exceptions 启用C++类型异常-fexceptions Enable support for exception handling 启用异常-fmodules Enable the &apos;modules&apos; language feature 启用“模块”语言功能-fplugin=&lt;dsopath&gt; Load the named plugin (dynamic shared object) 启用插件-ObjC++ Treat source input files as Objective-C++ inputs 把源文件当做OC++-ObjC Treat source input files as Objective-C inputs 把源文件当做OC-g Generate source-level debug information 生成完整的调试信息。-o &lt;file&gt; Write output to &lt;file&gt; 输出文件-print-file-name=&lt;file&gt; Print the full library path of &lt;file&gt; 输出文件所在路径-print-ivar-layout Enable Objective-C Ivar layout bitmap print trace 启用OC的ivar布局-pthread Support POSIX threads in generated code 在生成的代码中支持POSIX线程-rewrite-objc Rewrite Objective-C source to C++ 将OC重写成C++-S Only run preprocess and compilation steps 仅运行预处理和编译步骤--target=&lt;value&gt; Generate code for the given target 为给定目标生成代码-w Suppress all warnings 禁用警告-Xclang &lt;arg&gt; Pass &lt;arg&gt; to the clang compiler 向clang编译器传递参数 常用组合命令 查看编译的几个阶段 1clang -ccc-print-phases main.m 查看预编译过程 1clang -E main.m 查看操作内部命令 1clang -### main.m -o main 重写成C++，报错 1clang -rewrite-objc main.m 编译成可执行文件 123456789101112131415clang -fobjc-arc -framework Foundation HelloWord.m -o HelloWord/*-x 编译语言比如objective-c-arch 编译的架构，比如arm7-f 以-f开头的。-W 以-W开头的，可以通过这些定制编译警告-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本-I 把编译信息写入指定的辅助文件-F 需要的Framework-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件-o 编译结果*/clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o 参考 官网 更多clang工具 深入研究Clang]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM入门]]></title>
    <url>%2F2017%2F08%2F20%2FLLVM%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1 简介&emsp;&emsp;LLVM是一个好用、好玩，而且超前的系统语言（比如C和C++语言）编译器。LLVM的官网 和 中文版，此外初学入门可参考LLVM零基础学习的学习思路 &emsp;&emsp;LLVM强大的原因：1. LLVM的“中间表示”（IR）是一项大创新。2. 模块化 &emsp;&emsp;Everything is a lib. Everything is a value. &emsp;&emsp;LLVM的组成部分： 前端，获取你的源代码然后将它转变为某种中间表示。Clang其实就是前端 流程（Pass），将程序在中间表示之间互相变换。一般情况下，流程也用来优化代码：流程输出的（中间表示）程序和它输入的（中间表示）程序相比在功能上完全相同，只是在性能上得到改进。 后端，可以生成实际运行的机器码。 &emsp;&emsp;LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 The Architecture of Open Source Applications 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于：LLVM 架构 1.1 重要文档 自动生成的Doxygen文档页非常重要。 LLVM的文档的分类简介，其中语言参考手册也非常有用 开发者手册描述了一些LLVM特有的数据结构的工具，编写LLVM流程 不过在在线浏览LLVM代码时，这个GitHub镜像有时会更方便。 推荐的入门书：《Getting Started with LLVM Core Libraries》 1.2 LLVM的IR&emsp;&emsp;LLVM IR的介绍，LLVM的IR是中间文件，是通用的，便于前后端扩展。LLVM的IR主要有三种格式：一种是在内存中的编译中间语言；一种是硬盘上存储的二进制中间语言（以.bc结尾），最后一种是可读的中间格式（以.ll结尾）。这三种中间格式是完全相等的。1234567hello.c文件//得到二进制的.bc文件clang -emit-llvm -c hello.c -o hello.bc // 得到对应的hello.ll文件llvm-dis hello.bc &emsp;&emsp;TODO: LLVM IR的语法简介 1.3 LLVM 的Pass&emsp;&emsp;在LLVM中优化以pass形式实现,每一个pass代表一种优化,可以把每个Pass看成一个小模块，可单独使用也可组合使用。所有的Pass都是继承自Pass类的, 基本上分为两类, 一类是分析analysis pass (存放在lib/Analysis下), 负责收集信息共其它pass使用, 辅助调试或使程序可视化; 另一类是变换transform pass (存放在lib/Transforms下), 改变程序的dataflow / controlflow. LLVM中实现了几十种优化pass, 其中许多pass运行不止一次 &emsp;&emsp;在文档 http://llvm.org/docs/Passes.html 中，列出了所有的PASS的命令行参数以及这个PASS主要是做什么用的，思维导图版 1.4 LLVM的源码结构&emsp;&emsp;参考：https://blog.csdn.net/snsn1984/article/details/8170575 llvm/examples 这个目录主要是一些简单例子，演示如何使用LLVM IR 和 JIT。还有建立一个简单的编译器的例子的代码。 llvm/include 这个目录主要包含LLVM library的公共头文件。 llvm/lib 这个目录包含了大部分的LLVM的源码。在LLVM中大部分的源码都是以库的形式存在的，这样不同的工具之前就很容易共用代码。 llvm/projects 这个目录包含着一些依赖LLVM的工程，这些工程严格来说又不算LLVM一部分。 llvm/runtimes 这个目录包含了一些库，这些库会编译成LLVM的bitcode，然后当clang linking 程序的时候使用。 llvm/test 这个目录是LLVM的测试套件，包含了很多测试用例，这些测试用例是测试LLVM的所有基本功能的。 llvm/tools 这个目录理是各个工具的源码，这些工具都是建立在刚才上面的那些库的基础之上的。也是主要的用户接口 llvm/utils 这个目录包含了一些和LLVM源码一起工作的应用。有些应用在LLVM的编译过程中是不可或缺的。 3 常用命令3.1 基本命令 llvm-as 解释 LLVM assembler 汇编器 llvm-dis 解释 LLVM disassembler 反汇编器 opt 解释 LLVM optimizer 优化器 llc 解释 LLVM static compiler 静态编译器 lli 解释 directly execute programs from LLVM bitcode 直接执行LLVM 字节码 llvm-link 解释 LLVM bitcode linker 字节码连接器 llvm-ar 解释 LLVM archiver 归档器 llvm-nm -list LLVM bitcode and object file’s symbol table 列出LLVM字节码和目标文件中的符号表 llvm-config 解释 Print LLVM compilation options 打印LLVM编译选项 llvm-diff 解释 LLVM structual ‘diff’ LLVM结构上的diff llvm-cov 解释 emit coverage information 省略覆盖信息 llvm-stress 解释 generate random .ll files 生成随机的.ll文件 llvm-symbolizer 解释 convert addresses into source code locations 把地址值转换成源代码位置 3.2 调试工具 bugpoint 解释 automatic test case reduction tool 自动测试用例下降工具 llvm-extract 解释 extract a function from an LLVM module 从LLVM模块中抽取一个函数 llvm-bcanalyzer 解释 LLVM bitcode analyzer LLVM字节码分析器 3.3 开发者工具 FileCheck 解释 Flexible pattern matching file verifier 弹性模式匹配的文件验证器 tblgen 解释 Target Description To C++ Code Generator 目标描述到C++代码生成器 lit 解释 LLVM Integrated Tester LLVM集成的测试器 llvm-build 解释 LLVM Project Build Utility LLVM项目生成工具 llvm-readobj 解释 LLVM Object Reader LLVM目标文件阅读器 参考 官网 和 中文版 objc中国：编译器 LLVM零基础学习 LLVM每日谈 LLVM Weekly 为什么人人都该懂点LLVM GETTING STARTED WITH LLVM/CLANG ON OS X]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP运行理论]]></title>
    <url>%2F2017%2F08%2F11%2FAPP%E8%BF%90%E8%A1%8C%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[转载自：https://zhidao.baidu.com/question/1370352051634002499.html main() 执行前发生的事Mach-O 格式虚拟内存基础Mach-O 二进制的加载理论速成Mach-O 术语Mach-O 是针对不同运行时可执行文件的文件类型。文件类型：Executable： 应用的主要二进制Dylib： 动态链接库（又称 DSO 或 DLL）Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。Image： executable，dylib 或 bundleFramework： 包含 Dylib 以及资源文件和头文件的文件夹Mach-O 镜像文件Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。几乎所有 Mach-O 都包含这三个段（segment）： TEXT , DATA 和 LINKEDIT ： TEXT 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。DATA 包含全局变量，静态变量等。可读写（rw-）。 LINKEDIT 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。Mach-O Universal 文件FAT 二进制 文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。虚拟内存虚拟内存就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。对于文件可以不用一次性读入整个文件，可以使用分页映射（ mmap() ）的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。也就是说 Mach-O 文件中的 TEXT 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。 DATA 段是可读写的。这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。Mach-O 镜像 加载所以在多个进程加载 Mach-O 镜像时 TEXT 和 LINKEDIT 因为只读，都是可以共享内存的。而 DATA 因为可读写，就会产生 dirty page。当 dyld 执行结束后， LINKEDIT 就没用了，对应的内存页会被回收。安全ASLR（Address Space Layout Randomization）：地址空间布局随机化，镜像会在随机的地址上加载。这其实是一二十年前的旧技术了。代码签名：可能我们认为 Xcode 会把整个文件都做加密 hash 并用做数字签名。其实为了在运行时验证 Mach-O 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 LINKEDIT 中。这使得文件每页的内容都能及时被校验确并保不被篡改。从 exec() 到 main()exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围 至少 是 4KB；对于 64 位进程则 至少 是 4GB。NULL 指针引用和指针截断误差都是会被它捕获。dyld 加载 dylib 文件Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 dyld ，其他 Unix 系统也有ld.so 。 当内核完成映射进程的工作后会将名字为 dyld 的Mach-O 文件映射到进程中的随机地址，它将 PC 寄存器设为 dyld 的地址并运行。 dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。下面的步骤构成了 dyld 的时间线：Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers加载 Dylib从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap() 。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。Fix-ups在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 DATA 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。所以 dyld 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。Rebasing 和 BindingRebasing：在镜像内部调整指针的指向Binding：将指针指向镜像外部的内容可以通过命令行查看 rebase 和 bind 等信息：xcrun dyldinfo -rebase -bind -lazy_bind myapp.app/myapp 通过这个命令可以查看所有的 Fix-up。rebase，bind，weak_bind，lazy_bind 都存储在 LINKEDIT 段中，并可通过 LC_DYLD_INFO_ONLY 查看各种信息的偏移量和大小。建议用 MachOView 查看更加方便直观。从 dyld 源码层面简要介绍下 Rebasing 和 Binding 的流程。ImageLoader 是一个用于加载可执行文件的基类，它负责链接镜像，但不关心具体文件格式，因为这些都交给子类去实现。每个可执行文件都会对应一个 ImageLoader实例。 ImageLoaderMachO 是用于加载 Mach-O 格式文件的 ImageLoader 子类，而ImageLoaderMachOClassic 和 ImageLoaderMachOCompressed 都继承于 ImageLoaderMachO ，分别用于加载那些 LINKEDIT 段为传统格式和压缩格式的 Mach-O 文件。因为 dylib 之间有依赖关系，所以 ImageLoader 中的好多操作都是沿着依赖链递归操作的，Rebasing 和 Binding 也不例外，分别对应着 recursiveBind() 和 recursiveBind() 这两个方法。因为是递归，所以会自底向上地分别调用 doRebase() 和 doBind() 方法，这样被依赖的 dylib 总是先于依赖它的 dylib 执行 Rebasing 和 Binding。传入 doRebase() 和 doBind() 的参数包含一个 LinkContext 上下文，存储了可执行文件的一堆状态和相关的函数。在 Rebasing 和 Binding 前会判断是否已经 Prebinding。如果已经进行过预绑定（Prebinding），那就不需要 Rebasing 和 Binding 这些 Fix-up 流程了，因为已经在预先绑定的地址加载好了。ImageLoaderMachO 实例 不使用预绑 定会有四个原因：Mach-O Header 中 MH_PREBOUND 标志位为 0镜像加载地址有偏移（这个后面会讲到）依赖的库有变化镜像使用 flat-namespace，预绑定的一部分会被忽略LinkContext 的环境变量禁止了预绑定ImageLoaderMachO 中 doRebase() 做的事情大致如下：如果使用预绑定， fgImagesWithUsedPrebinding 计数加一，并 return ;否则进入第二步如果 MH_PREBOUND 标志位为 1 （也就是可以预绑定但没使用），且镜像在共享内存中，重置上下文中所有的 lazy pointer。（如果镜像在共享内存中，稍后会在 Binding 过程中绑定，所以无需重置）如果镜像加载地址偏移量为0，则无需 Rebasing，直接 return ；否则进入第四步调用 rebase() 方法，这才是真正做 Rebasing 工作的方法。如果开启 TEXT_RELOC_SUPPORT 宏，会允许 rebase() 方法对 TEXT 段做写操作来对其进行 Fix-up。所以其实 TEXT 只读属性并不是绝对的。ImageLoaderMachOClassic 和 ImageLoaderMachOCompressed 分别实现了自己的doRebase() 方法。实现逻辑大同小异，同样会判断是否使用预绑定，并在真正的 Binding 工作时判断 TEXT_RELOC_SUPPORT 宏来决定是否对 TEXT 段做写操作。最后都会调用 setupLazyPointerHandler 在镜像中设置 dyld 的 entry point，放在最后调用是为了让主可执行文件设置好 dyld 或 program_vars 。Rebasing在过去，会把 dylib 加载到指定地址，所有指针和数据对于代码来说都是对的， dyld 就无需做任何 fix-up 了。如今用了 ASLR 后悔将 dylib 加载到新的随机地址(actual_address)，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有偏差，dyld 需要修正这个偏差(slide)，做法就是将 dylib 内部的指针地址都加上这个偏移量，偏移量的计算方法如下：Slide = actual_address - preferred_address然后就是重复不断地对 DATA 段中需要 rebase 的指针加上这个偏移量。这就又涉及到 page fault 和 COW。这可能会产生 I/O 瓶颈，但因为 rebase 的顺序是按地址排列的，所以从内核的角度来看这是个有次序的任务，它会预先读入数据，减少 I/O 消耗。BindingBinding 是处理那些指向 dylib 外部的指针，它们实际上被符号（symbol）名称绑定，也就是个字符串。之前提到 LINKEDIT 段中也存储了需要 bind 的指针，以及指针需要指向的符号。 dyld 需要找到 symbol 对应的实现，这需要很多计算，去符号表里查找。找到后会将内容存储到 DATA 段中的那个指针中。Binding 看起来计算量比 Rebasing 更大，但其实需要的 I/O 操作很少，因为之前 Rebasing 已经替 Binding 做过了。ObjC RuntimeObjective-C 中有很多数据结构都是靠 Rebasing 和 Binding 来修正（fix-up）的，比如 Class 中指向超类的指针和指向方法的指针。ObjC 是个动态语言，可以用类的名字来实例化一个类的对象。这意味着 ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时，其定义的所有的类都需要被注册到这个全局表中。C++ 中有个问题叫做易碎的基类（fragile base class）。ObjC 就没有这个问题，因为会在加载时通过 fix-up 动态类中改变实例变量的偏移量。在 ObjC 中可以通过定义类别（Category）的方式改变一个类的方法。有时你想要添加方法的类在另一个 dylib 中，而不在你的镜像中（也就是对系统或别人的类动刀），这时也需要做些 fix-up。ObjC 中的 selector 必须是唯一的。InitializersC++ 会为静态创建的对象生成初始化器。而在 ObjC 中有个叫 +load 的方法，然而它被废弃了，现在建议使用 +initialize 。对比详见： http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do现在有了主执行文件，一堆 dylib，其依赖关系构成了一张巨大的有向图，那么执行初始化器的顺序是什么？自顶向上！按照依赖关系，先加载叶子节点，然后逐步向上加载中间节点，直至最后加载根节点。这种加载顺序确保了安全性，加载某个 dylib 前，其所依赖的其余 dylib 文件肯定已经被预先加载。最后 dyld 会调用 main() 函数。 main() 会调用 UIApplicationMain() 。改善启动时间从点击 App 图标到加载 App 闪屏之间会有个动画，我们希望 App 启动速度比这个动画更快。虽然不同设备上 App 启动速度不一样，但启动时间最好控制在 400ms。需要注意的是启动时间一旦超过 20s，系统会认为发生了死循环并杀掉 App 进程。当然启动时间最好以 App 所支持的最低配置设备为准。直到 applicationWillFinishLaunching 被调动，App 才启动结束。测量启动时间Warm launch: App 和数据已经在内存中Cold launch: App 不在内核缓冲存储器中冷启动（Cold launch）耗时才是我们需要测量的重要数据，为了准确测量冷启动耗时，测量前需要重启设备。在 main() 方法执行前测量是很难的，好在 dyld 提供了内建的测量方法：在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 1 。控制台输出的内容如下：Total pre-main time:228.41 milliseconds (100.0%)dylib loading time:82.35 milliseconds (36.0%)rebase/binding time:6.12 milliseconds (2.6%)ObjC setup time:7.82 milliseconds (3.4%)initializer time:132.02 milliseconds (57.8%)slowest intializers :libSystem.B.dylib:122.07 milliseconds (53.4%)CoreFoundation:5.59 milliseconds (2.4%)优化启动时间可以针对 App 启动前的每个步骤进行相应的优化工作。加载 Dylib之前提到过加载系统的 dylib 很快，因为有优化。但加载内嵌（embedded）的 dylib 文件很占时间，所以尽可能把多个内嵌 dylib 合并成一个来加载，或者使用 static archive。使用 dlopen() 来在运行时懒加载是不建议的，这么做可能会带来一些问题，并且总的开销更大。Rebase/Binding之前提过 Rebaing 消耗了大量时间在 I/O 上，而在之后的 Binding 就不怎么需要 I/O 了，而是将时间耗费在计算上。所以这两个步骤的耗时是混在一起的。之前说过可以从查看 DATA 段中需要修正（fix-up）的指针，所以减少指针数量才会减少这部分工作的耗时。对于 ObjC 来说就是减少 Class , selector 和category 这些元数据的数量。从编码原则和设计模式之类的理论都会鼓励大家多写精致短小的类和方法，并将每部分方法独立出一个类别，其实这会增加启动时间。对于 C++ 来说需要减少虚方法，因为虚方法会创建 vtable，这也会在 DATA 段中创建结构。虽然 C++ 虚方法对启动耗时的增加要比 ObjC 元数据要少，但依然不可忽视。最后推荐使用 Swift 结构体，它需要 fix-up 的内容较少。ObjC Setup针对这步所能事情很少，几乎都靠 Rebasing 和 Binding 步骤中减少所需 fix-up 内容。因为前面的工作也会使得这步耗时减少。Initializer显式初始化使用 +initialize 来替代 +load不要使用 atribute((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_once() , pthread_once() 或 std::once() 。也就是在第一次使用时才初始化，推迟了一部分工作耗时。隐式初始化对于带有 复杂（non-trivial）构造器 的 C++ 静态变量：在调用的地方使用初始化器。只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算__DATA 中的数据，无需再进行 fix-up 工作。使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。使用 Swift 重写代码，因为 Swift 已经预先处理好了，强力推荐。不要在初始化方法中调用 dlopen() ，对性能有影响。因为 dyld 在 App 开始前运行，由于此时是单线程运行所以系统会取消加锁，但 dlopen() 开启了多线程，系统不得不加锁，这就严重影响了性能，还可能会造成死锁以及产生未知的后果。所以也不要在初始化器中创建线程。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效程序员的45个习惯]]></title>
    <url>%2F2017%2F07%2F31%2F%E9%AB%98%E6%95%88%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%8445%E4%B8%AA%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[态度决定一切 做事，把矛头对准问题的解决办法，而不是人，这是真正有用处的正面效应 欲速则不达，要投入时间和精力保持代码的整洁、敞亮 对事不对人，让我们骄傲的应该是解决了问题，而不是比较出谁的主意更好 排除万难，奋勇前进，要诚实有勇气去说出实情，有时候这样做很困难，所以我们需要有足够的勇气 学无止境 跟踪变化，不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯 对团队投资，通过午餐会议可以增进每个人的知识和技能，并帮助大家聚集在一起进行沟通交流。唤起人们对技术和技巧的激情，将会对项目大有裨益。 懂得丢弃，在学习一门新技术的时候，要丢去会阻止你前进的旧习惯。毕竟，汽车要比马车强得多。 打破沙锅问到底，不能只满足与别人告诉你的表面现象。要不停地提问直到你明白问题的根源。 把握开发节奏，保持时间之间稳定重复的间隔，更容易解决常见的重复任务 交付用户想要的软件 让客户做决定，开发者、经理或者业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。 让设计指导而不是操纵开发，设计指引你向正确的方向前进，它不是殖民地，它不应该标识具体的路线。你不要被设计（或者设计师）操控。 首先决定什么是你需要的，接着为这些具体的问题评估使用技术，对任何要使用的技术，多问一些挑剔的问题，并真实地作出回答。新技术就应该像是新的工具，可以帮助你更好地工作，她自己不应该是成为你的工作。 保持可以发布，保证你的系统随时可以编译、运行、测试并立即部署。 提早集成，频繁集成，代码集成式主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。 提早实现自动化部署，使用部署系统安装你的应用，在不同的机器上用不同的配置文件测试依赖问题。质量保证人员要像测试应用一样测试部署。 使用演示获得频繁反馈，在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有客户，给他们演示最新完成的功能，积极获得他们的反馈。 使用短迭代，增量发布，发布带有最小却可用功能块的产品。每个增量开发中，使用1~4周左右的迭代周期。 固定的价格就意味着背叛承诺，让团队和客户一起，真正地在当前项目中工作，做具体实际的评估。由客户控制他们要的功能和预算。 敏捷反馈 守护天使，好的单元测试能够为你的代码问题提供及时的警报。如果没有到位的单元测试，不要进行任何的设计和代码修改。 先用它再实现它，使用测试驱动开发作为设计工具，它会为你带来更简单更实效的设计。 环境中运行单元测试。要积极地寻找问题，为不是等问题来找你。 自动验收测试，为核心的业务逻辑创建测试，让你的客户单独验证这些测试，要让它们像一般的测试一样可以自动运行。 度量真实的进度，不要用不恰当的度量来欺骗自己或者团队。要评估那些需要完成的待办事项。 倾听用户的声音，每一个抱怨的背后都隐藏了一个事实，找出真相，修复真正的问题。 敏捷编码 代码要清晰地表达意图，向代码阅读者明确表明你的意图。可读性差的代码一点也不聪明。 用代码沟通，使用细心选择的、有意义的命名。用注释描述代码意图和约束。注释不能替代优秀的代码。 动态评估取舍，考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。 增量式编程，在很短的编辑/构建/测试循环中编写代码，这要比花费长时间仅仅做编写代码的工作好得多。可以创建更加清晰、简单、易于维护的代码。 保持简单，除非有不可辩驳的原因，否则不要使用模式、原则和高难度技术之类的东西。 编写内聚的代码，让类的功能尽量集中，让组件尽量小。要避免创建很大的类或组件，也不要创建无所不包的大杂烩类。 告知，不要询问，不要抢别的对象或者是组件的工作。告诉它做什么，然后盯着你自己的指责就好了。 根据契约进行替换，通过替换遵循接口契约的类，来添加并改进功能特性。要使用更多的委托而不是继承。 敏捷调试 记录问题解决日志，保留解决方案是修复问题过程的一部分，以后发生相同或类似问题时，就可以很快找到并使用了。 警告就是错误，签入带有警告的代码，就跟签入有错误或者没有通过测试的代码一样，都是极差的做法。签入构建工具中的代码不应该产生任何警告信息。 对问题各个击破，在解决问题时，要将问题域与周边隔离开。特别是在大型应用中。 报告所有的异常，不要将它们压制不管，就算是临时这样做也不行，在写代码时要估计到会发生的问题。 提供有用的错误信息，提供更多易于查找错误细节的方式，发生问题时，要展示出尽量多的支持细节，不过别让用户陷入其中。 敏捷协作 定期安排会面时间。使用立会(站着开的会议)可以让团队达成共识。保证会议短小精悍不跑题。 架构师必须写代码。优秀的设计从积极的程序员那里开始演化。积极的编程可以带来深入的理解。不要使用不愿意编程的架构师——不知道系统的真实情况。是无法展开设计的。 实行代码集体所有制。让开发人员轮换完成系统不同领域中不同模块的不同任务。 成为指导者。分享自己的知识很有趣——付出的同时便有收获。还可以激励别人获得更好的成果，而且提升了整个团队的实力。 允许大家自己想办法。指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西。 准备好后再共享代码。绝对不要提交尚未完成的代码。故意签入编译未通过或是没有通过单元测试的代码，对项目来说，应该被视作为玩忽职守的犯罪行为。 做代码复查。对于提升代码质量和降低错误率来说，代码复查是无价之宝。如果以正确的方式进行，复查可以产生非常实用而高效的成果。要让不同的开发人员在每个任务完成后复查代码。 及时通报进展与问题。发布进展状况，新的想法和目前正在关注的主题。不要等着别人来问项目状态如何。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消除项目警告]]></title>
    <url>%2F2017%2F07%2F22%2F%E6%B6%88%E9%99%A4%E9%A1%B9%E7%9B%AE%E8%AD%A6%E5%91%8A%2F</url>
    <content type="text"><![CDATA[1 修复方法1.1 Unused Entity Issues 定了了但没使用的变量，解决方案：判断上下文，如果真没用到就注掉，最好别删掉 1.2 User-Defined Issue 自定义警告，看看是不是TODO？是不是可以用NSAssert代替？ 1.3 Lexical or Preprocessor Issue 以前xcode传入weak对象会有警告，RAC就在里面做了屏蔽，现在xcode已经没有警告了！ 1.4 Format String Issue 格式化字符串的警告！处理办法，点击警告，使用xcod推荐的格式 1.5 Apple Mach-O Linker (Id) Warning 文件夹路径或Framework路径报错 1，Click on your project (targets)；2， Click on Build Settings if your error includes the -L flag, then delete the values in Library Search Paths if your error includes the -F flag, then delete the values in Framework Search Paths 参考：https://stackoverflow.com/questions/9458739/ld-warning-directory-not-found-for-option?noredirect=1&amp;lq=1 1.6 Deprecations 已经废弃的方法 处理办法：使用推荐方法替换 1.7 semantic issue 语法问题 根据警告添加、修改或注释相关方法 1.8 Unsupported Configuration https://stackoverflow.com/questions/26547399/xcode-storyboard-warning-constraint-referencing-items-turned-off-in-current-con https://blog.csdn.net/phantom2000x/article/details/56008709 https://stackoverflow.com/questions/13531035/xcode-scene-is-unreachable-due-to-lack-of-entry-points-but-cant-find-it 1.9 SB的push方法 https://stackoverflow.com/questions/26417175/xcode-6-push-segues-are-deprecated-in-ios-8-0-and-later 1.10 Validate Project Settings 配置文件更新到ios8 https://blog.csdn.net/isharestudio/article/details/20462737 https://stackoverflow.com/questions/9612226/any-way-to-make-validate-project-settings-warning-go-away-in-xcode-4-3-4-3-1 2 屏蔽方法2.1 屏蔽某个警告 相关命令获取方式：run -&gt; 找到对应警告 -&gt; 右击 -&gt; reveal in log -&gt; 找到一些带框的标识 [-Wunused-variable] [-Wenum-conversion] [-Wbool-conversion]，[]之中的就是关键字 12345clang diagnostic 是#pragma 第一个常用命令：#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;关键字&quot;// 你自己的代码#pragma clang diagnostic pop 参考：https://blog.csdn.net/zww1984774346/article/details/53409033 2.2 屏蔽某个文件的所有警告（慎用） target -&gt; Build Phases -&gt; 搜到你要的文件 -&gt; compiler Flages -&gt; -w 2.3 屏蔽cocoapod的警告 在Profile文件中添加如下代码123456789101112// 1. 先用 inhibit_all_warnings!标志位inhibit_all_warnings!// 2. 涉及雄兼容可用如下方法post_install do |installer|installer.pods_project.targets.each do |target|target.build_configurations.each do |config|if config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;].to_f &lt; 8.0config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;] = &apos;8.0&apos;endendendend 3 把所有警告当做错误 Build Setting -&gt; 搜treat -&gt; 把Treat Warning as Error的值为YES 4 监控？&emsp;&emsp;说实话，我想来想去也没想到除了Treat Warning as Error有什么好的监控方案]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[子线程绘制UI检查工具]]></title>
    <url>%2F2017%2F07%2F07%2F%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%98%E5%88%B6UI%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[问题&emsp;&emsp;今天UI走查，对样式进行了大量修改，但改完后一个view的背景色等总是慢半拍！一开始没注意到这个问题，直到UI童鞋给我提了BUG… 排查步骤 是不是网络延迟的事？改为写死颜色值！结论：复现 是不是动画造成的？删除相关动画，保留基础代码！结论：复现 打点后查看日志，发现 Main Thread Checker: UI API called on a background thread ，子线程渲染UI！改为主线程刷新，解决问题！ 问题根源 我习惯于网络请求成功后回调前切换到主线程回调，这样上层UI不需要关心线程问题，拿来数据进行渲染就可以了！毕竟UI请求时也没切换到子线程去请求 同事习惯于网络请求成功后先回调给UI，如果UI需要渲染在自己切换主线程……我就是这么掉坑里的 解决方案 自己写了个简单的子线程UI绘制检查方案，如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@implementation UIView (MainThread)#ifdef DEBUG+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;[[self class] hookWithOriginalSelector:@selector(setNeedsLayout) swizzledSelector:@selector(mainThread_setNeedsLayout)];[[self class] hookWithOriginalSelector:@selector(setNeedsDisplay) swizzledSelector:@selector(mainThread_setNeedsDisplay)];[[self class] hookWithOriginalSelector:@selector(setNeedsDisplayInRect:) swizzledSelector:@selector(mainThread_setNeedsDisplayInRect:)];&#125;);&#125;- (void)mainThread_setNeedsLayout &#123;[self UIMainThreadCheck];[self mainThread_setNeedsLayout];&#125;- (void)mainThread_setNeedsDisplay &#123;[self UIMainThreadCheck];[self mainThread_setNeedsDisplay];&#125;- (void)mainThread_setNeedsDisplayInRect:(CGRect)rect &#123;[self UIMainThreadCheck];[self mainThread_setNeedsDisplayInRect:rect];&#125;- (void)UIMainThreadCheck &#123;NSString *desc = [NSString stringWithFormat:@&quot;%@ 类没在主线程执行请检查相关代码实现&quot;, self.class];NSAssert([NSThread isMainThread], desc);&#125;#endif+ (void)hookWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector &#123;Class class = [self class];Method originalMethod = class_getInstanceMethod(class, originalSelector);Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);BOOL didAddMethod = class_addMethod(class,originalSelector,method_getImplementation(swizzledMethod),method_getTypeEncoding(swizzledMethod));if (didAddMethod) &#123;class_replaceMethod(class,swizzledSelector,method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));&#125;else &#123;method_exchangeImplementations(originalMethod, swizzledMethod);&#125;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码规范]]></title>
    <url>%2F2017%2F06%2F30%2F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[转载自https://github.com/samlaudev/Objective-C-Coding-Style#error-handling 其它参考：Objective-C编码规范(译)、Google代码规范以及中文版、 补充更新：如何提高代码的可读性?、何为代码质量？——用脑子写代码、WordPress的OC规范和Swift规范 &emsp;&emsp;看到一份不错的代码规范，摘录下来！PS：感觉比百度的好 目录 语言 代码组织 空格 注释 命名 下划线 方法 变量 属性特性 点符号语法 字面值 常量 枚举类型 Case语句 私有属性 布尔值 条件语句 三元操作符 Init方法 类构造方法 CGRect函数 黄金路径 错误处理 单例模式 换行符 Xcode工程 语言应该使用US英语. 应该: 1UIColor *myColor = [UIColor whiteColor]; 不应该: 1UIColor *myColour = [UIColor whiteColor]; 代码组织在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构： 12345678910111213141516171819202122232425262728293031#pragma mark - Lifecycle- (instancetype)init &#123;&#125;- (void)dealloc &#123;&#125;- (void)viewDidLoad &#123;&#125;- (void)viewWillAppear:(BOOL)animated &#123;&#125;- (void)didReceiveMemoryWarning &#123;&#125;#pragma mark - Custom Accessors- (void)setCustomProperty:(id)value &#123;&#125;- (id)customProperty &#123;&#125;#pragma mark - IBActions/Event Response- (IBAction)submitData:(id)sender &#123;&#125;- (void)someButtonDidPressed:(UIButton*)button#pragma mark - Protocol conformance#pragma mark - UITextFieldDelegate#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - Public- (void)publicMethod &#123;&#125;#pragma mark - Private- (void)privateMethod &#123;&#125;#pragma mark - NSCopying- (id)copyWithZone:(NSZone *)zone &#123;&#125;#pragma mark - NSObject- (NSString *)description &#123;&#125; 空格 缩进使用4个空格，确保在Xcode偏好设置来设置。(raywenderlich.com使用2个空格) 方法大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭。 应该: 12345if (user.isHappy) &#123;//Do something&#125; else &#123;//Do something else&#125; 不应该: 1234567if (user.isHappy)&#123;//Do something&#125;else &#123;//Do something else&#125; 在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。 优先使用auto-synthesis。但如果有必要，@synthesize 和 @dynamic应该在实现中每个都声明新的一行。 应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请不要这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。 应该: 123456// blocks are easily readable[UIView animateWithDuration:1.0 animations:^&#123;// something&#125; completion:^(BOOL finished) &#123;// something&#125;]; 不应该: 12345678// colon-aligning makes the block indentation hard to read[UIView animateWithDuration:1.0animations:^&#123;// something&#125;completion:^(BOOL finished) &#123;// something&#125;]; 注释当需要注释时，注释应该用来解释这段特殊代码为什么要这样做。任何被使用的注释都必须保持最新或被删除。 一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。例外：这不应用在生成文档的注释 命名Apple命名规则尽可能坚持，特别是与这些相关的memory management rules (NARC)。 长的，描述性的方法和变量命名是好的。 应该: 1UIButton *settingsButton; 不应该: 1UIButton *setBut; 三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。 常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。 应该: 1static NSTimeInterval const RWTTutorialViewControllerNavigationFadeAnimationDuration = 0.3; 不应该: 1static NSTimeInterval const fadetime = 1.7; 属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@ synthesize语句，除非你有一个好的理由。 应该: 1@property (strong, nonatomic) NSString *descriptiveVariableName; 不应该: 1id varnm; 下划线当使用属性时，实例变量应该使用self.来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有self.。 但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。 局部变量不应该包含下划线。 方法在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。 “and”这个词的用法应该保留。它不应该用于多个参数来说明，就像initWithWidth:height以下这个例子： 应该:1234- (void)setExampleText:(NSString *)text image:(UIImage *)image;- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;- (id)viewWithTag:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height; 不应该: 12345-(void)setT:(NSString *)text i:(UIImage *)image;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;- (id)taggedView:(NSInteger)tag;- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;- (instancetype)initWith:(int)width and:(int)height; // Never do this. 变量变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在for()循环。 星号表示变量是指针。例如， NSString *text 既不是 NSString* text 也不是 NSString * text，除了一些特殊情况下常量。 私有变量 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。 通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(init, initWithCoder:, 等…)，dealloc 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看这里 应该: 12345@interface RWTTutorial : NSObject@property (strong, nonatomic) NSString *tutorialName;@end 不应该: 123@interface RWTTutorial : NSObject &#123;NSString *tutorialName;&#125; 属性特性所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。 应该: 12@property (weak, nonatomic) IBOutlet UIView *containerView;@property (strong, nonatomic) NSString *tutorialName; 不应该: 12@property (nonatomic, weak) IBOutlet UIView *containerView;@property (nonatomic) NSString *tutorialName; NSString应该使用copy 而不是 strong的属性特性。 为什么？即使你声明一个NSString的属性，有人可能传入一个NSMutableString的实例，然后在你没有注意的情况下修改它。 应该: 1@property (copy, nonatomic) NSString *tutorialName; 不应该: 1@property (strong, nonatomic) NSString *tutorialName; 点符号语法点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读这里 点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。 应该:123NSInteger arrayCount = [self.array count];view.backgroundColor = [UIColor orangeColor];[UIApplication sharedApplication].delegate; 不应该:123NSInteger arrayCount = self.array.count;[view setBackgroundColor:[UIColor orangeColor]];UIApplication.sharedApplication.delegate; 字面值NSString, NSDictionary, NSArray, 和 NSNumber的字面值应该在创建这些类的不可变实例时被使用。请特别注意nil值不能传入NSArray和NSDictionary字面值，因为这样会导致crash。 应该: 1234NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];NSDictionary *productManagers = @&#123;@"iPhone": @"Kate", @"iPad": @"Kamal", @"Mobile Web": @"Bill"&#125;;NSNumber *shouldUseLiterals = @YES;NSNumber *buildingStreetNumber = @10018; 不应该: 1234NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];NSNumber *buildingStreetNumber = [NSNumber numberWithInteger:10018]; 常量常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。 应该: 123static NSString * const RWTAboutViewControllerCompanyName = @"RayWenderlich.com";static CGFloat const RWTImageThumbnailHeight = 50.0; 不应该: 123#define CompanyName @"RayWenderlich.com"#define thumbnailHeight 2 枚举类型当使用enum时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏NS_ENUM()来帮助和鼓励你使用固定的基本类型。 例如: 12345typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) &#123;RWTLeftMenuTopItemMain,RWTLeftMenuTopItemShows,RWTLeftMenuTopItemSchedule&#125;; 你也可以显式地赋值(展示旧的k-style常量定义)： 123456typedef NS_ENUM(NSInteger, RWTGlobalConstants) &#123;RWTPinSizeMin = 1,RWTPinSizeMax = 5,RWTPinCountMin = 100,RWTPinCountMax = 500,&#125;; 旧的k-style常量定义应该避免除非编写Core Foundation C的代码。 不应该: 1234enum GlobalConstants &#123;kMaxPinSize = 5,kMaxPinCount = 500,&#125;; Case语句大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。 12345678910111213141516switch (condition) &#123;case 1:// ...break;case 2: &#123;// ...// Multi-line example using bracesbreak;&#125;case 3:// ...break;default: // ...break;&#125; 有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。 12345678910switch (condition) &#123;case 1:// ** fall-through! **case 2:// code executed for values 1 and 2break;default: // ...break;&#125; 当在switch使用枚举类型时，’default’是不需要的。例如： 12345678910111213RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;switch (menuType) &#123;case RWTLeftMenuTopItemMain:// ...break;case RWTLeftMenuTopItemShows:// ...break;case RWTLeftMenuTopItemSchedule:// ...break;&#125; 私有属性私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如RWTPrivate或private)应该从不使用除非是扩展其他类。匿名分类应该通过使用+Private.h文件的命名规则暴露给测试。 例如: 1234567@interface RWTDetailViewController ()@property (strong, nonatomic) GADBannerView *googleAdView;@property (strong, nonatomic) ADBannerView *iAdView;@property (strong, nonatomic) UIWebView *adXWebView;@end 布尔值Objective-C使用YES和NO。因为true和false应该只在CoreFoundation，C或C++代码使用。既然nil解析成NO，所以没有必要在条件语句比较。不要拿某样东西直接与YES比较，因为YES被定义为1和一个BOOL能被设置为8位。 这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。 应该: 12if (someObject) &#123;&#125;if (![anotherObject boolValue]) &#123;&#125; 不应该: 1234if (someObject == nil) &#123;&#125;if ([anotherObject boolValue] == NO) &#123;&#125;if (isAwesome == YES) &#123;&#125; // Never do this.if (isAwesome == true) &#123;&#125; // Never do this. 如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如： 1@property (assign, getter=isEditable) BOOL editable; 文字和例子从这里引用Cocoa Naming Guidelines 条件语句条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，even more dangerous defect可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。 应该: 123if (!error) &#123;return success;&#125; 不应该: 12if (!error)return success; 或 1if (!error) return success; 三元操作符当需要提高代码的清晰性和简洁性时，三元操作符?:才会使用。单个条件求值常常需要它。多个条件求值时，如果使用if语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。 Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。 应该: 12345NSInteger value = 5;result = (value != 0) ? x : y;BOOL isHorizontal = YES;result = isHorizontal ? x : y; 不应该: 1result = a &gt; b ? x = c &gt; d ? c : d : y; Init方法Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用instancetype而不是id 1234567- (instancetype)init &#123;self = [super init];if (self) &#123;// ...&#125;return self;&#125; 查看关于instancetype的文章Class Constructor Methods 类构造方法当类构造方法被使用时，它应该返回类型是instancetype而不是id。这样确保编译器正确地推断结果类型。 123@interface Airplane+ (instancetype)airplaneWithType:(RWTAirplaneType)type;@end 关于更多instancetype信息，请查看NSHipster.com CGRect函数当访问CGRect里的x, y, width, 或 height时，应该使用CGGeometry函数而不是直接通过结构体来访问。引用Apple的CGGeometry: 在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。 应该: 1234567CGRect frame = self.view.frame;CGFloat x = CGRectGetMinX(frame);CGFloat y = CGRectGetMinY(frame);CGFloat width = CGRectGetWidth(frame);CGFloat height = CGRectGetHeight(frame);CGRect frame = CGRectMake(0.0, 0.0, width, height); 不应该: 1234567CGRect frame = self.view.frame;CGFloat x = frame.origin.x;CGFloat y = frame.origin.y;CGFloat width = frame.size.width;CGFloat height = frame.size.height;CGRect frame = (CGRect)&#123; .origin = CGPointZero, .size = frame.size &#125;; 黄金路径当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。 应该: 1234567- (void)someMethod &#123;if (![someOther boolValue]) &#123;return;&#125;//Do something important&#125; 不应该: 12345- (void)someMethod &#123;if ([someOther boolValue]) &#123;//Do something important&#125;&#125; 错误处理当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。 应该:1234NSError *error;if (![self trySomethingWithError:&amp;error]) &#123;// Handle Error&#125; 不应该:12345NSError *error;[self trySomethingWithError:&amp;error];if (error) &#123;// Handle Error&#125; 在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。 单例模式单例对象应该使用线程安全模式来创建共享实例。 12345678910+ (instancetype)sharedInstance &#123;static id sharedInstance = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125; 这会防止possible and sometimes prolific crashes. 换行符换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。 例如: 1self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; 一行很长的代码应该分成两行代码，下一行用两个空格隔开。 12self.productsRequest = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdentifiers]; Xcode工程物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据类型来分组，而且还可以根据功能来分组，这样代码更加清晰。 尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下additional warnings。如果你需要忽略特殊的警告，使用 Clang’s pragma feature。 其他Objective-C编码规范如果我们的编码规范不符合你的口味，可以查看其他的编码规范： Robots &amp; Pencils New York Times Google GitHub Adium Sam Soffes CocoaDevCentral Luke Redpath Marcus Zarra]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSException介绍]]></title>
    <url>%2F2017%2F06%2F17%2FNSException%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1 介绍 name : 唯一标识符 reason: 异常原因，最重要的属性！找问题就靠它了 userInfo：当异常被抛出时，返回原因等的一个字典12345678@try &#123;// 如果这里面的代码执行后会导致程序崩溃，就会跳到@catch这个方法中// @throw someException&#125; @catch(NSException *exception) &#123;// 处理异常&#125;@finally&#123;// 这里的代码是一定执行的&#125; 2 常见异常2.1 NSGenericException 通用异常？我也翻译不准还要看reason，不能一概而论，不过个人理解就跟枚举的第一个default一样 我只见一次NSGenericException，对数组进行删除操作时见到的12345NSMutableArray *muArr = @[@1, @2, @3].mutableCopy;for (id elem in muArr) &#123;[muArr removeObject:elem];&#125;// Terminating app due to uncaught exception &apos;NSGenericException&apos;, reason: &apos;*** Collection &lt;__NSArrayM: 0x600002052310&gt; was mutated while being enumerated.&apos; 2.2 NSRangeException越界 一般是数组越界，字符创越界两种！Debug下打开全局断点基本都是定位到，release下分析崩溃行上下文基本也能处理123456// 空数组NSMutableArray *photos = [NSMutableArray array];NSLog(@&quot;--- %@&quot;,photos[0]);// Crash// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 0 beyond bounds for empty array&apos; 2.3 NSInvalidArgumentException 非法入参 开发阶段可用NSAssert代替，但使用NSInvalidArgumentException可以保证在release阶段也不会出现入参问题的crash1234NSMutableArray *muArr = [[NSMutableArray alloc] init];NSString *str = nil;[muArr addObject:str];// erminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil&apos; 2.4 NSInternalInconsistencyException 内部矛盾异常，主要在断言失败时自动调用！ 出现这个异常，一般都是类型问题，xib连线问题，约束问题等1NSAssert(NO, @&quot;this will call NSInternalInconsistencyException&quot;); 2.5 NSMallocException 内存不足 内存不足的问题，无法分配足够的内存空间,比如需要分配的内存大小是一个不正常的值，比较巨大或者设备的内存空间不足以及耗尽 3 小技巧3.1 @throw的妙用 限制某方式使用，特别是废弃的方法 1234// 强制使用initWithPath作为初始化，也可以直接用NSAssert(NO, @&quot;原因&quot;);@throw [NSException exceptionWithName:NSGenericExceptionreason:@&quot;`-init` unavailable. Use `-initWithReachability:` instead&quot;userInfo:nil]; 强制子类实现某个方法 12345678// 如果所有子类都必须实现某个方法，怎么做才好？// 第一种方法声明协议，父类遵守，子类实现；但协议只能产生警告，不够强硬！而且一旦父类实现了该方法，子类实现不实现根本就无所谓！// 第二种方法，父类实现该方法并添加@throw强制实现子类去自己重载- (void)changeActivityState:(BOOL)active &#123;@throw [NSException exceptionWithName:NSInternalInconsistencyExceptionreason:[NSString stringWithFormat:@&quot;You must override %@ in %@&quot;, NSStringFromSelector(_cmd), self.class]userInfo:nil];&#125; 3.2 自己捕获异常 注意，很多三方SDK也用到了自定义异常处理，咱们捕获了要转发出去1234567891011121314151617181920static NSUncaughtExceptionHandler *_previousHandler;// 在程序开始运行就监控异常- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;// 保存第三方处理异常的 handler_previousHandler = NSGetUncaughtExceptionHandler();// 将下面C函数的函数地址当做参数NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);return YES;&#125;// 设置一个C函数，用来接收崩溃信息void UncaughtExceptionHandler(NSException *exception)&#123;// 崩溃栈NSArray *symbols = [exception callStackSymbols];NSString *reason = [exception reason];NSString *name = [exception name];// 本地记录并上传// 转发为三方_previousHandler(exception);&#125; 参考 https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB PS: NSException 异常，非正常，想不到的是异常 NSError 错误，流程的一部分，有正确就有错误 NSAssert 断言，保证正确（或错误），就是程序员确定这个是正确的（或错误的），常用测试和参数校验]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有意思的@try@Catch]]></title>
    <url>%2F2017%2F06%2F10%2F%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84-try-Catch%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天和同事聊天，聊到了tryCatch的使用，他说trycatch用起来很简单！我问他有风险吗！他说，trycatch有啥风险，随便用！回头想想iOS的@try@catch，额…不提也…哎，其实也是可以水一篇的哈！ &emsp;&emsp;简单的来说，Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。 &emsp;&emsp;参考：官网 Important: You should reserve the use of exceptions for programming or unexpected runtime errors such as out-of-bounds collection access, attempts to mutate immutable objects, sending an invalid message, and losing the connection to the window server. You usually take care of these sorts of errors with exceptions when an application is being created rather than at runtime.If you have an existing body of code (such as third-party library) that uses exceptions to handle error conditions, you may use the code as-is in your Cocoa application. But you should ensure that any expected runtime exceptions do not escape from these subsystems and end up in the caller’s code. For example, a parsing library might use exceptions internally to indicate problems and enable a quick exit from a parsing state that could be deeply recursive; however, you should take care to catch such exceptions at the top level of the library and translate them into an appropriate return code or state. &emsp;&emsp;此外tryCatch比较耗性能，不能用于流程控制 https://stackoverflow.com/questions/3678438/try-catch-exception-handling-practice-for-iphone-objective-c ；容易造成内存泄漏 https://stackoverflow.com/questions/27140891/why-does-try-catch-in-objective-c-cause-memory-leak ；更重要的是tryCatch干的活，基本上NSError和断点都能干 https://stackoverflow.com/questions/13774611/try-catch-equivalent-in-objective-c &emsp;&emsp;当然这篇水文关注的不是tryCatch少用的原因！ &emsp;&emsp;其实我本来打算研究一下tryCatch为什么耗性能的！但真没研究出来，不过到发现一个好玩的东西，本着水一篇算一篇，水一会算一会的精神，我还是水了出来！ &emsp;&emsp;测试代码1234567891011@implementation Person- (void)test &#123;@try &#123;NSLog(@&quot;try&quot;);&#125; @catch (NSException *exception) &#123;NSLog(@&quot;catch&quot;);&#125; @finally &#123;NSLog(@&quot;finally&quot;);&#125;&#125;@end &emsp;&emsp;编译后得到如下代码：123456789101112131415161718192021222324252627282930313233// @implementation Personstatic void _I_Person_test(Person * self, SEL _cmd) &#123;&#123;id volatile _rethrow = 0;try &#123;// 这里对应@try @catchtry &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_0);&#125; catch (_objc_exc_NSException *_exception) &#123;/*从代码上看只捕获_objc_exc_NSExceptiontypedef struct objc_object NSException;typedef struct &#123;&#125; _objc_exc_NSException;*/NSException *exception = (NSException*)_exception;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_1);&#125;&#125;catch (id e) &#123;// 理论上讲 非 _objc_exc_NSException才能走到这里_rethrow = e;&#125;&#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125;~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125;id rethrow;&#125; _fin_force_rethow(_rethrow);NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_2);&#125;&#125;&#125;// @end &emsp;&emsp;大家可直观的观察到包含两个trycatch，说实话哈！我是第一次见到try里面嵌套trycatch，很久以前学习JAVA时见过catch或finally里面还有trycatch，主要是因为JAVA处理异常时还可能发生别的异常，所以再加一个trycatch来捕获子异常。延伸一下，try配合多个catch 和 trycatch嵌套最主要的区别就是一个try多个catch只能捕获一次异常；而trycatch嵌套可以捕获多个异常。当然你要硬说一个try也可以捕获多个异常，我也不反对，毕竟这种方式不太常用！ &emsp;&emsp;可以参考try catch里面try catch嵌套加深对trycatch嵌套的理解！个人猜测，之所以try嵌套还是为了尽可能的捕获异常（我依然认为这么写的意义不大），但即便如此@try@catch无法捕获UncaughtException，而oc中大部分crash如：内存溢出、野指针等都是无法捕获的，而能捕获的只是像数组越界之类的，所以@try@catch真的比较鸡肋。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Category原理]]></title>
    <url>%2F2017%2F05%2F19%2FCategory%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 Category结构&emsp;&emsp;先看rutnime里category_t的源码1234567891011121314151617struct category_t &#123;const char *name; // 类的名字classref_t cls; // 类struct method_list_t *instanceMethods; // 实例方法struct method_list_t *classMethods; // 类方法struct protocol_list_t *protocols; // 协议struct property_list_t *instanceProperties; // 属性// Fields below this point are not always present on disk.struct property_list_t *_classProperties;method_list_t *methodsForMeta(bool isMeta) &#123;if (isMeta) return classMethods;else return instanceMethods;&#125;property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; &emsp;&emsp;待测试代码h文件1234567891011121314@interface Person : NSObject &#123;NSString *clsIvar;&#125;@property (nonatomic, copy) NSString *clsProperty1;@property (nonatomic, copy) NSString *clsProperty2;@end@interface Person (MyTest)@property (nonatomic, copy) NSString *clsProperty1;@end &emsp;&emsp;m文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#import &quot;Person.h&quot;#import &lt;objc/runtime.h&gt;static NSString *kClsProperty1 = @&quot;kClsProperty1&quot;;static NSString *kClsProperty3 = @&quot;kClsProperty3&quot;;@interface Person () &#123;NSString *_extensionIvar;&#125;@property (nonatomic, copy) NSString *extensionProperty;@end@implementation Person- (void)method1 &#123;NSLog(@&quot;method1&quot;);&#125;- (void)method2 &#123;NSLog(@&quot;method2&quot;);&#125;@end@implementation Person (MyTest)- (void)method1 &#123;NSLog(@&quot;category method1&quot;);&#125;- (void)method3 &#123;NSLog(@&quot;category method3&quot;);&#125;- (void)setClsProperty1:(NSString*)propertyValue &#123;objc_setAssociatedObject(self, &amp;kClsProperty1, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)clsProperty1 &#123;NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty1);return value;&#125;- (void)setClsProperty3:(NSString*)propertyValue &#123;objc_setAssociatedObject(self, &amp;kClsProperty3, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)clsProperty3 &#123;NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty3);return value;&#125;@end &emsp;&emsp;查看编译后文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298static NSString *kClsProperty1 = (NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_0;static NSString *kClsProperty3 = (NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_1;/** interface Person () &#123;NSString *_extensionIvar;**/ // @property (nonatomic, copy) NSString *extensionProperty;/* @end */// @implementation Personstatic void _I_Person_method1(Person * self, SEL _cmd) &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_2);&#125;static void _I_Person_method2(Person * self, SEL _cmd) &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_3);&#125;static NSString * _Nonnull _I_Person_clsProperty1(Person * self, SEL _cmd) &#123; return (*(NSString * _Nonnull __strong *)((char *)self + OBJC_IVAR_$_Person$_clsProperty1)); &#125;extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);static void _I_Person_setClsProperty1_(Person * self, SEL _cmd, NSString * _Nonnull clsProperty1) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _clsProperty1), (id)clsProperty1, 0, 1); &#125;static NSString * _Nonnull _I_Person_clsProperty2(Person * self, SEL _cmd) &#123; return (*(NSString * _Nonnull __strong *)((char *)self + OBJC_IVAR_$_Person$_clsProperty2)); &#125;static void _I_Person_setClsProperty2_(Person * self, SEL _cmd, NSString * _Nonnull clsProperty2) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _clsProperty2), (id)clsProperty2, 0, 1); &#125;static NSString * _I_Person_extensionProperty(Person * self, SEL _cmd) &#123; return (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_Person$_extensionProperty)); &#125;static void _I_Person_setExtensionProperty_(Person * self, SEL _cmd, NSString *extensionProperty) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _extensionProperty), (id)extensionProperty, 0, 1); &#125;// @end// @implementation Person (MyTest)static void _I_Person_MyTest_method1(Person * self, SEL _cmd) &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_4);&#125;static void _I_Person_MyTest_method3(Person * self, SEL _cmd) &#123;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_5);&#125;static void _I_Person_MyTest_setClsProperty1_(Person * self, SEL _cmd, NSString *__strong _Nonnull propertyValue) &#123;objc_setAssociatedObject(self, &amp;kClsProperty1, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;static NSString * _Nonnull _I_Person_MyTest_clsProperty1(Person * self, SEL _cmd) &#123;NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty1);return value;&#125;static void _I_Person_MyTest_setClsProperty3_(Person * self, SEL _cmd, NSString *__strong _Nonnull propertyValue) &#123;objc_setAssociatedObject(self, &amp;kClsProperty3, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;static NSString * _Nonnull _I_Person_MyTest_clsProperty3(Person * self, SEL _cmd) &#123;NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty3);return value;&#125;// @endstruct _prop_t &#123;const char *name;const char *attributes;&#125;;struct _protocol_t;struct _objc_method &#123;struct objc_selector * _cmd;const char *method_type;void *_imp;&#125;;struct _protocol_t &#123;void * isa; // NULLconst char *protocol_name;const struct _protocol_list_t * protocol_list; // super protocolsconst struct method_list_t *instance_methods;const struct method_list_t *class_methods;const struct method_list_t *optionalInstanceMethods;const struct method_list_t *optionalClassMethods;const struct _prop_list_t * properties;const unsigned int size; // sizeof(struct _protocol_t)const unsigned int flags; // = 0const char ** extendedMethodTypes;&#125;;struct _ivar_t &#123;unsigned long int *offset; // pointer to ivar offset locationconst char *name;const char *type;unsigned int alignment;unsigned int size;&#125;;struct _class_ro_t &#123;unsigned int flags;unsigned int instanceStart;unsigned int instanceSize;unsigned int reserved;const unsigned char *ivarLayout;const char *name;const struct _method_list_t *baseMethods;const struct _objc_protocol_list *baseProtocols;const struct _ivar_list_t *ivars;const unsigned char *weakIvarLayout;const struct _prop_list_t *properties;&#125;;struct _class_t &#123;struct _class_t *isa;struct _class_t *superclass;void *cache;void *vtable;struct _class_ro_t *ro;&#125;;struct _category_t &#123;const char *name;struct _class_t *cls;const struct _method_list_t *instance_methods;const struct _method_list_t *class_methods;const struct _protocol_list_t *protocols;const struct _prop_list_t *properties;&#125;;extern &quot;C&quot; __declspec(dllimport) struct objc_cache _objc_empty_cache;#pragma warning(disable:4273)extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$clsIvar __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, clsIvar);extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_extensionIvar __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _extensionIvar);extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_clsProperty1 __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _clsProperty1);extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_clsProperty2 __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _clsProperty2);extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_extensionProperty __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _extensionProperty);static struct /*_ivar_list_t*/ &#123;unsigned int entsize; // sizeof(struct _prop_t)unsigned int count;struct _ivar_t ivar_list[5];&#125; _OBJC_$_INSTANCE_VARIABLES_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_ivar_t),5,&#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$clsIvar, &quot;clsIvar&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_extensionIvar, &quot;_extensionIvar&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_clsProperty1, &quot;_clsProperty1&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_clsProperty2, &quot;_clsProperty2&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_extensionProperty, &quot;_extensionProperty&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;&#125;;static struct /*_method_list_t*/ &#123;unsigned int entsize; // sizeof(struct _objc_method)unsigned int method_count;struct _objc_method method_list[8];&#125; _OBJC_$_INSTANCE_METHODS_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_objc_method),8,&#123;&#123;(struct objc_selector *)&quot;method1&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_method1&#125;,&#123;(struct objc_selector *)&quot;method2&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_method2&#125;,&#123;(struct objc_selector *)&quot;clsProperty1&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_clsProperty1&#125;,&#123;(struct objc_selector *)&quot;setClsProperty1:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setClsProperty1_&#125;,&#123;(struct objc_selector *)&quot;clsProperty2&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_clsProperty2&#125;,&#123;(struct objc_selector *)&quot;setClsProperty2:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setClsProperty2_&#125;,&#123;(struct objc_selector *)&quot;extensionProperty&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_extensionProperty&#125;,&#123;(struct objc_selector *)&quot;setExtensionProperty:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setExtensionProperty_&#125;&#125;&#125;;static struct /*_prop_list_t*/ &#123;unsigned int entsize; // sizeof(struct _prop_t)unsigned int count_of_properties;struct _prop_t prop_list[2];&#125; _OBJC_$_PROP_LIST_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_prop_t),2,&#123;&#123;&quot;clsProperty1&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_clsProperty1&quot;&#125;,&#123;&quot;clsProperty2&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_clsProperty2&quot;&#125;&#125;&#125;;static struct _class_ro_t _OBJC_METACLASS_RO_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;1, sizeof(struct _class_t), sizeof(struct _class_t), (unsigned int)0, 0, &quot;Person&quot;,0, 0, 0, 0, 0, &#125;;static struct _class_ro_t _OBJC_CLASS_RO_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;0, __OFFSETOFIVAR__(struct Person, clsIvar), sizeof(struct Person_IMPL), (unsigned int)0, 0, &quot;Person&quot;,(const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_Person,0, (const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_Person,0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person,&#125;;extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_METACLASS_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_data&quot;))) = &#123;0, // &amp;OBJC_METACLASS_$_NSObject,0, // &amp;OBJC_METACLASS_$_NSObject,0, // (void *)&amp;_objc_empty_cache,0, // unused, was (void *)&amp;_objc_empty_vtable,&amp;_OBJC_METACLASS_RO_$_Person,&#125;;extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_NSObject;extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_data&quot;))) = &#123;0, // &amp;OBJC_METACLASS_$_Person,0, // &amp;OBJC_CLASS_$_NSObject,0, // (void *)&amp;_objc_empty_cache,0, // unused, was (void *)&amp;_objc_empty_vtable,&amp;_OBJC_CLASS_RO_$_Person,&#125;;static void OBJC_CLASS_SETUP_$_Person(void ) &#123;OBJC_METACLASS_$_Person.isa = &amp;OBJC_METACLASS_$_NSObject;OBJC_METACLASS_$_Person.superclass = &amp;OBJC_METACLASS_$_NSObject;OBJC_METACLASS_$_Person.cache = &amp;_objc_empty_cache;OBJC_CLASS_$_Person.isa = &amp;OBJC_METACLASS_$_Person;OBJC_CLASS_$_Person.superclass = &amp;OBJC_CLASS_$_NSObject;OBJC_CLASS_$_Person.cache = &amp;_objc_empty_cache;&#125;#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CLASS_SETUP[] = &#123;(void *)&amp;OBJC_CLASS_SETUP_$_Person,&#125;;static struct /*_method_list_t*/ &#123;unsigned int entsize; // sizeof(struct _objc_method)unsigned int method_count;struct _objc_method method_list[6];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_objc_method),6,&#123;&#123;(struct objc_selector *)&quot;method1&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_MyTest_method1&#125;,&#123;(struct objc_selector *)&quot;method3&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_MyTest_method3&#125;,&#123;(struct objc_selector *)&quot;setClsProperty1:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_MyTest_setClsProperty1_&#125;,&#123;(struct objc_selector *)&quot;clsProperty1&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_MyTest_clsProperty1&#125;,&#123;(struct objc_selector *)&quot;setClsProperty3:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_MyTest_setClsProperty3_&#125;,&#123;(struct objc_selector *)&quot;clsProperty3&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_MyTest_clsProperty3&#125;&#125;&#125;;static struct /*_prop_list_t*/ &#123;unsigned int entsize; // sizeof(struct _prop_t)unsigned int count_of_properties;struct _prop_t prop_list[2];&#125; _OBJC_$_PROP_LIST_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_prop_t),2,&#123;&#123;&quot;clsProperty1&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;,&#123;&quot;clsProperty3&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;&#125;;extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person;static struct _category_t _OBJC_$_CATEGORY_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;&quot;Person&quot;,0, // &amp;OBJC_CLASS_$_Person,(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_MyTest,0,0,(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person_$_MyTest,&#125;;static void OBJC_CATEGORY_SETUP_$_Person_$_MyTest(void ) &#123;_OBJC_$_CATEGORY_Person_$_MyTest.cls = &amp;OBJC_CLASS_$_Person;&#125;#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;(void *)&amp;OBJC_CATEGORY_SETUP_$_Person_$_MyTest,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;&amp;OBJC_CLASS_$_Person,&#125;;static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;&amp;_OBJC_$_CATEGORY_Person_$_MyTest,&#125;;static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;; &emsp;&emsp;通过观察编译代码得知 extension不是匿名Category，两者无关！extension是编译到类里的 使用category的方法需要引入对应的头文件，因为category是单独编译（如果把MyTest单独成一个文件，编译Person的时候是看不到MyTest相关代码的） Category是运行期决议的，因为如果编译阶段就决议必然会有重名错误问题 category不能添加ivar, category_t数据结构里没有，编译后代码也没相关逻辑 所有类和category编译后都是struct结构体，在DATA段下有 objc_classlist 和 objc_catlist ，再通过OBJC$_CATEGORY_Person_$_MyTest.cls = &amp;OBJC_CLASS_$_Person;方式指明category和类的关系 category的h文件声明的属性如果没手动实现getter和setter方法会报错的原因就是编译器没自动生成（废话，但这次是从源码角度看的） 2 Category加载&emsp;&emsp;category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images中有对category的处理，源码太长了, 只贴把category的实例方法、协议以及属性添加到类上的代码, 123456789101112131415161718192021// Process this category.// First, register the category with its target class.// Then, rebuild the class&apos;s method lists (etc) if// the class is realized.bool classExists = NO;if (cat-&gt;instanceMethods || cat-&gt;protocols|| cat-&gt;instanceProperties)&#123;// addUnattachedCategoryForClass只是把类和category做一个关联映射addUnattachedCategoryForClass(cat, cls, hi);if (cls-&gt;isRealized()) &#123;remethodizeClass(cls);classExists = YES;&#125;if (PrintConnecting) &#123;_objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,cls-&gt;nameForLogging(), cat-&gt;name,classExists ? &quot;on existing class&quot; : &quot;&quot;);&#125;&#125;//接下来是把category的类方法和协议添加到类的metaclass上的代码，逻辑一样参数改成cls-&gt;ISA() &emsp;&emsp;remethodizeClass最后会把Category的method、properties和protocols添加到cls里123// Attach method lists and properties and protocols from categories to a class.// Assumes the categories in cats are all loaded and sorted by load order, // oldest categories first. &emsp;&emsp;需要注意的是 category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 3 关联对象&emsp;&emsp;上面说到category没法添加ivar，而我们都知道可以通过关联对象的方式给category添加“实例变量”，它是怎么实现的？从runtime的objc_setAssociatedObject和objc_getAssociatedObject两个函数入手查看源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;_object_set_associative_reference(object, (void *)key, value, policy);&#125;void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;// retain the new value (if any) outside the lock.ObjcAssociation old_association(0, nil);id new_value = value ? acquireValue(value, policy) : nil;&#123;AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations());disguised_ptr_t disguised_object = DISGUISE(object);if (new_value) &#123;// break any existing association.AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123;// secondary table existsObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123;old_association = j-&gt;second;j-&gt;second = ObjcAssociation(policy, new_value);&#125; else &#123;(*refs)[key] = ObjcAssociation(policy, new_value);&#125;&#125; else &#123;// create the new association (first time).ObjectAssociationMap *refs = new ObjectAssociationMap;associations[disguised_object] = refs;(*refs)[key] = ObjcAssociation(policy, new_value);object-&gt;setHasAssociatedObjects();&#125;&#125; else &#123;// setting the association to nil breaks the association.AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123;ObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123;old_association = j-&gt;second;refs-&gt;erase(j);&#125;&#125;&#125;&#125;// release the old value (outside of the lock).if (old_association.hasValue()) ReleaseValue()(old_association);&#125; &emsp;&emsp; 不用看异常逻辑，代码很简单，直接copy美团的结论吧！所有的关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。 &emsp;&emsp; 对象的销毁逻辑里面也会清除关联对象 4 其它问题4.1 在类和category中都可以有+load方法，那么有两个问题： 在类的+load方法调用的时候，我们可以调用category中声明的方法么？可以调用，因为附加category到类的工作会先于+load方法的执行 这么些个+load方法，调用顺序是咋样的呢？ +load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的 4.2 怎么调用到原来类中被category覆盖掉的方法？&emsp;&emsp; 对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法 4.3 +initialize方法什么时候调用&emsp;&emsp; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次！initialize先初始化父类，之后再初始化子类。如果分类实现了+initialize，就覆盖类本身的+initialize调用 参考&emsp;&emsp;美团的深入理解Objective-C：Category，差距真的不是一点点！美团童鞋在15年就研究过相关问题了，我到17年才看到…]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极简主义]]></title>
    <url>%2F2017%2F05%2F08%2F%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[极简主义大多数时候我们都在寻找复杂的解决办法 常常问自己：要做的简单的是什么？是否还有更简单的？ 尝试用25个字简单明了的描述清楚，一件事，一个问题，一个方案，一个建议等 尝试30秒内完成这件事，“电梯公关”有限时间内将信息完整准确的传递 如果发现采用了复杂的办法，就要审视是否可以更简单点 只问最简单的问题：who? what? when? where? why? how? 使用水平思维，改变固有思维模式 大多数会议，往往倾向于复杂的操作，而不是简单的 弄明白自己要做什么 做一点计划永远比盲目的尝试好很多 真正理解你努力想做的事：这个工作最终要达到什么目标？什么事件的出现标志着这项工作的结束？ 搞清楚你想要走的事情是否也是其他人希望做的：让利益相关者永远开心是成功的关键，利益相关者也是有权重的。 具体工作形象化：其实就是幻想出要做的事情，能明确努力目标，缩小范围还能多角度观察要做的事情 任何事都有连续性 制定宏大的目标，却对“怎样”实现缺乏关注,即如果事件不具有连续性，那什么也做不了 建立事件连续性：一开始就做好计划；把计划做的详细周到；清楚的说清自己的意图；善于运用知识和假设；懂得运用因果关系；记录已经发生的事情 把要做的事情列成清单并定期更新 事情优先级排序：如果我现在只能做一件事，做什么呢？ 加快速度，时间间隙可以做什么？ 如果不去做，永远要做不完 分解落实到点并有效管理 处理点与点之间的关系与冲突 必须学会不做某事 事情的结果往往和预期不一样 计划中必须要有应急预案 风险管理与预留余地，对于我，感觉是多想想和多想想的区别 渐进式完成，先完成必须要做，在完成做了更好的 明确界定事情的结果 明确且有意义的目标：任务细分+具化量化 转移压力和缓解压力 学会从他人的角度看问题 尽可能满足利益相关者获利条件]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weak源码]]></title>
    <url>%2F2017%2F04%2F26%2Fweak%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;直接上源码吧，源码地址，我就写写我感兴趣的部分吧 1 内存属性类型123456789101112/*&quot;Unknown&quot; includes non-object ivars and non-ARC non-__weak ivars&quot;Strong&quot; includes ARC __strong ivars&quot;Weak&quot; includes ARC and new MRC __weak ivars&quot;Unretained&quot; includes ARC __unsafe_unretained and old GC+MRC __weak ivars*/typedef enum &#123;objc_ivar_memoryUnknown, // unknown / unknownobjc_ivar_memoryStrong, // direct access / objc_storeStrongobjc_ivar_memoryWeak, // objc_loadWeak[Retained] / objc_storeWeakobjc_ivar_memoryUnretained // direct access / direct access&#125; objc_ivar_memory_management_t; &emsp;&emsp;提问assign应该算到哪一个？答案unknown！copy呢？ 2 添加weak123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// Update a weak variable.// If HaveOld is true, the variable has an existing value // that needs to be cleaned up. This value might be nil.// If HaveNew is true, there is a new value that needs to be // assigned into the variable. This value might be nil.// If CrashIfDeallocating is true, the process is halted if newObj is // deallocating or newObj&apos;s class does not support weak references. // If CrashIfDeallocating is false, nil is stored instead.template &lt;bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123;assert(HaveOld || HaveNew);if (!HaveNew) assert(newObj == nil);Class previouslyInitializedClass = nil;id oldObj;/*声明新旧两个散列表，防止数据污染SideTable 下面有介绍*/SideTable *oldTable;SideTable *newTable;// Acquire locks for old and new values.// Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us.retry:if (HaveOld) &#123;oldObj = *location;/*SideTables的初始化很有意思，既不是在C++ static初始化时干的，也不是全局初始化时干的而是在runtime第一次初始化时干的*/oldTable = &amp;SideTables()[oldObj];&#125; else &#123;oldTable = nil;&#125;if (HaveNew) &#123;newTable = &amp;SideTables()[newObj];&#125; else &#123;newTable = nil;&#125;SideTable::lockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);/*if (HaveOld &amp;&amp; *location != oldObj)有两个作用：1，因为有goto retry重试机制，可用此if来判断是否处理过location2，预防多线程问题*/if (HaveOld &amp;&amp; *location != oldObj) &#123;SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);goto retry;&#125;// Prevent a deadlock between the weak reference machinery// and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa.if (HaveNew &amp;&amp; newObj) &#123;Class cls = newObj-&gt;getIsa();if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123;SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);/*我对上面说通过initialize来防止deadlock很感兴趣，到底怎么才会死锁？又怎么防止？*/_class_initialize(_class_getNonMetaClass(cls, (id)newObj));// If this class is finished with +initialize then we&apos;re good.// If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself)// then we may proceed but it will appear initializing and // not yet initialized to the check above.// Instead set previouslyInitializedClass to recognize it on retry.previouslyInitializedClass = cls;goto retry;&#125;&#125;// Clean up old value, if any.if (HaveOld) &#123;weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);&#125;// Assign new value, if any.if (HaveNew) &#123;newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating);// weak_register_no_lock returns nil if weak store should be rejected// Set is-weakly-referenced bit in refcount table.// 关于TaggedPointer https://www.infoq.cn/article/deep-understanding-of-tagged-pointerif (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123;newObj-&gt;setWeaklyReferenced_nolock();&#125;// Do not set *location anywhere else. That would introduce a race.*location = (id)newObj;&#125;else &#123;// No new value. The storage is not changed.&#125;SideTable::unlockTwo&lt;HaveOld, HaveNew&gt;(oldTable, newTable);return (id)newObj;&#125; 问题1 initialize deadlock1234567891011121314151617181920212223242526272829303132333435/************************************************************************ +initialize deadlock case when a class is marked initializing while * its superclass is initialized. Solved by completely initializing * superclasses before beginning to initialize a class.** OmniWeb class hierarchy:* OBObject * | ` OBPostLoader* OFObject* / \* OWAddressEntry OWController* | * OWConsoleController** Thread 1 (evil testing thread):* initialize OWAddressEntry* super init OFObject* super init OBObject * [OBObject initialize] runs OBPostLoader, which inits lots of classes...* initialize OWConsoleController* super init OWController - wait for Thread 2 to finish OWController init** Thread 2 (normal OmniWeb thread):* initialize OWController* super init OFObject - wait for Thread 1 to finish OFObject init** deadlock!** Solution: fully initialize super classes before beginning to initialize * a subclass. Then the initializing+initialized part of the class hierarchy* will be a contiguous subtree starting at the root, so other threads * can&apos;t jump into the middle between two initializing classes, and we won&apos;t * get stuck while a superclass waits for its subclass which waits for the * superclass.**********************************************************************/ 问题2 weak_register_no_lock 为啥是no_lock？1因为不关心！查看源码过程中，发现会有判断各种入参！ 问题3 weak的引用计数？不关心，直接加到哈希表里！到时候直接清空哈希表12345678910111213141516171819202122232425/** * Add new_entry to the object&apos;s table of weak references.* Does not check whether the referent is already in the table.*/static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)&#123;weak_entry_t *weak_entries = weak_table-&gt;weak_entries;assert(weak_entries != nil);size_t begin = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask);size_t index = begin;size_t hash_displacement = 0;while (weak_entries[index].referent != nil) &#123;index = (index+1) &amp; weak_table-&gt;mask;if (index == begin) bad_weak_table(weak_entries);hash_displacement++;&#125;weak_entries[index] = *new_entry;weak_table-&gt;num_entries++;if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123;weak_table-&gt;max_hash_displacement = hash_displacement;&#125;&#125; 3 移除weak12345678910111213141516171819202122232425262728293031323334353637383940414243444546// dealloc -&gt; _objc_rootDeallocstatic id _object_dispose(id anObject) &#123;if (anObject==nil) return nil;objc_destructInstance(anObject);// 这个有意思！将isa指向nil，防止销毁“类对象”和元类anObject-&gt;initIsa(_objc_getFreedObjectClass ()); free(anObject);return nil;&#125;// Slow path of clearDeallocating() // for objects with nonpointer isa// that were ever weakly referenced // or whose retain count ever overflowed to the side table.NEVER_INLINE voidobjc_object::clearDeallocating_slow()&#123;assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc));SideTable&amp; table = SideTables()[this];table.lock();if (isa.weakly_referenced) &#123;weak_clear_no_lock(&amp;table.weak_table, (id)this);&#125;if (isa.has_sidetable_rc) &#123;table.refcnts.erase(this);&#125;table.unlock();&#125;/** * Called by dealloc; nils out all weak pointers that point to the * provided object so that they can no longer be used.* * @param weak_table * @param referent The object being deallocated. */void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weakSelf和strongSelf]]></title>
    <url>%2F2017%2F04%2F08%2FweakSelf%E5%92%8CstrongSelf%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前几天水完了__block，这次水水weakself和strongself吧 1 不使用weak&emsp;&emsp;待测试代码12345678910@implementation Person- (void)test &#123;// __weak typeof(self) weakSelf = self;void (^myblock)(void) = ^&#123;// __strong typeof(weakSelf)self = weakSelf;NSLog(@&quot;%@&quot;,weakSelf);&#125;;myblock();&#125;@end &emsp;&emsp;使用clang编译命令,参考:How to use __weak reference in clang?1clang -rewrite-objc -fobjc-arc -stdlib=libc++ -mmacosx-version-min=10.7 -fobjc-runtime=macosx-10.7 -Wno-deprecated-declarations keke.m &emsp;&emsp;打开编译后cpp文件，找到@implementation Person1234567891011121314151617struct __Person__test_block_impl_0 &#123;struct __block_impl impl;struct __Person__test_block_desc_0* Desc;Person *const __strong self;__Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *const __strong _self, int flags=0) : self(_self) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void _I_Person_test(Person * self, SEL _cmd) &#123;void (*myblock)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, self, 570425344));((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);&#125; &emsp;&emsp;通过编译后源码得知，不使用weak时，Block捕获self，并强持有! 这时如果self也持有Block，就会造成循环引用1Person *const __strong self; 2 使用weakself&emsp;&emsp;删除上面weak的注释，使用clang编译 &emsp;&emsp;打开编译后cpp文件，找到@implementation Person。找到weakself相关代码123456789101112131415161718struct __Person__test_block_impl_0 &#123;struct __block_impl impl;struct __Person__test_block_desc_0* Desc;Person *const __weak weakSelf;__Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void _I_Person_test(Person * self, SEL _cmd) &#123;__attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;void (*myblock)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, weakSelf, 570425344));((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);&#125; &emsp;&emsp;objc_ownership字面意思是：对象的所有权，即Block中weakSelf的所有权为weak 3 使用weakself，也使用strongself&emsp;&emsp;删除上面weak和strong的注释，使用clang编译 &emsp;&emsp;打开编译后cpp文件，找到@implementation Person。123456789101112131415161718192021222324252627/***********这段和2 只有weak没strong时一样************/struct __Person__test_block_impl_0 &#123;struct __block_impl impl;struct __Person__test_block_desc_0* Desc;Person *const __weak weakSelf;__Person__test_block_impl_0(void *fp, struct __Person__test_block_desc_0 *desc, Person *const __weak _weakSelf, int flags=0) : weakSelf(_weakSelf) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void _I_Person_test(Person * self, SEL _cmd) &#123;__attribute__((objc_ownership(weak))) typeof(self) weakSelf = self;void (*myblock)(void) = ((void (*)())&amp;__Person__test_block_impl_0((void *)__Person__test_block_func_0, &amp;__Person__test_block_desc_0_DATA, weakSelf, 570425344));((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);&#125;/***********这段和2 只有weak没strong时一样************/static void __Person__test_block_func_0(struct __Person__test_block_impl_0 *__cself) &#123;Person *const __weak weakSelf = __cself-&gt;weakSelf; // bound by copy__attribute__((objc_ownership(strong))) typeof(weakSelf)self = weakSelf;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_883428_mi_0,self);&#125; &emsp;&emsp;综上Block捕获self时是weak的，这样能打破循环引用，在Block函数内部又对self声明所有权为strong，此时strongself的生命周期同Block函数生命周期一直，保证了在Black函数内部self是存在的 4 weakself是不是必须的？&emsp;&emsp;先献上大神的文章： 使用 Heap-Stack Dance 替代 Weak-Strong Dance，优雅避开循环引用 &emsp;&emsp;原理：利用了“参数”的特性：参数是存放在栈中的(或寄存器中)，系统负责回收，开发者无需关心。因为解决问题的思路是：将 block 会捕获变量到堆上的问题，化解为了：变量会被分配到栈(或寄存器中)上 &emsp;&emsp;实现方法就是：把self当做参数手动传给block，而不是通过Block的被动去捕获self &emsp;&emsp;其实我们一直在用只是没有注意到，例如FMDB里123456789- (void)inDatabase:(__attribute__((noescape)) void (^)(FMDatabase *db))block;- (void)inTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;- (void)inDeferredTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;- (void)inExclusiveTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block;- (void)inImmediateTransaction:(__attribute__((noescape)) void (^)(FMDatabase *db, BOOL *rollback))block; 5 @weakify和@strongify&emsp;&emsp;写到weakself就不得不提到RAC的@weakify和@strongify！说来惭愧，接触RAC很长一段时间了，源码也研究过一些！但始终也没写出点什么！整体框架太大，写不了！细节又太小，又不想写…… &emsp;&emsp;先看看一般情况下怎么写12#define BBWeakSelf(type) __weak typeof(type) weak##type = type#define BBStrongSelf(type) __strong typeof(type) type = weak##type &emsp;&emsp;是不是很lou？现在打开RACEXTScope.h文件，找到12345678910#define weakify(...) \rac_keywordify \metamacro_foreach_cxt(rac_weakify_,, __weak, __VA_ARGS__)#define strongify(...) \rac_keywordify \_Pragma(&quot;clang diagnostic push&quot;) \_Pragma(&quot;clang diagnostic ignored \&quot;-Wshadow\&quot;&quot;) \metamacro_foreach(rac_strongify_,, __VA_ARGS__) \_Pragma(&quot;clang diagnostic pop&quot;) &emsp;&emsp;先看rac_keywordify，作用是添加@符号，这也是比BBWeakSelf牛逼的不止一点点！12345678910111213141516// Details about the choice of backing keyword://// The use of @try/@catch/@finally can cause the compiler to suppress// return-type warnings.// The use of @autoreleasepool &#123;&#125; is not optimized away by the compiler,// resulting in superfluous creation of autorelease pools.//// Since neither option is perfect, and with no other alternatives, the// compromise is to use @autorelease in DEBUG builds to maintain compiler// analysis, and to use @try/@catch otherwise to avoid insertion of unnecessary// autorelease pools.#if DEBUG#define rac_keywordify autoreleasepool &#123;&#125;#else#define rac_keywordify try &#123;&#125; @catch (...) &#123;&#125;#endif &emsp;&emsp;metamacro_foreach最后也是调的metamacro_foreach_cxt，点到最后发现是 A ## B ， ## 是宏连接符，会将 ## 左右两边连接起来，整体替换下来是12autoreleasepool &#123;&#125;metamacro_foreach_cxt1(rac_weakify_, , __weak, self) &emsp;&emsp;接着看rac_weakify_是怎么回事12345#define rac_weakify_(INDEX, CONTEXT, VAR) \CONTEXT __typeof__(VAR) metamacro_concat(VAR, _weak_) = (VAR);#define rac_strongify_(INDEX, VAR) \__strong __typeof__(VAR) VAR = metamacro_concat(VAR, _weak_); &emsp;&emsp;最终替换成如下代码，和编译后的weak和strong几乎一模一样123@autoreleasepool &#123;&#125; __attribute__((objc_ownership(weak))) __typeof__(self) self_weak_ = (self);@autoreleasepool &#123;&#125; __attribute__((objc_ownership(strong))) __typeof__(self) self = self_weak_; &emsp;&emsp;折腾这么一大圈的原因是@weakify(…);可以支持最多20个参数1* For each consecutive variadic argument (up to twenty) &emsp;&emsp;参考：剖析RAC中的@weakify、@strongify]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__block]]></title>
    <url>%2F2017%2F04%2F02%2Fblock%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;水一水block到底怎么回事吧！ &emsp;&emsp;待测试方法12345678910#import &lt;Foundation/Foundation.h&gt;int main(int argc, char * argv[]) &#123;__block int age = 10;void (^myblock)(void) = ^&#123;NSLog(@&quot;%d&quot;,age);&#125;;age = 20;myblock();&#125; &emsp;&emsp;clang编译成C++,参考：How to translate Objective-C code to C++ with ARC enabling1clang -rewrite-objc main.m &emsp;&emsp;打开mian.cpp文件拉到最后发现如下代码1234567891011121314151617181920212223242526272829303132333435363738394041struct __Block_byref_age_0 &#123;void *__isa;__Block_byref_age_0 *__forwarding;int __flags;int __size;int age;&#125;;struct __main_block_impl_0 &#123;struct __block_impl impl;struct __main_block_desc_0* Desc;__Block_byref_age_0 *age; // by ref__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;__Block_byref_age_0 *age = __cself-&gt;age; // bound by refNSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_main_8a7d1e_mi_0,(age-&gt;__forwarding-&gt;age));&#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;age, (void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123;size_t reserved;size_t Block_size;void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main(int argc, char * argv[]) &#123;__attribute__((__blocks__(byref))) __Block_byref_age_0 age = &#123;(void*)0,(__Block_byref_age_0 *)&amp;age, 0, sizeof(__Block_byref_age_0), 10&#125;;void (*myblock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, 570425344));(age.__forwarding-&gt;age) = 20;((void (*)(__block_impl *))((__block_impl *)myblock)-&gt;FuncPtr)((__block_impl *)myblock);&#125;static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;; &emsp;&emsp;直接看main函数，可知使用 block后编译器将age包装成 Block_byref_age_0对象1234567struct __Block_byref_age_0 &#123;void *__isa; // age类型__Block_byref_age_0 *__forwarding; // 重定位用int __flags;int __size; // 内存大小int age; // 实际上的age&#125;; &emsp;&emsp;再看myblock的构成1void (*myblock)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_age_0 *)&amp;age, 570425344)); &emsp;&emsp;核心是__main_block_impl_01234567891011struct __main_block_impl_0 &#123;struct __block_impl impl; struct __main_block_desc_0* Desc;__Block_byref_age_0 *age; // by ref__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_age_0 *_age, int flags=0) : age(_age-&gt;__forwarding) &#123;impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = flags;impl.FuncPtr = fp;Desc = desc;&#125;&#125;; &emsp;&emsp;__block_impl是block的具体类型123456struct __block_impl &#123;void *isa; // block类型，分为3类：__NSGlobalBlock__全局区；__NSStackBlock__ 栈区；__NSMallocBlock__ 堆区int Flags; // 标志位int Reserved; // 这里为voidvoid *FuncPtr; // block块里具体执行代码的匿名函数&#125;; &emsp;&emsp;main_block_func_0是具体实现的匿名函数；main_block_desc_0_DATA表示对block内部参数变量等的引用计数管理(可随便加个变量检验例如 __block int age = 10; ) &emsp;&emsp;综上main_block_impl_0存储了block捕获的外部变量age并包装了下！这也解释了为什么用block修饰的变量可以在block内部修改！Block只有的是Block_byref_age_0对象，此对象不可变；但Block_byref_age_0通过(age.forwarding-&gt;age) = 20;的方式可以操纵__Block_byref_age_0对象内部的age对象的数值]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__attribute__笔记]]></title>
    <url>%2F2017%2F03%2F21%2Fattribute-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1 format123456#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))// “archetype”指定是哪种风格,这里是NSString；// “string-index”指定传入函数的第几个参数是格式化字符串；// “first-to-check”指定第一个可变参数所在的索引.format (archetype, string-index, first-to-check) 2 availability12345NS_DEPRECATED_IOS(2_0, 7_0, &quot;Use -sizeWithAttributes:&quot;)// 宏展开以后如下__attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;&quot;__VA_ARGS__)));// 例- (void)oldMethod:(NSString *)string __attribute__((availability(ios,introduced=2_0,deprecated=7_0,message=&quot;用 -newMethod: 这个方法替代 &quot;))); 3 unavailable &amp; deprecated&emsp;&emsp;unavailable告诉编译器该方法不可用，如果强行调用编译器会提示错误12- (void)method1 NS_UNAVAILABLE;- (void)method2 __attribute__((unavailable(&quot;不能用了，&quot;))); &emsp;&emsp;deprecated告诉用户方法被废弃，强行用提示警告12- (void)method1 DEPRECATED_ATTRIBUTE; - (void)method2:( NSString *)string __attribute__((deprecated(&quot;警告不要用了，可用xxx&quot;))); 4 nonnull &amp; nullable&emsp;&emsp;参考1234567// 对于属性、方法返回值、方法参数的修饰，使用：nonnull/nullable；@property(nonatomic, copy, nullable) NSString *str;- (nullable NSString*)method;- (void)formatString:(nullable NSString *)str;// 对于 C 函数的参数、Block 的参数、Block 返回值的修饰，使用：_Nonnull/_Nullable- (void)methodWithBlock:(id _Nonnull (^ _Nullable)(id _Nullable params))block; 5 always_inline 强制内联，好像没啥用12345678910/*内联函数不是在调用时发生控制转移(没有寻址、压栈入栈等操作)，而是在编译时将函数体嵌入在每一个调用处好处是:快代码的执行，减少系统开销.适用场景:A 这个函数更小;B这个函数不被经常调用*/ // 内联函数的一般写法static inline void af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;Method originalMethod = class_getInstanceMethod(theClass, originalSelector);Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);method_exchangeImplementations(originalMethod, swizzledMethod);&#125; 6 objc_requires_super&emsp;&emsp;子类复写父类方法时必须调用父类方法1234567891011121314@interface Father : NSObject- (void)hailHydra __attribute__((objc_requires_super));@end@implementation Father- (void)hailHydra &#123;NSLog(@&quot;hail hydra!&quot;);&#125;@end@interface Son : Father@end@implementation Son- (void)hailHydra &#123;&#125; // &lt;--- Warning missing [super hailHydra]@end 7 cleanup&emsp;&emsp;声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数！1234567891011121314- (void)test&#123;int a __attribute__((cleanup(intCleanup))) = 10;&#125;/*注意点:指定的函数传递的参数是变量的地址作用域的结束包括:大括号结束、return、goto、break、exception等情况当作用域内有多个cleanup的变量时,遵守 先入后出 的栈式结构.*///这里传递的参数是变量的地址void intCleanup(int *num)&#123;NSLog(@&quot;cleanup------%d&quot;,*num);&#125; &emsp;&emsp;,cleanup先于对象的dealloc执行。更多可看黑魔法attribute((cleanup)) 8 objc_subclassing_restricted&esmp;&emsp;使用这个属性可以定义一个 Final Class，也就是说，一个不可被继承的类1234__attribute__((objc_subclassing_restricted))@interface Eunuch : NSObject@end// 现在没人能继承Eunuch 9 enable_if&esmp;&emsp;参数静态检查，只能用在C函数上1234static void printValidAge(int age)__attribute__((enable_if(age &gt; 0 &amp;&amp; age &lt; 120, &quot;你丫火星人？&quot;))) &#123;printf(&quot;%d&quot;, age);&#125; 10 overloadable&esmp;&emsp;C函数实现类似java的重载1234567__attribute__((overloadable)) void print(NSString *string)&#123;NSLog(@&quot;%@&quot;,string);&#125;__attribute__((overloadable)) void print(int num)&#123;NSLog(@&quot;%d&quot;,num);&#125; 参考 Clang Attributes 黑魔法小记 attribute 总结 Objective-C 中 nullable、__nullable、_Nullable 的区别]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RN分享之后]]></title>
    <url>%2F2017%2F03%2F11%2FRN%E5%88%86%E4%BA%AB%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;RN出来之后，我自己学过，当时为了学RN，还专门复习了早就忘记的JavaScript，但一直没有正式用到项目上，仅限于自己学习！来度厂之后正好组内还没人分享过RN的使用，就借这个机会对RN进行简单的介绍！预计分享时间一个小时，主要听众是iOS童鞋、安卓童鞋以及部分FE童鞋！但整个分享过后，应者寥寥，甚至出现了短时间的沉默，不得不提前几分钟左右终止了分享！当然引入RN这件事也随之化为泡影！虽然会后领导还是对我的分享表示了赞扬，但作为试用期的第一次“露脸”还是比较尴尬的！ &emsp;&emsp;会后我对分享内容进行了反思：首先我分享的是RN入门级知识，并没有介绍JavaScript语言细节，也没有深入去探讨RN的高级用法，对于有两三年开发经验的RD应该不存在“鸿沟”；其次我主要介绍RN的使用以及优势、劣势和引入成本，优势劣势引入成本这些东西都不涉及到具体代码都是理论上的东西，大多数人都应该能听懂；最后我的分享范围很小，仅限于大前端组内童鞋的十几个人！而且在整个分享过程中我认为我把我罗列的提纲，基本上都说完了； &emsp;&emsp;再后来与同事闲聊时发现，最大的问题在于，iOS、安卓和FE童鞋，三个端的同学都只看明白一部分：iOS和安卓童鞋大概看明白界面展示，但对于javascript则一知半解；FE童鞋正好相反；如果要引入RN，iOS和安卓同学需要学习javaScript, 而FE童鞋则可能需要了解iOS和安卓知识；其实只是学习新语言对程序猿而言并不是什么大事，程序猿每天都在学习新东西！麻烦的是使用和学习RN，很可能要对Javascript、iOS和安卓都有所涉猎才行，强类型与弱类型之争、各种版本的iOS安卓系统的坑，困难的调试等问题已足以让团队成员放弃RN，更何况还有一条十万分之二的crash红线… &emsp;&emsp;说到底这次分享冷场还是自己的问题：选题不太好、问题考虑的不太充分、没有正确认清产品现状 &emsp;&emsp;PS: 其实这次我本来打算水一水RN的基本使用，但经历了失败的分享，标题也从RN入门变成了RN分享之后，但不管怎样！也算水了一篇吧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用操作]]></title>
    <url>%2F2017%2F03%2F02%2FGit%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;说来也奇葩，工作了好几年一直用的svn，Git只是听说过没有过！来了度厂发现都是用的Git（甚至码神训练营还专门讲Git的使用）慢慢的才发现Git真好用！这不又不知道水什么了，拿Git充数吧 Git&emsp;&emsp;Git是目前世界上最先进的分布式版本控制系统！Linus（创建Linux的大牛）花了两周时间用C语言写了Git！而我花了两周都没学会怎么用！！！ &emsp;&emsp;Mac上安装Git最简单的方式：安装XCode，运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 &emsp;&emsp;推荐使用SourceTree管理Git，简单、强大又免费！会用SourceTree的可以不用看了！ Git命令&emsp;&emsp;安利一个命令行工具：iTerm，感觉比自带的好 初始化一个Git仓库 12// 切换到一个目录，创建目录同名仓库git init 添加文件到Git仓库，分两步： 1234567891011// 放到暂存区git add &lt;file&gt; 添加，可一次添加多个文件，也可添加多次git add . 添加所有修改文件// 提交到分支git commit -m &lt;message&gt; 提交，message为备注// 合并上次和这一次修改后的，一起提交git commit --amend// 把本地库的内容推送到远程git push origin 状态 1234// 仓库当前的状态git status// 查看文件修改内容git diff &lt;file&gt; 查看历史记录 1234567891011git log// 简化输出信息git log --pretty=oneline// 查询结果如下// HEAD表示当前版本 xxxxx和yyyy是刚才commit的message9e5d99cf787fe37967247e67afce4e4686a3eeab (HEAD -&gt; Test1.4.2, origin/Test1.4.2) Motify xxxxxxxxxccacbbdd367438350515c55e26563b5f47a59e1f modify yyyyyyyy查询自己用过的命令不是提交记录（不要用上下键啦）git reflog 强制版本回滚 1git reset --hard ccacbbdd367438350 一键还原 123456// 只回滚工作区// 如果暂存区有东西（即add过）回滚到暂存区状态；如果暂存区没东西，回滚线上状态git checkout -- &lt;file&gt; // 两个横线// 一键还原工作区和暂存区文件git reset HEAD &lt;file&gt; 删除文件（其实我一直都是直接add来操作的） 1用命令git rm删掉，并且git commit 分支 12345678910111213141516171819// 查看本地分支git branch// 查看本地和远程所有分支git branch -a// 创建并切换到本地分支devgit checkout -b dev // 注意一个横线// 切换回master分支// 一般应保证master是非常稳定的,干活都在dev分支上，dev分支是不稳定的// Git工作区未提交代码，切换分支时，能提交的话就add并commit一起先提交了，不提交的就stash保存一下，就可以切换了git checkout master// 合并指定分支到当前分支，不能看出来git merge dev// 合并分支，能看出来！推荐git merge --no-ff // 有冲突 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 必须首先解决冲突，再提交，合并完成。// 查看分支合并图git log --graph// 删除分支git branch -d &lt;name&gt; 暂存工作区修改 123456// 暂存git stash// 查看所有暂存git stash list// 从暂存中恢复git stash pop 拉取代码 123git pull// 如果git pull提示no trackinginformation，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt; 标签 12345678// 新建标签，用-a指定标签名，-m指定说明文字git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb// 查看所有标签git tag// 删除标签git tag -d v0.1// 推送某个标签到远程git push origin &lt;tagname&gt; 看某个具体的 commit 的改动内容 1git show commitId 参考 Git教程 廖雪峰]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人性的弱点]]></title>
    <url>%2F2017%2F02%2F23%2F%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9%2F</url>
    <content type="text"><![CDATA[人类自然的天性，是做错事只会责备别人，而绝不会责备自己 不要评议人，免得为人所评议 不要批评他们，我们在相同的情形下，也会像他们一样。 尖锐的批评、斥责，、永远不会有效果的。 成功的秘诀，是：「我不说任何人的不好！」他又这样说：「而说我所知道的每一个人的好处！」 不要批评，责怪或抱怨。任何一个愚蠢的人，都会批评人，斥责人，和抱怨人同时，也是绝大部份愚蠢的人才这样做的 我能叫你去做任何事情的唯一方法，那就是把你所需要的给你 人类天性中最深切的冲动，那是「成为重要人物的欲望” 人类天性至深的本质，就是渴求为人所重视。 每个人都喜欢受人恭维。 世界上最容易摧毁一个人志向的，那就是上司所给他的批评。我从来不批评任何人，我只给人们工作的激励。我是急于称赞，而迟于寻错，如果说我喜欢什么的话，那就是诚于嘉许，宽于称道。」 赞赏是出于真诚，而谄媚是虚伪的。 别怕攻击你的敌人，提防谄媚你的朋友 谄媚是明白的告诉别人，他想到他自己的种种 献出你真实，诚恳的赞赏 想想别人的优点；我们就不必措辞卑贱、虚伪，在话 世界上唯一能影响对方的方法，就是谈论他所要的，而且还告诉他，如何才能得到它. 从你来到世界上这一天开始，你所有的每一种举动，出发点都是为了你自己，都是因为你需要些什么 如果有一个成功秘诀的话，那就是如何得到对方立场” 的能力，由他的观点设想，正同由你的观点一样。 很多人，费去一生的光阴在销售工作，却不站在买主的立场论事。他并没有注意到如何帮助我，他祇是注意帮助他自己 你会永远站在别人立场去打算、设想，并由对方的观点，去观察事物的趋向 先激起对方某种迫切的需要，若能做到这点就可左右逢源，否则到处碰壁 表现自己，那是人性最主要的需要。 一种深入、前驱的学习欲望，一个增加你应付他人能力的强烈决心 每周反省比我所尝试的其它任何方法，都更为有益。 如果你时刻关心别人，对别人发生兴趣，在两个月的时间里所交的朋友，要比只想让别人关心你，对你发生兴趣，在两年的时间里所交的朋友还多 如果我们只是想使人注意，使人对我们发生兴趣，我们、水远不会有很多真诚的朋友……朋友，真正的朋友，不是那样造成的 假如我们想交朋友，应该先出来替别人做些事——需要时间、精力、公义、体恤的事 到了有人生日那一天，我就发给他一封贺函，或是贺电。当那人接到贺函，或是贺电时，他是多幺高兴……：．除了他的亲人以外，我是世界上唯一知道他生日的一个朋友。 我真实的对他，就他的问题发生了兴趣，关心他和他切身的问题 微笑是从内心发出的 若干人，开始一桩事业的时候，怀着极大的希望和兴趣，所以能在早期获得部份的成就。当他们对这项工作，感到厌烦、沉闷，失去了原有的兴趣时，他的事业也渐渐走向下坡，终至失败。 如果你希望别人用一副高兴、欢愉的神情来接待你，那么你自己先要用这样的神情去对别人。 改掉原有对人的批评，把斥责人家的话，换成赞赏和鼓励。 快乐是出自自己内在的心情，不需要向外界寻求的 微笑是、永远受人所欢迎的 保持一种正确的心理状态——勇敢、诚实，和乐观 如果你希望人们都喜欢你，第一、强迫你自己微笑，如果你单独一人的时候，吹吹口哨，唱唱歌，尽量让自己高兴起来；第二项规则是：微笑！ 人们如果脸上没有带着笑容，千万别开店 一般人对自己的姓名，比杷世界上所有的姓名堆在一起的总数，还感到重要，和关心。把一个人的姓名记住，很自然的叫出口来，你已对他含有微妙的恭维、赞赏的意味 人们都重视自己的名字，尽量设法让自己的名字留传下去，甚至愿意付出任何的代价 一种最简单、最明显、而又是最重要的如何获得好感的方法，就是记住对方的姓名，使别人感到自己很重要 把一个恼怒的人，变成了一个满意的顾客。他是如何做的？他把这情形分成三个步骤：第一，他让我从头到尾，说出我的经过，他则静静听着，没有插进一句话来。第二，当我讲完那些话后，那两个店员又要开始与我争辩了。可是那负责人，却站在我的观点跟他们辩论；第三，他承认不知道这套衣服，会这样的差劲，而是坦直的对我锐：「你认为我该如何处理这套衣服，你尽管吩咐，我完全可以依照你的意思。』 最爱挑剔的人，最激烈的批评者，往往会在一个怀有忍耐、同情的静听者面前软化下来！这位静听者，必须要有过人的沉着，他必须当着寻衅者像一条大毒蛇张开嘴巴的时候– 静听 如果你要成为一个谈笑风生，受人欢迎的人，你需要静听别人的谈话。就像李夫人所说的：「要使别人对你感到兴趣，先要对别人感到兴趣。」问别人所喜欢回答的问题，鼓励他谈谈他自己，和他的成就。 做一个善于静听的人，鼓励别人多谈谈他们自己。 深入人们心底的最佳途径，就是对那人讲他知道得最多的事物 就别人的兴趣谈论。永远使别人感觉重要. 你希望别人怎样待你，你就该怎样去对待别人。 如何做?何时做？在什么地方做？这个答案是：「所有的时间，任何地点。」 平时客气的话，像「对不起，麻烦你，请你，你会介意吗．．谢谢你！」这些简短的话，可以减少人与人之间的纠纷，同时也自然地表现出高贵的人格来。 凡我所遇到的人，都有比我优越的地方，而在那些方面，我能向他学习。 有一条最明显的真理，就是你所遇到的任何人，几乎每个人，都觉得自己某方面比你优秀。可是有一个方法，可以深入他的心底——就是让他觉得你承认他在自己的小天地里，是高贵重要的，要真诚的承认 你只要对女人谈论她自己就行了。 使别人感觉到他的重要——必需真诚的这样做。 第一项规则：真诚的对别人发生兴趣。 第二项规则：微笑。 第三项规则：记住你所接触中，每一个人的姓名。 第四项规则：做一个善于静听的人，鼓励别人多谈谈他们自己。 第五项规则：就别人的兴趣谈论。 第六项规则：使别人感觉到他的重要——必需真诚的这样做。 你不可能在争辩中获胜 永远避免正面的冲突，那才是对的 天下只有一种方法，能得到辩论的最大胜利，那就是尽量避免辩论………避免辩论，就像避开毒蛇和地震一样。 你必需要知道，当人们逆着自己的意见，被人家说服时，他仍然会固执的坚持自己是对的。 一个真正成功的推销员，他决不会跟顾客争辩，即使轻微的争辩，也加以避免………人类的思想，不是那么容易改变的 如果你辩论、反驳，或许你会得到胜利，可是那胜利是短暂、空虚的………你永远得不到，对方给你的好感 我们要让顾客、爱人、丈夫、或者是妻子，在细小的争论上，胜过我们。 一个成大事的人，不能处处计较别人，消耗自己的时闲去和人家争论。无谓的争论，对自己性情上不但有所损害，且会失去自己的自制力。在尽可能的情形下，不妨对人谦让一点。与其跟一只狗子路走，不如让狗先走一步。如果给狗咬了一口，你即使把这只狗打死，也不能治好你的伤口。 在辩论中，获得最大利益的唯一方法，就是避免辩论。 你可以用神态、声调，或是手势，告诉一个人他错了，就像我们用话一样的有效……而如果你告诉他错了，你以为他会感激你？不，永远不会！因为你伤了他的自尊。 如果你要纠正某人的错误，就不应该直率的告诉他；而要运用一种非常巧妙的方法，才不会把对方得罪了。 普天下的人，决不会责怪你说这样的话：「或许是不对的，让我们看看，究竟是怎么一回事！」 我们有时发现自己会在毫无抵抗和阻力中，改变自己的意念。可是，如果有人告诉我们所犯的错误，我们却会感到懊恼和怀恨。我们不会去注意一种意念养成，可是当有人要抹去我们那股意念时，我们对这份意念突然坚实而固执起来。并非是我们对那份意念有强烈的偏爱，而是我们自尊受到了损伤。 如果有人硬把不合胃口的事实，往我们的喉咙塞下去，我们是无法接受下来的。 换句话说，别跟你的顾客、丈夫，或是敌手争辩，别指摘他错了，别激怒他，而不妨用点外交手腕。 别跟你的顾客、丈夫，或是敌手争辩，别指摘他错了，别激怒他，而不妨用点外交手腕。 尊重别人的意见，永速别指摘对方是错的。 假如我们已知道一定要受到责罚，那我们何不先责备自己，找出自己的缺点，那是不是比从别人嘴说出的批评，要好受得多 当我们错误的时候，我们要快速的、坦直的承认我们的错误。运用这种方法，不但能获得惊人的效果，而且在若干情形下，比替自己辩护更为有趣 用争夺的方法，你永远无法得到满足。可是当你谦让的时候，你可以得到比你所期望的更多 如果你错了，迅速、郑重的承认下来。 如果你握紧了两个拳头来找我，我可以告诉你，我的拳头会握得更紧。 友善的对他，赞许他、夸奖他，相信这办法，一定非常有效 温柔、友善的力量，永远胜过愤怒和暴力。 慈爱、友善的接近，能使人改变了他原有的心意，那比暴力的攻击更为有效 以友善的方法开始。 跟人们谈话时，别开始就谈你们意见相左的事，不妨谈些彼此间赞同的事情。如果可能的话，你更应该提出你的见解，告诉对方，你们所追求的是同一个目标，所差异的祇是方法而已。 有说话技巧的人，开始的时候就能得到很多「是」的反应，唯有如此，他才能将听者的心埋，导向正面方向。 争辩并不是一个聪明的办法。要从对方的观点去看事，设法让别人回答『是，是』，那才是一套成功的办法 处理一个抱怨者的安全手法，必需要忍耐的怀着舒畅的心情，静静的听着，而且用最诚恳的态度鼓励他，让他把所要说的话，完全说完。 如果你想得到仇人，你就胜过你的朋友，可是，如果想获得更多的朋友，就让你的朋友胜过你 你要获得对方对你的同意，第六项规则是：尽量让对方有多说话的机会 生命是短促的，别把我们不值一提的成就，作为谈话的资料，令人听了厌烦。我们要鼓励别人多说话。仔细想一想，你实在没有什么可以夸耀的。 你对你自己所发现的意念，是不是比别人代你说出的更信得过？如果是的话，你把你的意见，硬生生塞下别人喉咙里，这是不是错误的观念？如果提出意见，启发别人自己去得到他的结论，这不是一个更聪明的辨法吗？ 没有人喜欢强迫自己去买一样东西，或是被人派遣去做一件事。我们都喜欢随自已的心愿买东西，或是照着自己的意思去做事情。同时，希望有人跟我们谈谈我们的愿望、需要、想法 凡是都很费事的去征求别人的意见，且对他们的建议表示尊重 你要影响别人而使人同意于你，第七项规则是：使对方以为这是他的意念。 当对方并不承认有错误时，试着去了解对方，去原谅对方。 多学些待人的技巧，学学各种与人相处的手腕，常从别人的观点去看事物 当我们希望别人完成一件事的时候，不妨闭上眼睛，稍微想一想……把整个的情形，由对方的出发点来想一想！然后问自己：「他为什么要如此做？ 当你接触到每一件事时，会处处替别人着想。而且以对方的观点，去观察这件事情 要真诚的以他人的观点去看事情。 对你所感觉到的情形，我一点也不会责怪你，如果我是你的话，我也有同样的感觉。 你明天遇到的人，其中可能有四分之三都饥渴似的需要同情…．！如果你同情他们，他们就会喜欢你。 同情是消解恶感最有效的药物 人类普遍的追求同情，孩子们会急切的显示他受伤的地方。有的甚至于故意自己割伤、弄伤，以博得大人们的同情 你要获得别人对你的同意，第九项规则是：同情对方的意念和欲望。 要改变一个人的意志，需要激发他高尚的动机 你要当那位顾客是恳切、诚实、可靠的，且他是极愿意付帐的。一旦使他相信那帐目是对的，他会毫不迟疑的乐意债还。也就是说，人们都是诚实的，而且愿意履行他们该有的义务。 实行、推进，别停顿下来 如果我们想要完成一件事，必须鼓励竞争，那并不是说争着去赚钱，而是要有一种胜过别人的欲望 争胜的欲望加上挑战的心理，对一个有血气的人来说，是一种最有效的激励。 任何一个成功的人，都喜爱的竞技．！因为那是个表现他自己的机会，证明他的能力、价值胜过别人。 第一项规则：在辩论中，获得最大利益的唯一方法，就是避免辩论。 第二项规则：尊重别人的意见，永远别指摘对方是错的。 第三项规则：如果你错了，迅速、郑重的承认下来。 第四项规则：以友善的方法开始。 第五项规则：使对方很快的回答「是！是！」。 第六项规则：尽量让对方，有多说话的机会。 第七顼规则：使对方以为这是他的意念。 第八项规则：要真诚的以他人的观点去看事情。 第九项规则：同情对方的意念和欲望。 第十项规则：激发更高尚的动机。 第十一项规则：使你的意念戏剧化。 第十二项规则：提出一个挑战。 当我们听到别人对我们的称赞后，如果再听到其它不愉快的话，就比较容易接受了。 不使对方难堪、反感，而改变一个人的意志，第一项规则是：用称赞和真诚的欣赏作开始。 我们要劝阻一件事，永远躲开正面的批评这是必需要记住的。如果有这个必要的话，我们不妨旁敲侧击的去暗示对方。对人正面的批评，那会毁损了他的自重，剥夺了他的自尊。如果你旁敲侧击，对方知道你用心良善，他不但接受，而且还会感激你。 所以要改变人们的意志，而不引起对方的反感，第二项规则是：间接的指出人们的过错。 如果批评的人，开始先谦冲的承认自己也不是十全十美的、无可指责的，然后再指出人们的错误，这样就比较容易让人接受了。 在批评对方之前，不妨先谈谈你自己的错误。 措辞，始终是建议，而不是命令 发问时，别用直接的命令。 顾全到一个人的面子，那是多么重要 即使只有稍微的进步，我们也要称赞，这样可以鼓励别人继续进步。 我们具有各种潜在的能力，可是却惯于不会利用 称赞最细微的进步，而且称赞每一个进步。 一般人，都会愿意接受指导，如果你得到他的敬重，并且对他的某种能力表示敬重的话。 如果你想改善一个人某方面的缺点，你要表示出，他已经具有这方面的优点了 给人一个美名让他去保全，每一个人都愿意竭尽其所能，保持别人赠予他的美誉。 多给人们一些鼓励，把事情看成很容易。使对方知道，你对他有信心，他有尚未发展出的才干，那他就会付出最大的努力，争取到这个胜利。 用鼓励，使你要改正的错误，看来很容易做到；使你要对方所做的事，好象很容易做到。 永远使人们乐意去做你所建议的事。 第一项规则：用称赞和真诚的欣赏作开始。 第二项规则：间接的指出人们的错误。 第三项规则：在批评对方之前，不妨先谈谈你自己的过错。 第四项规则：发问时，别用直接的命令。 第五项规则：顾全对方的面子。 第六项规则：称赞最细微的进步，而且称赞每一个进步。 第七项规则：给人们一个美名让他去保全。 第八项规则：用鼓励，使你要改正的错误，看来很易做到；使你要对方所做的事，好象很易做到。 第九项规则：使人们乐意去做你所建议的事。 使对方有一种自重、高贵的感觉 我们需要尽量鼓起对方的自尊心，但不是运用谄媚，或是虚伪，如果引误了这个出发点，是绝不会有效果的。 必需记住：我们每一个人，都是希望如何被人欣赏、如何被人重视……甚至会不顾一切的去达到这个目的。可是，没有人会接受不诚恳的、虚伪的奉承。 我愿意再说一遍：这书中所告诉你的原则，必需出自由衷才会有效果出现。我不希望人们用奸诡的骗术，去欺骗人家;而我所讲的，只是一种新的生活方式。 男人离开家庭的一个主要原因，那是因为他们的妻子又吵又闹，喋喋不休 从来不批评她，他在她面前，从不说出一句责备的话…！如果有人嘲笑她时，他立即为她强烈的辩护。 跟人们交住，第一件应学的事，那是不干涉人们自己原有那种特殊快乐的方法 婚姻的成功，那不祗是寻找一个适当的人，而是自已该如何做一个适当的人 别尝试改造你的伴侣 不要批评。 给予真诚的欣赏。 自古到现在，鲜花是代表爱情的语言 对你所敬爱的人，表示你常想念着她，你希望她愉快。而她的欢愉、快乐，也会使你有同样的感受。 这条路，我只能经过一次，所以，凡我所能为人做的任何好事，任何一点仁慈，让我现在就做吧！不要迟延，不要忽略，因为我将不会再从这里经过了。 礼貌是内心的一种特质，它可以教人忽略破旧的园门，而专心注意到园内的好花 礼貌在我们婚后的生活中，就像汽车离不开汽油一样。 第一项规则：切莫喋喋不休。 第二项规则：别尝试改造你的伴侣。 第三项规则：不要任意的批评。 第四项规则：给予真诚的欣赏。 第五项规则：随时注意琐碎、细微的小地方。 第六项规则：要有礼貌。 第七项规则：阅读一本有关婚姻中性生活方面的好书。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设备标识符]]></title>
    <url>%2F2017%2F01%2F24%2F%E8%AE%BE%E5%A4%87%E6%A0%87%E8%AF%86%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[利用keyChain和UUID永久获得设备的唯一标识&emsp;&emsp;将获取的UUID永久存储在设备的KeyChain中, 这个方法在应用第一次启动时, 将获取的UUID存储进KeyChain中, 每次取的时候, 检查本地钥匙串中有没有, 如果没有则需要将获取的UUID存储进去。当你重启设备, 卸载应用再次安装,都不影响, 只是当设备刷机时, KeyChain会清空, 才会消失, 才会失效。&emsp;&emsp;PS：KeyChain使用工具 SFHFKeychainUtils 其他方案介绍IDFA 广告标识符, 由于广告是要赚钱的，所以广告标识符是唯一的。 iOS 10之后，如果用户手动限制广告跟踪（通用-&gt;隐私-&gt;广告-&gt;限制广告跟踪）的话，IDFA返回的都是0123456789#import &lt;AdSupport/AdSupport.h&gt;NSString *IDFA = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];//判断IDFA是否为空BOOL isEmpty = [[IDFA stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;] stringByReplacingOccurrencesOfString:@&quot;0&quot; withString:@&quot;&quot;].length;if (isEmpty) &#123;NSLog(@&quot;广告标识不为空：%@&quot;,IDFA);&#125; 使用MAC地址来识别设备，因为MAC地址也唯一的识别了一台设备并且不会被修改，不知道以后苹果会对此如何操作。IDFV(identifierForVendor) identifierForVendor 应用开发商标识符, 一种应用加设备绑定产生的标识符，相当于是：Z(identifierForVendor) = X(某应用开发商) + Y(某设备)。 同一个应用开发商(com.yourcompany.)下所有的APP（例com.yourcompany.a 和 com.yourcompany.b）的IDFV是一样的，a UUID that may be used to uniquely identify the device, same across apps from a single vendor. 如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。1[[[UIDevice currentDevice] identifierForVendor] UUIDString]; UUID Universally Unique Identifier,翻译过来就是通用唯一标识符。 是变化的，只是表示当前时间点这个设备的标识符！ UUID could be changed ??12345678for (int i = 0; i &lt; 5 ;i++) &#123;NSLog(@&quot;time:%i , uuid: %@&quot;,i ,[[NSUUID UUID] UUIDString]);&#125;//time:0 , uuid: EBA63BC1-E9B2-4E01-B27F-1A28EF3E305C//time:1 , uuid: AD799085-ABAB-48D1-86BB-4C7444E40220//time:2 , uuid: BAA893A3-FC77-4E98-8523-9AC77E66503D//time:3 , uuid: 78FBB61A-E93A-44EC-BB25-85DF5B96FD71//time:4 , uuid: 4E1E419A-938A-474D-AE7B-88A865FC5930 UDID UDID的全名为 Unique Device Identifier :设备唯一标识符 UDID 已经被禁止了，上不了AppStore1//[[UIDevice cuurrent] uniqueIdenfier] MAC Address 被禁了 OpenUDID 被禁了 UDID是系统生成的，OpenUDID是通过第一个带有OpenUDID SDK包的App生成的 参考： iOS-理解 : UDID、UUID、IDFA、IDFV]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法图解]]></title>
    <url>%2F2017%2F01%2F12%2F%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%E5%9B%BE%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一次只做一件事 25分钟专注于任务，如果响铃却没完成任务，并不代表失败，相反这是对已经连续专注25分钟的喝彩 把事拆分或组合，通过仪式感告知自己要专注，番茄工作法一天结束前要做三件事：记录，处理和优化 背景 通过执行一套相同的动作和准备程序，可以使大脑自我调整，进入执行某类事务的最佳状态 通过训练大脑，可以一扭番茄钟马上集中注意力，听到声响就放松 注意力不集中时，要么运动，要么休息 环境或任务的频繁切换回降低生产力 回忆曲线证明时间越长记得越差 25分钟专注+5分钟休息和联想回忆能提高生产力，促进消化吸收 对未知不可预测的事情会导致焦虑，降低生产力，如果将其视为一连串的事件各个击破，生产力将会提高 短暂的定期的休息，能够促进融会贯通的能力 重复的手势和惯例将帮助大脑适应线程情况 极其专注的心流状态是很好的，5分钟休息有助于从战略角度做出调整 5分钟休息有助于保持情绪和精力，持续生产，降低长时间的枯燥和厌烦 细分的番茄钟有助于理清起点终点，有助于缓解拖延症 专注工作中应当只对相关指标做持续记录，定期的会议和回顾才是专门用来分析调整的场合，在分析过往数据的同时展望未来，改善自己 拥抱变化，频繁的提供和接受反馈，严格控制我们必须完成的内容，并经常性的重新评估，从长期和短期角度问自己“完成什么才是最重要的” 方法 番茄工作者的一天具有以下5个阶段：A、计划：在一天开始的时候，从活动清单中提取最重要的活动，填写到今日待办表格，这就是自己对自己当天的承诺；B、跟踪：在每个番茄钟的时间段内，要收集一些过程指标，中断次数，注意力不集中…；C、在一天结束的时候，将当天收集的数据归档，写入记录表格；D、处理：从所记录的原始数据中提取有用的信息；E、可视化：最终你要将信息以某种方式组织起来，从中找出改进流程的思路 准备三张纸：A、“今日待办”表格：填写今天的日期、名字、列出打算今天进行的互动（要设置计划外紧急的栏目）。每天早上都要更新今日待办；B、“活动清单”表格：填写名字，列出最近要进行的活动，随想随填，不用排序。同一张“活动清单”表格可以用很多天，增加新的活动，划掉已完成的；C、“记录”表格：记录所采集样的流程指标，以便对流程进行改进。同一张“记录”表格可以用很多天，以便比较每天的跟踪记录 活动清单：随想随填，不要排序，不分轻重，不用写具体做法，只要写上要达成目标和deadLine就好。反正是给自己看，没什么不能写、不敢写的，能看懂知道是啥就行了。 感觉千头万绪的时候，把最重要的事放在第一位，开启番茄钟，全力以赴现在就做。在心目中将“必须的做完”变成“从哪里开始”，将“这个项目很大很重要”变成“我可以走出一小步” 要么做，要么不做！现在做的话，要么只有一件事可做，要么没事可做！学会选择，学会专注，当决定要做什么的时候，要有全局眼光，避免陷入琐事当中 使用番茄工作法，为刚才25分钟的工作打个好评，能让我们获得立即反馈 可以把当前要做的事情明确的写在一张纸上，放在眼前 钟响后，应立即在今日待办表格的相应活动旁边画上一个X，然后休息一下，个人觉得最好的休息，溜达、蹲起、冥想或者浅睡5分钟；在休息期间，思考上一个番茄钟或下一个番茄钟的工作是不允许的，重点应该放在放松！ 将4个番茄钟作为一组，每组进行15~30分钟阶段性休息 快速睡眠：舒服的床 + 放松的姿势 + 闭眼 + 想象扫描仪扫描全身 + 跟着扫描放松全身肌肉，尤其是眼部肌肉 在番茄钟进行中不应该切换活动也不应该停止当前活动，关键不在于25分钟内是否做完，关键在于25分钟内尽可能的努力。番茄钟具有原子性，一旦切换或中断都不能算一个番茄钟了。 中断 中断时常态，要学会记录，学会接受变化。针对内部中断，自己中断自己的情况：要接受它，记录它，然后接着进行手头的工作；处理外部中断，告知（番茄钟内），协商（等一下），计划（今日或以后），答复（中断在开启一个），前三项都要在简短的互动后全力以赴的继续番茄钟 预估 要经常回顾与反思，要写成功日记增强自信心 预估一个活动需要多个番茄钟，那最好把活动拆分为多个；如果一个活动用不了一个番茄钟，那最好多个任务组合成一个番茄钟 用不同标记记录超出或不足的番茄钟，作为思考与以后优化的依据 应变 循序渐进：经常中断或注意力不集中，那把25分钟缩短 建立一套自己的仪式方式，自己的时钟等，尽信书不如无书！]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreImage基本用法]]></title>
    <url>%2F2017%2F01%2F05%2FCoreImage%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1 基础概念 Core Image，允许编写自定义滤镜与系统滤镜（或滤镜链）来处理静止和视频图像 一个滤镜是一个对象，有很多输入和输出，并执行一些变换。例如，模糊滤镜可能需要输入图像和一个模糊半径来产生适当的模糊后的输出图像。 一个滤镜图表是一个链接在一起的滤镜链条，使得一个滤镜的输出可以是另一个滤镜的输入。以这种方式，可以实现精心制作的效果。我们将在下面看到如何连接滤镜来创建一个复古的拍照效果。 当多个滤镜连接成一个滤镜图表，Core Image 便把内核串在一起来构建一个可在 GPU 上运行的高效程序。只要有可能，Core Image 都会把工作延迟。通常情况下，直到滤镜图表的最后一个滤镜的输出被请求之前都不会发生分配或处理。 常用类 CIImage 保存图像数据的类，可以通过UIImage，图像文件或者像素数据来创建，包括未处理的像素数据。 CIFilter 表示应用的滤镜，这个框架中对图片属性进行细节处理的类。系统提供的滤镜列表 CIContext 表示上下文，CoreImage的上下文也是实现对图像处理的具体对象。可以从其中取得图片的信息。建立一个上下文是非常昂贵的，所以你会经常想创建一个反复使用的上下文。接下来我们将看到如何创建一个上下文 2 使用 基本用法 12345678910111213141516171819202122232425262728- (UIImage *)filterImage:(UIImage *)originImage filterName:(NSString *)filterName &#123;/*注意： 直接使用originImage.CIImage获取CIImage可能为nil@property(nullable,nonatomic,readonly) CIImage *CIImage NS_AVAILABLE_IOS(5_0); // returns underlying CIImage or nil if CGImageRef based*/CIImage *ciImage = [[CIImage alloc] initWithImage:originImage];if (!ciImage) &#123;return originImage;&#125;// 创建滤镜CIFilter *filter = [CIFilter filterWithName:filterName keysAndValues:kCIInputImageKey, ciImage, nil];// 设置相关参数[filter setValue:@(10.f) forKey:@&quot;inputRadius&quot;];// 渲染并输出CIImageCIImage *outputImage = [filter outputImage];// 建立一个上下文是非常昂贵的，最好设成属性CIContext *context = [CIContext contextWithOptions:nil];/*注意： 直接 用UIImage *image = [UIImage imageWithCGImage:outputImage]; 也是可以的，但这种方法有点让人郁闷：如果你试图在一个 UIImageView 上显示这样的图像，其 contentMode 属性将被忽略。使用过渡的 CGImage 则需要一个额外的步骤，但可以省去这一烦恼。*/CGImageRef cgImage = [context createCGImage:outputImage fromRect:[outputImage extent]];UIImage *image = [UIImage imageWithCGImage:cgImage];// CIImage、CIFilter和CIContext都是继承NSObject，故只需要手动release CGImageCGImageRelease(cgImage);return image;&#125; 滤镜太多记不住？ 12345678910111213141516171819202122232425/*https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html按效果分类：kCICategoryDistortionEffect 扭曲效果，比如bump、旋转、holekCICategoryGeometryAdjustment 几何开着调整，比如仿射变换、平切、透视转换kCICategoryCompositeOperation 合并，比如源覆盖（source over）、最小化、源在顶（source atop）、色彩混合模式kCICategoryHalftoneEffect Halftone效果，比如screen、line screen、hatchedkCICategoryColorAdjustment 色彩调整，比如伽马调整、白点调整、曝光kCICategoryColorEffect 色彩效果，比如色调调整、posterizekCICategoryTransition 图像间转换，比如dissolve、disintegrate with mask、swipekCICategoryTileEffect 瓦片效果，比如parallelogram、trianglekCICategoryGenerator 图像生成器，比如stripes、constant color、checkerboardkCICategoryGradient 渐变，比如轴向渐变、仿射渐变、高斯渐变kCICategoryStylize 风格化，比如像素化、水晶化kCICategorySharpen 锐化、发光kCICategoryBlur 模糊，比如高斯模糊、焦点模糊、运动模糊按使用场景分类：kCICategoryStillImage 用于静态图像kCICategoryVideo 用于视频kCICategoryInterlaced 用于交错图像kCICategoryNonSquarePixels 用于非矩形像素kCICategoryHighDynamicRange 用于HDR*/NSArray *names = [CIFilter filterNamesInCategory:kCICategoryBuiltIn]; 滤镜参数在哪里？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 特别注意入参的数据类型，通过KVC设置的，没类型检查，别弄错了CIFilter *filter = [CIFilter filterWithName:@&quot;CIMotionBlur&quot;];NSLog(@&quot;输入参数 : %@&quot;,[filter inputKeys]);NSLog(@&quot;输入参数的详细信息 : %@&quot;,[filter attributes]);NSLog(@&quot;输出参数 : %@&quot;,[filter outputKeys]);// 输入参数的详细信息// &#123;// &quot;CIAttributeFilterAvailable_Mac&quot; = &quot;10.4&quot;;// &quot;CIAttributeFilterAvailable_iOS&quot; = &quot;8.3&quot;;// CIAttributeFilterCategories = (// CICategoryBlur,// CICategoryStillImage,// CICategoryVideo,// CICategoryBuiltIn// );// CIAttributeFilterDisplayName = &quot;Motion Blur&quot;;// CIAttributeFilterName = CIMotionBlur;// CIAttributeReferenceDocumentation = &quot;http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/filter/ci/CIMotionBlur&quot;;// inputAngle = &#123;// CIAttributeClass = NSNumber;// CIAttributeDefault = 0;// CIAttributeDescription = &quot;The angle of the motion determines which direction the blur smears.&quot;;// CIAttributeDisplayName = Angle;// CIAttributeIdentity = 0;// CIAttributeSliderMax = &quot;3.141592653589793&quot;;// CIAttributeSliderMin = &quot;-3.141592653589793&quot;;// CIAttributeType = CIAttributeTypeAngle;// &#125;;// inputImage = &#123;// CIAttributeClass = CIImage;// CIAttributeDescription = &quot;The image to use as an input image. For filters that also use a background image, this is the foreground image.&quot;;// CIAttributeDisplayName = Image;// CIAttributeType = CIAttributeTypeImage;// &#125;;// inputRadius = &#123;// CIAttributeClass = NSNumber;// CIAttributeDefault = 20;// CIAttributeDescription = &quot;The radius determines how many pixels are used to create the blur. The larger the radius, the blurrier the result.&quot;;// CIAttributeDisplayName = Radius;// CIAttributeIdentity = 0;// CIAttributeMin = 0;// CIAttributeSliderMax = 100;// CIAttributeSliderMin = 0;// CIAttributeType = CIAttributeTypeDistance;// &#125;;// &#125; 是否需要指定OpenGL 123456789/*使用nil方式创建基于 GPU 的 CIContext 对象是最优选择它内部的渲染器会根据设备最优选择。依次为 Metal，OpenGLES，CoreGraphics。*/ CIContext *context = [CIContext contextWithOptions: nil];// 强制使用OpenGLEAGLContext *eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];context = [CIContext contextWithEAGLContext:eaglctx]; 参考： Core Image 介绍 Core Image Filter Explorer &amp; Showcase Core Image 你需要了解的那些事~ Core Image 之自定义 Filter~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小狗钱钱]]></title>
    <url>%2F2016%2F12%2F31%2F%E5%B0%8F%E7%8B%97%E9%92%B1%E9%92%B1%2F</url>
    <content type="text"><![CDATA[小狗钱钱 - 入门级理财书 想要金钱，必须真的有要钱的愿望，例如：必须找到10个我想变富裕的原因，再找出三个最重要的原因。 尝试纯粹是一种借口，你还没有做，就已经给自己想好了退路，不能试验，只有两个选择：做或者不做 做到三件事，1、准备一本相册，装满与梦想有关的照片；2、每天翻看几遍相册，想象着已经实现梦想的情景；3、为每一个梦想准备一个梦想储蓄罐 乐观前行，不放弃，越是被别人嘲笑的梦想，越值得去实现 是否能挣到钱，最关键的并不在于有没有一个好点子，不在于有多聪明，决定因素是你的自信程度；你的自信程度决定了你是否相信自己的能力，是否相信自己。不相信自己，怎么开始开始做？怎么做的好？ 建立自信的方法：拿一个本子，就叫成功日记，然后就把所有成功的事情记录进去，最好每天都做，每次至少写5条个人成果 两个重要的建议：1，尝试为别人解决一个难题，那么你就能赚到很多钱；2，把经理集中在你知道，你会的和你拥有的东西上 无论什么时候都不能把希望寄托在一份工作上，它持续时间不会像你设想的那么长，所以你要立即寻找一份替代的工作 最好想清楚，你喜欢做什么，然后在考虑你怎么用它来挣钱 逆境需要坚持，顺境更需要坚持，培养自信，憧憬梦想，花费不超过10分钟，但就这10分钟，让你与众不同 当你决定做一件事的时候，必须在72小时内完成它，否则很可能就永远不会在做了！没得选就是最好的选择，早做早超生！ 陷入债务的人需要听取四个忠告：1、欠债的人应该销毁所有的信用卡，因为使用虚拟的钱时，比用现金花的钱要多得多；2、支付许可范围内最小的分期付款数目，应当尽可能少的偿还他们的贷款；3、将扣除生活费之后富余的钱中50%再存起来，剩下的50%用于支付消费贷款，最好根本不要申请消费贷款；4、每次花费之前问自己：“这真的有必要吗？”。 要花钱，这是对的，但如果想变得富有，同时还要存钱，这笔钱是用于投资钱生钱的；最好是投资的钱（长期目标），储蓄罐的钱（短期目标），和用于生活的钱来划分 当你定下了大目标的时候，就意味着你必须付出比别人多得多的努力 你干的活最多只占报酬的一般，另一半是因为你的想法和实施这个想法的勇气 运气其实永远是充分的准备加上努力工作的结果 一个人要想过得更幸福、更满意的生活，就得对自身进行改变。 不要怕，恐惧是正常的，没必要因为恐惧而悲哀痛苦自暴自弃，克服恐惧，做了不敢做的事才是最美好的，不要怕 每当你觉得有些事情不好办的时候，你可以做一件事：翻一翻成功日记，你会从过去的事情中找到未来你也有能力完成任何事情的证据。恐惧重视在我们设想事情会如何不顺的时候出现，我们对失败的可能性想的越多就越害怕，当你朝着积极的目标去思考的时候，就不会心生畏惧 总结：1、确定自己的喜欢获得财务上的成功；2、自信，有想法，做自己喜欢做的事；3、把钱分成日常开销、梦想目标和全鹅账户三部分；4、进行明智的投资；5、享受生活 投资：1、应该把钱投资在安全的地方；2、我们当然想要最丰厚的利息；3、我们的投资应该简单明白 长线基金值得拥有，挑选基金的注意事项：1、基金应该至少有十年的历史，假如以前一直盈利，可以相信以后也会盈利；2、应该选择大型的跨国股票基金；3、对基金走势图进行比较，我们应该观察在过去10年间哪些基金的年终获利最好 年收益率 / 72 = 投资翻倍的年数 只有交易出去才能收益，才是赔钱或者赚钱了！不交易，没有任何意义 应该始终储备一些现金，绝不能把你全部的钱都投资在股票或基金上面 72 除以 3%的通货膨胀率 = 24，即24年后，钱只值现在的一半 不要着急否认，要多想，我只能告诉你要多想]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Crash分析与总结]]></title>
    <url>%2F2016%2F12%2F18%2FCrash%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1 Crash日志格式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1 进程信息// 1.1 崩溃报告的唯一标识符Incident Identifier: AC8D216D-65CA-414C-B354-1E5AD05E6981// 1.2 设备标识符，注意不是真正的设备标识符，但可做唯一标志使用CrashReporter Key: bb1c1545a3cae67e42a2e210ae253f10096200e7// 1.3 设备类型，这里是iPhone 7 PlusHardware Model: iPhone9,2// 1.4 应用名称[闪退时的进程ID]Process: 有道云笔记 [54279]// 1.5 应用路径Path: /private/var/containers/Bundle/Application/0A4AF891-56D6-4384-9B45-061500D6C8C3/有道云笔记.app/有道云笔记// 1.6 bound idIdentifier: com.youdao.note.iphone// 1.7 build &amp; versionVersion: 1213 (4.5.7)// 1.8 以下除了Code Type: ARM-64 (Native) 稍微有点用，其它都不用管AppStoreTools: 10G3AppVariant: 1:iPhone10,3:11Code Type: ARM-64 (Native)Role: Non UIParent Process: launchd [1]Coalition: com.youdao.note.iphone [9927]// 2 基本信息// 2.1 崩溃时间Date/Time: 2019-07-23 07:42:53.4906 +0800// 2.2 启动时间Launch Time: 2019-07-23 07:42:33.4417 +0800// 2.3 ios系统版本OS Version: iPhone OS 9.3.0 (16F203)Baseband Version: 3.60.01Report Version: 104// 3 异常// 3.1 异常类型Exception Type: EXC_CRASH (SIGKILL)// 3.2 异常编码Exception Codes: 0x0000000000000000, 0x0000000000000000Exception Note: EXC_CORPSE_NOTIFYTermination Reason: Namespace SPRINGBOARD, Code 0x8badf00dTermination Description: SPRINGBOARD, scene-create watchdog transgression: com.youdao.note.iphone exhausted real (wall clock) time allowance of 19.59 seconds | ProcessVisibility: Foreground | ProcessState: Running | WatchdogEvent: scene-create | WatchdogVisibility: Foreground | WatchdogCPUStatistics: ( | &quot;Elapsed total CPU time (seconds): 13.190 (user 13.190, system 0.000), 11% CPU&quot;, | &quot;Elapsed application CPU time (seconds): 1.093, 1% CPU&quot; | )Triggered by Thread: 0// 4 线程回顾// 4.1 线程编号和名称Thread 0 name: Dispatch queue: NSPersistentStoreCoordinator 0x2811a8080Thread 0 Crashed:// 4.2 调动方法顺序和各列含义//帧编号 | 库的名称 |方法地址 | 基本地址和偏移量0 libsystem_kernel.dylib 0x00000001b164a400 __semwait_signal + 81 libsystem_c.dylib 0x00000001b15c156c nanosleep + 2122 libsystem_c.dylib 0x00000001b15c136c sleep + 443 CoreData 0x00000001b4524da4 -[NSXPCStore sendMessage:fromContext:interrupts:error:] + 8364 CoreData 0x00000001b4589bfc -[NSXPCStore loadMetadata:] + 3445 CoreData 0x00000001b466963c __91-[NSPersistentStoreCoordinator addPersistentStoreWithType:configuration:URL:options:error:]_block_invoke + 16166 CoreData 0x00000001b46751a4 注意: 在后台任务列表中关闭已挂起的应用不会产生崩溃日志。 一旦应用被挂起，它何时被终止都是合理的。所以不会产生崩溃日志 2 CPU type i386 或 x86_64 ：模拟器 armv6：iPhone、iPhone2、iPhone3G、iPod Touch(第一代)、iPod Touch(第二代) armv7：iPhone3Gs、iPhone4、iPhone4s、iPad、iPad 2 armv7s：iPhone5、iPhone5c arm64：iPhone5s、iPhone6、iPhone6p、iPhone6s、iPhone6sp、iPhone7、iPhone7p、iPhone8、iPhone8p、iPhoneX arm64e：iPhone XS、iPhone XS Max、iPhone XR 3 Exception Codes 0x8badf00d：读做 “ate bad food”! (把数字换成字母，是不是很像 :p)该编码表示应用是因为发生watchdog超时而被iOS终止的 0xbad22222: 该编码表示 VoIP（网络语音电话） 应用因为过于频繁重启而被终止。 0xdead10cc: 读做 “dead lock”!该代码表明应用因为在后台运行时占用系统资源，如通讯录数据库不释放而被终止 。 0xdeadfa11: 读做 “dead fall”! 该代码表示应用是被用户强制退出的。根据苹果文档, 强制退出发生在用户长按开关按钮直到出现 “滑动来关机”, 然后长按 Home按钮。强制退出将产生 包含0xdeadfa11 异常编码的崩溃日志, 因为大多数是强制退出是因为应用阻塞了界面。 0xbaaaaaad 表明这个日志是整个系统的堆栈记录，而不是一份崩溃报告。 0xc00010ff 表明这个应用由于过热事件被系统杀掉了。 0x2bad45ec 表明由于安全违规问题被杀掉了 4 Exception Type4.1 EXC_BAD_ACCESS、SIGSEGV和SIGBUS 野指针、非法访问等内存问题 解决方案 开启僵尸对象：Producrt -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics -&gt; Zombie object 如果有 gpus_ReturnNotPermittedKillClient是非主线程渲染，参考： QA1766: How to fix OpenGL ES application crashes when moving to the background Address Sanitizer 4.2 EXC_BAD_INSTRUCTION、SIGILL 非法的指令，往往是运行指令的参数不对 4.3 EXC_RESOURCE cpu使用过高，一般都有cpu usage字段 内存不足，一般都有 page信息 4.4 EXC_GUARD C函数异常 4.5 SIGTRAP 不是一个真正的崩溃信号 解决方案：重启-&gt; clean -&gt; build 4.6 EXC_ARITHETIC 被除数是0 5 常见Crash5.1 doesNotRecognizeSelector 未实现方法 类型问题，常见于json和id的使用，例如NSArray调用了NSMutableArray的addobject方法; .h和.m 文件声明方法不一致；常见的就是.m方法名改了几次，.h文件忘改了 预防：强制消除所有警告， 解决方案，首选：添加相关方法，备选：消息转发 5.1 dNSRangeException 越界 数组越界问题，常见就是超过数组范围 字符串越界问题，常见字符串截取和NSAttributeString的使用 解决方案：尽量用相关属性，而不是写死的数值 5.2 NSNULL问题 常见json转化时， 解决办法：增加 [someValue isEqual:[NSNull null]判断 5.3 数组和字典的nil问题 数组 addObject: nil 会crash 字典 setOejct：nil 会crash 5.4 UI在非主线程绘制5.5 NSTimer忘了删除5.6 KVO重复添加或忘了删除5.7 通知忘了删除5.8 子线程刷新UI 一般crash子线程（非0）会有setNeedsDisplay等方法 5.9 多线程问题参考 http://www.cocoachina.com/articles/6677 https://developer.apple.com/library/content/technotes/tn2151/_index.html#//apple_ref/doc/uid/DTS40008184-CH1-ANALYZING_CRASH_REPORTS]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addChildViewController]]></title>
    <url>%2F2016%2F12%2F08%2FaddChildViewController%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;apple推荐的MVC是一个view对应一个Controller，但实际项目开发中几乎都是一堆view对应一个VC，这几天正尝试重构部分页面时，因为辑实在是比较乱，view层级只能用乱七八糟来形容！就尝试了一下使用addChildViewController将一个VC拆分成多个VC，也发现了几个坑！总的来说，addChildViewController方式各有利弊，如果页面很复杂还是值得拆分出来的！ 1 API介绍12345678// 添加childVC（如果已被加在别的VC上了先移除再添加）- (void)addChildViewController:(UIViewController *)childController NS_AVAILABLE_IOS(5_0);// self从父VC中移除，注意iOS7中会崩溃，ios7中最好让父类去移除- (void)removeFromParentViewController NS_AVAILABLE_IOS(5_0);// 父VC切换两个子ChildVC,fromViewController.view removeFromeSuperView；self.view addSubview:toViewController.view。- (void)transitionFromViewController:(UIViewController *)fromViewController toViewController:(UIViewController *)toViewController duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^ __nullable)(void))animations completion:(void (^ __nullable)(BOOL finished))completion NS_AVAILABLE_IOS(5_0); 关于willMoveToParentViewController方法和didMoveToParentViewController方法的使用1234567891011121314151617181920212223- (void)willMoveToParentViewController:(nullable UIViewController *)parent NS_AVAILABLE_IOS(5_0);- (void)didMoveToParentViewController:(nullable UIViewController *)parent NS_AVAILABLE_IOS(5_0);/*1.这两个方法用在子试图控制器交换的时候调用！即调用transitionFromViewController 方法时，调用。*/ /*2.当调用willMoveToParentViewController方法或didMoveToParentViewController方法时，要注意他们的参数使用：当某个子视图控制器将从父视图控制器中删除时，parent参数为nil。即：[将被删除的子试图控制器 willMoveToParentViewController:nil];当某个子试图控制器将加入到父视图控制器时，parent参数为父视图控制器。即：[将被加入的子视图控制器 didMoveToParentViewController:父视图控制器];*/ /*3.无需调用[子视图控制器 willMoveToParentViewController:父视图控制器]方法。因为我们调用[父视图控制器 addChildViewController:子视图控制器]时，已经默认调用了。只需要在transitionFromViewController方法后，调用[子视图控制器didMoveToParentViewController:父视图控制器];*//*4.无需调用[子视图控制器 didMoveToParentViewController:父视图控制器]方法。因为我们调用[子视图控制器 removeFromParentViewController]时，已经默认调用了。只需要在transitionFromViewController方法之前调用：[子视图控制器 willMoveToParentViewController:nil]。*/ 2 子VC的生命周期 示例 12345678910111213JZKChildViewController *childVC1 = [[JZKChildViewController alloc] init];childVC1.view.backgroundColor = [UIColor yellowColor];childVC1.view.frame = CGRectMake(0, 100, 300, 300);// step 1[self addChildViewController:childVC1];// step 2[self.view addSubview:childVC1.view];dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// step 3[childVC1.view removeFromSuperview];// step 4[childVC1 removeFromParentViewController];&#125;); step 1 时childVC1 123[JZKChildViewController initWithNibName:bundle:][JZKChildViewController loadView][JZKChildViewController viewDidLoad] step 2 时childVC1 123456[JZKChildViewController viewWillAppear:][JZKChildViewController viewWillLayoutSubviews][JZKChildViewController viewDidLayoutSubviews][JZKChildViewController viewWillLayoutSubviews][JZKChildViewController viewDidLayoutSubviews][JZKChildViewController viewDidAppear:] step 3 时childVC1 12[JZKChildViewController viewWillDisappear:][JZKChildViewController viewDidDisappear:] step 4 时childVC1 1[JZKChildViewController dealloc] 3 问题ddChildViewController VS addSubview 很简单的直接用addsubview，比较复杂而且可单独封装的用ddChildViewController Difference between addChildViewController and addSubview? 其它 What does addChildViewController actually do? When to use addChildViewController vs pushViewController]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖延心理学]]></title>
    <url>%2F2016%2F12%2F01%2F%E6%8B%96%E5%BB%B6%E5%BF%83%E7%90%86%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[小步快跑、深呼吸、平常心、多运动、允许不完美拖延VS行为了解你自己 拖延情绪的根源涉及到内心感受、恐惧、希望、记忆、梦想、怀疑以及压力。 另一个根源是拖延者与时间的纠葛，如果将时间看成一个需要制服和取胜的对手，将更加拖延！ 从你的经验中学习是一件令人兴奋的事–不否认、不遗忘、不判断，而是如实的接受，好好利用！ 个人理解：害怕就是自欺欺人，事实上没人关心你到底是什么样子，如果自己害怕自己，那只不过是欺骗自己！ 质疑拖延 智力和拖延没有关系！ 拖延怪圈：开始信心满满-&gt;处理不好-&gt;拖延-&gt;懊恼-&gt;找借口-&gt;再次信心满满 允许不完美，学会不恐惧，要有敬畏心，静心慢慢来！ 审问拖延 恐惧失败，追求完美！一丁点的失误、挫折、焦虑、甚至恐惧，就代表着不完美，不完美就代表着失败！ 我表现的好，我很有能力，所以我很喜欢自己！或我表现的不好，我没有能力，所以我不喜欢自己！事实上是自我价值感 等于 能力 不等于 表现！ 完美主义的世界：对犯错极为在意或对自己期待过高，不够现实；自卑，无法忍受平庸或自大，凡事信手拈来；一切都自己来，认为求助是软弱的标志；无法忍受失去；总有一个正确的解决办法，要么全部要么没有； 完美主义者容易绝对化，常以灾难性的方式思考问题；而幻想的，看不见，摸不着的灾难更显得可怕 对话拖延：拖延你好，成功再见 实际上很可能是在恐惧成功，并利用拖延来避免成功的到来！ 逃避成功的一般心理原因：成功需要太多的付出，这令我望而却步；成功是危险的，总有人会受到伤害；成功是禁区，我觉得自己不对劲； 成功不是一蹴而就的，顾虑害怕都很正常，但这不是拖延的理由，风险和机遇并存，just do it！做好自己就不错了，哪有时间和精力在乎别人怎么想的！ 拖延VS心理挣扎中的拖延者：恐惧在争夺战中失败 争夺控制权的较量，我偏不和我就不：跟规则斗，跟别人斗，跟自己斗！其实是 自我价值感 = 能力（具有独立性，反对受控制）= 表现（通过拖延，“我”说了算） 表现自己，表现自己意味着暴露自己的缺点、意味着承担责任、意味着突出、意味着合作、还意味着可能的失败等等！但这更意味着进步！ 要知道未来是不可确定的，即便你非常认同的某些观点，非常确定的事情，未来也有可能发生改变的！何况一些事情本来并没有想象的那么可怕、那么死板！既然如此，那为何恐惧，为何害怕！先干了再说，那些选择放弃的人，他们不会失败，因为一开始他们就失败了！ 如果不能抉择，哪为什么不听取别人的建议？选择的权利在于自己，多听建议永远是好的！ 心理舒适区：对亲近与疏远的恐惧 对疏远的恐惧，我决不独自行走：害怕孤独、害怕迷茫、害怕失去、 恐惧亲近，关系太近让人不舒服 个人理解：扯淡，谁还没个心理舒适区，不耽搁事不就得了！该来的自然会来，该走的自然会走！不如意十之八九，但求一二！ 拖延时钟：你知道现在几点吗？ 客观时间和主观时间：我认为花的时间和实际上花的时间的冲突，造成焦虑和拖延！无论是沉浸在过去还是沉浸在未来，都不如把握住现在！ 时间就在那里，不长不短，不快不慢，唯一变化的是自己！要学会接受，更要接受适应！适应主客观时间，并有能力在两者之间有弹性、自然的过渡和变换 拖延VS大脑世界上存在“拖延基因”吗 你的大脑处在不断地变化中：要学会跳出固有模式，学习批判性思维 感受很重要，即便它处于无意识中：接受并忍着，深呼吸！重要的是下一步怎么做，而不是现在多难受多害怕！ 潜伏记忆的影响：深呼吸，告诉自己活在当下 联结的通路：沟通不畅造成自卑！ 左逆转：多鼓励，多奖励，少自嘲，不自弃！ 如何打造大脑的全局领导力 执行功能障碍：分解拆分目标，自己开导自己 注意力缺失紊乱：注意力分散、冲动和躁动不安！根本原因是没有抑制能力！找到喜欢的 或 肾上腺素–加强运动！ 抑郁症的倾向于变种：当你抑郁时，你会感到能量不足，不愿意参与，失去兴趣，没有目标，不在乐观！方法：聊天+运动，比较有效 强迫症：事情已经已经解决了，这是我的强迫症在作怪！ 邋遢分子和囤积狂：优柔寡断 + 对犯错误的恐惧 = 邋遢分子，邋遢分子升级为囤积狂！方法：转移注意力+快刀斩乱麻 压力对人的影响：压力，面对或逃避，都需要时间来恢复精力 生物节奏：调整节奏，休息和运动同样重要 你是怎样变成一个拖延者的 家庭倾向造成拖延：施压、怀疑、控制、依附和疏远！根本就是压力和孤独 无条件的支持也会造成拖延症，因此压力太大了，所有人都支持你，你就不能失败，不能犯错！而不失败，不犯错最好的办法似乎就是拖延 拖延行为模式的法庭大调查 勇敢不是没有恐惧，而是克服恐惧，战胜恐惧 去认识那个拖延之外的你很重要，那个你就可以按照你自己的本来面目，而不是按照你所希望或者你认为的样子，来接受自己！诚实的了解自己，现实的评价自己，并最终接受你所发现的那个自己！ 最可怕的事情就是去全然的接受自己。这个“可怕”的接受自己的过程–接受所有的缺陷、创痛和伤疤，同时也可以让你如释负重！ 面对现实 生物现实：对于自己的弱项心怀敬畏的给予关注，友善的对待自己，并通过锻炼提高相应的技能！ 情感现实：在你焦头烂额的时候不要指望可以迅速或者完全的从中恢复过来！其实感觉一个比较靠谱的办法就是深呼吸，数到20再做下一步反应！ 价值现实：价值观是否相同，是否符合心意！也就是找志趣相投的 不要自欺欺人：万事无美好；努力尝试是一件好事，而不是愚蠢或软弱的表现；失败并不危险，失败才是生活的常态；真正的失败是不敢去经历，每个人都是局限，包括我自己；如果那是一件值得去做的事情，那么为它犯错误也是值得的；挑战有助于我的成长；我有成功的权利，我也能应对别人对此的反应；如果这一次我没有做好，下一次我还有机会；遵守别人的规则去做事，并不意味着我一点权利也没有；当我展现出真实的自我，真正喜欢我的人就会跟我坦诚相对；答案很多，但我需要找到那个最符合我的感觉的答案 拖延VS征服之战采取行动 观察并记录痛点，找到需求，just do it ! 改变是一个过程 慢慢来，平常心！just do it ! 找出导致拖延的因素： 对成功所需的能力缺乏自信：可以设立一个比较现实的、能够达成的、同时又容易衡量的目标；再细分成容易操作的小单元。 对要去完成的某个任务有反感心理，认定做事的过程中会遭遇很多困难，结局也会很惨：自己吓自己，放轻松 + 奖励 目标和回报太遥远了，感受不到对我有什么意义：拆分目标 + 奖励 无法自我约束 如何运用这些技巧：一次尝试一个技巧、慢慢来、观察内心的抵抗、写日记记录优缺点记录心态变化等作战前传：拖延大清点 不要批判，只要清点 盘点内心的挣扎 善意的对待内在或外在的结果 拖延的领域、风格、借口 作战武器：明确的目标与可执行的计划 可操作目标特性：可观察性、具体性和特殊性、可以被分解成几个小步骤、第一步可以在五分钟内被完成、 启动计划、番茄25分钟、5分钟休息、忠实的记录中断与借口、总结奖励与反思、下一步计划 灵活对待项目（时间、规划、聚合拆分等）、无需完美只需进步 灵活对待时间，逝去的已经逝去，与其懊恼不如把握现在！ 作战方法A：学会怎样判断时间 时间是固定的、可衡量的、有限的 个人理解：大多数情况预估时间都比实际花费时间短，我的办法是预估时间*系数 计划并不意味着每一天每一个小时都被占据，要有缓冲区！而且要提前考虑意外的情况！ 要想计划成为你的朋友，计划应该务实、合理。计划必须围绕着脚踏实地做事情这个核心，而不是老在盘算你应该干什么 跟踪目标进度，填写分段时间表记录每段时间做的啥！而且有助于更有效的利用碎片化时间，告诉自己碎片化时间不是一无所获！自我监测有助于增进工作时间和提升工作成就 提升你定时能力的技巧：练习判断时间，预估时间与实际时间的对比有助于提升时间判断！学会利用零碎时间，而不是消极的等待整块的时间段出现，一步步向前挪，也是前进！ 胡萝卜政策要比大棒政策要管用的多！ 每个方案都有优化空间，但最主要的是解决问题和性价比，记住时间是昂贵的资源，一直在研究有没有更好的方案也花费很多的时间 不要过分分散精力，不要利用忙碌来逃避更重要的事情 找出你的最佳时间，而不是幻想着我要怎样怎样 学会在过去、现在和未来之间取得认知上的平衡，不要黏滞在时间中！ 享受你的“自由”时间。“拖延”不是“自由”，甚至拖延都不能让你开心！ 作战方法B：学会接受和拒绝 我们应该有意识的接受那些提高我们生活品质的事情，而拒绝那些对此无益的事情，并且应该直接的表达出来，而不应该通过拖延的方式来拒绝。重要的是知道想要什么，不想要什么 学会接受有益于你的人和事：选对人、放开心胸不要处处为自己辩解、做一个公开的承诺、做完就要接受奖励、拖延就要受到惩罚、跟别人一起制订计划、尝试新的挑战、做更多你所热爱的事情、 当你寻求帮助的时候，没必要一定要采用它；当别人很有洞察力，看到了一些你看不到的事情，不必自卑！ 交谈很重要，可以进一步拉一个人跟你一起做事(至少有人跟你一块受罪，哈哈) 学会拒绝那些没意义的追求 对浪费时间和让你退步的人和事说不：对没意义的事情说不、 对不必要的事情说不；不能说不，那就减少影响 对杂乱无序说不：怎样才能过的更幸福，定期扔东西，包括真实的或头脑中虚拟的！定期自查自省！ 对电子上瘾说不：最简单最有效的方法，关掉手机关掉电脑等 坚持信息减肥：90%的信息都是没意义的，应该坚持扔掉！ 作战方法C:利用你的身体减轻拖延 通过运动启动你的状态：将运动作为调整自身（拖延、情绪、身体等等）的一种方法，总之就是感觉不舒服或感觉太舒服，都要来点运动！运动还能刺激大脑 冥想: 常练冥想，有助于精力、睡眠！ 深呼吸，越紧张越复杂越急躁越要深呼吸！ 拖延VS建议对患有注意力缺失紊乱和执行功能障碍拖延者的一些建议： 从外在开始，逐渐转向内在：借助工具，养成习惯 执行提示点：通过视觉、听觉、触觉等提醒自己要干活了，并立即马上just do it 架构和路线的重要性：toDoList；固定时间处理一些固定事务，例早起跑步；小步快跑 不要想在你的弱项上表现优异，而是要在你的强项上更上一层楼 拖延处理技巧汇编 确立一个可操作的目标（可观察、具体而实在的），而不是那种模糊而抽象的目标。 设定一个务实的目标。不是异想天开，而要从小事做起。不要过于理想化，而要选择一个能接受的程度最低的目标。 将目标分解成短小具体的迷你目标。每个迷你目标都要比大目标容易达成，小目标可以累积成大目标。 现实的（而不是按照自己的愿望）对待时间。 just do it ! 不要想一下子做完整件事，每次只要迈出一小步 番茄工作法：坚持一小段时间，并逐步增长！注意利用碎片化时间 为困难和挫折做好心理准备！多想多问 可能的话，将任务分派出去，甚至扔掉不管！ 保护你的时间，学会怎么样说不，不要去做额外的或不必要的事情 留意你的借口 奖励进步，将奖励聚焦于努力，而不是结果！小心非此即彼的思维方式：你可以说杯子是半空的，也可以说他是半满的！ 将拖延看成一个信号，停下来问自己：拖延传递给我的是什么意思？]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离屏渲染]]></title>
    <url>%2F2016%2F11%2F02%2F%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[离屏渲染GPU渲染机制&emsp;&emsp;CPU 计算好显示内容提交到 GPU，GPU渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照VSync信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 为什么会卡顿掉帧&emsp;&emsp;垂直同步的机制，如果在一个VSync时间内，CPU或者GPU没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。即卡顿原因： 1，CPU没提交，即CPU没完成计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等工作 2，GPU没提交，即GPU没完成变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区等工作 GPU屏幕渲染的方式: On-Screen Rendering (当前屏幕渲染) 指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。 Off-Screen Rendering (离屏渲染) 指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。代价很高：1，创建新缓冲区，要想进行离屏渲染，首先要创建一个新的缓冲区；2，上下文切换，离屏渲染的整个过程，需要多次切换上下文环境 CPU中的离屏渲染（特殊离屏渲染，即不在GPU中的渲染），如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染 如何检测离屏渲染 模拟器在工作栏上面的Debug -&gt; Color Off-Screen Rendered 真机在工作栏上面的Debug -&gt; View Debugging -&gt; Rendering -&gt; Color Off-Screen Rendered Yellow Core Animation工具检测离屏渲染 Color Blended Layers：红色的是layer透明的，绿色是layer不透明的。 Color Hits Green and Misses Red：红色没复用缓存，绿色复用缓存 Color Misaligned Images：缩放图片标记为黄色，像素没对齐则标记为紫色 Color Offscreen-Rendered Yellow：检测离屏渲染的，黄色表示有离屏渲染。 Flash Updated Regions：当对图层重绘的时候显示黄色，频繁重绘需加缓存。 引发离屏渲染因素 为图层设置遮罩（layer.mask） 将图层的layer.masksToBounds / view.clipsToBounds属性设置为true 将图层layer.allowsGroupOpacity属性设置为YES和layer.opacity小于1.0 为图层设置阴影（layer.shadow *）。 为图层设置layer.shouldRasterize=true 具有layer.cornerRadius，layer.edgeAntialiasingMask，layer.allowsEdgeAntialiasing的图层 文本（任何种类，包括UILabel，CATextLayer，Core Text等）。 使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。 优化圆角优化 利用CAShapeLayer渲染是直接用的GPU，减少CPU对圆角的大量计算12345678910UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];imageView.image = [UIImage imageNamed:@&quot;myImg&quot;];UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init];//设置大小maskLayer.frame = imageView.bounds;//设置图形样子maskLayer.path = maskPath.CGPath;imageView.layer.mask = maskLayer;[self.view addSubview:imageView]; 阴影优化 如果图层是个简单的几何图形或者圆角图形，我们可以通过设置shadowPath来优化性能12345imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0;imageView.layer.shadowRadius = 2.0;UIBezierPath *path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 其它建议 需要圆角效果时，可以使用一张中间透明图片蒙上去，这是效率最高的一种方案 尽量使用不包含透明（alpha）通道的图片资源 确保图片大小和frame一致，不要在滑动时缩放图片。 确保图片颜色格式被GPU支持，避免CPU转换。 确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明。如无特殊需要，不要设置低于1的alpha值。 尽量设置frame的大小值为整形值，避免CPU进行大量复杂计算 设置阴影效果时,使用ShadowPath指定layer阴影效果路径 参考： iOS 保持界面流畅的技巧]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[whistle使用]]></title>
    <url>%2F2016%2F10%2F20%2Fwhistle%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;使用charles已经好几年了，一直觉得挺好用的！但入职新公司才发现，我又out了，大家都用whistle！另外由于百度不允许自己带电脑，新发的电脑里所有的环境都需要重新安装一下，charles下载了两个却都没破解 1 Whistle安装方法1.1 安装Node： Windows或Mac系统，访问https://nodejs.org/，安装LTS版本的Node，默认安装即可。 Linux下推荐使用源码安装: 从Node官网下载最新版的SourceCode(或者用wget命令下载)，解压文件(tar -xzvf node-vx.y.z.tar.gz)后进入解压后的根目录(node-vx.y.z)，依次执行./configure、./make和./make install。 1.2 安装Whistle:&emsp;&emsp;Node安装成功后，执行如下npm命令安装whistle12//Mac或Linux的非root用户需要在命令行前面加sudo，如：sudo npm install -g whistle$ npm install -g whistle &emsp;&emsp;npm默认镜像是在国外，有时候安装速度很慢或者出现安装不了的情况，如果无法安装或者安装很慢，可以使用taobao的镜像安装：12$ npm install cnpm -g --registry=https://registry.npm.taobao.org$ cnpm install -g whistle &emsp;&emsp;或者直接指定镜像安装：1$ npm install whistle -g --registry=https://registry.npm.taobao.org &emsp;&emsp;whistle安装完成后，执行命令 whistle help 或 w2 help，查看whistle的帮助信息1$ w2 help &emsp;&emsp;如果能正常输出whistle的帮助信息，表示whistle已安装成功。 3.启动Whistle&emsp;&emsp;启动whistle:12$ w2 start// 如果要防止其他人访问配置页面，可以在启动时加上登录用户名和密码 -n yourusername -w yourpassword。 &emsp;&emsp;重启whsitle:1$ w2 restart &emsp;&emsp;停止whistle:1$ w2 stop &emsp;&emsp;调试模式启动whistle(主要用于查看whistle的异常及插件开发):1$ w2 run 2 代理&emsp;&emsp;使用Chrome访问本地的8899端口，http://127.0.0.1:8899/，进入Whistle的主页！没啥可说的，就两点：1、可以自建rule保存以往的配置文件；2、点击https，下载认证证书 &emsp;&emsp;重点：http://wproxy.org/whistle/rules 绑定转发 12345678910111213141516171819202122## disable,对某些域名不拦截## 一般放到 Default 分组/wx.qq.com/ disable://intercept## filter,在Network不会出现某些域名的请求/qq.com/ filter://hide## socks## 一般放到 Default 分组/facebook/ socks://127.0.0.1:1080/vk.com/ socks://127.0.0.1:1080/google/ socks://127.0.0.1:1080## 一般场景是调试内嵌APP页面，APP内有一个入口链接a，而调试的目标页面是b## 通过以下一行配置，页面a会自动换成页面bm.aliexpress.com/a.html m.aliexpress.com/b.html## 绑定## a.b.c.d 是某个环境的ip地址## 有时通过多个域名的方式来部署多套开发环境## 通过以下两行配置可以屏蔽开发环境域名与线上不一致的情况m.aliexpress.com mm.aliexpress.commm.aliexpress.com a.b.c.d req 12345678910111213141516171819202122232425## uam.aliexpress.com ua://&#123;wp_ua&#125;#m.aliexpress.com ua://&#123;ali_ua&#125;## referrerm.aliexpress.com referer://https://vk.com/## referrer null#m.aliexpress.com referer://## reqHeaders，修改请求头## ua、referer协议都可以通过reqHeaders来完成m.aliexpress.com reqHeaders://&#123;req-headers&#125;## values&#123;wp_ua&#125;Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; RM-1113) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/13.10586&#123;req-headers&#125;&#123;&quot;X-Forwarded-For&quot;:&quot; 188.146.171.71&quot;,&quot;X-Real-IP&quot;:&quot; 188.146.171.71&quot;,&quot;X-Client-Scheme&quot;:&quot;https&quot;,&quot;referer&quot;:&quot;https://vk.com/&quot;,&quot;User-Agent&quot;:&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 AliApp(H/5)&quot;&#125; res 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364## file，本地调试是其典型的使用场景m.aliexpress.com/sw.js file:///path/to/your/local/sw.js## xfile#m.aliexpress.com/sw.js xfile:///path/to/your/local/sw.js## tpl，常用于mock jsonp请求aliexpress.com/query.jsonp tpl://&#123;res-jsonp&#125;## xtpl，同tpl，本地不存在时走线上aliexpress.com/query.jsonp xtpl://&#123;res-jsonp&#125;## resHeaders，修改响应头ae01.alicdn.com resHeaders://&#123;res-cors&#125;## html，往html文档(&lt;/body&gt;之前)追加html标签(script,style or normal html tag)m.aliexpress.com html://&#123;html-test&#125;## js，往js响应追加脚本，如果响应是html文档，则自动用`&lt;script&gt;&lt;/script&gt;`包装后插入m.aliexpress.com/sw.js js://&#123;js-test&#125;## css，往css响应追加样式，如果响应是html文档，则自动用`&lt;style&gt;&lt;/style&gt;`包装后插入## `/`可以起到仅对首页追加的效果m.aliexpress.com/ css://&#123;css-test&#125;## resReplace，替换响应的某些字符串## 一般可用来快速验证某些功能m.aliexpress.com resReplace://&#123;res-replace&#125;## values&#123;res-jsonp&#125;: whistle会用请求对应的callback值来替换&#123;callback&#125;&#123;callback&#125;(&#123;&quot;ec&quot;: 0,&quot;list&quot;:[&#123;&quot;id&quot;:1,&quot;price&quot;:&quot;US $100&quot;,&quot;stock&quot;:&quot;100&quot;,&quot;imgUrl&quot;:&quot;https://ae01.alicdn.com/kf/HTB12x0CLpXXXXajaXXX760XFXXXS.png_640x640.png&quot;&#125;,...]&#125;);&#123;html-test&#125;&lt;script&gt;// make an errorx.x;&lt;/script&gt;&#123;js-test&#125;fetch(&quot;/&quot;).then(res=&gt;&#123;console.log(&quot;fetched!&quot;)&#125;);&#123;css-test&#125;body&#123;font-size:15px;&#125;&#123;res-cors&#125;&#123;&quot;access-control-allow-origin&quot;:&quot;*&quot;,&quot;access-control-expose-headers&quot;:&quot;Via&quot;&#125;&#123;res-replace&#125;&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait&quot;&gt;: &lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=436672029&quot;&gt; debugging 123456m.aliexpress.com weinre://debugm.aliexpress.com log://&#123;log-test&#125;## values&#123;log-test&#125;console.log(&quot;Yeah!&quot;) 参考：https://github.com/avwo/whistle#whistlehttps://avwo.github.io/whistle/install.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPod问题]]></title>
    <url>%2F2016%2F10%2F16%2FCocoaPod%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天pod install 遇到 Unable to add a source with url问题，着实折腾了半天才弄好！想想cocoapod遇到的坑也有不少，在此记录一下吧！最最主要的是没水过cocoapod，哈哈，一举多得！ 官网 Cocoapod官网 Podfile语法 cocoapod安装问题 升级ruby：sudo gem update –system 源：gen sources 后接 -l 查看命令 –remove 移除命令 –add 添加命令 123gem sources --remove https://rubygems.org/gem sources -a https://gems.ruby-china.org/gem sources -l 安装： sudo gem install cocoapods 当出现not permitted也就是没权限的时候，可以指定安装到bin下目录： sudo gem install -n /usr/local/bin cocoapods pod setup 命令的速度太慢：直接去 https://github.com/CocoaPods/Specs/archive/master.zip 然后解压缩到~/.cocoapods/repos/master pod install 遇到 Unable to add a source with url问题 多个xcode的话，需要xcode -&gt; preferences -&gt; locations -&gt; commond line tools 指定xcode pod的问题，最好卸载重装，卸载命令：witch pod 然后用 sudo gem uninstall 卸载所有cocoapod相关的 权限的问题，SSH是否配置了？用户名等config（在~/.ssh目录下）是否配对了？多个host的话需要在config中多次指定 xcode-select -–install 安装XcodeCommandLineTools 使用brew安装carthage时碰到报错 Error: Permission denied @ dir_s_mkdir - /usr/local/Frameworks 处理办法 sudo mkdir /usr/local/Frameworks；sudo chown $(whoami):admin /usr/local/Frameworks pod repo update是啥？ 意思是本地没有相应版本的库，需要更新本地库索引。默认情况下，执行pod install不会自动执行pod repo update命令 pod install ? pod update ? pod update 库名 来更新某个特定的库，或公司内部的库 pod install 第一次使用或新增库 新建Podfile文件 在终端中使用pod init命令可以直接产生一个Podfile文件 bin目录权限问题 一般情况：sudo chmod -R 777 你要修改文件上层目录的路径 但如果电脑启用了SIP（System Integrity Protection），增加了rootless机制 A，重启，过程中按住 command+R，进入保护模式 B，打开terminal终端，输入 csrutil disable C，再次重启，即可对 usr/bin 目录下文件进行修改 如果要恢复保护机制，重新进入保护模式，输入 csrutil enable]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能的ios应用开发]]></title>
    <url>%2F2016%2F10%2F07%2F%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84ios%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1 移动应用的性能性能指标 内存RAM：平均值、泄漏和峰值 耗电量：CPU、硬件(位置等) 初始化时间：mian前和main后 执行速度： 响应速读： 本地存储：更新频率、异常、清除策略 互操作性： 网络环境： 带宽 数据刷新：刷新频率*数据量，流量 多用户支持：切换迅速、数据隔离 单点登录：数据共享和同步 安全： 应用性能分析 采样 埋点 测量 构建和发布：一键打包 可测试性：单元测试、功能测试 设置崩溃报告： 对应用埋点： 日志：日志贯穿生命周期，埋点应只在开发特定阶段 2 内存管理内存消耗栈大小每个线程都有专属栈空间，栈大小影响因素： 方法数，每个方法调用其它方法都会入栈，Tail Call 一个方法中最多可用变量数 视图层级深度 堆大小 每个进程的所有线程共享一个堆。 从栈复制到堆，和从堆复制到栈，都是代价昂贵的操作 不要忽视 didReceiveMemoryWarning信号 内存管理模式 引用计数：MRC 和 ARC 自动释放： @autoreleasepool 引用类型：assign，retain，copy，atomic，nonatomic，readonly，readwrite以及strong，weak 僵尸对象：scheme -》 edit sheme -》 enable zombie objects 循环引用： delegate（例如animation）和block，解决办法：临时变量，手动置nil 和 weak处理；使用NSTimer和NSThread总应该通过间接层（WeakProxy）实现销毁 观察者：addObserver方法不会持有观察、被观察对象的强引用。想想KVO原理？再想想为啥没移除为crash？ 和通知中心一样，避免的方法就是中间加层 某方法接收NSError*参数时，必须写成 NSError __autoreleasing *error 警惕id类型 合理时候用全局变量：没有被其它对象持有、不是常量、整个应用只有一个而不是每个组件一个 单例：避免滥用单例 iOS依赖注入 禁用ARC，使用retain找到神秘持有者12345if !__has_feature(objc_arc)-(id) retain &#123;NSLog(@&quot;%s %@&quot;, __PRETTY_FUNCTION__, [NSThread callStackSymbols]);return [super retain];&#125; 代码感知123456789101112131415161718192021// 已用内存vm_size_t getUsedMemory() &#123;task_basic_info_data_t info;mach_msg_type_number_t size = sizeof(info);kern_return_t kerr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);if (kerr == KERN_SUCCESS) &#123;return info.resident_size;&#125;else &#123;return 0;&#125;&#125;// 可用内存vm_size_t getFreeMemory() &#123;mach_port_t host = mach_host_self();mach_msg_type_number_t size = sizeof(vm_statistics_data_t) / sizeof(integer_t) ;vm_size_t pagesize;vm_statistics_data_t vmstat;host_page_size(host, &amp;pagesize);host_statistics(host, HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;size);return vmstat.free_count * pagesize;&#125; 3 能耗CPU 尽量少的，快的处理数据 优化静态编译处理，例如tableview设备上可渲染N条数据，则处理3N数据而不是全部数据，快速滑动时等速度降下来再处理等 网络 蜂窝网络耗电高于wifi，因蜂窝数据连接会定期扫描以寻找更强信号。 无网时，应推迟后续网络请求，知道网络恢复。实现方案：待定,但感觉没有直接返回错误，网络恢复重要接口再请求好 减少Reachability网络状态检查频次。 数据源更新频率低时，减少重复请求频次：最简单的算法：数据相同，请求间隔累加 应定期集中短暂的使用网络，而不是持续的保持活动的数据流，只有这样，网络硬件才有机会关闭 定位管理器和GPS distanceFilter 移动最小距离，不会减少GPS接收器使用，但会影响CPU的使用 desiredAccuracy 影响使用天线个数，精度高用的天线多，更耗能 尽量关闭位置跟踪。在需要跟踪时调用startUpdatingLocation，不需要时调stopUpdatingLocation 后台长距离持续跟踪用 startMonitoringSignificantLocationChanges，精度跟desiredAccuracy和distanceFilter无关。比较好的办法是，前台用startUpdatingLocation，后台用startMonitoringSignificantLocationChanges 因缺乏资源，后台应用被关闭。此状况下一旦发生位置变化，应用会重启，因为需要重新初始化位置监听123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;if (launchOptions[UIApplicationLaunchOptionsLocationKey]) &#123;// 重启[LocaitonManager startMonitoringSignificantLocationChanges];&#125;&#125; 屏幕 前台使用动画，一旦程序进入后台应立即暂停动画 视频播放，使用UIApplication对象的idleTimerDisabled = YES 实现常亮，当前也可根据前后台切换来设置是否获取锁 多屏幕，当外部屏幕播放电影等时手机屏幕可保留最基本控制，以减少屏幕更新，延长电池使用 其它硬件 蓝牙、相机、扬声器、麦克风等，原则是当应用处于前台才与这些硬件交互，应用处于后台应停止交互 分析电量使用 instruments 精准电量：monsoon solutions 工具 代码感知123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 电池感知，ios8前只能精确动5%，以后可精确到1%- (BOOL)shouldProceedWithMinLevel:(NSUInteger)minLevel &#123;UIDevice *device = [UIDevice currentDevice];device.batteryMonitoringEnabled = YES;UIDeviceBatteryState state = device.batteryState;// 充电或满电if (state == UIDeviceBatteryStateCharging || state == UIDeviceBatteryStateFull) &#123;return YES;&#125;NSUInteger batteryLevel = (NSUInteger)(device.batteryLevel * 100);if (batteryLevel &gt;= minLevel) &#123;return YES;&#125;return NO;&#125;// cpu利用率- (float)appCPUUsage &#123;kern_return_t kr;task_info_data_t info;mach_msg_type_number_t infoCount = TASK_INFO_MAX;kr = task_info(mach_host_self(), TASK_BASIC_INFO, (task_info_t)info, &amp;infoCount);if (kr != KERN_SUCCESS) &#123;return -1;&#125;thread_array_t thread_list;mach_msg_type_number_t thread_count;thread_info_data_t thinfo;mach_msg_type_number_t thread_info_count;thread_basic_info_t basic_info_th;kr = task_threads(mach_host_self(), &amp;thread_list, &amp;thread_count);if (kr != KERN_SUCCESS) &#123;return -1;&#125;long total_time = 0;long total_userTime = 0;CGFloat total_cpu = 0;int j;for (j = 0; j &lt; (int)thread_count; j++) &#123;thread_info_count = THREAD_INFO_MAX;kr = thread_info(thread_list[j], THREAD_BASIC_INFO, (thread_info_t)thinfo, &amp;thread_info_count);if (kr != KERN_SUCCESS) &#123;return -1;&#125;basic_info_th = (thread_basic_info_t)thinfo;if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;total_time = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;total_cpu = total_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;&#125;&#125;vm_deallocate(mach_host_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));return total_cpu;&#125; 4 并发编程线程开销 主线程栈空间1M，二级线程默认分配512K的栈空间（可改），但某个时间点的实际使用栈空间要小的多 创建线程很耗时，平局在30毫秒左右，因多次上下文切换 dispatch_async 函数分发到全局队列不一定会新建线程执行任务，全局队列底层线程池上限是64个，如果线程池满了，那么后续的任务会被阻塞，有可能crash 操作和队列 GCD、NSOperationQueue 和 NSthread简介 锁的应用 GCD可以设置优先级，也可以cancel cancel都是设置标志位，对已开始的无效 线程安全的代码 原子性 atomic 默认的，但会增加开销 @synchronized 同步块，可以创建信号量并进入临界区，过度使用@synchronized会拖慢运行速度，因为任何时间都只有一个线程在临界区内执行。 锁：NSLock，NSRecursiveLock，NSCondition 将读写锁应用于并发读写 dispatch_barrier 阻塞操作用于写 使用不可变实体，不只是NSArray等，也包括怎么保证自定义类的不可变性？使用建造者模式 使用集中的状态更新服务 swift中尽量不使用类。 冰棒不可变实体：即使用一个frozen的bool属性标记此对象是否可变，所有属性setter方法均检查frozen来判断是否可更改。 状态观察与通知：RAC 异步优于同步，使用promise是最好的方式 应用的生命周期AppDelegate应用启动 第一次安装使用，反复拆解任务原则：确定在展示UI前必须执行的任务，按顺序执行，将任务分为必须在main执行和可在其它线程执行，其它任务可以在加载UI后执行或异步执行 冷启动：尽可能少的请求和展示数据，适当增加提示 热启动： 升级后启动：注意缓存问题 推送通知 远程通知：静默更新，富文本样式，通知调用顺序，当前app状态 先静默下载更新，在本地通知用户打开，可以更快显示内容 后台拉取 application：performFetchWith 任务必须在30秒内完成，尽量少拉取没用的东西，使用NSURLSession 后台拉取时其它挂起的队列也可能恢复，如果其它队列超时可能crash 后台拉取间隔受系统因素影响，不要过分依赖起规律 用户界面视图控制器 VC生命周期：init—&gt;loadView—&gt;viewDidLoad—&gt;viewWillApper—&gt;viewDidApper—&gt;viewWillDisapper—&gt;viewDidDisapper—&gt;viewWillUnload-&gt;viewDidUnload—&gt;dealloc 保持VC轻量：只是纽带，不是存放所有逻辑的地方 不要在VC中写动画：独立动画类，VC作为参数 使用数据源和委托协议，将代码按照数据检索、数据更新和其它业务逻辑进行分离，VC只能用来选择正确的视图，并将他们链接到供应源。 VC响应来自视图的事件，然后链接到数据接收器 VC响应系统级UI相关事件，例如方向和低内存等 不要编写自定义的init代码 VC中不要代码布局UI，也不要把所有布局都放到VC里 创建BaseVC 也可使用category创建可复用代码 如果载入时间过长，可加入等待动画，减少用户焦虑 视图加载 loadView 自定义UI的注意事项：将view属性设置到视图层级的根上，确保视图正被其它VC共享；不要调用super loadView 尽量不要重写loadView viewDidLoad要尽可能短 视图层级 视图结构和渲染步骤：1，构造子视图；2，计算并提供约束；3，为子视图递归执行步骤1和2；4，递归渲染 减少层级，异步计算 视图可见性 viewWillAppear 过渡动画未开始，不要启动任何视图动画 viewDidAppear VC展示且过渡动画结束，启动视图动画 viewWillDisappear 判断出栈还是入栈 123456789- (void)viewWillDisappear:(BOOL)animated &#123;NSInteger index = [self.navigationController.viewControllers indexOfObject:self];if (index == NSNotFound) &#123;// 出栈，销毁&#125;else &#123;// 入栈，保存，暂停&#125;[super viewWillDisappear:animated];&#125; viewDidAppear 视图 尽量减少在mian线程中所做的工作 避免较大的nib或故事板，拆分成小的，按需加载 避免多层嵌套，保持扁平化 延迟加载和重用 对于复杂的UI而言，最好使用自定义绘图，drawrect 减少cleanColor使用，减少透明度使用，减少圆角使用 UILabel 自定义字体，检查宽度或高度等都是很费时的任务 纯文本可以使用自定义绘图 UIButtonUIImageView 使用 imageName：加载已知图像 小图，复用，使用资源包 .xcassets 一次性大图用完就扔，使用imageWithContentsOfFile 使用SDWebImage,不要使用硬编码 尽量不要压缩或拉伸图像，图像多大显示多大性能最高 处理图像最好在一个单独的专用队列中进行。 UITableView 使用cell的重用机制 尽量避免动态高度单元格，如果必须使用动态高度，标记哪些是脏的，减少不必要渲染 使用自定义视图重用cell是避免调用 layoutIfNeeded每次都布局 避免透明子视图 快速滚动使用外壳cell（即模糊效果的cell），滚动快结束再刷新可视范围cell 避免渐变、图像缩放以及任何屏幕外的绘制。 自定义视图 drawRect方法不但可以使用CoreGraphics，也可以初始化再子视图调drawInRect方法绘制 自动布局 尽量用 网络指标和测量DNS查找时间 发起链接得第一步是DNS查找 减少查找时间：减少专有域名数量，启动时只链接关键域名， SSL握手时间 减少应用发起的连接数；为所有的https请求添加头Connection:keep-alive; 使用域分片 网络类型 Wifi，4G,3G,2G 设计时考虑不同网络的可用性；出现失败时，在随机的、以指数增长的延迟后进行重试，并设置最多重试次数；设定强制刷新之间的最短时间；监控网络状态变化但不要缓存网络状态；基于网络类型下载内容；预下载预缓存； 延迟 延迟 = 请求总时间 - 服务器话费时间 应用部署服务器请求 不要为每个操作都进行一次请求，使用批量请求 使用http缓存头设置正确的缓存级别 减少不必要的请求，如果有必要可限定请求间隔，请求重复数据可延长间隔，请求失败以指数增长延长重试间隔 数据格式 压缩 PB？ 工具网络链接调节器AT&amp;T应用资源优化器charles || whistle数据共享深层链接 使用统一资源标识符，其链接到应用内的特定位置 剪切板 不可控：传递不重要的消息 避免大数据， 进入后台后最好清除剪切板 安全 匿名用户设备id || 用户认证单点登录 使用https 本地敏感数据加密]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS锁相关]]></title>
    <url>%2F2016%2F09%2F18%2FiOS%E9%94%81%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前几天偶然看到不再安全的 OSSpinLock，里面介绍了9种锁，而我自己知道的只要三个：NSLock，dispatch_semaphore和@synchronized，今天抽时间查了下相关锁的使用，记录如下 1 锁的种类 临界区：指的是一块对公共资源进行访问的代码，并非一种机制或是算法。 自旋锁：反复检查(while(1)循环)锁变量是否可用。忙等虽然占用CPU，但避免了上下文切换的开销，所以只适用于阻塞时间很短的任务 互斥锁（Mutex）：当一个线程无法获得互斥量时直接挂起，当互斥量可用时系统在激活该线程 递归锁：可重复加锁并记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功。所以这个锁可以被同一线程多次请求，而不会引起死锁 读写锁：多读者-单写者锁，读操作可并发重入，写操作是互斥的。 读写锁通常用互斥锁、条件变量、信号量实现。 信号量（semaphore）：是一种更高级的同步机制，互斥锁可以说是semaphore在仅取值0/1时的特例。信号量可以有更多的取值空间，用来实现更加复杂的同步，而不单单是线程间互斥。 条件锁：顾名思义，不符合条件：锁住，符合条件：开锁，继续运行 死锁：由于竞争资源相互阻塞，谁也动不了就是死锁 2 互斥锁 2.1 NSlock 放心用AFN就在用 12345678910111213141516// NSLock的lock和unlock需要在同一个线程下// NSLock内部封装了一个 pthread_mutex，因此比较慢@property (readwrite, nonatomic, strong) NSLock *lock;// 初始化self.lock = [[NSLock alloc] init];self.lock.name = @&quot;com.compony.xxx.lock&quot;;// 使用[self.lock lock];// do something[self.lock unlock];// 试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程，相反，它只是返回NO[self.lock tryLock];// 尝试在给定时间内获得锁[self.lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:100]]; 2.2 pthread_mutex 1234567891011121314151617181920// C 语言下多线程加互斥锁的方式@interface JZKManager ()&#123;pthread_mutex_t _pLock;&#125;- (instancetype)init &#123;self = [super init];if (self) &#123;pthread_mutex_init(&amp;_pLock, NULL);&#125;return self;&#125;- (void)test &#123;pthread_mutex_lock(&amp;_pLock);// do somethingpthread_mutex_unlock(&amp;_pLock);&#125;- (void)dealloc &#123;pthread_mutex_destroy(&amp;_pLock);&#125; 2.3 @synchronized 慎用,更多内容：关于 @synchronized，这儿比你想知道的还要多 1234// obj为该锁的唯一标识,只有当标识相同时，才满足互斥@synchronized (obj) &#123;// do something&#125; 3 递归锁 3.1 NSRecursiveLock 12345// NSRecursiveLock与NSLock使用方式一样，区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVENSRecursiveLock *lock = [[NSRecursiveLock alloc] init];[lock lock];// dosomething [lock unlock]; 3.2 pthread_mutex(recursive) 12345678910111213141516171819202122232425262728293031/*PTHREAD_MUTEX_NORMAL 缺省类型，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后先进先出原则获得锁。PTHREAD_MUTEX_ERRORCHECK 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与普通锁类型动作相同。这样就保证当不允许多次加锁时不会出现嵌套情况下的死锁。PTHREAD_MUTEX_RECURSIVE 递归锁，允许同一个线程对同一个锁成功获得多次，并通过多次 unlock 解锁。PTHREAD_MUTEX_DEFAULT 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争，没有等待队列*/@interface JZKManager ()&#123;pthread_mutex_t _pLock;&#125;- (instancetype)init &#123;self = [super init];if (self) &#123;pthread_mutexattr_t attr;pthread_mutexattr_init (&amp;attr);pthread_mutexattr_settype (&amp;attr, PTHREAD_MUTEX_RECURSIVE);pthread_mutex_init (&amp;_lock, &amp;attr);pthread_mutexattr_destroy (&amp;attr);&#125;return self;&#125;- (void)test &#123;pthread_mutex_lock(&amp;_lock);// do somethingpthread_mutex_unlock(&amp;_lock);&#125;- (void)dealloc &#123;pthread_mutex_destroy(&amp;_lock);&#125; 4 信号量 4.1 dispatch_semaphore 放心用SD就在用1234567891011// 常用宏定义,SD源码#define LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);#define UNLOCK(lock) dispatch_semaphore_signal(lock);// 使用@property (nonatomic, strong, nonnull) dispatch_semaphore_t weakCacheLock; // a lock to keep the access to `weakCache` thread-safe// call At self initself.weakCacheLock = dispatch_semaphore_create(1);// useLOCK(self.weakCacheLock);// do somethingUNLOCK(self.weakCacheLock); 5 读写锁 5.1 pthread_rwlock 12345678910111213141516171819202122232425// 跟pthread_mutex类似，唯一区别是上锁时分为读锁还是写锁@interface JZKManager ()&#123;pthread_rwlock_t _rwlock;&#125;- (instancetype)init &#123;self = [super init];if (self) &#123;pthread_rwlock_init(&amp;_rwlock, NULL);&#125;return self;&#125;- (void)read &#123;pthread_rwlock_rdlock(&amp;_rwlock);// do somethingpthread_rwlock_unlock(&amp;_rwlock);&#125;- (void)write &#123;pthread_rwlock_wrlock(&amp;_rwlock);// do somethingpthread_rwlock_unlock(&amp;_rwlock);&#125;- (void)dealloc &#123;pthread_rwlock_destroy(&amp;_rwlock);&#125; 5.2 另类思路：dispatch_barrier_async / dispatch_barrier_sync 123456789/ 主要用于解决多线程并发读写同一个资源发生死锁// dispatchbarrier\(a)sync只在自己创建的并发队列上有效，在全局(Global)并发队列、串行队列上，效果跟dispatch_(a)sync效果一样。dispatch_queue_t queue = dispatch_queue_create(&quot;com.example.MyQueue&quot;, DISPATCH_QUEUE_CONCURRENT);// 其它异步操作a b cdispatch_barrier_async(queue, ^&#123;// 唯我独尊，这个时间段队列只运行这个block&#125;);// 其它异步操作 e f 6 条件锁 NSConditionLock1234NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];if([cLock tryLockWhenCondition:0])&#123;[cLock unlockWithCondition:1];&#125; 7 自旋锁 OSSpinLock 已废弃 参考或其他优秀博客 关于 @synchronized，这儿比你想知道的还要多 不再安全的 OSSpinLock 实现锁的多种方式和锁的高级用法 https://stackoverflow.com/questions/2065747/pthreads-mutex-vs-semaphore 正确使用多线程同步锁@synchronized 谈谈iOS多线程的锁 白夜追凶，揭开iOS锁的秘密 抛开性能，谈谈不该用@Synchronized的原因]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runloop]]></title>
    <url>%2F2016%2F09%2F11%2FRunloop%2F</url>
    <content type="text"><![CDATA[1 介绍1 Runloop&emsp;&emsp;Runloop是用于线程调度的，让线程有“事”干活，没“事”休息！方式就是执行一个while循环 “接受消息-&gt;等待-&gt;处理”，直到这个循环结束（比如传入quit的消息），函数返回。CFRunLoopRef是开源的，可以在 https://opensource.apple.com/tarballs/CF/ 下载到整个 CoreFoundation 的源码123456789101112int main(int argc, char * argv[]) &#123;//程序一直运行状态while (AppIsRunning) &#123;//睡眠状态，等待唤醒事件id whoWakesMe = SleepForWakingUp();//得到唤醒事件id event = GetEvent(whoWakesMe);//开始处理事件HandleEvent(event);&#125;return 0;&#125; 2 Runloop与线程&emsp;&emsp;线程和RunLoop之间是一一对应的，除主线程外（主线程默认开启runloop）其它线程需要手动开启runloop，即需要手动获取一下runloop，系统会自己开启runloop123456// 获取主线程runloop[NSRunLoop mainRunLoop];// 1、开辟新线程// 2、获取新线程的runloop[NSRunLoop currentRunLoop]; 3 Runloop组成&emsp;&emsp;在 CoreFoundation 里面关于 RunLoop 有5个类:CFRunLoopRef、CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef、CFRunLoopObserverRef，参考：盗的大神的图1234567891011121314151617181920typedef struct __CFRunLoop * CFRunLoopRef;struct __CFRunLoop &#123;// 其它变量.....pthread_t _pthread; // 线程和RunLoop之间是一一对应的uint32_t _winthread;CFMutableSetRef _commonModes; // Set &lt;ModeName&gt;CFMutableSetRef _commonModeItems; // Set &lt;Source/Observer/Timer&gt;CFRunLoopModeRef _currentMode; // Current Runloop Mode// 其它变量.....&#125;;typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123;// 其它变量.....CFMutableSetRef _sources0; // 处理如UIEvent，CFSocket这样的事件CFMutableSetRef _sources1; // Mach port驱动，CFMachport，CFMessagePortCFMutableArrayRef _observers; // typedef struct __CFRunLoopObserver * CFRunLoopObserverRef;CFMutableArrayRef _timers; // typedef struct CF_BRIDGED_MUTABLE_TYPE(NSTimer) __CFRunLoopTimer * CFRunLoopTimerRef;// 其它变量.....&#125;; 3.1 CFRunLoopModeRef&emsp;&emsp;CFRunLoopModeRef只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 NSDefaultRunLoopMode：默认，空闲状态 UITrackingRunLoopMode：ScrollView滑动时 UIInitializationRunLoopMode：启动时 NSRunLoopCommonModes：Mode集合Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes来解决 3.2 CFRunLoopSourceRef _sources0; // 处理如UIEvent，CFSocket这样的事件 _sources1; // Mach port驱动，CFMachport，CFMessagePort 3.3 CFRunLoopObserverRef12345678910/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入loopkCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 TimerkCFRunLoopBeforeSources = (1UL &lt;&lt; 2),// 即将处理 SourcekCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5),// 即将进入休眠kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出LoopkCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; 3.4 CFRunLoopTimerRef&emsp;&emsp; 和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 2 RunLoop使用1 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int test() &#123;pthread_t t;pthread_create(&amp;t, NULL, &amp;runLoopStart, NULL);pthread_join(t, NULL);return 1;&#125;static void *runLoopStart() &#123;CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFRunLoopSourceContext *context = malloc(sizeof(CFRunLoopSourceContext));CFRunLoopSourceContext contextTemplate = &#123;0,NULL,NULL,NULL,NULL,NULL,NULL,RunloopSourceSchedule,RunloopSourceCancel,RunloopSourcePerform&#125;;memcpy(context, &amp;contextTemplate, sizeof(CFRunLoopSourceContext));CFRunLoopSourceRef source = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, context);CFRunLoopAddSource(runLoop, source, kCFRunLoopDefaultMode);CFRunLoopSourceSignal(source);CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;switch (activity) &#123;case kCFRunLoopEntry:NSLog(@&quot;observer: loop entry&quot;);break;case kCFRunLoopBeforeTimers:NSLog(@&quot;observer: before timers&quot;);break;case kCFRunLoopBeforeSources:NSLog(@&quot;observer: before sources&quot;);break;case kCFRunLoopBeforeWaiting:NSLog(@&quot;observer: before waiting&quot;);break;case kCFRunLoopAfterWaiting:NSLog(@&quot;observer: after waiting&quot;);break;case kCFRunLoopExit:NSLog(@&quot;observer: exit&quot;);break;case kCFRunLoopAllActivities:NSLog(@&quot;observer: all activities&quot;);break;default:break;&#125;&#125;);CFRunLoopAddObserver(runLoop, observer, kCFRunLoopDefaultMode);CFRunLoopWakeUp(runLoop);NSTimeInterval theFuture = [NSDate timeIntervalSinceReferenceDate] + 4.0;while ([NSDate timeIntervalSinceReferenceDate] &lt; theFuture) &#123;CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.0, YES);sleep(1);&#125;CFRunLoopRemoveSource(runLoop, source, kCFRunLoopDefaultMode);CFRunLoopRemoveObserver(runLoop, observer, kCFRunLoopDefaultMode);free(context);CFRelease(source);CFRelease(observer);return NULL;&#125;void RunloopSourceSchedule(void *info, CFRunLoopRef rl, CFRunLoopMode mode) &#123;NSLog(@&quot;Schedule routine: source is added to runloop&quot;);&#125;void RunloopSourceCancel(void *info, CFRunLoopRef rl, CFRunLoopMode mode) &#123;NSLog(@&quot;Cancel Routine: source removed from runloop&quot;);&#125;void RunloopSourcePerform(void *info) &#123;NSLog(@&quot;Perform Routine: source has fired&quot;);&#125; 2 大神总结的问题，摘录在此 AutoreleasePool什么时候释放？ kCFRunLoopEntry、kCFRunLoopBeforeWaiting和kCFRunLoopExit时会自动释放AutoreleasePool 事件响应跟runloop关系？苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()，进行事件的包装处理和分发 手势识别，苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver() 界面更新，苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 定时器，一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件 PerformSelecter，当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 3 RunLoop内部逻辑&emsp;&emsp;先把大神的结论放出来:盗的大神的图 源码里核心方法是 __CFRunLoopRun，说实话不参照大神给的代码注解，真心不好看懂此函数有300多行，我就不显丑了，感兴趣的自己去研究源码吧!抄录大神的注解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123;CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;/// 首先根据modeName找到对应modeCFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);/// 如果mode里没有source/timer/observer, 直接返回。if (__CFRunLoopModeIsEmpty(currentMode)) return;/// 1. 通知 Observers: RunLoop 即将进入 loop。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);/// 内部函数，进入loop__CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;Boolean sourceHandledThisLoop = NO;int retVal = 0;do &#123;/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 4. RunLoop 触发 Source0 (非port) 回调。sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);/// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。if (__Source0DidDispatchPortLastTime) &#123;Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)if (hasMsg) goto handle_msg;&#125;/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。if (!sourceHandledThisLoop) &#123;__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);&#125;/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。/// • 一个基于 port 的Source 的事件。/// • 一个 Timer 到时间了/// • RunLoop 自身的超时时间到了/// • 被其他什么调用者手动唤醒__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg&#125;/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);/// 收到消息，处理消息。handle_msg:/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。if (msg_is_timer) &#123;__CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())&#125; /// 9.2 如果有dispatch到main_queue的block，执行block。else if (msg_is_dispatch) &#123;__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);&#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件else &#123;CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);if (sourceHandledThisLoop) &#123;mach_msg(reply, MACH_SEND_MSG, reply);&#125;&#125;/// 执行加入到Loop的block__CFRunLoopDoBlocks(runloop, currentMode);if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;/// 进入loop时参数说处理完事件就返回。retVal = kCFRunLoopRunHandledSource;&#125; else if (timeout) &#123;/// 超出传入参数标记的超时时间了retVal = kCFRunLoopRunTimedOut;&#125; else if (__CFRunLoopIsStopped(runloop)) &#123;/// 被外部调用者强制停止了retVal = kCFRunLoopRunStopped;&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;/// source/timer/observer一个都没有了retVal = kCFRunLoopRunFinished;&#125;/// 如果没超时，mode里没空，loop也没被停止，那继续loop。&#125; while (retVal == 0);&#125;/// 10. 通知 Observers: RunLoop 即将退出。__CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; &emsp;&emsp;: 好玩的CFRuntimeBase是啥？是所有CF “instances”的“根类”12345678910111213/* All CF &quot;instances&quot; start with this structure. Never refer to* these fields directly -- they are for CF&apos;s use and may be added* to or removed or change format without warning. Binary* compatibility for uses of this struct is not guaranteed from* release to release.*/typedef struct __CFRuntimeBase &#123;uintptr_t _cfisa;uint8_t _cfinfo[4];#if __LP64__uint32_t _rc;#endif&#125; CFRuntimeBase; 参考 https://blog.ibireme.com/2015/05/18/runloop/ https://github.com/ming1016/study/wiki/CFRunLoop 其它优质博客 http://mrpeak.cn/blog/ios-runloop/ https://juejin.im/post/5afcf305f265da0b8e7f9b74#comment https://juejin.im/post/5a951cb26fb9a0633229d4ec#comment]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime的使用]]></title>
    <url>%2F2016%2F09%2F02%2Fruntime%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。Runtime是C和汇编编写的，这里 https://opensource.apple.com/tarballs/objc4/ 可下载源码 常用API介绍 类相关 1234567891011121314151617181920212223242526// 获取类的类名const char * class_getName ( Class cls );// 获取类的父类，当cls为Nil或者cls为根类时，返回NilClass class_getSuperclass ( Class cls );// 判断给定的Class是否是一个元类，如果是cls是元类，则返回YESBOOL class_isMetaClass ( Class cls );// 创建一个新类和元类，如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );// 销毁一个类及其相关联的类，如果程序运class_conformsToProtocol行中还存在类或其子类的实例，则不能调用针对类调用该方法void objc_disposeClassPair ( Class cls );// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls );// 获取已注册的类定义的列表int objc_getClassList ( Class *buffer, int bufferCount );// 创建并返回一个指向所有已注册类的指针列表Class * objc_copyClassList ( unsigned int *outCount );// 返回指定类的类定义，如果类在运行时未注册，则objc_lookUpClass会返回nil，// 而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil// 而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程。Class objc_lookUpClass ( const char *name );Class objc_getClass ( const char *name );Class objc_getRequiredClass ( const char *name );// 返回指定类的元类Class objc_getMetaClass ( const char *name ); ivar 123456789101112131415// 获取类中指定名称实例成员变量的信息，返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。Ivar class_getInstanceVariable ( Class cls, const char *name );// 获取类成员变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量，只能在objc_allocateClassPair函数与objc_registerClassPair之间调用BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );// 获取整个成员变量列表，但不包含在父类中声明的变量，必须使用free()来释放。outCount指针返回数组的大小Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );// 获取成员变量名const char * ivar_getName ( Ivar v );// 获取成员变量类型编码const char * ivar_getTypeEncoding ( Ivar v );// 获取成员变量的偏移量ptrdiff_t ivar_getOffset ( Ivar v ); property 123456789101112131415161718// 获取指定的属性objc_property_t class_getProperty ( Class cls, const char *name );// 获取属性列表objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );// 为类添加属性BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );// 替换类的属性void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );// 获取属性名const char * property_getName ( objc_property_t property );// 获取属性特性描述字符串const char * property_getAttributes ( objc_property_t property );// 获取属性中指定的特性，必须使用free()来释放。char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );// 获取属性的特性列表，必须使用free()来释放。objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount ); 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 添加方法，如果本类中包含一个同名的实现，则函数会返回NO！// https://stackoverflow.com/questions/49003493/objc-class-addmethod-does-not-check-argument-type?r=SearchResultsBOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );// 移除方法？不能，参考：https://stackoverflow.com/questions/1315169/how-do-i-remove-instance-methods-at-runtime-in-objective-c-2-0// 获取实例方法，会去搜索父类的实现Method class_getInstanceMethod ( Class cls, SEL name );// 获取类方法，会去搜索父类的实现Method class_getClassMethod ( Class cls, SEL name );// 获取所有实例方法的数组，但不会去搜索父类的实现，必须使用free()来释放。outCount指针返回数组的大小// 获取类方法，则可以使用class_copyMethodList(object_getClass(cls), &amp;count)因为一个类的实例方法是定义在元类里面Method * class_copyMethodList ( Class cls, unsigned int *outCount );// 替代方法的实现，如果不存在同名方法则类似class_addMethod添加方法，存在则类似method_setImplementation替代原方法的实现IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );// 返回方法的具体实现，一个指向方法实现函数的指针。比method_getImplementation(class_getInstanceMethod(cls, name))更快IMP class_getMethodImplementation ( Class cls, SEL name );IMP class_getMethodImplementation_stret ( Class cls, SEL name );// 类实例是否响应指定的selectorBOOL class_respondsToSelector ( Class cls, SEL sel );// Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。// 工程中的所有的SEL组成一个Set集合，这也是为啥OC，不同类（无论是否继承）不能有同名方法！SEL方法签名// IMP实际上是一个函数指针，指向方法实现的首地址// 调用指定方法的实现id method_invoke ( id receiver, Method m, ... );// 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );// 获取方法名SEL method_getName ( Method m );// 返回方法的实现IMP method_getImplementation ( Method m );// 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );// 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );// 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );// 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );// 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );// 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );// 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );// 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );// 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 );// 返回给定选择器指定的方法的名称const char * sel_getName ( SEL sel );// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器SEL sel_registerName ( const char *str );// 在Objective-C Runtime系统中注册一个方法SEL sel_getUid ( const char *str );// 比较两个选择器BOOL sel_isEqual ( SEL lhs, SEL rhs ); 协议 12345678910111213141516171819202122232425262728293031323334353637// 添加协议BOOL class_addProtocol ( Class cls, Protocol *protocol );// 返回类是否实现指定的协议, 不检测父类中实现的Protocol,而 [NSObject conformsToProtocol:] 检测所有继承类中实现的ProtocolBOOL class_conformsToProtocol ( Class cls, Protocol *protocol );// 返回类实现的协议列表，但不包含在父类的协议，必须使用free()来释放。outCount指针返回数组的大小Protocol * class_copyProtocolList ( Class cls, unsigned int *outCount );// 返回指定的协议,如果仅仅是声明了一个协议，而未在任何类中实现这个协议，则该函数返回的是nilProtocol * objc_getProtocol ( const char *name );// 获取运行时所知道的所有协议的数组,，必须使用free()来释放Protocol ** objc_copyProtocolList ( unsigned int *outCount );// 创建新的协议实例，如果同名的协议已经存在，则返回nilProtocol * objc_allocateProtocol ( const char *name );// 在运行时中注册新创建的协议，协议注册后便可以使用，但不能再做修改，即注册完后不能再向协议添加方法或协议void objc_registerProtocol ( Protocol *proto );// 为协议添加方法void protocol_addMethodDescription ( Protocol *proto, SEL name, const char *types, BOOL isRequiredMethod, BOOL isInstanceMethod );// 添加一个已注册的协议到协议中void protocol_addProtocol ( Protocol *proto, Protocol *addition );// 为协议添加属性void protocol_addProperty ( Protocol *proto, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount, BOOL isRequiredProperty, BOOL isInstanceProperty );// 返回协议名const char * protocol_getName ( Protocol *p );// 测试两个协议是否相等BOOL protocol_isEqual ( Protocol *proto, Protocol *other );// 获取协议中指定条件的方法的方法描述数组struct objc_method_description * protocol_copyMethodDescriptionList ( Protocol *p, BOOL isRequiredMethod, BOOL isInstanceMethod, unsigned int *outCount );// 获取协议中指定方法的方法描述struct objc_method_description protocol_getMethodDescription ( Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod );// 获取协议中的属性列表objc_property_t * protocol_copyPropertyList ( Protocol *proto, unsigned int *outCount );// 获取协议的指定属性objc_property_t protocol_getProperty ( Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty );// 获取协议采用的协议Protocol ** protocol_copyProtocolList ( Protocol *proto, unsigned int *outCount );// 查看协议是否采用了另一个协议BOOL protocol_conformsToProtocol ( Protocol *proto, Protocol *other ); 实例对象 1234567891011121314151617181920212223242526// 获取实例大小size_t class_getInstanceSize ( Class cls );// 返回给定对象的类名const char * object_getClassName ( id obj );// 返回对象的类Class object_getClass ( id obj );// 设置对象的类Class object_setClass ( id obj, Class cls );// 返回指定对象的一份拷贝id object_copy ( id obj, size_t size );// 释放指定对象占用的内存id object_dispose ( id obj );// 修改类实例的实例变量的值Ivar object_setInstanceVariable ( id obj, const char *name, void *value );// 获取对象实例变量的值Ivar object_getInstanceVariable ( id obj, const char *name, void **outValue );// 返回指向给定对象分配的任何额外字节的指针void * object_getIndexedIvars ( id obj );// 返回对象中实例变量的值id object_getIvar ( id obj, Ivar ivar );// 设置对象中实例变量的值void object_setIvar ( id obj, Ivar ivar, id value ); 关联对象 123456// 设置关联对象void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );// 获取关联对象id objc_getAssociatedObject ( id object, const void *key );// 移除关联对象void objc_removeAssociatedObjects ( id object ); 编码类型,@encode返回这个类型的字符串编码 12345// 编译器将每个方法的返回值和参数类型编码为一个字符串，并将其与方法的selector关联在一起,@encode返回这个类型的字符串编码const char *argType = [self.methodSignature getArgumentTypeAtIndex:index];if (strcmp(argType, @encode(int)) == 0) &#123;// return value is int &#125; block 123456// 创建一个指针函数的指针，该函数调用时会调用特定的block，参数block的签名必须是method_return_type ^(id self, method_args …)形式的。IMP imp_implementationWithBlock ( id block );// 返回与IMP(使用imp_implementationWithBlock创建的)相关的blockid imp_getBlock ( IMP anImp );// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝BOOL imp_removeBlock ( IMP anImp ); 常用 Method Swizzle 123456789101112static void SwizzleMethod(Class cls, SEL ori, SEL rep) &#123;Method oriMethod = class_getInstanceMethod(cls, ori);Method repMethod = class_getInstanceMethod(cls, rep);BOOL flag = class_addMethod(cls, ori, method_getImplementation(repMethod), method_getTypeEncoding(repMethod));if (flag) &#123;class_replaceMethod(cls, rep, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));&#125; else &#123;method_exchangeImplementations(oriMethod, repMethod);&#125;&#125; 打印所有信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172- (void)print:(Class)cls &#123;unsigned int outCount = 0;NSLog(@&quot;===========================&quot;);NSLog(@&quot;----------------------&quot;);Class tempCls = cls;while (tempCls != NULL) &#123;NSLog(@&quot;class name: %s&quot;,class_getName(tempCls));// isa指针是啥？实例对象的isa指针指向类对象，类对象的isa指针指向元类对象。Class meta_class = objc_getMetaClass(class_getName(tempCls));NSLog(@&quot;%s&apos;s meta-class is %s&quot;, class_getName(tempCls), class_getName(meta_class));tempCls = class_getSuperclass(tempCls);&#125;NSLog(@&quot;----------------------&quot;);Ivar *ivars = class_copyIvarList(cls, &amp;outCount);for (int i = 0; i &lt; outCount; i++) &#123;Ivar ivar = ivars[i];NSLog(@&quot;ivar : %s type:%s at index: %d&quot;, ivar_getName(ivar) , ivar_getTypeEncoding(ivar), i);&#125;free(ivars);Ivar shoolNum = class_getInstanceVariable(cls, &quot;_schoolNum&quot;);if (shoolNum != NULL) &#123;NSLog(@&quot;ivar _schoolNum is exist&quot;);&#125;NSLog(@&quot;----------------------&quot;);objc_property_t *propertys = class_copyPropertyList(cls, &amp;outCount);for (int i = 0; i &lt; outCount; i++) &#123;objc_property_t p = propertys[i];NSLog(@&quot;property : %s attributes:%s at index: %d&quot;, property_getName(p) , property_getAttributes(p), i);&#125;free(propertys);objc_property_t name = class_getProperty(cls, &quot;name&quot;);if (name != NULL) &#123;NSLog(@&quot;property name is exist&quot;);&#125;NSLog(@&quot;----------------------&quot;);Method *methods = class_copyMethodList(cls, &amp;outCount);for (int i = 0; i &lt; outCount; i++) &#123;Method m = methods[i];NSLog(@&quot;Method : %s typeEncoding:%s&quot;,method_getName(m), method_getTypeEncoding(m));unsigned int argCount = method_getNumberOfArguments(m);for (int j = 0; j &lt; argCount; j++) &#123;char *argType = method_copyArgumentType(m, j);NSLog(@&quot;Method %s arg: %s at index: %i&quot;,method_getName(m), argType , j);free(argType);&#125;char *returnType = method_copyReturnType(m);NSLog(@&quot;Method %s return: %s&quot;,method_getName(m),returnType);free(returnType);&#125;free(methods);Method walk = class_getInstanceMethod(cls, @selector(walk));if (walk != NULL) &#123;NSLog(@&quot;method %s&quot;, method_getName(walk));&#125;Method sleep = class_getClassMethod(cls, @selector(sleep));if (sleep != NULL) &#123;NSLog(@&quot;class method : %s&quot;, method_getName(sleep));&#125;if (class_respondsToSelector(cls, @selector(eat))) &#123;IMP eat = class_getMethodImplementation(cls, @selector(eat));eat();&#125;NSLog(@&quot;----------------------&quot;);Protocol * __unsafe_unretained * protocols = class_copyProtocolList(cls, &amp;outCount);for (int i = 0; i &lt; outCount; i++) &#123;Protocol *p = protocols[i];NSLog(@&quot;protocol name: %s&quot;, protocol_getName(p));&#125;if (class_conformsToProtocol(cls, @protocol(UITableViewDelegate))) &#123;class_addProtocol(cls, @protocol(UITableViewDelegate));&#125;&#125; 添加新类 1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)addNewClass &#123;Class newClass = objc_allocateClassPair([Person class], &quot;XiaoHong&quot;, 0);/*Type Encodings：https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1*/class_addIvar(newClass, &quot;_shoes&quot;, sizeof(int), rint(log2(sizeof(int))), @encode(int));/*属性的特性字符串 以 T@encode(type) 开头type类型分为以下几种1、所有类，包括NSOjbect，是什么类型就 @“类型”即可2、基础类型：NSInteger-&gt;q、NSUInteger-&gt;Q、int-&gt;i、float-&gt;f、double-&gt;d、BOOL-&gt;B3、Block -&gt; @?*/objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;q&quot;&#125;;/*中间以特性编码填充R-&gt;readonly、C-&gt;copy、&amp;-&gt;retain、N-&gt;nonatomic、G(name)-&gt;getter=(name)、S(name)-》setter=(name)、D-&gt;@dynamic、W-&gt;weak*/objc_property_attribute_t ownership = &#123; &quot;N&quot;, &quot;&quot; &#125;;//以 V实例变量名称 结尾，注无法动态注册关联对象也没必要objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_shoes&quot;&#125;;objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;class_addProperty(newClass, &quot;shoes&quot;, attrs, 3);// method_getTypeEncoding/*https://stackoverflow.com/questions/11491947/what-are-the-digits-in-an-objc-method-type-encoding-stringhttps://stackoverflow.com/questions/43492021/runtime-what-does-this-mean-in-class-addmethod?r=SearchResults结论: &quot;v@:@&quot;：v：是void； @表示是id(即self) ：表示_cmd @表示：第一个参数类型（此为id），其他可参照Type Encodings，所以 &quot;v@:&quot; 即无参数https://stackoverflow.com/questions/20735814/adding-objective-c-method-to-class-at-runtime?r=SearchResults结论: colorWithWhite:alpha: -&gt; @@:ff*/ class_addMethod(newClass, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);class_replaceMethod(newClass, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);objc_registerClassPair(newClass);id instance = [[newClass alloc] init];[instance performSelector:@selector(submethod1)];[instance performSelector:@selector(method1)];&#125; 添加新协议 12345678910- (void)addNewProtocol &#123;Protocol *newP = objc_allocateProtocol(&quot;MyDelete&quot;);protocol_addMethodDescription(newP, @selector(submethod1), &quot;v@:&quot;, NO, NO);objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;q&quot;&#125;;objc_property_attribute_t ownership = &#123; &quot;N&quot;, &quot;&quot; &#125;;objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_shoes&quot;&#125;;objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;protocol_addProperty(newP, &quot;shoes&quot;, attrs, 3, NO, NO);objc_registerProtocol(newP);&#125; 父类到子类的强转是怎么进行的？ 12345// 把NSObject的实例（内存空间小）转为MyClass（内存空间大），即强制转换NSObject *a = [[NSObject alloc] init];id newB = object_copy(a, class_getInstanceSize(MyClass.class));object_setClass(newB, MyClass.class);object_dispose(a); 参考 http://southpeak.github.io/2014/10/25/objective-c-runtime-1/ http://southpeak.github.io/2014/10/30/objective-c-runtime-2/ http://southpeak.github.io/2014/11/03/objective-c-runtime-3/ http://southpeak.github.io/2014/11/06/objective-c-runtime-4/ http://southpeak.github.io/2014/11/08/objective-c-runtime-5/ http://southpeak.github.io/2014/11/09/objective-c-runtime-6/ https://github.com/ming1016/study/wiki/Objc-Runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画3：核心动画高级技巧笔记]]></title>
    <url>%2F2016%2F08%2F25%2F%E5%8A%A8%E7%94%BB3%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[参考：https://github.com/qunten/iOS-Core-Animation-Advanced-Techniques UIView和CAlayer关系：UIView处理交互，CAlayer处理渲染 CALayer的contents属性，如果赋值不是CGImage，那么图层将是空白的 CALayer的contentsGravity属性决定填充样式 layer.contentsScale = [UIScreen mainScreen].scale; contentsRect 裁切显示一部分 contentsCenter 定义了固定边界和可拉伸区域 CALayerDelegate anchorPoint 锚点 坐标转化：convertPoint: fromLayer 同 convertPoint: fromView: zPosition 可以设置layer显示层级，但最好不用 CALayer不支持自动布局，想要调整最好用delegate方法layoutSublayersOfLayer cornerRadius 圆角 masksToBound 剪切 borderWidth 和 borderColor shadowColor，shadowOffset和shadowRadius mask蒙层的color其实无关紧要，重要的是实心部分会保留，其它抛弃 CALayer为此提供了三种拉伸过滤方法，他们是：kCAFilterLinear，kCAFilterNearest，kCAFilterTrilinear。minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear 使用shouldRasterize属性解决组透明问题 CAShapeLayer能通过CGPath来表示形状 CATextLayer使用了Core text，用于文字绘制 CATransformLayer 解决3D变化 CAGradientLayer是用来生成两种或更多颜色平滑渐变的 CAReplicatorLayer的目的是为了高效生成许多相似的图层，使用CAReplicatorLayer并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果 UIScrollView并没有用CAScrollLayer CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入 CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果 CAEAGLLayer是CALayer的一个子类，用来显示任意的OpenGL图形 AVPlayerLayer是用来在iOS上播放视频的 [CATransaction begin]; 。。。。。。 [CATransaction commit]; 动画过程中可以通过-presentationLayer方法来访问图层，但是它的属性值代表了在任何指定时刻当前外观效果 把图层的speed设置成0，它会暂停任何添加到图层上的动画。类似的，设置speed大于1.0将会快进，设置成一个负值将会倒回动画 设置speed为0，然后来使用timeOffset让你手动控制动画 异步绘制，然后将由此绘出的图片直接设置为图层的内容。Core Animation提供了一些选择：CATiledLayer和drawsAsynchronously属性]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义UIPickerView]]></title>
    <url>%2F2016%2F08%2F05%2F%E8%87%AA%E5%AE%9A%E4%B9%89UIPickerView%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;为啥要写这篇文章？水肯定是必然的！更主要的原因是碰到了二逼UI，非说系统自带的3D效果滚轮不好看，非要做成安卓的样子（安卓用的三方库）！iOS没有现成的三方库（看到没，估计这UI大姐是设计界里第一个觉得iOS系统pickerview丑的“大神”，要不然怎么可能没有开源库！），UI又坚持就要安卓的样子，甚至闹到了老大那里…，老大问我能不能实现？呵呵！我能咋办…能实现！（其实我是想说不，但老大想息事宁人，还是不说了谁让自己是农民工呢…） 自定义PickerViewH文件1234567891011121314151617181920212223242526272829303132333435// 自定义picker#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@class BFPickerView;@protocol BFPickerViewDataSource&lt;NSObject&gt;@required- (NSInteger)numberOfComponentsInPickerView:(BFPickerView *)pickerView;- (NSInteger)pickerView:(BFPickerView *)pickerView numberOfRowsInComponent:(NSInteger)component;@end@protocol BFPickerViewDelegate&lt;NSObject&gt;@required- (NSString *)pickerView:(BFPickerView *)pickerView titleForRow:(NSInteger)row forComponent:(NSInteger)component;@optional- (CGFloat)pickerView:(BFPickerView *)pickerView widthForComponent:(NSInteger)component;- (CGFloat)pickerView:(BFPickerView *)pickerView rowHeightForComponent:(NSInteger)component;- (void)pickerView:(BFPickerView *)pickerView didSelectRow:(NSInteger)row inComponent:(NSInteger)component;@end@interface BFPickerView : UIView&lt;NSCoding&gt;@property(nullable,nonatomic,weak) id&lt;BFPickerViewDataSource&gt; dataSource;@property(nullable,nonatomic,weak) id&lt;BFPickerViewDelegate&gt; delegate;- (void)reloadAllComponents;- (void)reloadComponent:(NSInteger)component;- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component;- (NSInteger)selectedRowInComponent:(NSInteger)component;@end M文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280#import &quot;BFPickerView.h&quot;#import &lt;Masonry.h&gt;#import &quot;UIColor+LicaiColor.h&quot;#import &quot;UIFont+Licai.h&quot;#define kPickerSubscrollViewTag 8486@interface BFPickerView ()&lt;UIScrollViewDelegate&gt;@property (nonatomic, strong) UIImageView *upImageView;@property (nonatomic, strong) UIView *upLineView;@property (nonatomic, strong) UIImageView *downImageView;@property (nonatomic, strong) UIView *downLineView;@property (nonatomic, assign) BOOL isSubViewLayouted;@property (nonatomic, assign) NSInteger componentCount;@property (nonatomic, strong) NSMutableDictionary *selectDic;@end@implementation BFPickerView- (instancetype)init &#123;self = [super init];if (self) &#123;[self setUp];&#125;return self;&#125;- (void)selectRow:(NSInteger)row inComponent:(NSInteger)component&#123;[self reloadComponent:component];CGFloat cellHeight = [self rowHeightForComponent:component];// UITableView存在复用机制，可能会闪或者消失UIScrollView *scrollView = [self scrollViewFromComponent:component];[scrollView setContentOffset:CGPointMake(0, cellHeight * row) animated:NO];&#125;//- (NSInteger)selectedRowInComponent:(NSInteger)component &#123;return [[self.selectDic objectForKey:@(component + kPickerSubscrollViewTag)] integerValue];&#125;- (BOOL)verifyComponent:(NSInteger)component &#123;if (component &gt;= 0 &amp;&amp; component &lt; [self numberOfComponent]) &#123;return YES;&#125;else &#123;return NO;&#125;&#125;//- (BOOL)verifyrow:(NSInteger)row inComponent:(NSInteger)component &#123;if (row &gt;= 0 &amp;&amp; row &lt; [self numberOfRowsInComponent:component]) &#123;return YES;&#125;else &#123;return NO;&#125;&#125;#pragma mark reload- (void)reloadAllComponents &#123;for (int i = 0; i &lt; [self numberOfComponent]; i++) &#123;[self reloadComponent:i];&#125;&#125;- (void)reloadComponent:(NSInteger)component &#123;if (![self verifyComponent:component]) &#123;return;&#125;UIScrollView *scrollView = [self scrollViewFromComponent:component];CGFloat width = [self widthForComponent:component];if (scrollView) &#123;[scrollView mas_updateConstraints:^(MASConstraintMaker *make) &#123;make.width.equalTo(@(width));&#125;];&#125;else &#123;scrollView = [self makescrollView];scrollView.tag = kPickerSubscrollViewTag + component;CGFloat cellHeight = [self rowHeightForComponent:component];[self addSubview:scrollView];if (component == 0) &#123;[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.centerY.equalTo(self.mas_centerY);make.left.equalTo(@0);make.width.equalTo(@(width));make.height.equalTo(@(cellHeight));&#125;];&#125;else &#123;UIScrollView *prevscrollView = [self scrollViewFromComponent:component - 1];if (prevscrollView) &#123;[scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.centerY.equalTo(self.mas_centerY);make.left.equalTo(prevscrollView.mas_right);make.width.equalTo(@(width));make.height.equalTo(@(cellHeight));&#125;];&#125;&#125;&#125;[self refreshScrollView:scrollView inComponent:component];[self layoutIfNeeded];&#125;- (void)refreshScrollView:(UIScrollView *)scrollView inComponent:(NSInteger)component&#123;[scrollView.subviews makeObjectsPerformSelector:@selector(removeFromSuperview)];NSInteger count = [self numberOfRowsInComponent:component];CGFloat totalHeight = 0.0;CGFloat width = [self widthForComponent:component];CGFloat height = [self rowHeightForComponent:component];for (int row = 0; row &lt; count; row++) &#123;UILabel *label = [self makeLabel];label.text = [self titleForRow:row forComponent:component];label.frame = CGRectMake(0, totalHeight, width, height);[scrollView addSubview:label];totalHeight += height;&#125;scrollView.contentSize = CGSizeMake(width, totalHeight);[scrollView layoutIfNeeded];&#125;- (UILabel *)makeLabel &#123;UILabel *label = [[UILabel alloc] init];label.backgroundColor = [UIColor clearColor];label.textColor = [UIColor licaiColor_121C32];label.font = [UIFont licai_PFMediumOfSize:kScaledValueX(15)];label.textAlignment = NSTextAlignmentCenter;return label;&#125;#pragma mark scrollView- (UIScrollView *)makescrollView&#123;UIScrollView *scrollView = [[UIScrollView alloc] init];scrollView.backgroundColor = [UIColor clearColor];scrollView.delegate = self;scrollView.showsVerticalScrollIndicator = NO;scrollView.showsHorizontalScrollIndicator = NO;scrollView.pagingEnabled = YES;scrollView.layer.masksToBounds = NO;scrollView.clipsToBounds = NO;return scrollView;&#125;- (UIScrollView *)scrollViewFromComponent:(NSInteger)component &#123;NSInteger tag = kPickerSubscrollViewTag + component;return (UIScrollView *)[self viewWithTag:tag];&#125;- (NSInteger)componentFromscrollView:(UIScrollView *)scrollView &#123;if (scrollView) &#123;NSInteger component = scrollView.tag - kPickerSubscrollViewTag;if ([self verifyComponent:component]) &#123;return component;&#125;&#125;return -1;&#125;#pragma mark BFPickerViewDelegate- (CGFloat)widthForComponent:(NSInteger)component &#123;if (self.delegate &amp;&amp; [self verifyComponent:component] &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:widthForComponent:)]) &#123;return [self.delegate pickerView:self widthForComponent:component];&#125;else &#123;if (self.componentCount &gt; 1) &#123;return (kScreenWidth - 20*2) / self.componentCount;&#125;else &#123;return kScreenWidth - 20*2;&#125;&#125;&#125;- (CGFloat)rowHeightForComponent:(NSInteger)component &#123;if (self.delegate &amp;&amp; [self verifyComponent:component] &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:rowHeightForComponent:)]) &#123;CGFloat height = [self.delegate pickerView:self rowHeightForComponent:component];if (height &gt; 0) &#123;return height;&#125;&#125;return 60.0;&#125;- (NSString *)titleForRow:(NSInteger)row forComponent:(NSInteger)component &#123;if (self.delegate &amp;&amp; [self verifyComponent:component] &amp;&amp; [self verifyrow:row inComponent:component] &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:titleForRow:forComponent:)]) &#123;NSString *title = [self.delegate pickerView:self titleForRow:row forComponent:component];if (STRINGHASVALUE(title)) &#123;return title;&#125;&#125;return @&quot;&quot;;&#125;#pragma mark BFPickerViewDataSource- (NSInteger)numberOfComponent &#123;if (self.dataSource &amp;&amp; [self.dataSource respondsToSelector:@selector(numberOfComponentsInPickerView:)]) &#123;return [self.dataSource numberOfComponentsInPickerView:self];&#125;else &#123;return 1;&#125;&#125;- (NSInteger)numberOfRowsInComponent:(NSInteger)component &#123;if (self.dataSource &amp;&amp; [self verifyComponent:component] &amp;&amp; [self.dataSource respondsToSelector:@selector(pickerView:numberOfRowsInComponent:)]) &#123;return [self.dataSource pickerView:self numberOfRowsInComponent:component];&#125;return 0;&#125;#pragma mark scrollDelegate- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset &#123;NSInteger component = [self componentFromscrollView:scrollView];CGFloat offsetY = targetContentOffset-&gt;y;CGFloat cellHeight = [self rowHeightForComponent:component];NSInteger index = offsetY / cellHeight;[self.selectDic setObject:@(index) forKey:@(kPickerSubscrollViewTag + component)];NSLog(@&quot;scrollViewWillEndDragging--jzk %ld&quot;,(long)index);if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(pickerView:didSelectRow:inComponent:)]) &#123;[self.delegate pickerView:self didSelectRow:index inComponent:component];&#125;&#125;#pragma mark setUp- (void)setUp &#123;self.selectDic = [[NSMutableDictionary alloc] init];self.clipsToBounds = YES;self.layer.masksToBounds = YES;_upImageView = [[UIImageView alloc] init];_upImageView.backgroundColor = [UIColor yellowColor];[self addSubview:_upImageView];[_upImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.top.equalTo(@0);make.left.equalTo(@0);make.right.equalTo(@0);make.height.equalTo(@(kScaledValueX(120)));&#125;];_upLineView = [[UIView alloc] init];_upLineView.backgroundColor = [UIColor licaiColor_E1E4EB];[self addSubview:_upLineView];[_upLineView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.top.equalTo(self.upImageView.mas_bottom);make.left.equalTo(@20);make.right.equalTo(@(-20));make.height.equalTo(@0.5);&#125;];_downImageView = [[UIImageView alloc] init];_downImageView.backgroundColor = [UIColor yellowColor];[self addSubview:_downImageView];[_downImageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.bottom.equalTo(@0);make.left.equalTo(@0);make.right.equalTo(@0);make.height.equalTo(@(kScaledValueX(120)));&#125;];_downLineView = [[UIView alloc] init];_downLineView.backgroundColor = [UIColor licaiColor_E1E4EB];[self addSubview:_downLineView];[_downLineView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.bottom.equalTo(self.downImageView.mas_top);make.left.equalTo(@20);make.right.equalTo(@(-20));make.height.equalTo(@0.5);&#125;];&#125;@end 补充更改UIPickerView的上下两条线12345678910111213141516171819- (UIView *)pickerView:(UIPickerView *)pickerView viewForRow:(NSInteger)row forComponent:(NSInteger)component reusingView:(UIView *)view &#123;UILabel *label = (UILabel*)view;if (label == nil) &#123;label = [[UILabel alloc] init];label.backgroundColor = [UIColor whiteColor];label.textAlignment = NSTextAlignmentCenter;label.textColor = [UIColor licaiColor_121C32];label.font = [UIFont licai_PFMediumOfSize:kScaledValueX(15)];&#125;label.text = [self pickerView:pickerView titleForRow:row forComponent:component];if (_pickerView.subviews.count &gt;= 3) &#123;[_pickerView.subviews objectAtIndex:1].backgroundColor = [UIColor licaiColor_E1E4EB];[_pickerView.subviews objectAtIndex:2].backgroundColor = [UIColor licaiColor_E1E4EB];&#125;return label;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模态视图的半透明背景问题]]></title>
    <url>%2F2016%2F08%2F03%2F%E6%A8%A1%E6%80%81%E8%A7%86%E5%9B%BE%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E8%83%8C%E6%99%AF%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这两天做一个需求，弹出picker控件，本来很简单的需求，但开发过程中遇到一个坑：背景色怎么弄都没有半透明效果？查来查去才发现是presentViewController的坑 模态视图相关 弹出和消失方法 123- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);// The completion handler, if provided, will be invoked after the dismissed controller&apos;s viewDidDisappear: callback is invoked.- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0); 弹出模态视图相关属性 1234567891011121314151617181920212223242526272829303132333435363738/*Defines the transition style that will be used for this view controller when it is presented modally. Setthis property on the view controller to be presented, not the presenter. Defaults toUIModalTransitionStyleCoverVertical.*/// 弹出模态ViewController时的四种动画风格typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123;// 从底部滑入UIModalTransitionStyleCoverVertical = 0,// 水平翻转UIModalTransitionStyleFlipHorizontal __TVOS_PROHIBITED,// 交叉溶解UIModalTransitionStyleCrossDissolve,// 翻页效果UIModalTransitionStylePartialCurl NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,&#125;;@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0);// 弹出模态ViewController时弹出风格typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123;// 由下到上,全屏覆盖UIModalPresentationFullScreen = 0,// 设备横屏，VC的显示方式则从横屏下方开始UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,// VC显示都是从底部，宽度和屏幕宽度一样UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,// VC的弹出方式和VC父VC的弹出方式相同UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),// 自定义视图展示风格,UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),// 如果视图没有被填满,底层视图可以透过UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),// 视图全部被透过UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED,UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,&#125;;@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2); 示例：弹出半透明的模态视图 1234567// presentViewController并且需要半透明时UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:VC];[VC setModalPresentationStyle:UIModalPresentationCustom];[nav setModalPresentationStyle:UIModalPresentationCustom];self.modalPresentationStyle = UIModalPresentationCustom;[self presentViewController:nav animated:NO completion:nil];// presentViewController必须手写，使用xib或story都会有不可预测bug]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreGraphics2：进阶]]></title>
    <url>%2F2016%2F07%2F19%2FCoreGraphics2%EF%BC%9A%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[3.3 Quartz变换函数 平移绘图 1CGContextTranslateCTM(context, 100, 200); 旋转绘图 1CGContextRotateCTM(context, M_PI_4); 缩放绘图 1CGContextScaleCTM(context, 0.5, 0.8); 如果想要即平移又旋转怎么办？ 123456789101112131415161718192021222324252627/*CGAffineTransform 处理形变的类,二维坐标系,即向右为x轴正方向,向上为y轴正方向方法简介：CGAffineTransformTranslate // x轴方向上平移x单位,在y轴方向上平移y单位CGAffineTransformScale // x轴方向上缩放x倍,在y轴方向上缩放y倍CGAffineTransformRotate // 逆时针旋转弧度,M_PI=180角度)以下都是针对视图的原定最初位置的中心点为起始参照进行相应操作的，CGAffineTransformMakeTranslation // 将坐标系统x轴方向上平移x单位,在y轴方向上平移y单位CGAffineTransformMakeScale // 将坐标系统x轴方向上缩放x倍,在y轴方向上缩放y倍CGAffineTransformMakeRotation // 将坐标系统逆时针旋转弧度,M_PI=180角度)*/CGAffineTransform transform = CGAffineTransformIdentity;transform = CGAffineTransformTranslate(transform, newSize.width, newSize.height);transform = CGAffineTransformRotate(transform, M_PI);// 得到一个倒置矩阵。应用倒置矩阵将抵消原矩阵的变换效果。// CGAffineTransform invertTransform = CGAffineTransformInvert(transform);// 判断仿射变换是否相等。// CGAffineTransformEqualToTransform(invertTransform, transform) // 判断仿射变换是否为单位变换。单位变换没有平移、缩放和旋转操作。// CGAffineTransformIsIdentity(invertTransform)// 合并多个变换函数CGContextConcatCTM(context, invertTransform);// 在操作结束之后可对设置量进行还原：view.transform＝CGAffineTransformIdentity; 3.4 颜色与颜色空间 创建设备依赖颜色空间 1234567// 创建设备依赖RGB颜色空间。// CGColorSpaceCreateDeviceGray(); CGColorSpaceCreateDeviceCMYK();CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();// 设置填充的颜色空间CGContextSetFillColorSpace(context, colorSpace);// 设置描边的颜色空间CGContextSetStrokeColorSpace(context, colorSpace); 创建并填充颜色 1234567891011121314// 1, 使用颜色空间创建颜色CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();CGFloat components[] = &#123;250/255.0, 100/255.0, 70/255.0, 1.0&#125;;CGColorRef color = CGColorCreate(colorspace, components);CGContextSetStrokeColorWithColor(context, color);CGContextSetFillColorWithColor(context, color);// 2，快速设置依赖RGB颜色的颜色值。CGContextSetRGBStrokeColor(context, 1, 0, 0, 1);CGContextSetRGBFillColor(context, 1, 0, 0, 1);// 3, 使用UI函数设置颜色值CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor));CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor); 3.5 阴影 阴影被设置后，任何绘制的对象都有一个阴影，如果需多个阴影投射在一起，可使用一个透明层；该图层类似一个先是叠加所有绘图然后加上阴影的一个子上下文 关闭阴影：如果在设置阴影之前保存了图形状态，就可以通过恢复图形状态来关闭阴影。也可以通过设置阴影颜色为 NULL 来关闭阴影。1234// 阴影的位置表示为CGSize，如果CGSize的两个值都是正数，则表示阴影是朝下和朝右的。模糊度被表示为任何一个正数CGContextSetShadowWithColor(myContext, CGSizeMake(15, 20), 5, [UIColor redColor].CGColor);// 默认颜色 RGBA 值 &#123;0, 0, 0, 1.0 / 3.0&#125;CGContextSetShadow(context, CGSizeMake(15, 20), 5); 3.6 渐变 CGGradient 绘制径向和轴向渐变 1234567891011121314151617181920212223242526272829303132333435// 绘制渐变// 颜色数组和位置数组必须一一对应，最少两个：起点和终点CGFloat locs[3] = &#123; 0.0, 0.5, 1.0 &#125;;CGFloat colors[12] = &#123;0.3,0.3,0.3,0.8, // 开始颜色0.0,0.0,0.0,1.0, // 中间颜色0.3,0.3,0.3,0.8 // 末尾颜色&#125;;CGColorSpaceRef sp = CGColorSpaceCreateDeviceRGB();CGGradientRef grad = CGGradientCreateWithColorComponents (sp, colors, locs, 3);// 绘制轴向渐变/*CGContextRef cg_nullable c,CGGradientRef cg_nullable gradient,CGPoint startPoint, 起点CGPoint endPoint, 终点CGGradientDrawingOptions optionskCGGradientDrawsBeforeStartLocation 向外渐变kCGGradientDrawsAfterEndLocation 向里渐变*/// CGContextDrawLinearGradient(context, grad, CGPointMake(50,0), CGPointMake(100,0), 0);// 绘制径向渐变/*CGContextRef cg_nullable c,CGGradientRef cg_nullable gradient,CGPoint startCenter, 外圈中心点CGFloat startRadius, 外圈半径CGPoint endCenter, 内圈中心点CGFloat endRadius, 内圈半径CGGradientDrawingOptions options*/CGContextDrawRadialGradient(context, grad, CGPointMake(100, 200), 5, CGPointMake(100, 200), 50, 0);CGColorSpaceRelease(sp);CGGradientRelease(grad); CGShading 绘制径向和轴向渐变 1// to do 3.7 透明层 透明层通过组合两个或多个对象来生成一个组合图形。把它当场一个单独对象1234567891011// 给两个圆组成的大眼睛绘制阴影CGContextSetShadowWithColor(context, CGSizeZero, 10, [UIColor grayColor].CGColor);// 开始透明层，begin和end之间的当做一个单独对象对待CGContextBeginTransparencyLayer(context, NULL);// 添点料CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);CGContextFillEllipseInRect(context, CGRectMake(100, 150, 100, 100));CGContextSetFillColorWithColor(context, [UIColor blueColor].CGColor);CGContextFillEllipseInRect(context, CGRectMake(150, 150, 100, 100));// 结束透明层，生成一个组合图层，begin和end必须一一对应CGContextEndTransparencyLayer(context); 3.8 抗锯齿1CGContextSetShouldAntialias(context, YES); // 打开抗锯齿 3.9模板 模板表示为CGPattern（具体类型为CGPatternRef）。你可以创建一个模板并使用它进行描边或填充。跟帖瓷砖差不多12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void drawTile(void *info,CGContextRef context) &#123;CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);CGContextFillRect(context, CGRectMake(0, 0, 30, 30));CGContextSetFillColorWithColor(context, [UIColor grayColor].CGColor);CGContextFillRect(context, CGRectMake(0, 30, 30, 30));CGContextSetFillColorWithColor(context, [UIColor blueColor].CGColor);CGContextFillRect(context, CGRectMake(30, 0, 30, 30));CGContextSetFillColorWithColor(context, [UIColor purpleColor].CGColor);CGContextFillRect(context, CGRectMake(30, 30, 30, 30));&#125;- (void)drawRect:(CGRect)rect &#123;CGContextRef context = UIGraphicsGetCurrentContext();//填充模式回调函数结构体/*version 回调结构体的版本号，可以设置为 0drawPattern 指向绘制回调的指针。releaseInfo 该回调在释放 CGPatternRef 对象时被调用，如果不用可传NULL*/ CGPatternCallbacks callback = &#123;0,drawTile,NULL&#125;;//设置砖块样式/*void *infoCGRectbounds 每块瓷砖的大小CGAffineTransform matrix 变换矩阵，如果不用变换可以传入CGAffineTransformIdentityCGFloat xStep, CGFloat yStep 指定瓷砖块横向和纵向的间距，如果大于瓷砖大小，瓷砖间会有间隙CGPatternTiling tiling 平铺模式 kCGPatternTilingNoDistortion 无失真,kCGPatternTilingConstantSpacingMinimalDistortion 恒定间距的最小失真,kCGPatternTilingConstantSpacing恒定间距平铺bool isColored 瓷砖是否有颜色const CGPatternCallbacks *callbacks 回调函数结构体*/CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 60, 60), CGAffineTransformIdentity, 60, 60, kCGPatternTilingNoDistortion, true, &amp;callback);//设置颜色空间//设备无关的颜色空间 CGColorSpaceCreateDeviceRGB();//模式填充颜色空间,注意对于有颜色填充模式，这里传NULLCGColorSpaceRef colorSpace = CGColorSpaceCreatePattern(NULL);CGContextSetFillColorSpace(context, colorSpace);CGContextSetStrokeColorSpace(context, colorSpace);float alpha = 1;////最后一个参数对于有颜色瓷砖指定为透明度的参数地址，对于无颜色瓷砖则指定当前颜色空间对应的颜色数组CGContextSetFillPattern(context, pattern, &amp;alpha);CGContextSetStrokePattern(context, pattern, &amp;alpha);//绘制CGContextFillRect(context, CGRectMake(0, 20, 155, 155));CGContextStrokeRectWithWidth(context, CGRectMake(165,20, 155, 155), 5);&#125; 3.10 怎么绘制1像素的线 Core Graphics做了大量操作，一般不需要关注x y坐标中点和实际上屏幕显示的像素关系！ 像素到点的转化，可以通过 除以 UIView的contentScaleFactor属性 最精确的方式绘制一条水平或垂直的线条的方式不是描边路径，而是填充路径1CGContextFillRect(context, CGRectMake(0,0,1.0/self.contentScaleFactor,100)); 3.11 每次都setNeedsDisplay好烦呀 可以通过修改view的contentMode为UIViewContentModeRedraw，这将引起缓存内容的自动缩放和重定位被关闭，最终结果是视图的setNeedsDisplay方法将被调用，触发drawRect：方法重绘视图内容 1View.contentMode = UIViewContentModeRedraw; 如果只是暂时调整大小，例如动画变大再还原，正确设置contentMode的值是UIViewContentModeScaleToFill，被伸缩的内容仅仅是视图内容的一副缓存图片，所以它运行起来十分的高效]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreGraphics1：基础]]></title>
    <url>%2F2016%2F07%2F17%2FCoreGraphics1%EF%BC%9A%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[序：CoreGraphics 与 Quartz 2D Core Graphic框架是一组基于C的API，UIKit用Core Graphics将“显示”绘制在屏幕上 Quartz 2D API是Core Graphic框架的一部分，因此其中的很多数据类型和方法都是以CG开头的。会经常见到Quartz 2D（Quartz）和Core Graphics两个术语交互使用！Quartz 2D与分辨率和设备无关，因此在使用Quartz 2D绘图时，无需考虑最终绘图的目标设备 Core Graphic是线程安全的，可以异步绘制回调刷新 官方dome 1 Quartz 2D数据类型1.1 常用类型解释 CGPathRef：用于向量图，可创建路径，并进行填充或描画(stroke) CGImageRef：用于表示bitmap图像和基于采样数据的bitmap图像遮罩 CGLayerRef：用于表示可用于重复绘制(如背景)和幕后 (offscreen)绘制的绘画层 CGShadingRef、CGGradientRef：用于绘制渐变 CGFunctionRef：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型 CGColorRef, CGColorSpaceRef：一般用[UIColor redColor].CGColor之类 CGImageSourceRef,CGImageDestinationRef：用于在Quartz中移入移出数据 CGFontRef：用于绘制文本 CGPatternRef：用于重绘图 1.2 内存管理 谁开辟谁释放（类似MRC原则），使用含有”Create”或“Copy”单词的函数获取一个对象，当使用完后必须释放 xxxRelease。其它情况不用释放 也可以用过 retain和release 来持有一个对象 不能传NULL值来释放，必须通过对应的release方法 2 上下文2.1 注意事项 Quartz提供了 5 种类型的 Graphics Context。Bitmap Graphics Context、PDF Graphics Context、Window Graphics Context、Layer Context、Post Graphics Context。 使用Core Graphics之前需要指定一个用于绘图的图形上下文（CGContextRef） 通过drawRect、drawRect: inContext 可用UIGraphicsGetCurrentContext获得当前UIView的绘图上下文，直接绘图 使用UIGraphicsBeginImageContextWithOptions时，不仅创建了一个绘图上下文，并且该上下文也属于当前上下文 回调方法所持有的context：参数并不会让任何上下文成为当前图形上下文。只是引用了一下。 如果想持有一个别人的context时，必须通过UIGraphicsPushContext 将该上下文转化为当前上下文，最后通过UIGraphicsPopContext恢复上下文环境 2.2 获取上下文的方式 drawRect获取 不应该手动调用drawRect：方法 在UIView子类的drawRect：方法中无需调用super 如果你想调用drawRect：方法更新视图，只需发送setNeedsDisplay方法 不要覆盖drawRect：例，在UIImageView子类中覆盖drawRect：方法是不合法的，你将得不到你绘制的图形。 当视图的backgroundColor为nil并且opaque属性为YES，视图的背景颜色就会变成黑色 12345- (void) drawRect: (CGRect) rect &#123; CGContextRef con = UIGraphicsGetCurrentContext();// 用不到可不获取，例如直接用UIBezierPath画个圈// do something&#125; UIGraphicsBeginImageContextWithOptions 12345678910// size区域大小，opaque是否透明，scale屏幕分辨率, 0表示 [UIScreen mainScreen].scaleUIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0); // UIGraphicsBeginImageContext(CGSize size);方法相当于opaque参数为NO,scale为1.0。CGContextRef context = UIGraphicsGetCurrentContext();// 用不到可不获取，例如直接用UIBezierPath画个圈// do something// only return a 8-bit per channel context in the DeviceRGB color space.UIImage* im = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); drawLayer:inContext：没用过 2.3 坐标问题 Core Graphics源于Mac OS X系统，在Mac OS X中Y轴是朝上的，而在iOS中Y轴是朝下的，正好相反！需用CTM转换到目标设备 以下情况不要CTM，不需要转换 别人给你的，即当做参数传过来的，包括系统创建的 使用 UIGraphicsBeginImageContextWithOptions 返回的绘图 [UIImage imageWithCGImage:];返回的绘图 3 绘图3.1 一般绘图模式 绘图的一般过程是先设定好图形上下文参数，然后绘图。比方说，要画一根红线，接着画一根蓝线。那么首先需要将上下文的线条颜色属性设定为为红色，然后画红线；接着设置上下文的线条颜色属性为蓝色，再画出蓝线。表面上看,红线和蓝线是分开的，但事实上，在你画每一条线时，线条颜色却是整个上下文的属性 在绘图之前调用CGContextSaveGState函数保存当前状态，接着根据需要设置某些上下文状态，然后绘图，最后调用CGContextRestoreGState函数将当前状态恢复到绘图之前的状态。要注意的是，CGContextSaveGState函数和CGContextRestoreGState函数必须成对出现，否则绘图很可能出现意想不到的错误，这里有一个简单的做法避免这种情况。代码如下：12345678910- (void)drawRect:(CGRect)rect &#123;CGContextRef ctx = UIGraphicsGetCurrentContext();CGContextSaveGState(ctx);&#123;// 绘图代码&#125;CGContextRestoreGState(ctx);&#125; 3.2 path 设置起点 1CGContextMoveToPoint(context, 0, 0); 添加几条直线 12345CGContextAddLineToPoint(context, 200, 0);CGPoint point2 = CGPointMake(200, 200);CGPoint point3 = CGPointMake(200, 0);CGPoint points[2] = &#123;point2, point3&#125;;CGContextAddLines(context, points, 2); 设置虚线样式 12345CGFloat dashWidth = 5; // 线宽度CGFloat spaceWidth = 3; // 间隔宽度CGFloat lengths[2] = &#123;dashWidth, spaceWidth&#125;;// phase表示在第一个虚线绘制的时候跳过多少个点, lengths 绘制规则，count 表示lengths数组countCGContextSetLineDash(context, 0, lengths, 2); 画圆形或矩形 12345// 画一个椭圆或圆形CGContextAddEllipseInRect(context, CGRectMake(0, 0, 100, 200));// 画一个矩形CGContextAddRect(context, CGRectMake(200, 400, 100, 200));// CGContextAddRects 画圆弧 1234// 根据圆形和弧度画弧线CGContextAddArc(context, 200, 200, 100, 0, M_PI_2, 0);// 当前点到(x1, y1)，当前点到(x2, y2)的两条切线 和 圆弧半径画弧线CGContextAddArcToPoint(context, 200, 400, 400, 400, 100); 画贝塞尔曲线 1234// 通过一个控点画贝塞尔曲线CGContextAddQuadCurveToPoint(context, 0, 100, 200, 100);// 通过两个控点画贝塞尔曲线CGContextAddCurveToPoint(context, 100, 400, 200, 300, 100, 200); 画虚线 12345CGFloat dashWidth = 5; // 线宽度CGFloat spaceWidth = 3; // 间隔宽度CGFloat lengths[2] = &#123;dashWidth, spaceWidth&#125;;// phase表示在第一个虚线绘制的时候跳过多少个点, lengths 绘制规则，count 表示lengths数组countCGContextSetLineDash(context, 0, lengths, 2); 线的属性 1234567891011121314151617// 设置线宽CGContextSetLineWidth(context, 20);// 设置线帽，即线条的起始点样式// kCGLineCapButt：无端点// kCGLineCapRound：圆形端点// kCGLineCapSquare：方形端点（样式上和kCGLineCapButt是一样的，但是比kCGLineCapButt长一点）CGContextSetLineCap(context, kCGLineCapButt);//设置线条的拐角的样式// kCGLineJoinMiter, 尖角// kCGLineJoinRound, 圆角// kCGLineJoinBevel 缺角CGContextSetLineJoin(context, kCGLineJoinRound);//// kCGLineJoinMiter 下最大倾斜长度，边角的角度越小，斜接长度就会越大CGContextSetMiterLimit(context, 10); 填充颜色 12345678// 线条颜色(描边)// CGContextSetRGBStrokeColor、CGContextSetGrayStrokeColor没用过CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);// 填充颜色// CGContextSetRGBFillColor、CGContextSetGrayFillColorCGContextSetFillColorWithColor(context, [UIColor yellowColor].CGColor);// 设置颜色混合模式CGContextSetBlendMode(context, kCGBlendModeNormal); 透明度 1234// 整体透明度CGContextSetAlpha(context, 0.5);// 擦除一个区域内的所有已存在的绘图,上下文颜色如果不是透明的，剪切区域显示黑色，如果是透明的，则显示透明的CGContextClearRect(context, CGRectMake(10, 10, 100, 200)); 填充路径规则 123456789101112131415// 使用奇偶规则填充当前路径,等于CGContextDrawPath(context, kCGPathFill);// CGContextEOFillPath(context);// 使用非零绕数规则填充当前路径// CGContextFillPath(context);// 注意：CGContextStrokePath(context) 和 CGContextFillPath(context) 不能同时使用。CGContextStrokePath(context);/*kCGPathFill 填充路径kCGPathEOFill 使用奇偶规则填充路径kCGPathStroke 描边路径kCGPathFillStroke 填充并描边路径kCGPathEOFillStroke 使用奇偶规则填充并描边*/CGContextDrawPath(context, kCGPathStroke); 闭合路径 1234// 闭合路径，如果你打算填充一段路径，那么就不需要使用该命令，因为该命令会被自动调用。CGContextClosePath(context); // 当画完一部分，需抬起画笔画另一部分的时候（例：同心圆）需CGContextBeginPath(context); 最后别忘了释放内存 123// xxxReleaseCGColorRelease(color);CGFontRelease(cgFont);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手势2：进阶]]></title>
    <url>%2F2016%2F06%2F24%2F%E6%89%8B%E5%8A%BF2%EF%BC%9A%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[1 UIGestureRecognizer&emsp;&emsp;手势识别器，前面介绍的基本手势的父类，注意UIGestureRecognizer : NSObject UIGestureRecognizerState 官方注释翻译 1234567UIGestureRecognizerStatePossible, // 默认，还没识别，可能正在遍历runloopUIGestureRecognizerStateBegan, // 手势开始被识别，下个runloop会回调方法UIGestureRecognizerStateChanged, // 手势识别发生改变的状态，下个runloop会回调方法UIGestureRecognizerStateEnded, // 手势识别结束，下个runloop会回调方法，重置为UIGestureRecognizerStatePossibleUIGestureRecognizerStateCancelled, // 手势识别取消，下个runloop会回调方法，重置为UIGestureRecognizerStatePossibleUIGestureRecognizerStateFailed, // 识别失败，方法将不会被调用，重置为UIGestureRecognizerStatePossibleUIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded UIGestureRecognizerStateChanged为啥总调 1https://stackoverflow.com/questions/14227465/whats-the-different-between-uigesturerecognizerstatechanged-and-touchesmoved?r=SearchResults 是否手势都有UIGestureRecognizerStateBegan？否 1234567// UITapGestureRecognizer 只有一个UIGestureRecognizerStateEnded状态// UIGestureRecognizerState的官方解释如下// Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled// 非连续手势没有begin，changed的过渡，也不能失败或取消// 事实上UIGestureRecognizerState表示可能的状态，不要被begin，changed，end等字眼迷惑 几个容易乱的属性 @property(nullable, nonatomic,readonly) UIView *view; // 表示添加手势的view，并不是响应连上的view @property(nonatomic) BOOL cancelsTouchesInView; // 默认YES，即一旦响应手势就终止响应连 @property(nonatomic) BOOL delaysTouchesBegan;// 默认为NO，不会延迟响应触摸事件，如果我们设置为YES，在手势没有被识别失败前，都不会给事件传递链发送消息。 @property(nonatomic) BOOL delaysTouchesEnded;//默认为YES，手势识别失败立马调用touchEnd:withEvent。设置为NO，会等待一个很短的时间，如果没有接收到新的手势识别任务，才会发送touchesEnded消息到事件传递链。 iOS9之后的 @property(nonatomic, copy) NSArray *allowedTouchTypes NS_AVAILABLE_IOS(9_0); // Array of UITouchTypes as NSNumbers. @property(nonatomic, copy) NSArray *allowedPressTypes NS_AVAILABLE_IOS(9_0); // Array of UIPressTypes as NSNumbers. 123456typedef NS_ENUM(NSInteger, UITouchType) &#123;UITouchTypeDirect, // A direct touch from a finger (on a screen)UITouchTypeIndirect, // An indirect touch (not a screen)UITouchTypePencil NS_AVAILABLE_IOS(9_1), // Add pencil name variantUITouchTypeStylus NS_AVAILABLE_IOS(9_1) = UITouchTypePencil, // A touch from a stylus (deprecated name, use pencil)&#125; NS_ENUM_AVAILABLE_IOS(9_0); @property (nonatomic) BOOL requiresExclusiveTouchType NS_AVAILABLE_IOS(9_2); // defaults to YES 12345// Indicates whether the gesture recognizer will consider touches of different touch types simultaneously.// If NO, it receives all touches that match its allowedTouchTypes.// NO, 同一时刻接收所有允许的触摸类型// If YES, once it receives a touch of a certain type, it will ignore new touches of other types, until it is reset to UIGestureRecognizerStatePossible.// YES, 同一时刻只接受一种触摸类型 两个方法 设置手势优先级 requireGestureRecognizerToFail 123456789101112131415161718192021222324// [A requireGestureRecognizerToFail：B] 优先响应B，再尝试响应A，都失败的话则响应失败// 实现一个View，即响应双击，又响应单击// 参考：https://stackoverflow.com/questions/8876202/uitapgesturerecognizer-single-tap-and-double-tap?r=SearchResults- (void)addSingleAndDoubleTapGestureRecognizersToView:(UIView *)view &#123;// single tap UITapGestureRecognizer *singleTapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget: tableViewController action: @selector(handleSingleTapOnView:)]; // must set 1 [singleTapRecognizer setNumberOfTouchesRequired:1];[view addGestureRecognizer: singleTapRecognizer];// double tap UITapGestureRecognizer *doubleTapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget: tableViewController action: @selector (handleDoubleTapOnView:)]; // must set 2[doubleTapRecognizer setNumberOfTouchesRequired:2]; [singleTapRecognizer requireGestureRecognizerToFail: doubleTapRecognizer];[view addGestureRecognizer: doubleTapRecognizer]; &#125;- (void)handleSingleTapOnView:(id)sender&#123;&#125;- (void)handleDoubleTapOnView:(id)sender&#123;&#125; 手指在view中的位置 1234567891011121314151617// 单点位置UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];[imageView addGestureRecognizer:tap];- (void)tap:(UITapGestureRecognizer *)tapGesture &#123;CGPoint location = [tapGesture locationInView:self.view];&#125;// 多根手指UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];tap.numberOfTouchesRequired = 2;[imageView addGestureRecognizer:tap];- (void)tap:(UITapGestureRecognizer *)tapGesture &#123;NSInteger touchsCount = [tapGesture numberOfTouches];for (int index = 0; index &lt; touchsCount; index++) &#123;CGPoint point = [tapGesture locationOfTouch:index inView:self.view];&#125;&#125; 2 UIGestureRecognizerDelegate 是否识别手势 12345678//将要开始时调用（Possible将要变成Began），返回NO，则手势识别失败- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;// touchesBegan:withEvent:之前调用，返回NO，则手势不识别这个touch- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;// pressesBegan:withEvent:之前调用，返回NO，则手势不识别这个press- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press; 多手势冲突怎么办 12345678910111213141516171819//是否支持同时多个手势触发,默认NO//返回YES，则可以多个手势一起触发方法，返回NO则为互斥, 但不保证一定互斥，因为otherGestureRecognizer可能返回YES- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer;//返回YES，第二个手势的优先级高于第一个手势- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer //返回YES，第一个手势的优先级高于第二个手势- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer// 所以为什么要设置两个方法呢？一个方法返回YES或NO不就行了？因为返回YES能保证优先级改变，但返回NO不保证优先级，因为其他的可能返回NO// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&apos;s counterpart delegate or subclass methods may return YES 自定义手势1 组合 通过组合多手势和优先级实现复杂手势操作1// 略，参见上文 requireGestureRecognizerToFail 部分代码 2 扩展 实现一个只能横向或纵向的拖动手势1234567891011121314// 参考：https://stackoverflow.com/questions/7100884/uipangesturerecognizer-only-vertical-or-horizontal?r=SearchResultsUIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];pan.delegate = self;[imageView addGestureRecognizer:pan];- (void)pan:(UIPanGestureRecognizer *)panGesture &#123;&#125;- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)panGestureRecognizer &#123;CGPoint velocity = [panGestureRecognizer velocityInView:self.view];return fabs(velocity.y) &gt; fabs(velocity.x);&#125; 3 自定义 主要步骤 123456781、创建一个UIGestureRecognizer的子类2、包含头文件#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;3、使用touch相关方法判断手指轨迹- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;4、轨迹完成后设置self.state = UIGestureRecognizerStateEnded;就会自动调用相关回调 例：实现一个松开调用的tap类 123456789101112131415161718192021222324252627282930313233343536373839// 参考: https://stackoverflow.com/questions/15628133/uitapgesturerecognizer-make-it-work-on-touch-down-not-touch-up?r=SearchResultsTouchDownGestureRecognizer.h#import &lt;UIKit/UIKit.h&gt;@interface TouchDownGestureRecognizer : UIGestureRecognizer@endTouchDownGestureRecognizer.m#import &quot;TouchDownGestureRecognizer.h&quot;#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;@implementation TouchDownGestureRecognizer-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;if (self.state == UIGestureRecognizerStatePossible) &#123;self.state = UIGestureRecognizerStateRecognized;&#125;&#125;-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123;self.state = UIGestureRecognizerStateFailed;&#125;-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123;self.state = UIGestureRecognizerStateFailed;&#125;@endimplementation:#import &quot;TouchDownGestureRecognizer.h&quot;TouchDownGestureRecognizer *touchDown = [[TouchDownGestureRecognizer alloc] initWithTarget:self action:@selector(handleTouchDown:)];[yourView addGestureRecognizer:touchDown];-(void)handleTouchDown:(TouchDownGestureRecognizer *)touchDown&#123;NSLog(@&quot;Down&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手势1：常用]]></title>
    <url>%2F2016%2F06%2F23%2F%E6%89%8B%E5%8A%BF1%EF%BC%9A%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1 点按手势 UITapGestureRecognizer 创建 1234567// 创建两根手指，连续点击三次的手势，常用于调出调试页面等UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];// 点击数，Default is 1.tap.numberOfTapsRequired = 3;// 手指数，Default is 1..tap.numberOfTouchesRequired = 2;[view addGestureRecognizer:tap]; 回调 123- (void)tap:(UITapGestureRecognizer *)tapGesture&#123;NSLog(@&quot;调出调试页面&quot;);&#125; 2 拖拽手势 UIPanGestureRecognizer 实现 123456UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];// default is 1. the minimum number of touches required to matchpan.minimumNumberOfTouches = 1;// default is UINT_MAX. the maximum number of touches that can be downpan.maximumNumberOfTouches = 1;[view addGestureRecognizer:pan]; 代理 1234567891011- (void)pan:(UIPanGestureRecognizer *)panGesture &#123;// translationInView : 手指在视图上移动的偏移量CGPoint point1 = [panGesture translationInView:self.view];NSLog(@&quot;translationInView x: %f y:%f&quot;,point1.x , point1.y);// locationInView ： 手指在视图上的位置CGPoint point2 = [panGesture locationInView:self.view];NSLog(@&quot;locationInView x: %f y:%f&quot;,point2.x , point2.y);// velocityInView： 手指在视图上移动的速度, 正负也是代表方向，CGPoint point3 = [panGesture velocityInView:self.view];NSLog(@&quot;velocityInView x: %f y:%f&quot;,point3.x , point3.y);&#125; 3 清扫手势 UISwipeGestureRecognizer 实现 12345678910111213UISwipeGestureRecognizer *swipeUp = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];// 手指数，default is 1swipeUp.numberOfTouchesRequired = 1;// 注意，手势方向虽然是NS_OPTIONS，但不要使用 或 方式设置，网上都是错的// https://stackoverflow.com/questions/3319209/setting-direction-for-uiswipegesturerecognizer// swipeUp.direction = UISwipeGestureRecognizerDirectionUp | UISwipeGestureRecognizerDirectionDown;// 手势方向只是识别一个方向，需要多个方向可设置多个清扫手势，实现一个代理swipeUp.direction = UISwipeGestureRecognizerDirectionUp | UISwipeGestureRecognizerDirectionDown;[view addGestureRecognizer: swipeUp];UISwipeGestureRecognizer *swipeDown = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];swipeDown.direction = UISwipeGestureRecognizerDirectionDown;[view addGestureRecognizer: swipeDown]; 代理 12345678910111213141516- (void)swipe:(UISwipeGestureRecognizer *)swipeGesture&#123;switch (swipeGesture.direction) &#123;case UISwipeGestureRecognizerDirectionLeft:NSLog(@&quot;向左清扫&quot;);break;case UISwipeGestureRecognizerDirectionRight:NSLog(@&quot;向右清扫&quot;);break;case UISwipeGestureRecognizerDirectionUp:NSLog(@&quot;向上清扫&quot;);break;case UISwipeGestureRecognizerDirectionDown:NSLog(@&quot;向下清扫&quot;);break;&#125;&#125; 4 长按手势 UILongPressGestureRecognizer 实现 1234567891011UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];// 识别长按手势前需要点击几次，Default is 0， PS:从没见过这个属性的使用longPress.numberOfTapsRequired = 1;// 手指数longPress.numberOfTouchesRequired = 1;// 最短按多长时间才识别长按手势 Default is 0.5秒longPress.minimumPressDuration = 1;// 识别长按手势前允许的最大移动距离，Default is 10，手势识别后无效longPress.allowableMovement = 20;[view addGestureRecognizer:longPress]; 代理 123456789// 注意回调处理- (void)longPress:(UILongPressGestureRecognizer *)longPressGesture &#123;if (sender.state == UIGestureRecognizerStateEnded) &#123;// 结束&#125;else if (sender.state == UIGestureRecognizerStateBegan)&#123;// 开始&#125;&#125; 5 旋转手势 UIRotationGestureRecognizer 实现 12UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotation:)];[view addGestureRecognizer:rotation]; 代理 12345678910- (void)rotation:(UIRotationGestureRecognizer *)rotationGesture &#123;//获取旋转的角度CGFloat scale = rotationGesture.rotation;//获取旋转的速度 radians/secondNSLog(@&quot;转速： %f&quot;, rotationGesture.velocity);// 设置view的角度,使用transform设置rotationGesture.view.transform = CGAffineTransformRotate(rotationGesture.view.transform, scale);// 复位,否则旋转角度会叠加，会疯狂转圈rotationGesture.rotation = 0;&#125; 6 缩放 UIPinchGestureRecognizer 实现 12UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinch:)];[view addGestureRecognizer:pinch]; 代理 123456- (void)pinch:(UIPinchGestureRecognizer *)pinchGesture &#123;CGFloat scale = pinchGesture.scale;pinchGesture.view.transform = CGAffineTransformScale(pinchGesture.view.transform, scale, scale);// 复位pinchGesture.state = 1;&#125; 7 屏幕边缘轻扫 UIScreenEdgePanGestureRecognizer 实现 12UIScreenEdgePanGestureRecognizer *screenPan = [[UIScreenEdgePanGestureRecognizer alloc]initWithTarget:self action:@selector(screenEdgePan:)];[view addGestureRecognizer:screenPan]; 代理 1234//创建边缘事件-(void)screenEdgePan:(UIScreenEdgePanGestureRecognizer *)screenEdgePanGesture &#123;NSLog(@&quot;边缘&quot;);&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片处理2：CGImage]]></title>
    <url>%2F2016%2F06%2F15%2F%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%862%EF%BC%9ACGImage%2F</url>
    <content type="text"><![CDATA[序 UIImage、CGImage与CIImage UIImage：UIKit的封装，最常用 CGImage：UIImage类的Core Graphics版本的结构体指针，用C语言编写，只能表示位图 CIImage：并不是一张图片。它包含了所有生成一张图片所有的必要信息。CIImage对象通常用在CIFilter,CIContext,CIColor,CIVector。跟GPU的处理相关。 CGImage绘制图片的方式 根据数据源创建位图CGImageCreate 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*// 图片宽度，单位像素, CGImageGetWidth(imageRef);size_t width// 图片高度，单位像素, CGImageGetHeight(imageRef);size_t height// 每个颜色的比特数，在rgba-32模式下为 8, CGImageGetBitsPerComponent(imageRef)size_t bitsPerComponent// 每个像素的总比特数，The number of bytes per pixel is equal to `(bitsPerComponent * number of components + 7)/8&apos; ，参照CGBitmapContextCreate的注释， CGImageGetBitsPerPixel(imageRef)size_t bitsPerPixel,// 每一行占用的字节数，注意单位是字节,`bytesPerRow&apos; bytes, which must be at least width * bytes per pixel&apos; bytes 即 width * bitsPerPixel / BYTE_SIZE ，参照CGBitmapContextCreate的注释，通常1字节=8位,CGImageGetBytesPerRow(imageRef)size_t bytesPerRow,// 颜色空间,iOS中一般为CGColorSpaceCreateDeviceRGB， CGImageGetColorSpace(imageRef)CGColorSpaceRef cg_nullable space,// 位图的布局信息，iOS上一般为小端32位序，获取方式参见 备注2CGBitmapInfo bitmapInfo,// 数据提供者 ，CGDataProviderCreateWithCFData((__bridge CFDataRef)data);CGDataProviderRef cg_nullable provider,// 固定为NULL，即不允许重新映射颜色值const CGFloat * __nullable decode,// 固定为false，即不采用插值算法，高分辨率上可能会显示锯齿bool shouldInterpolate,// 渲染意图，kCGRenderingIntentDefaultCGColorRenderingIntent intent*/CGImageRef image = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, YYCGColorSpaceGetDeviceRGB(), bitmapInfo, provider, NULL, false, kCGRenderingIntentDefault);// 备注1：size_t 在64位机器上为8字节，32位机器上为4字节// 备注2：直接使用CGImageGetBitmapInfo(imageRef)获得的CGBitmapInfo 位图布局信息是不准的，以下是AFNetwork的代码// CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);// CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);//// if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;// uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);//#pragma clang diagnostic push//#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;// if (alpha == kCGImageAlphaNone) &#123;// bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;// bitmapInfo |= kCGImageAlphaNoneSkipFirst;// &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;// bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;// bitmapInfo |= kCGImageAlphaPremultipliedFirst;// &#125;//#pragma clang diagnostic pop// &#125; 通过上下文创建位图 1234567// 同时设data为NULL、bytesPerRow为0 （必须两个都设），表示系采用统会自动分配一段合适的内存，保存位图数据CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);if (!context) return NULL;CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decodeCGImageRef newImage = CGBitmapContextCreateImage(context);CFRelease(context);// 如果有图像数据了，当然用CGImageCreate，毕竟用CGBitmapContextCreate还需要拷贝啥的比较耗时 UIGraphicsBeginImageContext 12345678// 生成纯色图片CGRect rect=CGRectMake(0,0, 1, 1);UIGraphicsBeginImageContext(rect.size);CGContextRef context = UIGraphicsGetCurrentContext();CGContextSetFillColorWithColor(context, [color CGColor]);CGContextFillRect(context, rect);UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext(); 其它方法 蒙层 1234// 创建mask图片图层,参数和CGImageCreate一样CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow,CGDataProviderRef cg_nullable provider, const CGFloat * __nullable decode, bool shouldInterpolate)//调用CGImageCreateWithMask并指定图像作为蒙版，则必须使用设备灰色颜色空间定义图像。CGImageCreateWithMask(CGImageRef cg_nullable image, CGImageRef cg_nullable mask) 截图 1CGImageCreateWithImageInRect(CGImageRef cg_nullable image, CGRect rect) 从NSData生成CGImageRef 1234567891011121314151617181920// 以下为AFNetwork源码CGImageRef imageRef = NULL;CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);if ([response.MIMEType isEqualToString:@&quot;image/png&quot;]) &#123;imageRef = CGImageCreateWithPNGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);&#125; else if ([response.MIMEType isEqualToString:@&quot;image/jpeg&quot;]) &#123;imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);if (imageRef) &#123;CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);// CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScaleif (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;CGImageRelease(imageRef);imageRef = NULL;&#125;&#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片处理1：常用工具]]></title>
    <url>%2F2016%2F06%2F12%2F%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%861%EF%BC%9A%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300//// UIImage+tool.m// test//// Created by JZK on 2016/7/4.// Copyright © 2016 test. All rights reserved.//#import &quot;UIImage+tool.h&quot;static inline CGFloat DegreesToRadians(CGFloat degrees) &#123;return M_PI * (degrees / 180.0);&#125;@implementation UIImage (tool)#pragma mark 裁剪- (UIImage *)clipInRect:(CGRect)rect &#123;CGImageRef imageRef = CGImageCreateWithImageInRect([self CGImage], rect);UIImage *croppedImage = [UIImage imageWithCGImage:imageRef];CGImageRelease(imageRef);return croppedImage;&#125;#pragma mark 缩放//- (UIImage *)scaleToSize:(CGSize)size &#123;UIGraphicsBeginImageContext(size);[self drawInRect:CGRectMake(0 ,0 ,size.width ,size.height)];UIImage *result = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return result;&#125;// 整体缩放等比缩放- (UIImage *) scaleImageByScale:(float)scaleSize &#123;UIGraphicsBeginImageContext(CGSizeMake(self.size.width * scaleSize, self.size.height * scaleSize));[self drawInRect:CGRectMake(0, 0, self.size.width * scaleSize, self.size.height * scaleSize)];UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return scaledImage;&#125;// 根据给定bound画最高质量的图片- (UIImage *)resizedImageInBounds:(CGSize)bounds &#123;return [self resizedImageInBounds:bounds quality:kCGInterpolationHigh];&#125;- (UIImage *)resizedImageInBounds:(CGSize)bounds quality:(CGInterpolationQuality)quality &#123;// UIViewContentModeScaleAspectFitCGFloat horizontalRatio = bounds.width / self.size.width;CGFloat verticalRatio = bounds.height / self.size.height;CGFloat ratio = MIN(horizontalRatio, verticalRatio);CGSize newSize = CGSizeMake(self.size.width * ratio, self.size.height * ratio);CGAffineTransform transform = [self transformForOrientation:newSize];CGRect newRect = CGRectIntegral(CGRectMake(0, 0, newSize.width, newSize.height));CGRect toRect = CGRectMake(0, 0, newRect.size.height, newRect.size.width);CGImageRef imageRef = self.CGImage;CGContextRef bitmap = CGBitmapContextCreate(NULL,newRect.size.width,newRect.size.height,8,0,CGImageGetColorSpace(imageRef),kCGImageAlphaNoneSkipLast);CGContextConcatCTM(bitmap, transform);CGContextSetInterpolationQuality(bitmap, quality);CGContextDrawImage(bitmap, toRect, imageRef);// 或 UIGraphicsGetImageFromCurrentImageContextCGImageRef newImageRef = CGBitmapContextCreateImage(bitmap);UIImage *newImage = [UIImage imageWithCGImage:newImageRef];CGContextRelease(bitmap);CGImageRelease(newImageRef);return newImage;&#125;#pragma mark 拉伸// 使用中心点拉伸- (UIImage *)stretchableImageByCenter &#123;CGFloat leftCapWidth = floorf(self.size.width / 2);if (leftCapWidth == self.size.width / 2) &#123;leftCapWidth--;&#125;CGFloat topCapHeight = floorf(self.size.height / 2);if (topCapHeight == self.size.height / 2) &#123;topCapHeight--;&#125;return [self stretchableImageWithLeftCapWidth:leftCapWidthtopCapHeight:topCapHeight];&#125;/*注意事项：1，UIEdgeInsets 上 左 下 右2，UIImageResizingMode 解释UIImageResizingModeTile：平铺模式，通过 重复 UIEdgeInsets指定的矩形区域来填充图UIImageResizingModeStretch：拉伸模式，通过 拉伸 UIEdgeInsets指定的矩形区域来填充图片[originImage resizableImageWithCapInsets:UIEdgeInsetsMake(10, 10, 10, 10) resizingMode:UIImageResizingModeStretch];*/#pragma mark 旋转图片/*UIImageOrientationUp, // 默认方向UIImageOrientationDown, // 让默认方向旋转180度UIImageOrientationLeft, // 让默认方向逆时针旋转90度UIImageOrientationRight, // 让默认方向顺时针旋转90度UIImageOrientationUpMirrored, // 默认方向的竖线镜像//（即以原图的左(或右)边的竖线为对称轴，对原图进行对称投影得到的镜像）UIImageOrientationDownMirrored, // 让镜像旋转180度UIImageOrientationLeftMirrored, // 让镜像逆时针旋转90度UIImageOrientationRightMirrored, // 让镜像顺时针旋转90度*/// 按方向旋转图片- (UIImage *)rotatedByOrientation:(UIImageOrientation)orientation &#123;return [UIImage imageWithCGImage:self.CGImage scale:self.scale orientation:orientation];&#125;// 按角度旋转图片- (UIImage *)rotatedByDegrees:(CGFloat)degrees&#123;UIView *rotatedViewBox = [[UIView alloc] initWithFrame:CGRectMake(0,0,self.size.width, self.size.height)];// 逆时针旋转angle弧度CGAffineTransform t = CGAffineTransformMakeRotation(DegreesToRadians(degrees));rotatedViewBox.transform = t;CGSize rotatedSize = rotatedViewBox.frame.size;UIGraphicsBeginImageContext(rotatedSize);CGContextRef context = UIGraphicsGetCurrentContext();CGContextTranslateCTM(context, rotatedSize.width/2, rotatedSize.height/2);CGContextRotateCTM(context, DegreesToRadians(degrees));CGContextScaleCTM(context, 1.0, -1.0);CGContextDrawImage(context, CGRectMake(-self.size.width / 2, -self.size.height / 2, self.size.width, self.size.height), [self CGImage]);UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return newImage;&#125;#pragma mark 修正图片方向- (UIImage *)imageFixOrientation &#123;if (self.imageOrientation == UIImageOrientationUp) return self;CGAffineTransform transform = [self transformForOrientation:self.size];CGFloat width = self.size.width;CGFloat height = self.size.height;size_t bits = CGImageGetBitsPerComponent(self.CGImage);CGColorSpaceRef colorSpace = CGImageGetColorSpace(self.CGImage);CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(self.CGImage);if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;if (alpha == kCGImageAlphaNone) &#123;bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;bitmapInfo |= kCGImageAlphaNoneSkipFirst;&#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;bitmapInfo |= kCGImageAlphaPremultipliedFirst;&#125;#pragma clang diagnostic pop&#125;CGContextRef ctx = CGBitmapContextCreate(NULL, width, height, bits, 0, colorSpace, bitmapInfo);if (ctx == NULL) &#123;return self;&#125;CGContextConcatCTM(ctx, transform);switch (self.imageOrientation) &#123;case UIImageOrientationLeft:case UIImageOrientationLeftMirrored:case UIImageOrientationRight:case UIImageOrientationRightMirrored:// Grr...CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);break;default:CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);break;&#125;// And now we just create a new UIImage from the drawing contextCGImageRef cgimg = CGBitmapContextCreateImage(ctx);UIImage *img = [UIImage imageWithCGImage:cgimg];CGContextRelease(ctx);CGImageRelease(cgimg);return img;&#125;//- (CGAffineTransform)transformForOrientation:(CGSize)newSize &#123;/*CGAffineTransform 处理形变的类,二维坐标系,即向右为x轴正方向,向上为y轴正方向方法简介：CGAffineTransformTranslate // x轴方向上平移x单位,在y轴方向上平移y单位CGAffineTransformScale // x轴方向上缩放x倍,在y轴方向上缩放y倍CGAffineTransformRotate // 逆时针旋转弧度,M_PI=180角度)以下都是针对视图的原定最初位置的中心点为起始参照进行相应操作的，CGAffineTransformMakeTranslation // 将坐标系统x轴方向上平移x单位,在y轴方向上平移y单位CGAffineTransformMakeScale // 将坐标系统x轴方向上缩放x倍,在y轴方向上缩放y倍CGAffineTransformMakeRotation // 将坐标系统逆时针旋转弧度,M_PI=180角度)在操作结束之后可对设置量进行还原：view.transform＝CGAffineTransformIdentity;*/CGAffineTransform transform = CGAffineTransformIdentity;switch(self.imageOrientation) &#123;case UIImageOrientationDown:case UIImageOrientationDownMirrored:transform = CGAffineTransformTranslate(transform, newSize.width, newSize.height);transform = CGAffineTransformRotate(transform, M_PI);break;case UIImageOrientationLeft:case UIImageOrientationLeftMirrored:transform = CGAffineTransformTranslate(transform, newSize.width, 0);transform = CGAffineTransformRotate(transform, M_PI_2);break;case UIImageOrientationRight:case UIImageOrientationRightMirrored:transform = CGAffineTransformTranslate(transform, 0, newSize.height);transform = CGAffineTransformRotate(transform, -M_PI_2);break;default:break;&#125;switch(self.imageOrientation) &#123;case UIImageOrientationUpMirrored:case UIImageOrientationDownMirrored:transform = CGAffineTransformTranslate(transform, newSize.width, 0);transform = CGAffineTransformScale(transform, -1, 1);break;case UIImageOrientationLeftMirrored:case UIImageOrientationRightMirrored:transform = CGAffineTransformTranslate(transform, newSize.height, 0);transform = CGAffineTransformScale(transform, -1, 1);break;default:break;&#125;return transform;&#125;#pragma mark 生成image+ (UIImage *)createImageWithView:(UIView *)view&#123;// size区域大小，opaque是否透明，屏幕分辨率 0表示 [UIScreen mainScreen].scaleUIGraphicsBeginImageContextWithOptions(view.bounds.size, view.opaque, 0.0);// 将view的layer渲染到当前的绘制的上下文中[view.layer renderInContext:UIGraphicsGetCurrentContext()];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return image;&#125;#pragma mark 水印// 图片水印- (UIImage *)waterImage:(UIImage *)otherImage &#123;// 右下角CGFloat x = self.size.width - (self.size.width - otherImage.size.width)/2;CGFloat y = self.size.height - (self.size.height - otherImage.size.height)/2;return [self mergeImage:otherImage center:CGPointMake(x, y)];&#125;- (UIImage *)mergeImage:(UIImage *)otherImage center:(CGPoint)center&#123;UIGraphicsBeginImageContext(self.size);[self drawInRect:CGRectMake(0, 0, self.size.width, self.size.height)];CGFloat width = otherImage.size.width;CGFloat height = otherImage.size.height;[otherImage drawInRect:CGRectMake(center.x - width/2, center.y - height/2, width, height)];UIImage *resultingImage = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return resultingImage;&#125;#warning TODO：实现一个文字版水印效果@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息传递2：机制]]></title>
    <url>%2F2016%2F05%2F22%2F%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%922%EF%BC%9A%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;刚学OC时水过一次为啥叫消息发送，具体就不贴了！看了看实在是水的不行！前些天专门写了点消息发送的方式以及注意事项！今天就水一水，消息发送的机制是什么 1 动态绑定VS静态绑定1.1 静态绑定-就是编译时已经写死了调用函数，硬编码的，不会变1234567891011121314151617181920/*********** 例1 静态绑定 ***********/#import &lt;stdio.h&gt;void printHello() &#123;printf(&quot;Hello, world!\n&quot;);&#125;void printGoodbye() &#123;printf(&quot;Goodbye, world!\n&quot;);&#125;void saySomething(int type) &#123;/*重点不是if，而是写死的printHello();和printGoodbye();这两个函数在编译时已经硬编码进了程序，是不会改变的*/ if (type == 0) &#123;printHello();&#125; else &#123;printGoodbye();&#125;return 0;&#125; 1.2 动态绑定 是运行时再绑定实际的调用函数，OC就是通过消息传递的方式来动态绑定的123456789101112131415161718192021/*********** 例2 动态绑定 ***********/#import &lt;stdio.h&gt;void printHello() &#123;printf(&quot;Hello, world!\n&quot;);&#125;void printGoodbye() &#123;printf(&quot;Goodbye, world!\n&quot;);&#125;void saySomething(int type) &#123;/*通过函数指针的方式调用printHello();和printGoodbye();函数将具体调用哪个函数推迟到了运行时再确定，我们可修改函数指针指向一个printLog();函数来实现动态效果，而不需要修改硬编码*/ void (*func)();if (type == 0) &#123;func = printHello;&#125; else &#123;func = printGoodbye;&#125;func();return 0;&#125; 1.3 PS:函数指针和指针函数1234// 函数指针：函数的指针int (*fun)(int x,int y);// 指针函数：指针两字在前面，所以返回值是指针int * fun(int x,int y)； 2 objc_msgSend2.1 向某个OC对象发送消息123456// OC写法id returnValue = [someObject messageName:parameter];// 编译器转化为C语言调用id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter); 2.2 objc_msgSend原型， 参考: https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm.s.auto.html1234// self表示调用函数的实例对象// SEL表示调用的函数指针// ...表示对应的参数，支持多参数id objc_msgSend(id self, SEL _cmd, ...); 3 消息传递流程3.1 一般流程&emsp;&emsp;由于动态绑定需在运行时确定具体函数地址，也就存在一个查找内存地址的过程：1231. 从方法缓存里找！为啥要缓存？当时是为了加快检索速度，毕竟常用方法就那么几个，每次都遍历一遍所有方法很耗时耗性能的2. 从类的所有方法形成的列表里找！找到则写入缓存，方便下次查找3. 沿着继承链从父类类中查找 &emsp;&emsp;正常流程下，如果遍历了所有父类依然没有找到对应的方法就会Crash，并给出unrecognized selector sent to instance的Crash信息，但OC贴心的为我们提供了补救措施 3.2 补救措施 动态方法解析，OC提供了两个方法用于处理找不到方法的情况123456789101112131415161718192021222324252627// 用于解决类方法找不到的情况+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 用于解决实例方法找不到的情况+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);// 示例- (void)viewDidLoad &#123;[super viewDidLoad];[self performSelector:@selector(unrecognizedSelector)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;NSString *selectorString = NSStringFromSelector(sel);if ([selectorString isEqualToString:@&quot;unrecognizedSelector&quot;]) &#123;// 将sel的函数指针指向recognizedOtherSelector的地址class_addMethod(self,sel,(IMP)recognizedOtherSelector,&quot;&quot;);return YES;&#125;return NO;&#125;void recognizedOtherSelector() &#123;NSLog(@&quot;----&quot;);&#125; 没有实现动态方法解析，则查看有没有备用接受者12345678// 其实就是找个能响应aSelector方法的替死鬼- (id)forwardingTargetForSelector:(SEL)aSelector &#123;NSString *selectorString = NSStringFromSelector(aSelector);if ([selectorString isEqualToString:@&quot;unrecognizedSelector&quot;]) &#123;return @&quot;能够响应unrecognizedSelector的对象&quot;;&#125;return nil;&#125; 消息转发123456789101112131415161718192021222324必须要覆盖两个方法在methodSignatureForSelector和forwardInvocation// 创建一个有效的签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];if (!signature) &#123;return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];&#125;return signature;&#125;// 转发给某个方法- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;[anInvocation setSelector:@selector(forwardTo:)];NSString *arg1;[anInvocation getArgument:&amp;arg1 atIndex:2];[anInvocation invokeWithTarget:self];&#125;- (void)forwardTo:(NSString *)arg1 &#123;NSLog(@&quot;%@&quot;,arg1);&#125; 4 总结&emsp;&emsp;调用一个objc_msgSend(id theReceiver, SEL selectot,……)`方法系统执行的步骤为: 判断receiver是否为nil，如果是nil的话则不往下执行，返回nil，这就是为什么在oc中一个nil发送消息不会引起奔溃。 从方法的缓存中查找被调用过的方法会存在缓存里面，每个类都会有一个表来存被调用过的方法，以便下次更快的调用。 从本类的方法表中查找方法寻找selector，找到则写入缓存，返回方法。否则再从父类中查找方法，如此往复，直到达到基类。如果找不到则执行方法的动态解析。 方法的动态解析： 调用+(BOOL)resolveInstanceMethod:(SEL)sel方法来查看是否能够返回一个selector，如果存在则返回selector。不存在进入下一步。 备用接受者 - (id)forwardingTargetForSelector:(SEL)aSelector这个方法来询问是否有接受者可以接受这个方法呀。如果有人接受，则交给它处理，就好像一切都没发生过一样。 方法的转发： 如果到这一步还不能够找到相应的Selector的话，就要进行完整的方法转发过程。调用方法(void)forwardInvocation:(NSInvocation *)anInvocation 最后还是没有找到的话就只有呵呵了，这时候unrecognized selector sent to instance 0x100111df0’的错误就来了。 参考 https://www.jianshu.com/p/64ed325c1f19 https://www.zybuluo.com/MicroCai/note/64270]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[消息传递1：方式]]></title>
    <url>%2F2016%2F05%2F20%2F%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%921%EF%BC%9A%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;前几天做CR时发现，一个同事特别喜欢Block，甚至在Base里添加了几个方法，把tableview的常用代理方法都用block实现了一遍，我对此提出了异议！但其他同事觉得没什么，个人喜好而已！你不喜欢可以不用呀！额……好吧，我不喜欢，我可以不用……。那么咱们就讨论一下iOS里一共有几种消息传递方式？各自的优缺点以及使用场景？ 1 常见方式以及介绍1.1 KVO 含义：属性观察器，当对象中的某个属性值发生了改变，可以对这些值的观察者做出通知。 优点： 简单的方法实现映射关系，很方便的实现“联动”效果 能够对非“我族类“进行观察观测，方便进行调试或及时响应 能够观察嵌套的属性，方便窥探私有属性。例如CAAnimation可用@”transform.scale”的方式进行缩放 耦合低，因被观察属性根本就不知道已经被偷窥了 缺点： keyPath必须是NSString，很容易写错且XCode不会检查 观察多个属性时，if处理逻辑非常复杂，容易出错 依赖被观察属性，一旦改名就没用了 不能重复addObserver, dealloc时必须removeObserver 没有返回值，当然也不需要 注意事项：不能重复addObserver, dealloc时必须removeObserver 1.2 Notification 含义：通知（广播），典型的”管杀不管埋“ 优点： 解耦，最解耦的消息传递方式 简单，一个[NSNotificationCenter defaultCenter]走天下 一对多 参数传递比较简单，默认提供一个id类型的object，也可以用过aUserInfo字典传递 缺点： 没有编译检查,虽然可以通过NSString const name = @”name”;extern NSString const name; 的方式减少失误 同一个线程调用，常见问题是异步线程postNotification，主线程接收造成UI绘制出问题 同步调用，注意NSNotificaiton是同步调用 无论通过id类型的object还是通过userInfo字典传递参数都必须做”苛刻“的参数校验，否则很容易出现类型转换问题 没有返回值，通知（广播）甚至都不关心是否有”人“响应 dealloc必须移除observer 注意事项：同一线程同步调用，dealloc必须移除observer12345678910111213141516- (void)viewDidLoad &#123;[super viewDidLoad];[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notTest) name:@&quot;notTest&quot; object:nil];dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;NSLog(@&quot;------ 1&quot;);[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notTest&quot; object:nil];NSLog(@&quot;------ 3&quot;);&#125;);&#125;- (void)notTest &#123;NSLog(@&quot;------ 2&quot;);NSLog(@&quot;current queue:%@&quot;,[NSThread currentThread]);&#125;- (void)dealloc &#123;[[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 1.3 协议delegate（代理） 已经是设计模式了 优点： 强制性编译器检查，默认都是@required，除非特殊标明@optional 代码可读性好，一般都按照UITableViewDataSource的格式写，而且一般都会将sender作为第一个参数传回去 参数以及返回值类型明确，是的可以有返回值 没有循环引用，因为一般delegate都设置为weak属性 调试比较方便，因为”数据“流向很清晰 耦合度比较低 缺点： 书写复杂，比较考验命名以及方法的拆分能力 发送对象和回调方法在代码上是”分开“的，不能一眼就看出来逻辑关系 delegate一般用weak修饰，避免野指针问题 @optional方法需要判断delegate是否实现 注意事项：@optional方法需要判断delegate是否实现，delegate一般用weak修饰 1.4 Block 代码块 优点 简单，不需要提前声明，不需要addObserver 类型安全，block声明时已经指定了参数和返回值类型，对可以有返回值 可读性强，更有连贯性 减少命名恐惧症，因为可以不命名 与GCD配合解决多线程问题 缺点 小心循环引用问题 多层bloc嵌套时，逻辑比较乱 小心block的捕获外部变量行为 作为属性时需要用copy修饰 耦合度高 需要判断block是否为nil 注意事项：循环引用问题 1.5 Target-Action Target-Action主要被用于响应用户界面事件时所需要传递的消息中。 iOS中的UIControl和Mac中的NSControl/NSCell都支持这种机制。Target-Action在消息的发送者和接收者之间建立了一个非常松散耦合。消息的接收者不知道发送者，甚至消息的发送者不需要预先知道消息的接收者。如果target是nil，action会在响应链(responder chain)中被传递，知道找到某个能够响应该aciton的对象。在iOS中，每个控件都能关联多个target-action。 基于target-action消息传递的机制有一个局限就是发送的消息不能携带自定义的payload。在Mac的action方法中，接收者总是被放在第一个参数中。而在iOS中，可以选择性的将发送者和和触发action的事件作为参数。除此之外，没有别的办法可以对发送action消息内容做控制。 2 使用方式2.1 其它博客推荐方式 以下图片是破船翻译的Communication Patterns，已经给出了详细的设计方向，可精读。参考：http://www.cocoachina.com/articles/7543 2.2 个人总结 KVO：属性观察器、反射 Notification：跨层级通信、一对多通信 协议delegate：通信事件比较多、强制用户实现 Block：一次性使用、简单的传值操作 Target-Action：UI控件、自定义控件专用 结论&emsp;&emsp;综上所述，我认为在Base里把tableview的常用代理方法都用block实现了一遍是得不偿失的，撇开Base更加臃肿和可能存在的循环引用不谈！用block代替tableview的delegate方法并不能保证调用者一会实现你的block，增加了调用者使用难度 参考 http://www.cocoachina.com/articles/7543]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应链]]></title>
    <url>%2F2016%2F05%2F03%2F%E5%93%8D%E5%BA%94%E9%93%BE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;响应链是啥？我也说不清，不管了，我就写点我知道的吧 &emsp;&emsp;最简单的查看响应链的方法就是递归打印nextResponder, 可见顺序是当前view一直到UIApplication的顺序，有view响应则此链中断123456789101112131415161718192021222324252627- (void)viewDidLoad &#123;[super viewDidLoad];UIButton *btn1 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 300, 500)];btn1.backgroundColor = [UIColor redColor];[self.view addSubview:btn1];UIButton *btn2 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 250, 400)];btn2.backgroundColor = [UIColor blueColor];[btn1 addSubview:btn2];UIButton *btn3 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 200, 300)];btn3.backgroundColor = [UIColor yellowColor];[btn2 addSubview:btn3];NSArray *arr = @[btn1, btn2, btn3];for (UIButton *btn in arr) &#123;[btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];&#125;&#125;- (void)btnClick:(UIButton *)btn &#123;[self logNextResponder:btn];&#125;- (void)logNextResponder:(UIResponder *)responder &#123;NSLog(@&quot;responder:%@&quot;,responder);UIResponder *next = responder.nextResponder;if (next) &#123;[self logNextResponder:next];&#125;&#125; &emsp;&emsp;再说事件传递，就是点了下屏幕，系统时怎么知道“点击”的？点击之后，由UIApplication管理事件，然后递归查找最合适的view类接收事件！对的，跟nextResponder的顺序相反！但系统怎么知道到底是哪个view呢？毕竟UIApplication最“大”，点击的那个view只是大量subviews中的一个！这时需要借助两个UIView的函数： pointInside: withEvent: 用于判断某个事件是否在某个view的bound范围内 hitTest: withEvent: 用于判断某个view是否响应某个事件1234567891011121314151617181920- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;//首先判断是否可以接收事件if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;//然后判断点是否在当前视图上if ([self pointInside:point withEvent:event] == NO) return nil;//循环遍历所有子视图，查找是否有最合适的视图for (NSInteger i = self.subviews.count - 1; i &gt;= 0; i--) &#123;UIView *childView = self.subviews[i];//转换点到子视图坐标系上CGPoint childPoint = [self convertPoint:point toView:childView];//递归查找是否存在最合适的viewUIView *fitView = [childView hitTest:childPoint withEvent:event];//如果返回非空，说明子视图中找到了最合适的view，那么返回它if (fitView) &#123;return fitView;&#125;&#125;//循环结束，仍旧没有合适的子视图可以处理事件，那么就认为自己是最合适的viewreturn self;&#125; &emsp;&emsp;pointInside: withEvent:的妙用，可控制view的响应范围 例如扩大button的点击范围1234567- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event &#123;CGRect bounds = self.bounds;CGFloat widthDelta = MAX(100.0 , bounds.size.height);;CGFloat heightDelta = MAX(100.0 , bounds.size.height);bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);return CGRectContainsPoint(bounds, point);&#125; &emsp;&emsp;hitTest: withEvent:的妙用，常用于事件透传或转发123456- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;CGPoint yellowPoint = [self convertPoint:point toView:_yellowView];if ([_yellowView pointInside:yellowPoint withEvent:event]) &#123;return _yellowView;&#125;&#125; &emsp;&emsp;说实话，我很怀疑有些同志问的问题自己都说不清：你知道响应链吗？响应链是啥？呵呵，响应链是啥这种问题，叫我怎么回答？响应链要我说就是view的事件响应优先级！不过这么回答，肯定错了！他们想知道的是：为啥用hittest、pointinside，以及怎么用。。。。 参考 https://www.jianshu.com/p/36d2eb74fb23 https://www.jianshu.com/p/2f664e71c527]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程2：NSOperation、NSThread和pthread]]></title>
    <url>%2F2016%2F04%2F21%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B2%EF%BC%9ANSOperation%E3%80%81NSThread%E5%92%8Cpthread%2F</url>
    <content type="text"><![CDATA[1 操作队列&emsp;&emsp;NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象！更高级意味着 可以添加依赖关系，便于控制执行顺序， 可以设定优先级 监控操作状态（isExecuteing、isFinished、isCancelled） 可以实现completionBlock来实现完成时自动回调 &emsp;&emsp;个人理解：使用NSOperationQueue才真正的创建新线程，NSOperation就相当于就是GCD里面的block！还有就是我们只能“创建”线程，但具体到底创建了几个线程，是由系统决定的……好坑！不过一般情况下不用关心线程数量 &emsp;&emsp;另外需要注意的是：cancel某个操作（或操作队列），并不代表操作立即取消，只是设置个标志位告诉系统这个操作（或操作队列）需要cancel，系统去决定什么时候cancel 1.1 NSOperation使用 NSBlockOperation的使用 1234567891011121314151617181920212223242526272829303132333435NSBlockOperation *opearation = [NSBlockOperation blockOperationWithBlock:^&#123;// do something&#125;];// 添加额外子操作，等所有子操作(包括do something)都完成，才认为这次操作完成了[opearation addExecutionBlock:^&#123;// other something&#125;];// 以下为NSOperation属性以及解释opearation.name = @&quot;name可做标志位&quot;;opearation.completionBlock = ^&#123;NSLog(@&quot;已完成&quot;);&#125;;// 开启任务[opearation start];// 是否正在执行[opearation isExecuting];// 是否执行完了[opearation isFinished];// 当前操作是否执行完了[opearation isAsynchronous];// 是否准备好去执行[opearation isReady];// 添加依赖, 就是要等beferOpearation完成，才执行opearation// 注意一定不要创建一个循环依赖，A依赖B，B依赖A，这样会造成死锁// [opearation addDependency:beferOpearation];// 移除依赖// [opearation removeDependency:beferOpearation];// 阻塞当前线程，直到该操作结束, GCD的栅栏效果[opearation waitUntilFinished];// 取消if (![opearation isCancelled]) &#123;[opearation cancel];&#125; NSInvocationOperation的使用 123456NSInvocationOperation *opearation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];[opearation start];- (void)test &#123;// do something&#125; NSOperation的使用 12345678910111213@interface MyOperation: NSOperation@end@implementation MyOperation- (void)main &#123;@autoreleasepool &#123;// do something&#125;&#125;@end// 使用MyOperation *operation = [[MyOperation alloc] init];[operation start]; 1.2 NSOperationQueue使用1234567891011121314151617181920212223242526272829NSBlockOperation *opearation = [NSBlockOperation blockOperationWithBlock:^&#123;// do something&#125;];// 创建队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 添加操作，操作顺序有依赖关系和qualityOfService决定，并不一定是FIFO[queue addOperation:opearation];// 添加一组操作，并阻塞线程到这一组操作都完成[queue addOperations:@[opearation] waitUntilFinished:YES];// 添加一个新操作[queue addOperationWithBlock:^&#123;// new opearation will do something&#125;];NSLog(@&quot;当前所有的操作：%@，注意操作完成后会自动从数组中移除&quot;, queue.operations);NSLog(@&quot;当前所有的操作数量：%i&quot;, queue.operationCount);/*最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。不等于并发线程的数量，线程个数是系统决定的，而且一个操作也有可能不止再一个线程执行当然maxConcurrentOperationCount为1，即表示串行队列*/queue.maxConcurrentOperationCount = 1;// 暂停或开启所有操作if (queue.suspended) &#123;[queue setSuspended:NO];&#125;// 阻塞当前线程，直到队列中的操作全部执行完毕[queue waitUntilAllOperationsAreFinished];// 取消所有操作[queue cancelAllOperations]; 2 NSThread&emsp;&emsp;NSThread和pthread很不常用，而且需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销! 创建线程方法 1234567891011121314151617// 1 创建线程并启动[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil]; // 2 创建线程，但需要手动启动NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil]; [myThread setName=@&quot;调试用&quot;];[myThread setThreadPriority:NSQualityOfServiceDefault];// 设置优先级[myThread start]; // 启动[myThread cancel]; // 取消[myThread exit]; // 退出// 3 系统会创建一个子线程并启动[self performSelectorInBackground:@selector(threadRun) withObject:self];// 一般配合使用来更新UI[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; // 4 继承NSThread需重写main方法 常用方法 1234// 获取当前线程[NSThread currentThread]// 当前线程是不是主线程[[NSThread currentThread] isMainThread] 2.1：主线程检测的最标准写法1234// RAC源码+ (BOOL)isOnMainThread &#123;return [NSOperationQueue.currentQueue isEqual:NSOperationQueue.mainQueue] || [NSThread isMainThread];&#125; 3 pthread 转载自：https://github.com/ming1016/study/wiki/iOS并发编程 下面是并发4个线程在一百万个数字中找最小值和最大值的pthread例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#import &lt;pthread.h&gt;struct threadInfo &#123;uint32_t * inputValues;size_t count;&#125;;struct threadResult &#123;uint32_t min;uint32_t max;&#125;;void * findMinAndMax(void *arg)&#123;struct threadInfo const * const info = (struct threadInfo *) arg;uint32_t min = UINT32_MAX;uint32_t max = 0;for (size_t i = 0; i &lt; info-&gt;count; ++i) &#123;uint32_t v = info-&gt;inputValues[i];min = MIN(min, v);max = MAX(max, v);&#125;free(arg);struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));result-&gt;min = min;result-&gt;max = max;return result;&#125;int main(int argc, const char * argv[])&#123;size_t const count = 1000000;uint32_t inputValues[count];// 使用随机数字填充 inputValuesfor (size_t i = 0; i &lt; count; ++i) &#123;inputValues[i] = arc4random();&#125;// 开始4个寻找最小值和最大值的线程size_t const threadCount = 4;pthread_t tid[threadCount];for (size_t i = 0; i &lt; threadCount; ++i) &#123;struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));size_t offset = (count / threadCount) * i;info-&gt;inputValues = inputValues + offset;info-&gt;count = MIN(count - offset, count / threadCount);int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err);&#125;// 等待线程退出struct threadResult * results[threadCount];for (size_t i = 0; i &lt; threadCount; ++i) &#123;int err = pthread_join(tid[i], (void **) &amp;(results[i]));NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err);&#125;// 寻找 min 和 maxuint32_t min = UINT32_MAX;uint32_t max = 0;for (size_t i = 0; i &lt; threadCount; ++i) &#123;min = MIN(min, results[i]-&gt;min);max = MAX(max, results[i]-&gt;max);free(results[i]);results[i] = NULL;&#125;NSLog(@&quot;min = %u&quot;, min);NSLog(@&quot;max = %u&quot;, max);return 0;&#125; 使用NSThread来写 123456789101112131415161718192021222324252627282930313233343536373839404142@interface FindMinMaxThread : NSThread@property (nonatomic) NSUInteger min;@property (nonatomic) NSUInteger max;- (instancetype)initWithNumbers:(NSArray *)numbers;@end@implementation FindMinMaxThread &#123;NSArray *_numbers;&#125;- (instancetype)initWithNumbers:(NSArray *)numbers&#123;self = [super init];if (self) &#123;_numbers = numbers;&#125;return self;&#125;- (void)main&#123;NSUInteger min;NSUInteger max;// 进行相关数据的处理self.min = min;self.max = max;&#125;@end//启动一个新的线程，创建一个线程对象NSMutableSet *threads = [NSMutableSet set];NSUInteger numberCount = self.numbers.count;NSUInteger threadCount = 4;for (NSUInteger i = 0; i &lt; threadCount; i++) &#123;NSUInteger offset = (count / threadCount) * i;NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);NSRange range = NSMakeRange(offset, count);NSArray *subset = [self.numbers subarrayWithRange:range];FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];[threads addObject:thread];[thread start];&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程1：概念和GCD]]></title>
    <url>%2F2016%2F04%2F17%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B1%EF%BC%9A%E6%A6%82%E5%BF%B5%E5%92%8CGCD%2F</url>
    <content type="text"></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器]]></title>
    <url>%2F2016%2F03%2F30%2F%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1 NSTimer1.1 NSTimer准不准？ 无论是单次执行的NSTimer还是重复执行的NSTimer都不是准时的 原因 只添加到了runloop的defaultmode里，当scrollView滑动时runloop会切换到UITrackingRunLoopMode下，造成NSTimer延后 当前线程阻塞或正在进行大量数据计算，NSTimer会延后处理 1.2 创建NSTimer需要加到runloop里 默认NSTimer加到runloop是NSDefaultRunLoopMode模式，此模式下scrollview滑动时会切换到UITrackingRunLoopMode下暂停NSTimer，因此需要让NSTimer都响应，需要使用NSRunLoopCommonModes 故runloop强持有NSTimer，来保证timer按时触发12NSTimer *bTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(automaticCountDown) userInfo:nil repeats:YES];[[NSRunLoop mainRunLoop] addTimer:bTimer forMode:NSRunLoopCommonModes]; 1.3 scheduledTimerWith和timerWith的区别 timerWith创建的NSTimer需要手动添加到runloop里 scheduledTimerWith创建的NSTimer已经自动添加到当前runloop的NSDefaultRunLoopMode模式1234567891011/// Creates and returns a new NSTimer object initialized with the specified block object. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire./// - parameter: timeInterval The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead/// - parameter: repeats If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires./// - parameter: block The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));/// Creates and returns a new NSTimer object initialized with the specified block object and schedules it on the current run loop in the default mode./// - parameter: ti The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead/// - parameter: repeats If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires./// - parameter: block The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)); 1.4 NSTimer内存泄漏 NSTimer的target是strong强持有的，即NSTimer持有target！如果target强持有NSTimer，就会形成循环引用 1target： The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated. weak修饰NSTimer不管用，只能解除target对NSTimer的强持有！一般情况下循环引用只要断掉一环就可以释放了，但runloop还引用着NSTimer，NSTimer又引用target，因此也无法解决内存泄漏问题 很多时候使用retain或strong修饰，更多是提醒开发者需要手动处理NSTimer 12345678910111213141516- (instancetype)init &#123;self = [super init];if (self) &#123;_timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];&#125;return self;&#125;- (void)timerRun &#123;NSLog(@&quot;%s&quot;, __func__);&#125;- (void)dealloc &#123;[self.timer invalidate];NSLog(@&quot;%s&quot;, __func__);&#125; 使用block解除引用，参考《Effective Objective-C》第52条 12345678910111213141516171819- (void)viewDidLoad &#123;[super viewDidLoad];__weak id weakSelf = self;NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer *timer) &#123;NSLog(@&quot;block %@&quot;,weakSelf);&#125;];&#125;@implementation NSTimer(BlockTimer)+ (NSTimer*)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats blockTimer:(void (^)(NSTimer *))block&#123;NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(timered:) userInfo:[block copy] repeats:repeats];return timer;&#125;+ (void)timered:(NSTimer*)timer &#123;void (^block)(NSTimer *timer) = timer.userInfo;block(timer);&#125;@end 注意当repeats=NO时执行完定时任务，会自动执行invalidate操作，即不会有循环引用 1.5 销毁NSTimer1234- (void)invalidateTimer &#123;[_timer invalidate];_timer = nil;&#125; 1.6 立即执行 NSTimer无论是循环repeats=YES，还是延迟repeats=NO，第一次调用都是X时间后，如果想立即执行，可采用fire方法1[_timer fire]; 1.7 创建和销毁要在同一线程 因为创建Timer要把Timer加入到该线程对应的RunLoop中，故在同一个线程中才能cancel这个Timer12345678910111213141516// 创建NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];[thread start];- (void)newThread &#123;@autoreleasepool&#123;_timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];// 即便是scheduledTimerWith方法也需手动加入runloop[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];// 子线程需手动开启runloop[[NSRunLoop currentRunLoop] run];&#125;&#125;// 销毁[self performSelector:@selector(invalidateTimer) onThread:thread withObject:nil waitUntilDone:YES]; 2 CADisplayLink CADisplayLink是用于同步屏幕刷新频率的计时器，ios都是60hz，即每秒60次回调selector，回调频率通过frameInterval属性设置，CADisplayLink的selector每秒调用次数=60/frameInterval 精准度比较高,但并不保证都是60hz的刷新频率，例如主线程卡顿 2.1 重要属性介绍 frameInterval 标识间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。官方文档中强调，当该值被设定小于1时，结果是不可预知的。 duration 表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。 timestamp 当前帧的时间戳 2.2 示例1234567891011121314151617@property (nonatomic, strong) CADisplayLink* displayLink;- (void)startDisplayLink &#123;_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkProc)];[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;- (void)stopDisplayLink &#123;[_displayLink setPaused:YES];[_displayLink removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];[_displayLink invalidate];_displayLink = nil;&#125;- (void)displayLinkProc &#123;&#125; 3 GCD实现timer 示例代码 12345678910111213141516171819202122232425262728@property (nonatomic, strong) dispatch_source_t countDownTimer;// 开启timer- (void)startTimer &#123;if (!_timer) &#123;// 设置时间间隔，每秒执行NSTimeInterval period = 1.0;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);/*dispatch_walltime 可以让计时器按照真实时间间隔进行计时，但使用dispatch_time 或者 DISPATCH_TIME_NOW 时当系统休眠的时候计时器会停止*/ dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0);/*dispatch_source_set_event_handler 这个函数在执行完之后，block 会立马执行一遍,相当于NSTimer fire*/ dispatch_source_set_event_handler(_timer, ^&#123;// do something&#125;);dispatch_resume(_timer);&#125;&#125;// 关闭timer- (void)stopTimer &#123;if (_timer) &#123;dispatch_source_cancel(_timer);_timer = nil;&#125;&#125; 注意挂起后不得释放timer 12dispatch_suspend(_timer);_timer = nil; // EXC_BAD_INSTRUCTION 崩溃 参考]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决快速push的崩溃]]></title>
    <url>%2F2016%2F03%2F06%2F%E8%A7%A3%E5%86%B3%E5%BF%AB%E9%80%9Fpush%E7%9A%84%E5%B4%A9%E6%BA%83%2F</url>
    <content type="text"><![CDATA[Crash详情：Can’t add self as subview crash 原理就是当前有跳转动画就抛弃其它VC 123456789101112131415161718192021222324@implementation NSObject (Hook)#pragma mark hook+ (void)hookWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector &#123;Class class = [self class];Method originalMethod = class_getInstanceMethod(class, originalSelector);Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);BOOL didAddMethod = class_addMethod(class,originalSelector,method_getImplementation(swizzledMethod),method_getTypeEncoding(swizzledMethod));if (didAddMethod) &#123;class_replaceMethod(class,swizzledSelector,method_getImplementation(originalMethod),method_getTypeEncoding(originalMethod));&#125;else &#123;method_exchangeImplementations(originalMethod, swizzledMethod);&#125;&#125;@end UINavigationController &amp; UIViewController 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#import &quot;UINavigationController+Safely.h&quot;#import &quot;NSObject+Hook.h&quot;static char const * const kViewTransitionInProgress = &quot;kViewTransitionInProgress&quot;;@implementation UINavigationController (Safely)- (void)setViewTransitionInProgress:(BOOL)property &#123;NSNumber *number = [NSNumber numberWithBool:property];objc_setAssociatedObject(self, kViewTransitionInProgress, number , OBJC_ASSOCIATION_RETAIN);&#125;- (BOOL)viewTransitionInProgress &#123;NSNumber *number = objc_getAssociatedObject(self, kViewTransitionInProgress);return [number boolValue];&#125;+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;[[self class] hookWithOriginalSelector:@selector(pushViewController:animated:) swizzledSelector:@selector(safe_PushViewController:animated:)];[[self class] hookWithOriginalSelector:@selector(popViewControllerAnimated:) swizzledSelector:@selector(safe_PopViewControllerAnimated:)];[[self class] hookWithOriginalSelector:@selector(popToViewController:animated:) swizzledSelector:@selector(safe_PopToViewController:animated:)];[[self class] hookWithOriginalSelector:@selector(popToRootViewControllerAnimated:) swizzledSelector:@selector(safe_PopToRootViewControllerAnimated:)];&#125;);&#125;#pragma mark - hookSelecter- (NSArray *)safe_PopToRootViewControllerAnimated:(BOOL)animated &#123;if (self.viewTransitionInProgress) &#123;return nil;&#125;if (animated) &#123;self.viewTransitionInProgress = YES;&#125;NSArray *VCArray = [self safe_PopToRootViewControllerAnimated:animated];if (VCArray.count == 0) &#123;self.viewTransitionInProgress = NO;&#125;return VCArray;&#125;- (NSArray *)safe_PopToViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;if (self.viewTransitionInProgress) &#123;return nil;&#125;if (animated)&#123;self.viewTransitionInProgress = YES;&#125;NSArray *VCArray = [self safe_PopToViewController:viewController animated:animated];if (VCArray.count == 0) &#123;self.viewTransitionInProgress = NO;&#125;return VCArray;&#125;- (UIViewController *)safe_PopViewControllerAnimated:(BOOL)animated &#123;if (self.viewTransitionInProgress) &#123;return nil;&#125;if (animated) &#123;self.viewTransitionInProgress = YES;&#125;UIViewController *VC = [self safe_PopViewControllerAnimated:animated];if (VC == nil) &#123;self.viewTransitionInProgress = NO;&#125;return VC;&#125;- (void)safe_PushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;if (self.viewTransitionInProgress == NO) &#123;[self safe_PushViewController:viewController animated:animated];if (animated) &#123;self.viewTransitionInProgress = YES;&#125;&#125;&#125;@end@implementation UIViewController (Safely)+ (void)load &#123;method_exchangeImplementations(class_getInstanceMethod(self, @selector(safe_ViewDidAppear:)),class_getInstanceMethod(self, @selector(viewDidAppear:)));method_exchangeImplementations(class_getInstanceMethod(self, @selector(safe_ViewDidDisappear:)),class_getInstanceMethod(self, @selector(viewDidDisappear:)));&#125;- (void)safe_ViewDidAppear:(BOOL)animated &#123;if (self.navigationController) &#123;self.navigationController.viewTransitionInProgress = NO;&#125;[self safe_ViewDidAppear:animated];&#125;- (void)safe_ViewDidDisappear:(BOOL)animated &#123;if (self.navigationController) &#123;self.navigationController.viewTransitionInProgress = NO;&#125;[self safe_ViewDidDisappear:animated];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSDate使用]]></title>
    <url>%2F2016%2F02%2F25%2FNSDate%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天开发时遇到需要获取当前是星期几的需求！虽然NSDate经常在用，但这个需求确实不知道，百度了一下，其实挺简单！顺便总结一下NSDate的使用，于是乎又水了一篇 1 概念理解 NSDate获取的都是当前机器的时间，用户是可以改的！NSDate所获取到的时间, 都是相对于GMT的, 即格林威治标准时间 1.1 时区问题 当前时区的时间 123456// 零时区时间NSDate *date = [NSDate date];// 如果没有指定NSDateFormatter的时区，NSDateFormatter默认是当前时区的时间NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];[dateFormat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];NSString *time = [dateFormat stringFromDate:date]; 指定时区 12345678910NSDate *date = [NSDate date];NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];[dateFormat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];NSLog(@&quot;系统时区：%@&quot;, [NSTimeZone systemTimeZone]);dateFormat.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;];// 还可用GMT+0800 加8小时, GMT-0800减8小时来表示// dateFormat.timeZone = [NSTimeZone timeZoneWithName:@&quot;GMT+0800&quot;];// 相对0时区的 秒 数// dateFormat.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:28800];NSString *time = [dateFormat stringFromDate:date]; 1.2 时间比较 唯一需要注意的：需要转化为同一时区，不同时区时间比价没有意义1234- (NSDate *)earlierDate:(NSDate *)anotherDate;- (NSDate *)laterDate:(NSDate *)anotherDate;- (NSComparisonResult)compare:(NSDate *)other;- (BOOL)isEqualToDate:(NSDate *)otherDate; 1.3 timeIntervalSinceXXX1234567// 以下三个方法默认都是0时区时间，中国要 + 8个小时// 自2001年1月1日晚上12点NSDate *date1 = [NSDate dateWithTimeIntervalSinceReferenceDate:0];// 自19070年1月1日晚上12点NSDate *date2 = [NSDate dateWithTimeIntervalSince1970:0];// nowNSDate *date3 = [NSDate dateWithTimeIntervalSinceNow:0]; 2常见用法2.1 NSDate与NSString转化1234567891011121314151617181920212223242526272829// NSDateFormatter是线程安全的，而且使用起来开销非常大，故可以只初始化一次即可static NSDateFormatter *dateFormatter = nil;NSDateFormatter *shareDateFormatter() &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;dateFormatter = [[NSDateFormatter alloc] init];&#125;);return dateFormatter;&#125;@implementation NSDate (String)- (NSString *)dateStringWithFormat:(NSString *)format &#123;[shareDateFormatter() setDateFormat:format];return [shareDateFormatter() stringFromDate:self];&#125;@end@implementation NSString (Date)- (NSDate *)dateWithFormat:(NSString *)format &#123;[getDateFormatter() setDateFormat:format];return [getDateFormatter() dateFromString:self];&#125;@end https://stackoverflow.com/questions/24777496/how-can-i-convert-string-date-to-nsdate?r=SearchResults 2.2 现在是星期几12345678910111213141516171819202122232425262728293031323334353637383940+ (NSDateComponents *)dateComponentsFromDate:(NSDate* )date&#123;NSDateComponents *components = [[NSDateComponents alloc] init];// 可获得很多信息，自己看吧NSInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitWeekday | NSCalendarUnitWeekOfMonth | NSCalendarUnitWeekOfYear;NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];calendar.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];components = [calendar components:unitFlags fromDate:date];return components;&#125;// 注意在西方周日是第一天+ (NSString *)getWeekDayFromDateComponents:(NSDateComponents *) comps&#123;NSString *weekDayStr = @&quot;&quot;;switch ([comps weekday]) &#123;case 1:weekDayStr = @&quot;周日&quot;;break;case 2:weekDayStr = @&quot;周一&quot;;break;case 3:weekDayStr = @&quot;周二&quot;;break;case 4:weekDayStr = @&quot;周三&quot;;break;case 5:weekDayStr = @&quot;周四&quot;;break;case 6:weekDayStr = @&quot;周五&quot;;break;case 7:weekDayStr = @&quot;周六&quot;;break;default:break;&#125;return weekDayStr;&#125; https://stackoverflow.com/questions/3694867/nsdate-get-year-month-day?r=SearchResults 2.3 获取当前时间若干年、月、日之后的时间1234567891011121314151617+ (NSDate *)dateWithFromDate:(NSDate *)date years:(NSInteger)years months:(NSInteger)months days:(NSInteger)days&#123;NSDate * latterDate;if (date) &#123;latterDate = date;&#125;else&#123;latterDate = [NSDate date];&#125;NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];NSDateComponents *comps = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinutefromDate:latterDate];[comps setYear:years];[comps setMonth:months];[comps setDay:days];return [calendar dateByAddingComponents:comps toDate:latterDate options:0];&#125; https://stackoverflow.com/questions/5067785/how-do-i-add-1-day-to-an-nsdate?r=SearchResults 参考 https://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html https://stackoverflow.com/questions/5965044/how-to-compare-two-nsdates-which-is-more-recent/5965106?r=SearchResults#5965106]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业36条军规]]></title>
    <url>%2F2016%2F02%2F01%2F%E5%88%9B%E4%B8%9A36%E6%9D%A1%E5%86%9B%E8%A7%84%2F</url>
    <content type="text"><![CDATA[军规1 不是每个人都适合创业 创业很难，成功者寥寥无几！就像俞敏洪说的，很多人死在了第二天晚上 创业是做未知的事，不可能出发前就想清楚所有的事，创业者需要在前进的过程中随机应变 创业路上，最常见的不是成功或失败，而是长时间的苦苦挣扎 创业的机会成本很高，开始创业之前一定要认清自己，战略规划在前 创业者要过非人的生活 创业者的时间表上没有生活时间 创业者要给所有人交代！必须承担所有的责任，很简单因为没得选！但请记住没有选择往往是最好的选择 只有不到十分之一的人适合创业 打工和创业所需能力不一样 领军人物应具备4个素质：1、目标高远，意志坚定；2、心胸开阔，情商要高；3、企业利益放第一位；4、学习能力强，爱学习而且会学习 创业者应具备4个素质：1、事业心，是否把企业当做命根子来做；2、眼光和境界，要比别人想得多，要比别人看得远；3、心理素质，能否百折不挠处变不惊；4、学习能力。是否已学习为生活方式，有无及时复盘的习惯 接受正规的职业化训练是非常必要的。 军规2 梦想是唯一的创业理由 创业就是一个逐梦的过程 人的时间是有限的，所以不要按照别人的意愿去活，这是浪费时间！做你想做的事！ 拒绝行尸走肉，人的梦想是不会终结的 越是被别人嘲笑的梦想，越有实现的价值！ 创业是一个不断试错的过程 一切都是未知的，比的是耐力、智慧和运气，这也正是创业的魅力所在 坚持与放弃，源于战略规划、战术智慧和冷静决断的结合！优柔寡断不可取，刚愎自用更不可取 创业没什么高不可攀 创业并不神秘也不高不可攀，只是一个生活方式 不要想得太复杂，也不用给自己界定太明确是具体成功时点，只是拼尽全力去做 早开始一点没坏处，不要幻想把一切都准备好再出发，因为你永远都准备不完，创业是一步一步干出来的，不是想出来的 关于创业的三个错误观念 不要把上市当做创业目标，实际上99%的企业上不了市，还有很多企业根本不适合上市 不要有为了就业而创业的思想。就业 = 安逸，创业就要做好思想准备 不要为了那些美丽的大道理去创业。那是“果”，不是“因” 军规3 学先进，傍大款，走正道 创业必须走正道 要善于向优秀的同行学习，要追求与强者合作，要坚守规范经营的原则。投机取巧看似占便宜，实则吃大亏，出来混早晚是要换的 有所为，有所不为，是为有为 对手不正当竞争，不等于你也可以不正当竞争。面对对手死缠烂打，第一要淡定，要冷静应付，不能自乱阵脚；第二，多做实事反击是在市场上，能不说就不说，能少说就少说，不得不说的时候要高举用户利益的大旗，重复正确的话，不回应攻击者，也不反击攻击者，切记言多必失，对攻击者的蔑视是最好的反击，切记不要去争论和回应对方的具体问题。最后坚持桌面上出牌 学先进要全盘学习 坚守自己的道德底线 学先进必须要先僵化，再固化，再优化。国情不同我们是特殊的，这绝对是个陷阱；绝大多数的事，绝大多数时候，没有谁特殊！进步的捷径就是直接学习那些已经成功的企业和人，学习他们已经被验证了的行之有效的方法！落后的组织，落后的人怎么会有水平判断先进方法的对错？所以必须先僵化的学习，教条似的做，等做熟练了，再坐下来复盘研究是否有优化之处 傍大款不是靠大款 和好的最强者合作发展，好处多多！正向激励 + 资源保证 + 流程优化 等等 傍大款是为了提升自己，互惠互利 军规4 创新是最好的武器 伟大不是模仿来的 再小的创新，再小的分支细节，放到14亿人口里都是一个非常可观的成功 模仿是不是成功的捷径！即便复制美国创新东西，也要先跟踪先复制，最后还要本土化创新 小公司尤其不可能通过模仿生存。大公司对市场的反应必然会慢半拍，小公司必须敢于冒险，勇于创新，快速反应才有机会。只有差异化才有市场空间 个人认为：模仿就是copy，因为很多差异化都体现在很小的细节 只有创新才有机会 每个成功的企业都是一系列创新的结果。做企业就是两件事–创新和营销。创新分为两类，一类发现新大陆，一类打破常规 企业的每个角落都需要不断地创新。产品创新很重要，但并不是企业创新的全部，这是每个创业者必须明确的理念。 一把手要为创新构建一个环境 创新者一定是少数派，会遭到大多数普通人的质疑；创新必然会经过艰难的探索，甚至不断地失败；创新会触犯很多既得利益者或市场领先者。这些都决定了创新是很艰难的，而这也正式创新的意义所在 军规5 放下身段死缠烂打 每一个成功都是拼出来的 成功有规律，走正道、创新和死缠烂打这三个普世成立的真理，可以帮助你更好的成功 成功者不找借口！逮住机会就死缠烂打，别太把自己当回事！成功者该放下身段时都能放下身段，放下身段从最基础的业务做起！对于创业公司，最基础的业务是最迫切的业务 成功者都善于调整自己的心态；他们往往缺乏过程感，急躁冒进，幻想一夜成功，把小公司当大公司来做，过分关注战略，规划，制度，流程等大公司的东西，提高了成本又降低了效率 成功者都有极强的意志力，再难也能咬牙扛过去！（可怜我总嚷嚷怕什么天塌下来大不了用脑袋顶着） 成功者风光的背后是和你一样的坎坷，都是雨里泥里爬出来的，只是你没有看到 伟大都是熬出来的 剩者为王，俞敏洪说很多人都死在了第二天晚上！所以首先要活下去，慢慢熬 成功的关键在于多坚持5分钟！你筋疲力尽时也是对手筋疲力尽的时候，虽然对手表面装的不累！ 把每个机会都当做最后一根稻草才能成功 机会太多的人往往不容易成功，因为他们很容易放弃，遇阻则推，不愿坚持，心想反正还有下一个机会！ 成功与否主要还是看自己！不否认客观因素存在，那是事实，你没得选，唯一能做的就是想尽办法去克服 军规6 凡事只能靠自己 任何时候创始人都不能放弃 创始人别无退路：凡事只能靠自己，万事皆有解且有唯一正解，凡是你担心的事一定会发生，享受创业过程 创业初期最难的三件事只能靠创始人自己 三座大山基本上只能靠你自己爬：找方向，找人和找钱 自己不会做的事不要指望下属创造惊喜 不是说创始人不需要合伙人、团队，而是说所有结果都由你自己负全责，所以你只能靠自己做决定 不要指望别人来救你 顾问公司只能帮锦上添花的忙 随时准备自救才能长命百岁，所有人都喜欢锦上添花，如果你自己都不竭尽全力，别人更不会伸出援手 不能以授权为名推卸自己的责任 军规7 领导要有预见性 预见未来是领军者的责任 只有预见未来才能做对的事，对未来预见的越早越清晰，你就越可能做正确的事。永远要比别人多思考一点，永远要做好最坏的打算、最全面的准备 只有预见未来才能走的更远，要站得高，看得远还要理的清！要留意新兴事务，要开阔眼界还要跳出具体业务细节看事情的能力 早做布局，早5分钟行动 快速决策，快速行动。要善于决断，敢于取舍！问题不会自己解决，“拖”着只能让事变的更糟 - 早做布局。居安思危，早作打算！先发优势不容小觑！ 留两分余力，随时准备自救 任何时候都不要孤注一掷！赌博中输的最惨的就是拼一把 越是顺风顺水，越要警惕。越要克制冲动和贪婪，睡觉都得睁半只眼！ 军规8 心力强大者胜 所有的比拼最终都是精神的比拼，必须拥有强大的心理素质和自我复盘学习的能力 什么奇迹都可能出现，前提是你不能认输！ 创业者要不断强大自己的心力！凡是不能消灭你的，都只能让你变得更强！ 领导者必须树立远大的理想！记住取法其上，得乎其中 创始人必须志存高远，有远大的理想且意志坚定，要知道绝大多数人是没有主意的！ 远大理想是鼓舞团队奋斗的动力！没有理想的队伍就是一盘散沙 领导者必须有必胜的信念 必胜的信念是创业者最宝贵的品质。你都不能破釜沉舟必胜而还的信念，下属为什么要跟着你？再说你的极限也是对手的极限，成功往往在于多坚持5分钟 只要肉体没被消灭，精神就不应该垮掉！必须的有股子狠劲！ 军规9 要敢于冒险 有五成把握就要开始行动 敢于打破常规才有机会！敢于质疑，敢于说不，敢于行动！ 所有的成功都是突破常规的结果。天鹅肉从来都是被第一个敢张嘴的蛤蟆吃掉的。现实生活中，绝大多数的雷池是我们自己想象出来的！ 敢于冒险才有胜机 成功总是青睐那些具有探险精神的人，宁愿失败也不要平庸！ 小公司只能靠冒险寻求生存空间 大公司必须以规避风险为主，追求稳步发展少犯错 我们失去的只是锁链，一旦成功，我们获得的将是整个世界 军规10 相信直觉 与直觉相悖的事不要干 根据直觉先做一个大胆假设，然后小心求证 别人的建议尤其是具体建议要慎听，永远不要用集体决策代替自己的决策 建议和经验要贴合自身实际而慎重选择 直觉是上天赐给创业者的礼物 大胆假设，小心求证。 军规11 创业要靠团队 一个人包打天下的时代已经过去了 创业需要一个团队，一个志同道合、优势互补、紧密配合、把公司当做命根子 团队强大才能打胜仗 没有合适的人做“1”，再多的“0”也没用！管理者的能力是找到对的人 每个团队都有基因。扩张新业务需要新基因 建立高效的团队：1，头是唯一的；2，组织结构要清晰；3，令行禁止；4，个人利益服从整体利益；5，互相补台 团队要协同作战：1，共同的愿景和价值观；2，彼此信任；3，注重沟通技巧 需要主次配合，主动去理解领导意图，积极去贯彻领导意图，是团队成员素质基础！领导对错，小兵说了不算，那还不如提高执行力 团队必须有唯一的“头”儿 必须有领导者，否则就是一盘散沙，领军人物的威信只能在战斗中形成 军规12 干部要靠自己培养 下决心自己培养干部 培养干部是革命的首要问题！提拔个排长当团长，也比空降个师长当团长好！外来的和尚未必会念经！ 人才标准需要一把手亲自制定，优秀干部标准：1，理解上意；2，有意见和见解可以表达，但一旦做了决策，就必须马上忘记自己的分歧，坚决彻底的贯彻决议；3，做任何一件事，都要和上级明晰目标、结构规划和里程碑，宁可不做，不要做错；4，及时汇报，多汇报没坏处 建立起人才的培养机制， 企业选材标准：1，悟性，能举一反三分析出事物的本质；2，心胸宽广；3，有大局观；4，学习能力强，勤于思考，逻辑清楚，善于归纳总结提炼 创业不要用职业经理人 职业经理人是创业公司的天敌。职业经理人注定短视，注重流程且道德堪忧，再苦再难也不要请！ 慎用空降兵 空降兵的误区：1，如果真厉害早就自己干了，为啥给你干；2，和你的基因不一定相符，且不一定接受低的职位；3，他的经验不一定有用，反而可能有害；4，外来的和尚未必会念你的经，未必会执着的念你的经 空降兵尤其不适合创业期 军规13 选对股东 股东对企业至关重要 股东是企业的基因，慎重选择，优劣势是啥？ 企业要处理好三个圈子：股东圈、员工圈和朋友圈 企业垮掉一半以上是因为股东问题 股东有问题企业很难持久，股东常常是可以共患难不可以共富贵 如何选择股东？1，志同道合；2，认同合体规则；3，出资，不要给干股；4，优先选择有资源有经验的 创业者选股东的四个误区：1，用股份来激励员工；2，让短期能帮上忙的朋友成功股东；3，让亲朋好友当股东；4，吸收不好的“战略投资者” 军规14 搭好治理结构 企业的治理结构很关键 两个核心问题：1，公司股东的构成及其相互比例关系；2，董事会和管理层之间的权利分配 治理结构有问题公司很难成功 企业必须有主人 股东层面，企业要有大股东 经营层面，管理层必须有“主人翁”意识，可以给股权，也可给激励 理想的股东结构是怎样的？ 军规15 事先要签股东协议 定好规则才能合作长久 认可规则和遵守规则是成为股东的前提。先小人后君子，规则一定要说出来 股东协议要约定哪些事？ 约定股东义务，最好不要把业务对象发展为股东 约定退出机制。 约定决策机制。 约定公司方向 军规16 做最肥的市场 选对创业方向最重要 正确的创业方向让你事半功倍！创业最常犯的错误是“会啥做啥”，最好是自己爱好、自己特长和用户需求三大因素的平衡点来创业 盯住用户的真需求 围绕用户需求创业，目标用户是谁？解决哪些痛点？学会取舍 区分真假需求。无关痛痒的和超出实际的都是假需求；创业者容易吧自己的爱好当做用户需求，把个别需求当普遍需求；有人需要你跟有市场是两回事 盯住最肥的市场 选择创业方向的原则：1，市场应该足够大，利用率应该足够高；2，事情本省应该是有意义的；3，事情应该是有所创新的 小池塘养不出大鱼；看五年，想三年，认认真真做好一两年 军规17 做减法 成功是做了一件事。砍掉鸡肋项目，抓住用户的一个需求把它做到极致 遍地开花不可能成功。任何一个领域，只要深入进去都会发现机会遍地，但这只是表象！如果找不到切入点，形不成用户规模，哪个机会都是理论上的机会，形不成你的市场 做好一件事好过做了很多事 应该时刻提醒自己“做减法”，很多技术性企业都希望把产品的功能做到极致和全面，但想要打开市场，抓好一个点就够了！关键不在于技术上有多么高深，而在于你能不能解决用户的某个迫切需求 资源永远是稀缺的 天下没有免费的午餐！分配好有限的资源，聚焦聚焦再聚焦 专注于一件事更容易成功 创业期企业要做到四个“最小”：1，只确定最关键点的战略，集中力量突破一点；2，只设最低限度指标，指标多重点必然分散，核心指标达成了其他指标自然合格；3，只用最不得不用的人，不胜任要换人而不是加人；4，只管到最低程度，给下属留出发展空间； 军规18 好的商业模式是成功的一半 商业模式是企业的核心 商业模式就是你的赚钱方式，核心四个问题：你的用户是谁？你为他们解决了什么问题？你用什么产品解决他们的问题？如何收费？ 何为好的商业模式 好的商业模式特点：1，产品简单；2，前提要简单；3，一次创意型；4，可低成本扩张；5，要有一定的门槛 商业模式是否成立需要验证 尽早验证你的商业模式 军规19 集中兵力突破重点 创业期公司要关注业务问题 在公司没有找到方向之前，公司的主要矛盾就是找方向 找到方向后先验证商业模式，再找到有效的业务推广方法。创业公司要抓开源而非节流，抓业务突破而非管理的规范化 突破重点才能解决问题 要想成功必须打赢“命运之战”，决定目标是否达成的一定是一两个关键项目，创业者需要学会舍得，必须保持头脑清醒，禁得住诱惑，时刻牢记你的主战场是什么 创业公司唯一的战略就是突破重点 找到突破点，突破突破点。创业头两年的公司不要考虑什么宏伟的战略规划，那东西只有坏处没有益处 军规20 先赚到钱再考虑发展 赢利的公司有的是发展机会。 要性感还是要赚钱？小钱都挣不了，怎么挣大钱！赚钱才是企业的头等大事 能赚钱和赚到钱是两码事。 烧钱的发展模式不可取 烧钱的发展模式是特例 赚不赚钱是衡量公司好坏的第一标准 估值不是衡量公司好坏的核心标准。企业的核心价值是满足用户需求，为用户创造价值。 赚钱的公司最优秀 公司初创时要有愿景，但是具体的伟大战略都是在公司在市场上站稳脚跟，衣食无忧后才规划的 军规21 为公司找一个好的总经理 好的总经理是成功的一半 每个伟大的企业都有一个伟大的总经理 不是每个人都适合当总经理，创始人如果不适合，最好三顾茅庐找到合适的总经理并让贤 创业公司的总经理必须是股东，因为屁股决定脑袋 总经理需要具备什么素质？ 总经理要什么素质？1，有事业心；2，有战略水平；3，有胸怀；4，心理素质好；5，学习能力强 技术专家做总经理非常危险，技术专家易陷误区：1，技术自负，把技术等同于经营；2，藐视管理，崇尚自由，拒绝规范；3，独享心态，不认同产业链，妄图自己全部自力更生；4，拒绝授权，只愿意自己把握航向自己决策，不愿意授权 如何当总经理 总经理的职责：1，对行业的认知；2，打造企业文化；3，设计管理工具；4，建班子、定战略、带队伍； 军规22 企业文化必须一开始就建立：制度早建、规矩早定、丑话早说 企业文化要尽早建立 没有好的企业文化就没有好的企业，企业文化包括企业的核心价值观、方法论以及战术原则 企业文化特征：1，为愿景使命服务的；2，是品牌的重要组成部分；3，因时而变，因势而变，与时俱进 生存重要还是文化重要？越是小公司、越是创业公司，越需要企业文化；你要带领一群人去未知的远方，人家凭什么？ 文化是企业战斗力的倍增器 核心价值观创造企业的凝聚力 方法论提升我们的工作能力。拉卡拉的方法论：先问目的，再做推演，亲自打样，及时复盘 战术原则提高我们的工作水平 企业文化需要大力宣传 提出来，明确价值观，并分解为易于理解和执行的几个角度 天天讲， 身体力行：1,企业和领导正在做什么？2，已经做了什么？3，怎么做的？4，未来要做什么 军规23 管理是一门专业 没有人生来就是管理者 创业最大的难题是创始人不懂管理 管理方法的核心就是三大要素：建班子、定战略、带队伍 不同阶段的企业用不同的方法管理 创业期公司的关键是抓业务，最忌讳的就是小公司大做 小公司的6个管理天条：1，由点及面式定战略，执行战略不撞南墙不回头；2，跟我冲而不是给我上；3，只做最低限度的规范化管理，以奖惩分明作为管理核心；4，精兵简政，聚焦目标做减法，给精兵发一个半人的钱让他做两个人的事；5，老事定指标精细化管理，新事设目标鼓励试错；6，先打样再推广，打样不怕慢，推广必须快 大公司管人 大公司管理的核心是通过管人来管事 分权管理，授权的核心：授对人，授对事，授对法 军规24 建班子是管理的首要问题 一个好汉三个帮 班子领导非常重要，领导班子的核心是一把手 建班子是管理的首要问题 如何建班子 班子成员需要什么素质？1，把公司当命根子做；2，身经百战，有把聪明转化为智慧的能力；3，互补和团结 建班子四部曲：选对人、定核心、塑文化、建机制 一把手建班子注意问题：1，避免一言堂；2，充分调动班子成员的积极性；3，班子的调整机制 军规25 坚持战略和定战略同样重要 定战略意义重大，核心是确定打法和领军人物！ 四不做：1，没有合适领军人物的项目不做；2，没有下决心死磕的项目不做；3，不掌握主动权的项目不做；4，无法复制的项目不做 如何定战略 联想的战略七步法：1，设定愿景；2，设定战略目标；3，制定战略路线，要有清晰的打法；4，确定领军人物，千万不要“凑合”；5，战术分解，沙盘上推演不出的结果，实战中根本不可能达成；6，确定组织结构和预算；7，考核激励，及时复盘调整 执行战略的过程就是坚持战略的过程 经常复盘校正战略 撞了南墙再考虑调整战略 军规26 打造一支铁军 带出一支铁军才能战无不胜 让员工“入模” 打胜仗只能靠我们自己的队伍，不要相信外来的和尚会念经，一定要清楚引入新人是对我们队伍的补充而非代替，引入新人必须要融入队伍。 选好材才能带好兵 “三心”用人标准，员工必须要有责任心，中层干部要有上进心，核心高管必须要有事业心 什么样的人有潜力：事业心、有韧劲和善总结 如何带队伍 建立有效的组织结构 建立管理模式，拉卡拉管理模式：设目标，做计划，抓考评和理规范 宣贯文化 建立培训体系 军规27 物质激励是第一位的 人人都需要激励，都喜欢激励 多激励少惩罚。激励业务，惩治违规 公司必须建立起一套激励体系 比较通用的激励方法：中低级岗位现金激励，中高级岗位现金+期权，高级岗位期权激励 激励的三大误区 误区1，只讲物质激励，特别是只讲钱 误区2，学而优则仕式奖励，记住并不是所有人都有管理控制他人的能力和欲望 误区3，江湖式分配，记住革命不是靠自觉 激励的三大原则 公平是激励的第一原则，要杜绝大锅饭 红包式激励不可取，激励必须是可预见的，可计算的 激励必须和严格的目标考评配套 高效激励的4个原则 1，物质激励与精神激励相结合 2，当期激励与远期激励相结合，奖惩的时效性远比奖惩的力度更重要，远期激励可以增大员工的离职成本 3，现金激励与期权激励相结合 4，单场奖和连胜奖相结合 军规28 不要搞大跃进，大跃进的必然结果就是大倒退！ 成功没有捷径 做企业是跑长跑，要快速启动，迅速行动，但过程之中要一步一步来 创业者要有过程感，不要急于求成 俞永福的企业发展“三关”论 产品关，关注于产品本身，而不是技术深度或者营销策略！ 市场关，要学会自己尝试，独自开创出一条适合自己的道路来 管理关，创业初期犯错成本不高，但随着业务发展，代价必然直线上升。因此企业必须建立相关的规范管理制度 企业发展速度要按经济规律来 革命晚成功半年又如何？任何时候做事的关键都是控制，让一切在你的控制之内比速度力度都重要，革命可以晚成功但不能翻车 出来混总是要还的。企业的发展速度并非越快越好 军规29 先试点再推广 推广前先试点 先试点，一般情况下试点要找一个有代表性的，但又不是主要市场的地方展开，核心是验证想法是否可行，拿出有说服力的数据来！不要认为自己是产品的用户！ 榜样的力量是无穷的 营销的核心是找到推广方法 企业经营重在两件事：营销和创新 营销的核心是找到可复制的推广方法，特点：1，能够产生规模销量；2，简单且可复制；3，投入产出比合适 如何试点 一般而言试点目的：1，验证方法是否可行；2，抓数据，量化方案；3，写菜谱，形成手册，让所有的人可以复制 推广之前必须打样，方法：1，亲自抓；2，可复制；3，要抠细节；4，打样的过程要细；5，要写手册 军规30 坚持是必须的，维持是没有意义的 转型不是失败，为了维持的维持才是最大的失败 几乎所有的成功都历经磨难 几乎所有伟大的公司都经历过转型 维持没有意义 分清坚持还是维持，要学会跳出画面看画，必须让自己脱离公司的日常事务 抬头看路比低头拉车更重要 军规31 成功后不折腾 成功后不要头脑发热 多元化要慎重，首先隔行如隔山，其次多元化会导致资源分散，管理能力不足 加速度要节制，重要的是可持续增长 不要被转件忽悠 纸上谈兵的正规化对企业有害无利，要善于揣摩、借鉴别人的管理经验，但绝不能生搬硬套 靠专家建议定战略基本上没戏!战略是一门实践科学，记住不在其位不谋其政，不担其责 要敢于坚守自己的成功之道。谦虚是好事，但不能怀疑自己，尤其不要邯郸学步。管理要改良而不是革命 军规32 借助资本的力量创业 现在是资本时代 资本的介入已经改变了企业的成长周期 只有用好资本才能成功 不融资就会输在起跑线上 借助资本的力量加快发张速度 和最强的资本结合 学会和资本打交道是创始人的必修课 军规33 融资要敢于吃亏 别相信那些融资神话，企业融不到资是常态 想清楚缺钱干什么再去融资 竭尽全力之后再去融资。自己的钱都不敢花，别人凭什么给你钱？做好你的事，钱会来找你的 尽可能多的验证你的想法 融资要找对人，一般而言只有合伙人在基金中才能发挥作用，只有决策委员会才能最终决策 融资的窍门是吃亏，融资的三个窍门：1，融资价格要低点儿；2，融资规模要小点儿；3，融资时间要早点儿 军规34 风险投资只是你的一段情 风险投资进入企业的唯一目的是获利退出 不要指望投资人能帮你钱以外的事情 克服融资时的“弱势”心理 不要被“战略投资”控制 不要被team sheet忽悠，team sheet几投资条款清单 不要“卖”了公司 军规35 任何时候都不要让投资人替你决策 投资人和公司不在一条船上 投资人和公司的利益即统一有对立 投资人不是陪伴企业终生的人 投资人代表的尴尬地位 融资条款很关键 所谓的行业惯例条款都是可以改的 记住你才是企业的主人 任何时候都不要放弃你对公司的责任 不要对赌 军规36 不要为了上市而上市 上市不是目的 上市时企业的成人礼 上市能够极大的促进企业的规范发展 上市不是判断企业是否成功的标准 下决心上市才能成功 只有横下一条心上市才可能成功 漫长的国内上市路 上市之后，考试才刚刚开始 包装上市不可取 附录：名将是怎样炼成的&emsp;&emsp;名将学校开学了，第一个年级要学习的是军事理论。所有想成为名将的人，必须要学习一些经典的理论知识，包括孙子兵法、吴子兵法等等，只有在积累了大量的理论知识后，你才能跨入下一个年级，但这个年纪有一个很特殊的规定，因为有些同学家里穷，买不起书本，所以他们只能在实战中去学习这些理论。他们之中的优秀代表就是李云龙同学。&emsp;&emsp;穷人家的孩子早当家，实在没有说错的，这些在实战中学习理论的同学将可以跳过第二个程序，直接进入第三个程序。&emsp;&emsp;我们还是和大多数同学一起，来看看第二个年级要学习些什么，第二个年级学习的内容是实战。这是极为重要的，那些理论中学习的优秀者如果不能过这一关，他们就将被授予一个光荣的称号–纸上谈兵，这个称号的第一个获得者是赵括同学，授予者是二年级的年级主任赵奢。&emsp;&emsp;我们来解释一下为什么实战如此重要，这是因为虽然军事理论都是高年级的学长们经验总结，但由于他们写这些东西的时候，情况和现状是不完全一样的，在实战中，如果照搬是要吃大亏的。赵括同学就是没有学好，才不能毕业的。&emsp;&emsp;作为一个学员，想成为名将，一般都是从小兵干起，当然除了**外，比如赵括同学，由于年级主任赵奢是他父亲，所以他一开始就是大将，这是不妥当的。&emsp;&emsp;因为只有战场才能让一个人成为真正的名将，他必须亲手持刀去追击敌人，见识战场的惨烈，明白人被刀砍是要死的，了解你不杀我，我就杀你这条战场上永不过时的真理，知道所谓打仗就是以性命相搏，他们才会明白什么是战场，什么是实战。&emsp;&emsp;大多数学员会在这一关被淘汰，他们会改行，一生当一个军事票友，这对他们来说并不见得是一件坏事。&emsp;&emsp;而留存下来的那些学员，在残酷的实战中逐渐了解了战争的规律，开始真正走上名将之路。&emsp;&emsp;好了，我们带领剩下的学员来到三年级，三年级要学习的是冷酷。&emsp;&emsp;成为一个名将，就必须和仁慈、温和之类的名词说再见，他必须心如铁石，冷酷无情，当然历史上也有很多以仁出名的儒将，但请大家注意，他们的仁是对士兵和老百姓而言的，对敌人他们比谁都冷酷。&emsp;&emsp;所谓仁不带兵，义不行贾，冷酷不是残忍，不是杀戮无辜的老百姓，而是坚忍，比如你的一个很好的朋友触犯了军纪，但你为了执行军纪，一定要杀了他，只有这样，你才能控制军队，即使他是你最要好的朋友，甚至是你的亲人，你也要这样做。&emsp;&emsp;这才是真正的冷酷！&emsp;&emsp;学员们将在战场上学会冷酷，他们可能都是善良的年轻人，平时从不与人争吵，但当他们走上战场，亲眼看到自己的同乡和战友被敌人杀死，或者身负重伤在地上痛苦的呻吟，他们会被愤怒和痛苦所鼓动，毫不留情的杀死一切与自己敌对的人，给地上的伤兵补上一刀，然后一个人在尸体旁边喃喃自语，就在这地狱一般的环境中，他们变了。&emsp;&emsp;从杀鸡都怕见血到敌人的脑浆和鲜血溅到身上浑然不知，从温文尔雅到冷酷无情，他们在残酷的环境中毕业了，不合格者将被淘汰，而那些心如坚石的人将进入四年级的学习，他们离成为名将越来越近。&emsp;&emsp;四年级要学习的是理智，这也是极为重要的一个环节，我们作为普通人，生活中会被许多事情左右自己的情绪，比如买彩票中个二等奖几百块，你也会高兴半天，要是炒股票赚了大钱，就更不用说了。那么如果你玩的游戏是以人命为赌注呢？你会有何反应。&emsp;&emsp;当你在极度紧张的环境中与敌人僵持了很长时间，突然敌人退却了，你能遏制住心中的激动，先判断形势再去追击吗？当你抵挡不住敌人的进攻，全军即将崩溃时，你能及时冷静下来，发现敌人的弱点吗？&emsp;&emsp;是的，这太难了，我们都是凡人，都有感情，容易激动，而我们的学员们就必须保持冷静和理智，在任何时候都不被感情左右，就如同赛车一样，赛车是一项激情四射的运动，然而车手却必须保持绝对的冷静。&emsp;&emsp;这就是四年级学员要做到的，能过这一关的人，已经很少了，剩下的精英们，我们继续前进！&emsp;&emsp;五年级是最重要的一个年级，在这个年级里，学员们要学习的是判断。&emsp;&emsp;这是名将的重要特征，不需要理由，不需要依据，你能依靠的就是你自己的判断。你要明白的是，你所掌握的是无数士兵的生命，而所有的人都等着你拿注意。&emsp;&emsp;小兵只管打仗，遇到问题，他会问伍长，伍长会问百户，百户会问千户，千户问指挥，你就是指挥，你还能去问谁？！&emsp;&emsp;在士兵的眼中，你就是上帝，就是主宰世界的神！他们能否活下来就看你的了！&emsp;&emsp;兵法之所以奇妙，关键在于一个变字，所谓善出奇者，无穷如天地，不竭如江海！战场是一个瞬息万变的世界，决断只在一线之间，进攻还是防守，前进还是退却，都要你拿注意，在你身边也许有一大群参谋，但他们往往并不站在真理一边，决断的还是你。如果参谋比你高明，为什么要你当主帅？！&emsp;&emsp;如果你能从那变化莫测的世界中，发现其中的奥妙，并就此做出正确的决断，那么恭喜你，你已经具备了名将最主要的素质。但是还有一关是你必须通过的，只有过了这一关，你才是真正的名将。&emsp;&emsp;现在我们来到最后一个年级，这个年级我们要学习的是坚强。&emsp;&emsp;从某种意义上说，这是非常重要的一个学习内容，所谓胜败兵家常事，不过安慰自己而已，打了败仗，死几万人，你能承受这样的心理压力吗，你怎么去面对那些士兵的家人，怎么有脸去见将指挥权交给你的上级？那是几万人命，不是几万只鸡！&emsp;&emsp;然而你的选择只能是坚强，即使你屡战屡败，但必须屡败屡战！我们可以想象，当你数次败在同一个人手下时，你会畏惧这个人，所谓的恐某症就是这么来的，即使你有着杰出的军事才能，不能战胜自己的软弱，还是不能成为名将的。&emsp;&emsp;而那些最优秀的人能够从失败中爬起来，去挑战那个多次战胜自己的人，这才是坚强！&emsp;&emsp;当你具备了以上所有条件后，你就成为了真正的名将，但还有一点，是你必须具备的，那就是运气。&emsp;&emsp;说起来似乎有点滑稽，这也是很重要的一个因素，没准就在你万事俱备，准备大展身手时，一支冷箭射来，就此死掉，那才是比窦娥还冤，你的一切抱负和能力都无法展现了。战史上只会这样记载，某年某月某日，某某人在战场上被不知名小兵射死，其人具体情况不详。&emsp;&emsp;所以名将之路是一条艰苦的道路，非大智大勇，大吉大利之人不能为。&emsp;&emsp;故兵无常势，水无常形。能因敌变化而取胜者，谓之神。&emsp;&emsp;在这变化无穷的战场上，要想成为真正的军神，你必须在一次次的残杀中幸存下来，看着周围的人死去，忍受无尽的痛苦，在战争中学习战争，努力获取那不为人知的奥秘和规律，经历无数次失败，有勇气从无数士兵的尸体上站立起来，去打败对手。&emsp;&emsp;这才是真正的名将之路，一条痛苦、孤独、血腥的道路，在这条路上，能信任和依靠的人只有你自己。但只要你走到终点，光荣和胜利就会在那里等待着你。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例的利与弊]]></title>
    <url>%2F2016%2F01%2F18%2F%E5%8D%95%E4%BE%8B%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A%2F</url>
    <content type="text"><![CDATA[单例模式 概念：一个单例类，在整个程序中只有一个实例，并且提供一个类方法供全局调用，在编译时初始化这个类，然后一直保存在内存中，到程序（APP）退出时由系统自动释放这部分内存。 存储位置：全局区 系统的单例：UIApplication、NSNotificationCenter、NSFileManager、NSUserDefaults 创建 通用版单例 12345678910+ (ZKSingleManager *)sharedInstance &#123;static dispatch_once_t onceToken;static ZKSingleManager *instance = nil;dispatch_once(&amp;onceToken, ^&#123;if (instance == nil) &#123;instance = [[ZKSingleManager alloc] init];&#125;&#125;);return instance;&#125; 严格版单例 1234567891011121314151617181920212223242526272829303132@interface ZKSingleManager : NSObject+ (ZKSingleManager *)sharedInstance;// NS_UNAVAILABLE 表示禁止此方法调用- (instancetype)init NS_UNAVAILABLE;// 效果同上，但可以带上文字说明+ (instancetype)new __attribute__((unavailable(&quot;单例只能通过sharedInstance初始化&quot;)));- (id)copy __attribute__((unavailable(&quot;单例禁止深拷贝&quot;)));@end#import &quot;ZKSingleManager.h&quot;@implementation ZKSingleManager+ (ZKSingleManager *)sharedInstance &#123;static dispatch_once_t onceToken;static ZKSingleManager *instance = nil;dispatch_once(&amp;onceToken, ^&#123;if (instance == nil) &#123;instance = [[ZKSingleManager alloc] initPrivate];&#125;&#125;);return instance;&#125;- (id)initPrivate &#123;self = [super init];return self;&#125;@end 单例模式的优缺点 优点：1、在整个程序中只会实例化一次，所以在程序如果出了问题，可以快速的定位问题所在；2、由于在整个程序中只存在一个对象，节省了系统内存资源，提高了程序的运行效率； 缺点:1、不能被继承，不能有子类；2、不易被重写或扩展（可以使用分类）；3、同时，由于单例对象只要程序在运行中就会一直占用系统内存，该对象在闲置时并不能销毁，在闲置时也消耗了系统内存资源； 当你使用单例的时候 你需要问自己以下四个问题 这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？; 这个单例持有的内存一直存在； 是否能用类方法代替？； 这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为另一个单例的属性 参考 避免滥用单例]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视图更新的几个方法]]></title>
    <url>%2F2016%2F01%2F01%2F%E8%A7%86%E5%9B%BE%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1 layoutSubviews1.1 官方介绍The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews. Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly. You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method. 1.2 分析 只能重写layoutSubviews，不能主动调用！只能系统调用 想要调layoutSubviews方法，需要调setNeedsLayout或layoutIfNeeded 此方法作用是更加精细的控制子视图frame 1.3系统调用layoutSubviews时机简单的说更新布局总会重新触发layoutSubviews方法，但注意：init初始化不会触发layoutSubviews 调用 addSubview 方法时会执行该方法。 设置并改变子视图的frame属性时会触发该方法。 滑动UIScrollView及继承与UIScrollView的控件时会触发该方法。 旋转屏幕时，会触发父视图的layoutSubviews方法。 设置并改变视图的frame属性时会触发父视图的layoutSubviews方法。 2 layoutIfNeeded2.1 官方介绍Use this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks. 2.2 分析 如果需要刷新的haul，立即强制刷新接受者和它的子视图！ 也就是说layoutIfNeeded之后有可能不刷新不调用layoutSubviews，例如view的frame等状态没有变化 2.3 参考 How is layoutIfNeeded used? 3 setNeedsLayout3.1 官方介绍Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance. 3.2 分析 当需要重新布局时，在主线程调用setNeedsLayout，将设置一个标志位并立即返回 调用setNeedsLayout并不会立即更新视图，而是下次runloop更新视图 可以将多个视图更新合并在一起，提高性能 layoutSubviews一定会被调用 4 setNeedsDisplay4.1 官方介绍You can use this method or the setNeedsDisplayInRect: to notify the system that your view’s contents need to be redrawn. This method makes a note of the request and returns immediately. The view is not actually redrawn until the next drawing cycle, at which point all invalidated views are updated. Note:If your view is backed by a CAEAGLLayer object, this method has no effect. It is intended for use only with views that use native drawing technologies (such as UIKit and Core Graphics) to render their content. If your view is backed by a CAEAGLLayer object, this method has no effect. It is intended for use only with views that use native drawing technologies (such as UIKit and Core Graphics) to render their content.You should use this method to request that a view be redrawn only when the content or appearance of the view change. If you simply change the geometry of the view, the view is typically not redrawn. Instead, its existing content is adjusted based on the value in the view’s contentMode property. Redisplaying the existing content improves performance by avoiding the need to redraw content that has not changed. 4.2 分析 当需要重绘调用setNeedsDisplay，将设置一个标志位并立即返回 调用setNeedsDisplay并不会立即更新视图，而是下次runloop更新视图 setNeedsDisplay一定会调用drawRect:方法 如果视图由caeagllayer对象支持，则此方法无效 如果只更改视图的几何图形，需要通过ContentMode的值进行调整的 4.3 参考 setNeedsLayout and setNeedsDisplay 5 other question 更改约束怎么实现动画？参考：How do I animate constraint changes? 12345[UIView animateWithDuration:5animations:^&#123;self._addBannerDistanceFromBottomConstraint.constant = -32;[self.view layoutIfNeeded]; // Called on parent view&#125;]; setNeedsLayout vs. setNeedsUpdateConstraints and layoutIfNeeded vs updateConstraintsIfNeeded 123setNeedsUpdateConstraints makes sure a future call to updateConstraintsIfNeeded calls updateConstraints.setNeedsLayout makes sure a future call to layoutIfNeeded calls layoutSubviews.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再读编写高质量iOS的52个方法]]></title>
    <url>%2F2015%2F12%2F29%2F%E5%86%8D%E8%AF%BB%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8FiOS%E7%9A%8452%E4%B8%AA%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[OC 的起源 在头文件中尽量少引入其他头文件 使用@class 将引入头文件的时机尽量延后，同时用于两个文件相互引用的问题。 用#import 不用#include 必要的时候用一个 .h 文件来整理用到的引用 可以用语法糖 要注意nil的情况，语法糖创建的都是不可变对象 多用类型常量，少用#define预处理指令 少用#define 用类似 static const CGFloat time = 0.3 ，如需要则在 .h 中使用extern CGFloat const time 声明为外部可用的 常量在 .m 文件内用k开头，不过现在好像所有的都是k开头 变量一定要同时用static和const来声明，const表示不能修改，static则表示该变量仅在定义此变量的编- - 译单元中可见，不加static在编译器会自动加external 外部符号，若此时在另外声明同名变量，则报错 用枚举表示状态选项状态码-fobjc-arc 尽量不用enum 用NS_ENUM ， 凡是以按位或操作的组合枚举都应使用NS_OPTIONS定义，枚举量对应的值可以用 1&lt;&lt;0 方便各选项通过“按位或”操作来组合。不需要互相组合则用NS_ENUM 使用switch来区分枚举的时候，最好不要加上default语句，这样当新加一种枚举类型时，编译器会报错 理解属性这一概念 @dynamic 阻止编译器自动合成getter和setter方法，但如果自己也不实现，编译器是不会报错的 nonatomic readwrite readonly assign strong weak copy unsafe_unretained getter setter iOS中使用同步锁开销很大，开发Mac OS X程序时使用同步锁却没事 在对象内部尽量直接访问实例变量 直接用下划线访问属性，不会触发KVO，不经过getter和setter方法 在getter和setter方法中不要出现self 在初始化及dealloc方法中，总是应该直接通过实例变量来读写数据,在init和dealloc方法中避免时候用self.property 理解对象等同性这一概念 == 判断内存是否相等， isEqual 判断对象是都相等 相同对象必须有相同的哈希码，但两个哈希码相同的对象却未必相同 以类簇隐藏实现细节 实现子类时，一定要注意父类指明覆盖的方法 在既有类中使用关联对象存放自定义数据 objc_setAssociateObject objc_getAssociatedObject objc_removeAssociatedObjects 慎用，很难发现也很难排查 理解objc_msgSend的作用 理解消息转发机制 resolveInstanceMethod: resolveClassMethod: forwardingTargetForSelector forwardInvocation 用方法调配技术（method swizzling）调试黑盒方法 理解类对象的用意 id本身就是指针，所以不用 * isMemberOfClass isKindOfClass 用前缀避免命名空间冲突 apple宣称其保留使用所有“两字母前缀”的权利，所以自己选用的前缀应该是三个字母及以上的 项目中所有的方法、函数都最好加前缀 提供全能初始化方法 必须要实现的，放到init里让对象实例化的时候就实现。（全能初始化） 子类要包含父类全能初始化方法干的事。 可以抛出异常来提醒，但不建议，OC中只有发生严重错误时，才应该抛出异常。、 实现description 方法 重写description 方法能自定义打印内容，其实可以Hook一下让所有的类以及其属性值都打印出来，不过暂时没必要。 debugDescription 是开发者在调试器中以控制台命令打印对象时才调用。 尽量使用不可变对象 尽量少的暴露属性，即便暴露属性也要尽量设置为只读的。 暴露的readonly属性最好设置内存管理，并在内部重新声明为readwrite，避免正在写的时候外面有人在读，必要的时候可以用dispatch_sync 将存取操作设置为同步操作。 不要暴露可变的collection属性，应该提供相关方法修改内部可变的collection，而在公开属性中getter方法中对内部可变的copy操作。 使用清晰而协调的命名方式 如果方法的返回值是新创建的，那么方法名的首个词应是返回值类型。 应该把表示参数类型的名词放在参数前面。 如果方法要在当前对象上执行凑走，那么久应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。 不要使用str这种简称，应该用string这样的全称。 BOOL属性应加is前缀。如果某方法返回非属性的BOOL值，那么应该根据其功能，选用has或is当前缀。 将get这个前缀留给那些借由“输出参数”来保存返回值的方法。 为私有方法名加前缀 不要用下划线作为前缀定义私有方法，因为这是预留给苹果公司用的。 可以将使用的类名前缀用作私有方法前缀来避免冲突。 理解Objective-C错误类型 如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放，即便不用ARC，也很难写出在抛出异常时不会导致内存泄漏的代码 OC采用的做法：只在极其罕见（致命）的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。 如果父类强制子类实现某方法，可以在父类对应方法里抛出异常。 出现不非致命错误是OC一般让方法返回nil，或者使用NSError。 NSError一般通过(NSError)error 这种输出参数来返回。实际上编译器会将NSError转换成NSError _ _ autoreleasing ,也就是说指针所指的对象会这方法执行完毕后自动释放。 理解NSCopying协议 自己的类支持拷贝操作，就需要实现NSCopying协议。copyWithZone方法中zone参数是因为以前是按zone（区）来划分的，但现在都是使用default zone，因此可以不用管zone参数。 非属性的内部使用实例，可以通过 -&gt; 语法 mutableCopy copy 区别 通过委托与数据源协议进行对象间通信 delegate 属性要定义成weak，而不是strong的。 @optional 将类的实现代码分散到便于管理的数个分类之中 将应该视为“私有”的方法归入名为private的分类中以隐藏实现细节。 总是为第三方类的分类名称加前缀 如果相同属性或方法，分类会覆盖原来的，而且很可能覆盖很多次。。。解决的办法就是加前缀。 勿在分类中声明属性 把封装数据所用到的全部属性都定义在主接口里 使用“class-continuation分类”隐藏实现细节 必须定义在其接续的那个类的实现文件里，没有名字；并且是唯一能声明实例变量的分类 @interface Person() { // something } 非公开的属性最好写在class-continuation 通过协议提供匿名对象 @property (nonatomic , weak) id delegate; id 就是匿名对象 协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法 使用匿名对象类隐藏类型名称（或类名） 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以用匿名对象来表示。 理解引用计数 retainCount方法不太准，不建议使用。 保留环，一则般需要设置weak处理，block的循环引用则用_ _weak _ _strong _ _block来处理 以 ARC简化引用计数 在dealloc方法中只释放引用并解除监听 不应该自己调用dealloc，虽然非ARC用调 [super dealloc]，但ARC不用。应该做的就是释放引用，取消订阅或KVO 错误，异常，对于一些特殊操作很重要，提醒释放内存。 系统并不保证每个创建出来的对象的dealloc都会执行。 编写dealloc方法时，不要在里面随便调用其他方法。 dealloc里也不要调用属性的存取方法 编写“异常安全代码”时留意内存管理问题 @try {} @catch {} @finally {} 捕获异常时，一定要注意将try块内所创立的对象清理干净。 默认情况下,ARC不生成安全处理异常所需的清理代码，开启编译器标志 –fobjc-arc-exceptions 后，可以生成清理代码，但开启后将导致程序变大，而且会降低运行效率。 以若引用避免保留环 避免保留环的最佳方式就是弱引用。 weak 、assign 和 unsafe_unretained 以自动释放池块降低内存峰值 通常只有一个地方需要创建自动释放池 @autoreleasepoll { // dosomething }，那就是在main函数里面 自动释放池可以嵌套，可以控制应用程序峰值 自动释放池的释放要等线程下一次runloop时才会清空 用僵尸对象调试内存管理 不用使用retainCount ARC已经废弃此方法，即便非ARC此方法获取的值也不准。 理解“块”这一概念 int (^addBlock)(int a , int b) = ^(int a, int b){ return a+ b; }; Block捕获的变量在块内是不可变的，需要改的用_ _block修饰 _ _weak _ _strong 定义Block的内存是分配在栈区，离开相应的范围之后，编译器有可能把分配给块的内存覆盖掉，因此需要用copy，拷贝到堆区当做一个一对象处理，拥有引用计数 全局块不会捕捉任何状态，运行时也无须状态来参与，声明在全局内存区，因此拷贝是个空操作，故全局块绝不可能为紫铜所收回，这种块实际上相当于单例。 为常用的块类型创建typedef 块的类型有参数和返回值组成。 用handler块降低代码分散程度 系统发现某个应用程序的主线程已经阻塞了一段时间后，就会令其停止。 建议使用同一个块来处理成功与失败的情况。 应该由调用API的人来决定handler应该运行在哪个线程上。 用块引用其所属对象时不要出现保留环 一定要找个适当的时间解除保留环，而不能把责任推给API的调用者。 多用派发队列，少用同步锁 @synchronized(self) 同步锁，会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。 NSLock 安全高效代替同步块和锁对象的是 串行同步队列 执行异步派发时，需要拷贝块 dispatch_barrier_async dispatch_barrier_sync 多用GCD，少用performSelector系列方法 用performSelector 调用一个方法，编译器并不知道将要调用的方法，也就不了解其方法签名以及返回值情况，所以没办法运用ARC的内存管理规则来判定返回值是不是应该释放，鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作，然而这么做可能导致内存泄漏。 一般返回只能是void或对象类型，而performSelector返回的是id类型，那么就需要执行一些转换操作，很容易出错！若返回类型为C的结构体，则不可使用performSelector方法。 没机会为被调用的方法指定参数，被调用的selec的输入可能指向位置的垃圾内存 如果跨线程执行，最好不用performSelector，而用GCD 掌握GCD及操作队列的使用时机 GCD是纯C的API，而操作队列则是Ojbective-C的对象。 NSOperation 运行之前，可以取消某个操作（但已经启动的无法取消）；可指定操作间依赖关系；通过KVO观察属性；指定操作的优先级（GCD可以控制队列的优先级，不是块的） 通过Dispatch Group机制，根据系统资源状况来执行任务 dispatch_group_t dispatch_group_async dispatch_group_enter dispatch_group_leave dispatch_group_wait dispatch_group_notify 使用dispatch_once来执行只需运行一次的线程安全代码 标记应该声明static或global作用域中，而且每次标记应该相同 不要使用dispatch_get_current_queue iOS6 之后已经弃用dispatch_get_current_queue，极其容易造成死锁 典型错误用法：用dispatch_get_current_queue检测当前队列是不是某个特定队列，试图避免执行同步派发时可能遭遇的死锁问题。 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。 熟悉系统框架 多用块枚举，少用for循环、 块枚举法，本身就能通过NSEnumerationOptions 配置GCD来并发执行遍历操作。 若提前知道待遍历对象类型，则应修改块签名，指出对象的具体类型。 对自定义其内存管理语义的collection使用无缝桥接 _ bridge 本身的意思是：ARC仍然具备这个OC对象的所有权，而 _bridge_retained意味着ARC将交出对象的所有权 构建缓存时选用NSCache而非NSDictionary 当系统资源将要耗尽时，NSCache可以自动删减缓存。 NSCache并不会“拷贝”键，而是会“保留”它。 NSCache是线程安全的，不加锁多个线程也可以同时访问。 精简initialize与load的实现代码 当包含类或分类的程序载入系统时会调用load方法，而且只会调一次。如果类和分类都实现了load方法，则先调类的，再调分类的。 load方法中使用其他类是不安全的，因为比先执行超类的load方法，而根据某个给定的程序库却无法判断出其中各个类的载入顺序。 load方法并不像普通方法那样，如果某个类本身没实现load方法，那么不管其各级超类是否实现此方法，系统都不会调用 load方法必须实现的精简，因为整个应用程序在执行load方法时都会阻塞。 (void) initialize 与 – (void) init 不一样 (void) initialize 对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。 (void) initialize方法时惰性调用的，用不到的类不会运行，但load方法是程序会一直阻塞到所有类的load都执行完。 (void) initialize 与其他方法一样，如果某个类未实现它，而超类实现了，则运行超类的实现代码。 (void) initialize 方法要尽量精简，只应该用来设置内部数据，不应该调用其他方法，即便是本类自己的方法最好也别调用；若某个全局状态无法再编译期间初始化，则可放到initialize里来做。 别忘了NSTimer会保留其目标对象 设置成重复执行模式计时器，很容易引入保留环 self.timer 设置self为target 就产生了保留环。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毛玻璃效果代码]]></title>
    <url>%2F2015%2F12%2F19%2F%E6%AF%9B%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[方法1，使用CIFilter滤镜 12345678910111213141516//生成一张毛玻璃图片 - (UIImage*)blur:(UIImage*)theImage &#123; CIContext *context = [CIContext contextWithOptions:nil]; CIImage *inputImage = [CIImage imageWithCGImage:theImage.CGImage]; CIFilter *filter = [CIFilter filterWithName:@&quot;CIGaussianBlur&quot;]; [filter setValue:inputImage forKey:kCIInputImageKey]; [filter setValue:[NSNumber numberWithFloat:15.0f] forKey:@&quot;inputRadius&quot;]; CIImage *result = [filter valueForKey:kCIOutputImageKey]; CGImageRef cgImage = [context createCGImage:result fromRect:[inputImage extent]]; UIImage *returnImage = [UIImage imageWithCGImage:cgImage]; CGImageRelease(cgImage); return returnImage; &#125; 方法2，使用iOS8系统效果 123456789101112UIImageView *imageView =[[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 200, 100)];imageView.image = [UIImage imageNamed:@&quot;logo&quot;];[self.view addSubview:imageView];/*UIBlurEffectStyleExtraLight, //高亮UIBlurEffectStyleLight, //亮UIBlurEffectStyleDark //暗*/UIBlurEffect *blurEffect =[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark];UIVisualEffectView *effectView =[[UIVisualEffectView alloc]initWithEffect:blurEffect];effectView.frame = CGRectMake(0,0, imageView.frame.size.width, imageView.frame.size.height);[self.view addSubview:effectView];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习技巧]]></title>
    <url>%2F2015%2F11%2F30%2F%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我，半个码农！还没入行Java，马上又换行到iOS，重新自学新语言：Object-C！因是公司内部转岗，基本上所有的东西都要自学，东一榔头，西一棒子的学，也不可能专门拿出两三个月专门去培训（还是因为穷，不工作连房租饭费都没有！更不要说1万多的天文培训费，真心没钱！贷款培训？我傻吗！有工作不干，借钱吃饭贷款培训！！！），历经种种阵痛，现在也算是可以写tableview的iOS，现总结一下以往的学习经验 &emsp;&emsp;公司和学校真的不一样！我承认我是学渣，渣的不能再渣！大学（也很渣…）4年，上午的课几乎就没去过(嗯，我要说都怪晚上11点半才断电，手机电脑还能撑好几个小时你们可以理解吧)！下午的课，看心情……整天不是在看小说就是在玩游戏（三国志系列和P社四萌是我的最爱，但真心不推荐玩，比网游更费时间）！啰里啰嗦的说了这么多，其实我想说的：学校里的东西真的很简单，没人强迫你拿出产出，考试过了就可以了。我虽然是渣中之渣，但混个60分还是很简单的：考前两三天看看书背一背就可以了（额…高数，用了两周）！当然也挂过科，唯一一次挂科贡献给了一门选修课！但等到工作的时候，再背书就不管用了，再集中突击，该不会的还不会！而现实是我必须要尽快上手(公司内部转岗，给我一两周学习已经是天大的恩赐了)！压力不一样，心态和效率也就不一样！ &emsp;&emsp;学习新语言必先学语法！很多人告诉我，语法看看就行了，先去做项目，多做几遍什么语法都会了！等等，这些语法都是什么鬼？这么多层嵌套都是咋回事？嗯，一开始我就是这么被坑的，我真的花了一两天时间熟悉一下语法就去看项目了！一看它认识我，我不认识它！啃了一天也没弄明白数据是怎么流动的，又强忍着性子，从新学习语法！再重申一遍：学习新语言必先学语法！不要求百分之百都记下来，但特殊语法一定要记下来！例如，基本类型、枚举、结构体等一带而过就可以，这些东西99%都一样，没必要花费时间去仔细研究，大不了采坑！但像block，MRC、引用计数啥的要敲些代码仔细研究一下使用方法才好！ &emsp;&emsp;尽快学习IDE的使用技巧！xcode是我见过的，最简单、最可靠、功能最齐全的IDE,说实话一开始配置SSH（Spring、Struts、Hibernate）时，我着实的折腾了一两天，还是在同学的帮助下弄完的！但XCode只能用一个字来形容：爽！学习一门新语言要尽快适应IDE，学习IDE使用技巧和调试技巧！这是稳赚不赔的买卖，提升的何止是效率！我印象最深的教训：第一次使用xib时，我足足花了一下午的时间去学习xib的属性是怎么和h文件的属性连接在一起的！因我们项目整体是手动计算frame的，几乎没用到xib，而我是快速自学的，代码都是参照现有项目来的，没见过xib！网上的文章将xib的都是什么属性怎么用，我最关心的怎么连接这点事根本就没人写,最后还是找了个视频才知道….还真就是太简单了才没人写 &emsp;&emsp;关于教学视频，我是不喜欢的！现在网上资源十分丰富，很多人都是通过教学视频来入门各种语言的，但我个人不以为然！原因如下：1，大多数的教学视频质量真的不咋地！2，质量稍微好点的都要去培训班，而我没时间去！3，大多数视频时间太长，能用5分钟解决的，非要用一小时去哔哔！当然，每个人都有自己的看法，我只不过没有养成认真听讲的习惯…… &emsp;&emsp;关于看书,最好一目十行，找到不懂得或感兴趣的再仔细研究！现在的书籍同质化太严重了，翻来覆去就那点东西，网上大堆大堆的iOS入门书籍，大多是废话连篇，没啥干货，连我这种还没入门的小菜鸟都忽悠不了！但有些经典书还是非常好的，编写高质量iOS和OSX的52个方法和OC高级编程iOS与OSX多线程和内存管理就非常不错 &emsp;&emsp;请教问题是个大学问！我总结了一下我认为比较合理的方法：1、百度不到再去问人！不要浪费别人的时间，何况别人的时间更值钱！2、在别人有时间的时候见缝插针的提问，能问到更好，问不到也别纠缠！重要是别让人烦！3、态度要诚恳，语气要温和！你有问题没解决你很着急，但这管他什么事？把他惹毛了就不告诉你，你岂不是更尴尬更难受！4、实在处理不了，要学会放弃！毕竟是菜鸟，与其问也问不到写也不会写还死扛着，还不如认怂交给老大做，老大做完你再慢慢学吗 &emsp;&emsp;最最重要的是会百度，肯踩坑！]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSUserDefault]]></title>
    <url>%2F2015%2F11%2F08%2FNSUserDefault%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天打算水一水最基础的NSUserDefault，因为太常用了都没啥可写的！但后来发现可以APP间共享数据！嗯，正好最近也不知道水什么，就水它了！ 概念 轻量级数据持久化工具类 存储方式key-value，key要实现NSCoding协议，注意使用对应方法value才可以是值类型 文件格式：plist，保存位置：/Library/preferences/ Bound ID.plist NSUserDefault中5个域的检索顺序：NSArgumentDomain-&gt;Application-&gt;NSGlobalDomain-&gt;Languages-&gt;NSRegistrationDomain 优缺点优点 简单，一个单例走天下，跟NSDictionary用法差不多 提供了大量的快捷方法，例arrayForKey: setBool: forKey: 线程安全,不管存的啥，取出来的都是不可变类型 缺点 非实时写入硬盘，而是先写入内存，系统再定时写入硬盘。想要实时写入硬盘调用synchronize方法 1// 非实时写入，最可能问题是程序突然中断，虽然调用了setObject forkey，但再次启动时读取的仍是上个数据 不适合写入大量数据 频繁的读写会导致性能问题 单例写法很独特 [NSUserDefaults standardUserDefaults] 使用基础技巧 存取值 1234567// 设值set方法和取值forKey方法都一样，唯一区别就是参数类型// 注意所有object都必须实现NSCoding协议NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults];NSMutableArray *muArr = [[NSMutableArray alloc] initWithObjects:@1,@2, nil];[userDefault setObject:muArr forKey:@&quot;key&quot;];[userDefault synchronize];NSArray *arr = [userDefault objectForKey:@&quot;key&quot;];// 取出来是不可变类型 删除值 123NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults];[userDefault setObject:nil forKey:@&quot;key&quot;];// 不建议[userDefault removeObjectForKey:@&quot;key&quot;];// 建议 注册默认值 1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;NSDictionary *defaultSet = @&#123;@&quot;name&quot;:@&quot;JZK&quot;, @&quot;sex&quot;:@&quot;man&quot;&#125;;// 注册默认值，主要用于通用配制的初次载入！取值的时候节省了if判断和测试[[NSUserDefaults standardUserDefaults] registerDefaults:defaultSet];// Override point for customization after application launch.return YES;&#125; 高级玩法 APP间数据共享 12345678910111213// 开启App Groups，共享的App都需要加入同一个Group，@&quot;com.yourcompany.appsShare&quot;// appA中NSUserDefaults *shareDefaultA = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];[shareDefaultA setObject:@&quot;appA&quot; forKey:@&quot;shareKey&quot;];// appB中NSUserDefaults *shareDefaultB = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];NSString *value = [shareDefaultB objectForKey:@&quot;shareKey&quot;];// 域名管理，几乎用不到// 将指定的域名插入到接收方的搜索列表中// - (void)addSuiteNamed:(NSString*)suiteName;// 从接收器的搜索列表中移除指定的域名// - (void)removeSuiteNamed:(NSString*)suiteName; 查看所有数据 1234// 当前域名下所有的key valueNSUserDefaults *userDefault = [[NSUserDefaults standardUserDefaults];// NSUserDefaults *userDefault = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];NSDictionary* dic = [userDefault dictionaryRepresentation];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络图片怎么适配]]></title>
    <url>%2F2015%2F10%2F19%2F%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这两天UI给提了个bug，说网络下载的图片变小了？查了半天才才发现UI后端上传的图片是2x的，而客户端是按3x来处理的！这就比较坑了……所以就产生了这篇水文！ &emsp;&emsp; 我们采用的是如下（1.1）方案，但约定毕竟不靠谱呀！出现问题又是客户端背锅！ 1.1 跟后端约定只能穿3x图片，客户端下载图片之后直接绘制即可123456int scale = 3;UIImage *image = [UIImage imageWithCGImage:img.CGImage withScale:scale];CGFloat imageHeight = image.size.height / scale;CGFloat imageWidth = image.size.width / scale;imageView.frame = CGRectMake(0, 0, imageHeight, imageWidth);imageView.image = image; &emsp;&emsp; 约定不靠谱，那就让服务端都传过来吧！ 1.2 增强型约定格式1234567891011/*image:&#123;imgUrl:ttps://xxx.png,scale:3,width:100,height:100&#125;*/UIImage *image = [UIImage imageWithCGImage:img.CGImage withScale:scale];imageView.frame = CGRectMake(0, 0, width, height);imageView.image = image; &emsp;&emsp;1.2的方案确实更好一点，但服务端的童鞋说这么多接口都这么改，怕要累死了…… &emsp;&emsp;那么怎么办？来看看SD怎么玩的吧 1.3 SD怎么玩的？原来是通过url是否包含2x和3x来处理的123456789101112131415161718192021if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;CGFloat scale = 1;if (key.length &gt;= 8) &#123;NSRange range = [key rangeOfString:@&quot;@2x.&quot;];if (range.location != NSNotFound) &#123;scale = 2.0;&#125;range = [key rangeOfString:@&quot;@3x.&quot;];if (range.location != NSNotFound) &#123;scale = 3.0;&#125;&#125;if (scale != image.scale) &#123;UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];scaledImage.sd_imageFormat = image.sd_imageFormat;image = scaledImage;&#125;&#125;return image; &emsp;&emsp;等等if (scale != image.scale)，那是不是直接用image.scale也可以呢？ 1.4 不行1具体代码不写了，可以让后端给你传2x和3x图片分别测试，也可以自己设代理映射本地图片，结果都是一样的！无论2x还是3x，下载后的image，image.scale都是1！但通过imageNamed方式加载本地图片，image.scale却是正确的！！ &emsp;&emsp;综上所述，想要完美适配图片，只能通过约定的方式：要么约定只能穿3x图片，要么约定上传图片时带着2x或3x信息 &emsp;&emsp;至于jpg格式，jpg要什么适配！！]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[核心动画]]></title>
    <url>%2F2015%2F10%2F08%2F%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[CAlayer简介UIView与CALayer 关系 CALayer 是 Core Animation Layer UIView默认有个CALayer，是负责真正的绘图部分 UIView可以理解为是CALayer的管理器，对CALayer进行封装，所以他们大部分属性都是类似的 区别 CALayer继承自NSObject不响应事件，UIView继承自UIResponder能够响应事件 CAlayer是QuatzCore框架内容，UIView是UIKit框架内容 CALayer直接支持3D展示，UIView需要借助transform CALayer大部分属性修改都能形成隐式动画，UIView没有 常用属性 属性 说明 是否支持隐式动画 anchorPoint 锚点，取值0到1，比例值！默认(0.5,0.5)，永远和position重合 是 backgroundColor 图层背景颜色 是 borderColor 边框颜色 是 borderWidth 边框宽度 是 bounds 图层大小 是 contents 图层显示内容，例如可以将图片作为图层内容显示 是 contentsRect 图层显示内容的大小和位置 是 cornerRadius 圆角半径 是 doubleSided 图层背面是否显示，默认为YES 否 frame 图层大小和位置，不支持隐式动画 否 hidden 是否隐藏 是 mask 图层蒙版 是 maskToBounds 子图层是否剪切图层边界，默认为NO 是 opacity 透明度 ，类似于UIView的alpha 是 position 图层中心点位置，类似于UIView的center 是 shadowColor 阴影颜色 是 shadowOffset 阴影偏移量 是 shadowOpacity 阴影透明度，注意默认为0，如果设置阴影必须设置此属性 是 shadowPath 阴影的形状 是 shadowRadius 阴影模糊半径 是 sublayers 子图层 是 sublayerTransform 子图层形变 是 transform 图层形变 是 注意：一般CALayer中很少使用frame，通常使用bounds和position代替 注意：UIView的transform是CGAffineTransform用于2D变化，CALayer的的transform是CATransform3D用于3D变化，可互转; CGAffineTransform和CATransform3D的共同点是带有rotation用于旋转、带有scale用于缩放、带有translation用于平移 Core AnimationCAAnimation 核心动画的根类123456789101112131415// 时间函数/*kCAMediaTimingFunctionLinear // 匀速kCAMediaTimingFunctionEaseIn // 慢进kCAMediaTimingFunctionEaseOut // 慢出kCAMediaTimingFunctionEaseInEaseOut // 慢进慢出kCAMediaTimingFunctionDefault // 默认值（慢进慢出）*/@property(nullable, strong) CAMediaTimingFunction *timingFunction;// 注意是strong，设置代理后必须在适当时机手动释放delegate@property(nullable, strong) id &lt;CAAnimationDelegate&gt; delegate;// 动画执行完毕后是否从图层上移除，默认为YES（视图会恢复到动画前的状态），可设置为NO（图层保持动画执行后的状态，前提是fillMode设置为kCAFillModeForwards）@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion; CAMediaTiming 协议 CAMediaTiming是一个很好的使用协议实现多继承的样例123456789101112131415161718192021222324252627282930// 开始时间，默认0即当前时间，延迟2秒可用 beginTime=CACurrentMediaTime() + 2;@property CFTimeInterval beginTime;// 动画持续时长，默认0@property CFTimeInterval duration;// 动画速度，默认1，设为0表示暂停动画// 动画的实际时间 = duration / speed@property float speed;// 动画已经进行了多长时间，默认0@property CFTimeInterval timeOffset;// 重复次数，默认0@property float repeatCount;// 重复时间，默认0@property CFTimeInterval repeatDuration;// 是否反转，即所有动画倒着来一遍，默认NO@property BOOL autoreverses;/*首先设置animation.removeOnCompletion = NOkCAFillModeForwards // 动画结束后保持最后一帧的状态kCAFillModeBackwards // 动画开始前报纸第一帧的状态kCAFillModeBoth // 都有kCAFillModeRemoved // 相当于动画对CALayer没影响，执行完就移除*/@property(copy) CAMediaTimingFillMode fillMode; CAAnimationDelegate 注意此delegate是用strong修饰的，使用完必须手动置nil12345// 动画开始时回调- (void)animationDidStart:(CAAnimation *)anim;// 动画结束或中断时回调，finished为YES表示动画结束- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; CAPropertyAnimation 属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用12345678910// 一般基础动画和关键帧动画都都会通过去下便利初始化初始化+ (instancetype)animationWithKeyPath:(nullable NSString *)path;// 其实即使CALayer的属性（支持隐式动画的）参照上面// 注意是NSString，KVC方式来赋值的，所以特别注意拼写问题，大小写等// 使用transform时 ，应该具体到属性，例@&quot;transform.scale&quot;、@&quot;transform.rotation.z&quot;@property(nullable, copy) NSString *keyPath;// 插值计算函数，不用管，用系统的就好！@property(nullable, strong) CAValueFunction *valueFunction; CABasicAnimation 基础动画，通过属性修改进行动画参数控制，最常见用法是设置fromValue和toValue 注意：fromValue、toValue和byValue都是strong修饰的id类型，具体类型需要根据keyPath的类型处理 1234567891011/*fromValue和toValue不为nil，keyPath属性值在fromValue与toValue之间渐变fromValue和byValue不为nil，keyPath属性值在fromValue与(fromValue+byValue)之间渐变byValue和toValue不为nil，keyPath属性值在(toValue-byValue)与toValue之间渐变fromValue不为nil，keyPath属性值在fromValue与图层对应当前值之间渐变toValue不为nil，keyPath属性值在图层对应当前值与toValue之间渐变byValue不为nil，keyPath属性值在图层对应当前值与(图层对应当前值+toValue)之间渐变*/@property(nullable, strong) id fromValue;@property(nullable, strong) id toValue;@property(nullable, strong) id byValue; 当然fromValue、toValue和byValue也可使用CATransform3D对象 123CATransform3D transformFrom = CATransform3DMakeScale(1.0, 1.0, 1.0);CASpringAnimation *springAnimation = [CASpringAnimation animationWithKeyPath:@&quot;transform&quot;];springAnimation.fromValue = [NSValue valueWithCATransform3D:transformFrom]; 示例 123456789101112CABasicAnimation* animation;animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];animation.toValue = [NSNumber numberWithFloat: M_PI * 30 ];animation.duration = 2.0;// 可设时间函数// animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];animation.cumulative = YES;animation.repeatCount = 0;animation.removedOnCompletion = NO;animation.fillMode = kCAFillModeForwards;[view.layer addAnimation:rotationAnimation forKey:@&quot;rotationAnimation&quot;]; CAKeyframeAnimation 关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。 1234567891011// 关键帧（就是标志位）数组，类型由keyPath确定@property(nullable, copy) NSArray *values;// 将时间点和关键帧（标志位）一一对应，数值为总时长的百分比，默认均分@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;// 每个关键帧之间的动画缓冲效果，timingFunctions.count = keyTimes.count-1@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;// 指定动画路径，设置此属性将忽略values等@property(nullable) CGPathRef path; 示例 123456789double duration = 16 / 30.0;NSArray *keyTimes = @[@0, @((7/30.0)), @((13/30.0)), @((16/30.0))];CAKeyframeAnimation *sizeAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.scale&quot;];sizeAni.values = @[@1.0, @1.2, @0.90, @1.0];sizeAni.keyTimes = keyTimes;CAAnimationGroup *group = [CAAnimationGroup animation];group.animations = @[sizeAni];group.duration = duration;[view.layer addAnimation:group forKey:nil]; CAAnimationGroup 动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。 实例12345678910111213141516171819202122232425NSArray *keyTimes = @[@0, @((7/43.0)), @((17/43.0)), @((29/43.0)), @(1)];CAKeyframeAnimation *sizeAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.scale&quot;];sizeAni.values = @[@0, @1.1, @1, @1, @1];sizeAni.duration = duration;sizeAni.keyTimes = keyTimes;sizeAni.repeatCount = CGFLOAT_MAX;CAKeyframeAnimation *opacityAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];opacityAni.values = @[@0, @1, @1, @1, @1];opacityAni.keyTimes = keyTimes;CAKeyframeAnimation *positionAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];CGPoint centerPoint = adView.center;CGRect frameRect = adView.frame;CGPoint startPoint = CGPointMake(centerPoint.x, (frameRect.origin.y + frameRect.size.height));CGPoint endPoint = CGPointMake(centerPoint.x, centerPoint.y);NSArray *values = [NSArray arrayWithObjects:[NSValue valueWithCGPoint:startPoint], [NSValue valueWithCGPoint:endPoint],[NSValue valueWithCGPoint:endPoint], [NSValue valueWithCGPoint:endPoint], [NSValue valueWithCGPoint:endPoint], nil];positionAni.values = values;positionAni.keyTimes = keyTimes;CAAnimationGroup *group = [CAAnimationGroup animation];group.animations = @[sizeAni, positionAni];group.duration = duration;group.removedOnCompletion = NO;[adView.layer addAnimation:group forKey:@&quot;addArrowViewGroupAnimation&quot;]; CATransaction 事务的作用：保证一个或多个layer的一个或多个属性变化同时进行123456789[CATransaction begin];&#123;// some animaiton&#125;[CATransaction commit];[CATransaction setCompletionBlock:^&#123;// do something&#125;]; UIView&emsp;&emsp;不写了，除了弹簧动画需要自己测试下参数外，其它的都很简单！另外需要注意的是animate的completionblock不会引起循环引用，可放心使用！ 参考 http://www.cocoachina.com/articles/10005]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView瀑布流]]></title>
    <url>%2F2015%2F09%2F26%2FUIScrollView%E7%80%91%E5%B8%83%E6%B5%81%2F</url>
    <content type="text"><![CDATA[原理：先计算出所有cell的位置，然后根据offset判断屏幕内的进行加载 JZKWaterFallView.h 1234567891011121314151617181920212223242526272829#import &lt;UIKit/UIKit.h&gt;@class JZKWaterFallView;@protocol JZKWaterFallViewDelegate &lt;NSObject&gt;// 多少列- (NSInteger)numberOfCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView;// 一共多少个cell- (NSInteger)numberOfCellsInWaterFallView:(JZKWaterFallView *)waterFallView;// 定制cell类型- (UIView *)waterFallView:(JZKWaterFallView *)waterFallView cellForRowAtIndex:(NSInteger )index;// cell高度,可以用NSIndexPath，但我懒得整了- (CGFloat)waterFallView:(JZKWaterFallView *)tableView heightForRowAtIndex:(NSInteger )index;// 点击事件自己写吧，懒得判断UIView具体类型了@optional// 列间距- (CGFloat )offsetXBetweenCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView;// 行间距- (CGFloat )offsetYBetweenLinesInWaterFallView:(JZKWaterFallView *)waterFallView;@end@interface JZKWaterFallView : UIView@property (nonatomic, assign) id&lt;JZKWaterFallViewDelegate&gt; delegate;- (UIView *)dequeueReusableCell;- (void)reloadData;@end JZKWaterFallView.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#import &quot;JZKWaterFallView.h&quot;#define kItemViewTag 6848@interface JZKWaterFallView ()&lt;UIScrollViewDelegate&gt;@property (nonatomic, strong) UIScrollView *scrollView;@property (nonatomic, strong) UIView *contentView;// 各个cell的位置@property (nonatomic, strong) NSMutableArray *cellFrames;// cell 缓冲池@property (nonatomic, strong) NSMutableArray *cellCachePool;@end@implementation JZKWaterFallView- (instancetype)initWithFrame:(CGRect)frame &#123;self = [super initWithFrame:frame];if (self) &#123;[self setUpWithFrame:frame];&#125;return self;&#125;- (void)setUpWithFrame:(CGRect)frame &#123;CGFloat width = frame.size.width;CGFloat height = frame.size.height;_scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, width, height)];_scrollView.delegate = self;[self addSubview:_scrollView];_cellCachePool = [[NSMutableArray alloc] init];_cellFrames = [[NSMutableArray alloc] init];&#125;- (void)reloadData &#123;[self clear];if ([self numberOfCulumns] &gt; 0 &amp;&amp; [self numberOfCells] &gt; 0) &#123;[self reloadScrollView];CGFloat offsetY = _scrollView.contentOffset.y;[self refreshItemViewWithOffsetY:offsetY];&#125;&#125;- (void)clear &#123;[_contentView removeFromSuperview];_contentView = nil;[_cellFrames removeAllObjects];[_cellCachePool removeAllObjects];&#125;- (void)reloadScrollView &#123;CGFloat scrollViewWidth = _scrollView.frame.size.width;_contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, scrollViewWidth, 200)];[_scrollView addSubview:_contentView];NSInteger culumnsCount = [self numberOfCulumns];NSInteger cellCount = [self numberOfCells];CGFloat offsetX = [self offsetXBetweenCulumns];CGFloat offsetY = [self offsetYBetweenLines];CGFloat cellWidth = (scrollViewWidth - (culumnsCount * offsetX))/ culumnsCount;CGFloat maxHeight = [self cellHeightAtIndex:0] + offsetY;NSMutableArray *culumnsHeight = [[NSMutableArray alloc] init];NSInteger targetCulumn = 0;for (int index = 0; index &lt; cellCount; index++) &#123;CGFloat cellHeight = [self cellHeightAtIndex:index];CGFloat originX = 0;CGFloat originY = 0;// 第一排c特殊处理if (index &lt; culumnsCount) &#123;originY = 0;originX = index*(cellWidth + offsetX);[culumnsHeight addObject:@(cellHeight + offsetY)];&#125;else &#123;// 找到所有列中最矮的CGFloat minHeight = MAXFLOAT;for (int j = 0 ; j &lt; culumnsHeight.count; j++) &#123;CGFloat height = [[culumnsHeight objectAtIndex:j] floatValue];if (minHeight &gt; height) &#123;minHeight = height;targetCulumn = j;&#125;&#125;originY = minHeight;originX = targetCulumn * (cellWidth + offsetX);// 替换[culumnsHeight replaceObjectAtIndex:targetCulumn withObject:@(originY+cellHeight + offsetY)];&#125;CGRect frame = CGRectMake(originX, originY, cellWidth, cellHeight);NSValue *value = [NSValue valueWithCGRect:frame];[_cellFrames addObject:value];if (maxHeight &lt; originY + cellHeight +offsetY) &#123;maxHeight = originY + cellHeight +offsetY;&#125;&#125;_contentView.frame = CGRectMake(0, 0, scrollViewWidth, maxHeight);_scrollView.contentSize = CGSizeMake(scrollViewWidth, maxHeight);&#125;- (void)refreshItemViewWithOffsetY:(CGFloat )offsetY &#123;for (int index = 0; index &lt; [self numberOfCells]; index++) &#123;NSValue *value = [_cellFrames objectAtIndex:index];CGRect frame = [value CGRectValue];// 判断是否在屏幕内NSInteger tag = kItemViewTag + index;if (frame.origin.y + frame.size.height &gt; offsetY &amp;&amp; frame.origin.y + frame.size.height &lt; offsetY + _scrollView.frame.size.height) &#123;if (![_contentView viewWithTag:tag]) &#123;UIView *view = [self cellViewForIndex:index];view.frame = frame;[_contentView addSubview:view];[view setNeedsLayout];&#125;&#125;else &#123;if ([_contentView viewWithTag:tag]) &#123;UIView *view = [_contentView viewWithTag:tag];[_cellCachePool addObject:view];[view removeFromSuperview];&#125;&#125;&#125;&#125;- (UIView *)dequeueReusableCell &#123;if (_cellCachePool.count &gt; 0) &#123;UIView *view = [_cellCachePool firstObject];[_cellCachePool removeObjectAtIndex:0];return view;&#125;else &#123;return nil;&#125;&#125;#pragma mark scrollDelegate- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;CGFloat offsetY = scrollView.contentOffset.y;[self refreshItemViewWithOffsetY:offsetY];&#125;#pragma mark getter- (NSInteger )numberOfCulumns &#123;return [self.delegate numberOfCulumnsInWaterFallView:self];&#125;- (NSInteger )numberOfCells &#123;return [self.delegate numberOfCellsInWaterFallView:self];&#125;- (CGFloat )offsetXBetweenCulumns &#123;if ([self.delegate respondsToSelector:@selector(offsetXBetweenCulumnsInWaterFallView:)]) &#123;return [self.delegate offsetXBetweenCulumnsInWaterFallView:self];&#125;else &#123;return 5;&#125;&#125;- (CGFloat )offsetYBetweenLines &#123;if ([self.delegate respondsToSelector:@selector(offsetYBetweenLinesInWaterFallView:)]) &#123;return [self.delegate offsetYBetweenLinesInWaterFallView:self];&#125;else &#123;return 5;&#125;&#125;- (CGFloat )cellHeightAtIndex:(NSInteger)index &#123;return [self.delegate waterFallView:self heightForRowAtIndex:index];&#125;- (UIView *)cellViewForIndex:(NSInteger )index &#123;return [self.delegate waterFallView:self cellForRowAtIndex:index];&#125;@end 使用方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@interface ViewController ()&lt;JZKWaterFallViewDelegate&gt;@property (nonatomic, strong) NSMutableArray *heights;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];JZKWaterFallView *waterFallView = [[JZKWaterFallView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, 300)];waterFallView.delegate = self;[self.view addSubview:waterFallView];_heights = [[NSMutableArray alloc] init];for (int i = 0; i &lt; 20; i++) &#123;CGFloat height = (arc4random() % 9)*11;[_heights addObject:@(height)];&#125;[waterFallView reloadData];&#125;- (NSInteger)numberOfCellsInWaterFallView:(JZKWaterFallView *)waterFallView &#123;return _heights.count;&#125;- (NSInteger)numberOfCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView &#123;return 3;&#125;- (UIView *)waterFallView:(JZKWaterFallView *)waterFallView cellForRowAtIndex:(NSInteger)index &#123;UILabel *label = (UILabel *)[waterFallView dequeueReusableCell];if (label == nil) &#123;label = [[UILabel alloc] init];&#125;label.text = [NSString stringWithFormat:@&quot;第%li个&quot;,(long)index];if (index % 2 == 0) &#123;label.backgroundColor = [UIColor blueColor];&#125;else &#123;label.backgroundColor = [UIColor yellowColor];&#125;return label;&#125;- (CGFloat)waterFallView:(JZKWaterFallView *)tableView heightForRowAtIndex:(NSInteger)index &#123;return [[_heights objectAtIndex:index] floatValue];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC怎么实现多参数]]></title>
    <url>%2F2015%2F09%2F17%2FOC%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天被一个问题难到了，OC怎么实现多参数？ &emsp;&emsp;其实我们经常用的NSArray里就有多参数的实例1+ (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION; &emsp;&emsp;那么我们怎么自己定义多参数函数呢？几经周折找到了官方源码如下12345678910111213141516171819202122232425#import &lt;Cocoa/Cocoa.h&gt;@interface NSMutableArray (variadicMethodExample)- (void) appendObjects:(id) firstObject, ...; // This method takes a nil-terminated list of objects.@end@implementation NSMutableArray (variadicMethodExample)- (void) appendObjects:(id) firstObject, ...&#123;id eachObject;va_list argumentList;if (firstObject) // The first argument isn&apos;t part of the varargs list,&#123; // so we&apos;ll handle it separately.[self addObject: firstObject];va_start(argumentList, firstObject); // Start scanning for arguments after firstObject.while (eachObject = va_arg(argumentList, id)) // As many times as we can get an argument of type &quot;id&quot;[self addObject: eachObject]; // that isn&apos;t nil, add it to self&apos;s contents.va_end(argumentList);&#125;&#125;@end &emsp;&emsp;要不要加NS_REQUIRES_NIL_TERMINATION ？ 我认为要加，这个宏表示最后需要一个nil，就是为了多参数准备的 &emsp;&emsp;stackoverflow上有个问题，也可以参考一下（其实就是省略函数名）：https://stackoverflow.com/questions/722651/how-do-i-pass-multiple-parameters-in-objective-c?r=SearchResults]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tableview的坑]]></title>
    <url>%2F2015%2F09%2F12%2Ftableview%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[header问题 tableview的reloadSections刷新时，如果cell或secitonHeader中有XIB创建的subview，可能会出现frame问题,一会大一会小，但没任何地方更改frame，结论：慎用XIB https://blog.csdn.net/weixin_33686714/article/details/89615265 reloadSection的坑 现象：reloadSections后，再设置P2P或爆品抢购对应的选中tab会闪动。 实验结果：reloadSections时好像不会复用已展示的cell，而是cellA和cellB的循环展示，cellA的scrollViewContentOffset与cellB的scrollViewContentOffset不一致，造成闪动，且scrollViewContentOffset大小没有必然规律 补充：参考 https://blog.csdn.net/hherima/article/details/84573076 更新：tableView reloadData 有跳动 在iOS 11Self-Sizing自动打开后，contentSize和contentOffset都可能发生改变。可以通过以下方式禁用 tableView.estimatedRowHeight = 0; tableView.estimatedSectionHeaderHeight = 0; tableView.estimatedSectionFooterHeight = 0;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于NSArray的几个问题]]></title>
    <url>%2F2015%2F08%2F29%2F%E5%85%B3%E4%BA%8ENSArray%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数组里可放不同类型，不能放nil，特别注意插入、删除和查找时的越界问题123NSArray &lt;NSString *&gt; *array = @[@&quot;one&quot;，@&quot;two&quot;];// 此nil为结束标识符不计入数组内NSArray *arr = [NSArray arrayWithObjects:@1,@&quot;2&quot;, nil]; 数组是否有值校验1#define ISARRAYHASVALUE(array) (array &amp;&amp; [array isKindOfClass:[NSArray class]] &amp;&amp; [array count] &gt; 0) indexOfObject 与 indexOfObjectIdenticalTo答：indexOfObjectIdenticalTo比较内存地址是否相同，indexOfObject比较isEqual方法。参考 怎么快速剔除数组中相同元素123NSArray *arr = @[@1,@1,@2,@2,@3,@4,@4];NSSet *set = [NSSet setWithArray:arr];NSLog(@&quot;%@&quot;,[set allObjects]); 快速过滤1234NSArray *filteredArray = @[@2, @4, @6];NSArray *dataArray = @[@1,@2,@3,@4,@5,@6,@7];NSPredicate *filterPredicate = [NSPredicate predicateWithFormat:@&quot;NOT (SELF IN %@)&quot;,filteredArray];NSLog(@&quot;过滤后：%@&quot;,[dataArray filteredArrayUsingPredicate:filterPredicate]); for、for in 还是 enumerateObjectsUsingBlock答： for、 for in 差别不大，线程不安全。随便用 enumerateObjectsUsingBlock是线程安全的123456789101112NSMutableArray *muArr = @[@0, @1, @2, @3, @4].mutableCopy;[muArr enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;\if ([obj integerValue] == 2) &#123;// break; 不能用，如果想要同样效果用*stop = YES;// *stop = YES;// continue不能用，如果想要同样效果用return；return ;&#125;NSLog(@&quot;obj : %@ ,idx : %lu&quot;, obj, (unsigned long)idx);&#125;];` 排序12345678910111213NSArray *array = @[@1,@2,@3,@1,@2,@5,@4];NSArray *sortArr = [array sortedArrayWithOptions:NSSortStable usingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123;int value1 = [obj1 intValue];int value2 = [obj2 intValue];if (value1 &gt; value2) &#123;return NSOrderedDescending;&#125;else if (value1 == value2)&#123;return NSOrderedSame;&#125;else&#123;return NSOrderedAscending;&#125;&#125;]; 可变数组不能add和remove，但可以replace12345NSMutableArray *muArr = @[@1, @2, @3].mutableCopy;for (id elem in muArr) &#123;[muArr removeObject:elem];&#125;// Terminating app due to uncaught exception &apos;NSGenericException&apos;, reason: &apos;*** Collection &lt;__NSArrayM: 0x600002052310&gt; was mutated while being enumerated.&apos; 快速取得最小值123456789NSMutableArray* array = [NSMutableArray array];for (int i = 0; i &lt; 10; i++) &#123;CGFloat num = arc4random() % 100 + 1; [array addObject:[NSNumber numberWithFloat:num]];&#125;CGFloat maxValue = [[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];CGFloat minValue = [[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];/*min、max是NSArray的私有属性，通过.语法是拿不到的，会报错的。类似这种私有属性还有@”@avg.floatValue” (获取平均值)，@”@count.floatValue”(获取数组大小) @&quot;@sum.floatValue&quot;（求和）*/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling]]></title>
    <url>%2F2015%2F08%2F17%2FMethod-Swizzling%2F</url>
    <content type="text"><![CDATA[Method Swizzling 参考： https://blog.csdn.net/yiyaaixuexi/article/details/9374411 https://nshipster.com/method-swizzling/ https://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling 建议阅读：https://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c 方法 123456789101112static void SwizzleMethod(Class cls, SEL ori, SEL rep) &#123;Method oriMethod = class_getInstanceMethod(cls, ori);Method repMethod = class_getInstanceMethod(cls, rep);BOOL flag = class_addMethod(cls, ori, method_getImplementation(repMethod), method_getTypeEncoding(repMethod));if (flag) &#123;class_replaceMethod(cls, rep, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));&#125; else &#123;method_exchangeImplementations(oriMethod, repMethod);&#125;&#125; 测试用例 123456789101112131415161718192021222324252627282930313233343536373839404142434445@interface Person : NSObject+ (void)sleep;- (void)walk;@end@implementation Person+ (void)sleep &#123;NSLog(@&quot;睡觉&quot;);&#125;- (void)walk &#123;NSLog(@&quot;去哪里？&quot;);&#125;@end// hook@interface Person (china)@end@implementation Person (china)+ (void)load &#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;// hook实例方法SwizzleMethod([self class], @selector(jzk_walk), @selector(walk));// hook类方法SwizzleMethod(object_getClass([self class]), @selector(sleep), @selector(jzk_sleep));&#125;);&#125;- (void)jzk_walk &#123;[self jzk_walk];NSLog(@&quot;当然是学校&quot;);&#125;+ (void)jzk_sleep &#123;NSLog(@&quot;起来嗨&quot;);// 注意hook类方法直接用self就好[self jzk_sleep];&#125;@end/*起来嗨睡觉去哪里？当然是学校*/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Category和关联对象的使用]]></title>
    <url>%2F2015%2F08%2F02%2FCategory%E5%92%8C%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Category&emsp;&emsp;个人觉得Category才是OC最好玩的地方，如果不用category我们能怎么办？继承！对最好的方式就是继承，但继承的问题总所周知：层级关系复杂，使用不便，最主要的还是麻烦！category就很爽了！ 概念&emsp;&emsp;分类就是对一个类的功能进行扩展,利用OC的动态运行时分配机制，Category提供了一种比继承更为简洁的方法来对类进行扩展，无需创建对象类的子类就能为现有的类添加新的方法，可以为任何已经存在的类添加方法，包括系统框架UIKit等 优点 分散功能，可将体积比较大的类拆分成几个小类，减少依赖提高复用率 方便代码的管理。将同类功能放到同一category里面是一个非常不错的选择，UIKit也是这么做的 减少继承，编码核心就是能用组合用组合，实在没办法再用继承 声明私有方法 缺点 同名方法有可能被覆盖掉！处理办法是增加前缀，注意OC里主要通过前缀来代替包，而且apple声称拥有任何两个字母的使用权，开发者最好使用三个或三个以上字母作为前缀 由于功能分散，非常考验命名 多人协作时，最好将同一个类的category放到同一文件夹，增加冲突可能性 &emsp;&emsp;category和extension的区别 extension固定为 ClassName()，外部引用不到 ； category需要起个好名字，外部能引用到 extension 能直接增加成员变量， category需要借助于关联对象 extension 只能在.m文件中，用于隐藏相关信息；category可单独一个文件 实现&emsp;&emsp;新建category: new file -&gt; Object-C File -&gt; File Type -&gt; Category 1. 实例：给NSMutableArray添加安全方法 .h 文件 12345678@interface NSMutableArray (Safely)- (void)addObjectSafely:(id)anObject;- (void)insertObjectSafely:(id)anObject atIndex:(NSUInteger)index;- (void)removeObjectAtIndexSafely:(NSUInteger)index;- (void)replaceObjectAtIndexSafely:(NSUInteger)index withObject:(id)anObject;@end .m文件 12345678910111213141516171819202122232425@implementation NSMutableArray (Safely)- (void)addObjectSafely:(id)anObject &#123;if (nil != anObject) &#123;[self addObject:anObject];&#125;&#125;- (void)insertObjectSafely:(id)anObject atIndex:(NSUInteger)index &#123;if (nil != anObject &amp;&amp; index &lt; [self count]) &#123;[self insertObject:anObject atIndex:index];&#125;&#125;- (void)removeObjectAtIndexSafely:(NSUInteger)index &#123;if (index &lt; [self count]) &#123;[self removeObjectAtIndex:index];&#125;&#125;- (void)replaceObjectAtIndexSafely:(NSUInteger)index withObject:(id)anObject &#123;if (nil != anObject &amp;&amp; index &lt; [self count]) &#123;[self replaceObjectAtIndex:index withObject:anObject];&#125;&#125;@end 2. 声明私有方法 原文件 MyClass 12345678910111213// .h文件@interface MyClass : NSObject// 注意原来类中没有暴露somePrivateMethod方法@end// .m文件@implementation MyClass- (void)somePrivateMethod &#123;NSLog(@&quot;就是不想让你用！&quot;);&#125;@end category暴露私有方法 12345678910// .h文件@interface MyClass (Public)// 暴露somePrivateMethod方法，注意不要在category的m文件实现。实现就覆盖了- (void)somePrivateMethod;@end// .m文件@implementation MyClass (Public)@end 使用私有方法 12345678910111213// 注意声明私有方法时必须两个都要引入#import &quot;MyClass.h&quot;#import &quot;MyClass+Public.h&quot;@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];MyClass *my = [[MyClass alloc] init];[my somePrivateMethod];&#125;@end 关联对象&emsp;&emsp;为什么把关联对象放到这里写？因为关联对象一般都在category里；更因为category可以给原类增加方法，关联对象正好可以给原来增加实例变量，参考：https://stackoverflow.com/questions/8733104/objective-c-property-instance-variable-in-category 实例 .h文件 12345@interface MyClass (Public)@property (copy, nonatomic) NSString *someProperty;@end .m文件 1234567891011121314151617181920212223242526272829// 注意引入runtime#import &lt;objc/runtime.h&gt;static NSString *kAssociatedObjectKey = @&quot;kAssociatedObjectKey&quot;;@implementation MyClass (Public)// setter和getter必须都要写// setter方法- (void)setSomeProperty:(NSString*)propertyValue &#123;/*OBJC_ASSOCIATION_ASSIGN //@property(assign)。OBJC_ASSOCIATION_RETAIN_NONATOMIC //@property(strong, nonatomic)。OBJC_ASSOCIATION_COPY_NONATOMIC //@property(copy, nonatomic)。OBJC_ASSOCIATION_RETAIN //@property(strong,atomic)。OBJC_ASSOCIATION_COPY //@property(copy, atomic)。*/// 注意propertyValue只能给类，int、NSInterger、Bool时需要转成NSNumberobjc_setAssociatedObject(self, &amp;kAssociatedObjectKey, propertyValue, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;// getter- (NSString *)someProperty &#123;// int、NSInterger、Bool时需要将NSNumber转成对应类型NSString *value = objc_getAssociatedObject(self, &amp;kAssociatedObjectKey);return value;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小强升职记]]></title>
    <url>%2F2015%2F07%2F31%2F%E5%B0%8F%E5%BC%BA%E5%8D%87%E8%81%8C%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[成功的关键在于构建自己的核心 成熟意味着什么？意味着确定的价值观、顺畅的时间管理、以及属于自己的处世哲学 1、寻找种子 你真的很忙吗？记录时间日志、分类整理、原因分析、总结优化（工作、学习、娱乐同样重要,提高效率而不是做苦行僧） 时间黑洞：自己都不知道自己的时间花到哪去了，也就是我经常写的nothing，原因是：大脑不善于记忆，而善于创造性思维，只有对大脑形成强烈刺激的事情才会被存储下来。因此那些极具规律性、比较枯燥、或者目的性不强、没有主动性的事情，将很容易被遗忘。解决方案：每个一个小时写出下一个小时计划要做的事情，一个小时结束之后记录下结果，坚持一整天！慢慢来 衡量一件事是不是有意义，主要是看我们投入时间后是否有预期的产出！达到了预期就是有意义的，没达到自然是没意义的！有点意思，举例：比起每次玩完游戏就后悔，更应该比较的应该是计划做什么，结果是什么，应不应该后悔？ 注意力被打断之后，如果想要重新集中注意力至少需要15分钟；而如果思路被打断，那可能永远都想不到了。。。所以要勇于“拒绝” 任务处理： A、将所有的任务放入工作篮，不论是谁什么时候交给我的任务，统统放进工作篮里； B、将可以置之不理的任务清除掉，将必须在某天处理或者必须转交别人处理的任务拿出来，将那些可以在两分钟之内完成的任务立即完成； C，将需要在特定日期处理的事情写进日程表，将需要别人处理的事情立即转交并且设定到期提醒，将需要现在处理的事情摆在办公桌上； D，在自己最高效的时间段，做最重要的事情，其他事情也要做合理的安排 提高工作效率的方法： A、每天早晨别一上班就急着投入工作，先看看今天的工作重点是什么，哪些事情是重要并且紧迫的，将这些事情安排在你的高效时间段完成； B、回顾你需要发布或者呈送上司的资料，不可能第一次就做的尽善尽美，不要吝啬时间！ C、看新闻用RSS，也可用广告拦截器，将注意力集中在新闻上，而不是铺天盖地的广告超链接； D、减少检查邮件的次数，每天两次足够了，并且应该注意，往往在上网聊天或者无所事事的时候就会“习惯性”的检查邮件，因此应该找些事情来分散自己的注意力； E、能休息的时候尽量休息，保持自己的精力，游戏!=休息、做别的!=休息、真正的休息就是：大脑放空，冥想或睡眠 价值观没有对错，也不是记忆，更不是一成不变的，而是要不断地从经验中去提炼！可以呀借助心理学的问答测试工具！！！写在卡片上，放到触目可见的地方，不断地巩固和修正，这很重要！ 2、让种子发芽 四象限：很多人经常会被假象迷惑，认为“紧急”的就是“重要”的，其实“紧急”和“重要”一点关系都没有！ 重要且紧急。必须马上处理，但真的有这么多重要且紧急的事情吗？ 重要但不紧急。分解任务，制定计划，按部就班，绝不拖延，思考怎样避免它进入第一象限？ 不重要但紧急。能不做就不做，或交给别人，思考如果尽量减少第三象限的事务？ 不重要且不紧急。尽量别做，应该思考我们工作中是否有必要进入这个象限？ 标签划分事务：A，先“轻重”，给所有任务以职业价值观为标准标出“重要”或“不重要”；B，再“缓急”，给所有任务以截止日期标出“紧急”或“不紧急”；C，最后按照自己的意愿给所有任务标出“高”“中”“低”三种优先级 走出第三象限（不重要且紧急）：其实就是推脱，哪怕暂时的推脱！当然，推脱也是讲究技巧的 第二象限工作法（重要但不紧急）：应该将自己的主要精力集中在解决重要但不紧急的事务，平时制定的工作计划和工作目标都是相对于第二象限来说的！ 进行目标描述和任务分解的好处：项目分解做细，有计划更全面，知道现在在哪，逐步减轻压力和提升自信，及时发现问题并处理优化 时间管理三大杀手：拖延，犹豫不决，目标不明确 时间管理并不是追求在1个小时内能做3件或5件事情，时间管理的目的应该是充分利用时间来创造最大的价值 要有耐心，慢慢来！ 找到最重要的事，集中精力，拿下它！ 下一步行动是什么？怎么做？找出下一步行动的秘诀：A，动词开头；B，内容清晰；C，描述结果；D，设定开始时间、周期、最后期限；例如：早上9点带上做好的计划书在会议室开始讨论营销计划，2小时内说服与会者认同我的营销方案！ 学习使用流程图之类的工具，先想好怎么做，做的时候就很简单了！一开始不妨做完一步，再想下一步是什么，怎么做；等以后熟练了再整体去想整个的流程步骤是什么！ 衣柜整理法 收集一切我们注意的事情：集中处理某一件事的时候，有其他的事就记上，回头再处理！收集工具应该越少越好，随手能拿到，还有定期清理收集篮 加工处理后，确定它们的实质以及解决方法 处理收集篮原则：A，从最上面一项开始处理；B，一次只处理一件事；C，永远不要再放回收集篮； 不可执行事务：A，垃圾 -&gt; 丢弃； B，将来某时或也许的事 ；C，参考资料 -&gt; 分类归档 可执行事务：2分钟能搞定的 -&gt; 立即去做；B，需要多个步骤搞定的项目；C，指派给别人；D，特定时间做的事 -&gt; 写入日程表；E，普通待办事项 把它们列为我们的行动选择方案 行动 定期组织整理得出结论 3、生长出主干和枝丫 我们不但要设定目标，而且要强有力地执行它，一般人达不成自己的目标原因：A，设定了不可达成的目标；B，没有将目标分解为计划；C，放任偶尔的失败；D，没有写下来；E，没有及时修正目标；F，没有坚持行动 实现目标第一步，正确描述目标，是否符合smart原则？ 实现目标的关键是将目标转变成计划：A，写出你的目标；B，为什么要达成此目标，最主要的理由写在最前面；C，我为什么可以达成此目标，首先要说服自己一定可以达成这个目标；D，哪些个人、团队、组织对我达成这个目标有帮助？没有一个人的成功是靠自己一个人完成的；E，这个目标要在多长时间内完成？过短或过长都是没意义的 提高执行力：A，找到最大的障碍，第一个就去解除这个障碍；B，写下来！一定要写下来！C，拒绝第一次失败，面对失败我们要，重视失败分析原因和以变化应对变化 目标应该是条铁链而不是铁砂，可以按六个高度原则（原则 &gt; 愿景 &gt; 目标 &gt; 责任范围 &gt; 任务 &gt; 下一步行动）设定目标 不要每天都做白日梦！只有从一块块砖头开始，一步步的才能达成目标；]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIScrollView轮播图]]></title>
    <url>%2F2015%2F07%2F01%2FUIScrollView%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[原理: 使用左中右三个imageview，每次循环完就强制滚到中间ImageView，同时刷新左中右三个imageview；代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#import &quot;ZKAutoScrollPicture.h&quot;@interface ZKAutoScrollPicture ()&lt;UIScrollViewDelegate&gt;@property (nonatomic, retain) UIScrollView *scrollView;@property (nonatomic, retain) UIImageView *leftImageView;@property (nonatomic, retain) UIImageView *centerImageView;@property (nonatomic, retain) UIImageView *rightImageView;@property (nonatomic, retain) UIPageControl *pageControl;@property (nonatomic, copy) NSArray&lt;UIImage *&gt; *images;@property (nonatomic, assign) NSUInteger currentImageIndex;//当前图片索引@property (nonatomic, retain) NSTimer *timer;@property (nonatomic, assign) NSTimeInterval timeInterval;@end@implementation ZKAutoScrollPicture- (instancetype)initWithFrame:(CGRect)frametimeInterval:(NSTimeInterval)intervalimages:(NSArray&lt;UIImage *&gt; *)images&#123;self = [super initWithFrame:frame];if (self) &#123;self.images = images;self.timeInterval = interval;[self startTimer];[self setupWithFrame:frame];&#125;return self;&#125;- (void)setImages:(NSArray&lt;UIImage *&gt; *)images &#123;_images = images;if (images.count == 0) &#123;[self stopTimer];&#125;&#125;- (void)setTimeInterval:(NSTimeInterval)timeInterval &#123;if (timeInterval &lt;= 0) &#123;[self stopTimer];_timeInterval = 0;&#125;else &#123;_timeInterval = timeInterval;&#125;&#125;- (void)setupWithFrame:(CGRect)frame &#123;CGFloat imageWidth = frame.size.width;CGFloat imageHeight = frame.size.height;_currentImageIndex = 0;// pageControl_pageControl=[[UIPageControl alloc]init];CGSize size= [_pageControl sizeForNumberOfPages:_images.count];_pageControl.bounds=CGRectMake(0, 0, size.width, size.height);_pageControl.center=CGPointMake(imageWidth / 2, imageHeight - 10);_pageControl.pageIndicatorTintColor=[UIColor blackColor];_pageControl.currentPageIndicatorTintColor=[UIColor redColor];_pageControl.numberOfPages = _images.count;// 初始化左中右三个imageview_leftImageView=[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, imageWidth, imageHeight)];_centerImageView=[[UIImageView alloc]initWithFrame:CGRectMake(imageWidth, 0, imageWidth, imageHeight)];_rightImageView=[[UIImageView alloc]initWithFrame:CGRectMake(2*imageWidth, 0, imageWidth, imageHeight)];// scrollview_scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, imageWidth, imageHeight)];_scrollView.delegate = self;_scrollView.showsVerticalScrollIndicator = NO;_scrollView.showsHorizontalScrollIndicator = NO;_scrollView.pagingEnabled = YES;//[_scrollView addSubview:_leftImageView];[_scrollView addSubview:_centerImageView];[_scrollView addSubview:_rightImageView];_scrollView.contentSize = CGSizeMake(3*imageWidth, imageHeight);[self addSubview:_scrollView];[self addSubview:_pageControl];// 设置默认显示中间的[self resetScrollViewContentOffset];[self refreshImageByOffsetX:imageWidth];&#125;-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView&#123;//重新加载图片[self refreshImageByOffsetX:scrollView.contentOffset.x];[self resetScrollViewContentOffset];NSLog(@&quot;scrollViewDidEndDecelerating offsetX:%f&quot;,_scrollView.contentOffset.x);&#125;- (void)resetScrollViewContentOffset &#123;//永远移动到centerImageView[_scrollView setContentOffset:CGPointMake(self.frame.size.width, 0) animated:NO];&#125;#pragma mark 重新加载图片-(void)refreshImageByOffsetX:(CGFloat)offsetX &#123;CGFloat width = self.frame.size.width;NSUInteger totalCount = _images.count;if (offsetX &gt; width) &#123; //向右滑动_currentImageIndex = (_currentImageIndex + 1) % totalCount;&#125;else if(offsetX &lt; width)&#123; //向左滑动_currentImageIndex = (_currentImageIndex + totalCount - 1) % totalCount;&#125;[self refreshImageAndPage];&#125;- (void)refreshImageAndPage &#123;NSUInteger totalCount = _images.count;_centerImageView.image = _images[_currentImageIndex];//重新设置左右图片NSUInteger leftIndex = (_currentImageIndex + totalCount - 1) % totalCount;NSUInteger rightIndex = (_currentImageIndex + 1) % totalCount;_leftImageView.image = _images[leftIndex];_rightImageView.image = _images[rightIndex];//设置分页_pageControl.currentPage = _currentImageIndex;&#125;//开始拖拽-(void)scrollViewWillBeginDragging:(UIScrollView *)scrollView&#123;[self stopTimer];&#125;- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate &#123;[self startTimer];&#125;- (void)startTimer &#123;[self stopTimer];_timer = [NSTimer timerWithTimeInterval:_timeInterval target:self selector:@selector(autoScrollToNext) userInfo:nil repeats:YES];[[NSRunLoop mainRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];&#125;- (void)stopTimer &#123;[_timer invalidate];&#125;- (void)autoScrollToNext &#123;[UIView animateWithDuration:0.25 animations:^&#123;// 小坑，设置动画YES，下面reset是又设置NO,动画就不执行了[self.scrollView setContentOffset:CGPointMake(self.frame.size.width*2, 0) animated:NO];&#125; completion:^(BOOL finished) &#123;self.currentImageIndex++;if (self.currentImageIndex &gt;= self.images.count) &#123;self.currentImageIndex = 0;&#125;[self refreshImageAndPage];[self resetScrollViewContentOffset];&#125;];&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于NSDictionary的几个问题]]></title>
    <url>%2F2015%2F06%2F21%2F%E5%85%B3%E4%BA%8ENSDictionary%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[NSDictionary12NSDictionary &lt;NSString *, NSNumber *&gt; *dict = @&#123;@&quot;one&quot;:@1&#125;;dict.allKeys; dict.allValues; // 顺序都是随机的 NSDictionary的key必须是字符串吗？答：只要遵守NSCoding协议就行，也可以不是NSString12NSDictionary *dic = @&#123;@1 : @&quot;one&quot;&#125;;NSLog(@&quot;%@&quot;,dic[@1]); // one NSMutableDictionary的 setObject: forKey: 与 setValue： forKey: 有啥区别？答： setObject: forKey: 的object不能为nil，否则会crash setValue: forKey: 的value可以为nil，若nil则remove对应的key；此外，setValue: forKey: 是KVC方法，故key 必须是字符串1234NSMutableDictionary *muDic = [[NSMutableDictionary alloc] init];// [muDic setObject:nil forKey:@1]; crash[muDic setValue:nil forKey:@&quot;2&quot;];// [muDic setValue:@&quot;第三个&quot; forKey:@3]; 黄牌警告 NSDictionary的 objectForKey: 与 valueForKey: 有啥区别？答： objectForKey: 根据key取值，否则返回nil valueForKey: 根据key取值，key必须是字符串，且如果key以@开头会crash12345NSDictionary *dic = @&#123;@&quot;1&quot;:@&quot;one&quot;, @&quot;@2&quot;:@&quot;two&quot;&#125;;NSLog(@&quot;%@&quot;,[dic objectForKey:@&quot;1&quot;]);NSLog(@&quot;%@&quot;,[dic objectForKey:@&quot;@2&quot;]);NSLog(@&quot;%@&quot;,[dic valueForKey:@&quot;1&quot;]);// NSLog(@&quot;%@&quot;,[dic valueForKey:@&quot;@2&quot;]); crash 扩展阅读 NSMapTable: 不只是一个能放weak指针的 NSDictionary NSHashtable and NSMaptable]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于数字的几个问题]]></title>
    <url>%2F2015%2F06%2F05%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%97%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[NSNumber答: 基础数字类型的封装，继承自NSObject，引用类型。语法糖 @(123) 32位系统上使用assign修饰NSNumber会Crash原因：NSNumber在32bit设备之上0-12都是存在内存共享区，无论调用多少次指针指向的都是相同的一块内存区域，永远不会被销毁。而只要大于12就是正常的创建在堆上的对象。在64-bit机器上无论NSInterger保存的这个数有多大，只要在正常范围之内，一定是存放在常量区的，也就是永远不会释放。因此需要用retain或strong NSInteger是不是引用类型答：别看是以NS开头就以为是对象了！NSInteger不是引用类型，int同C的int，NSInteger是对int的封装，推荐使用，根据操作系统位数返回最大值。uint与NSUInteger同上。 NSTimeInterval答: typedef double NSTimeInterval; 为什么专门typedef 一下? 最主要是方便用户使用,见名知义,一看就知道专门给time使用的 CGFloat怎么这么奇怪？答：- float同C的float，double同C的double，CGFloat在32位上是float，64位上是double，没查到为什么是CG开头？ Bool的问题答:记住是YES或NO,不是true和false;0为NO,其它为flase;nil为NO,非nil为YES;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIEvent简介]]></title>
    <url>%2F2015%2F05%2F30%2FUIEvent%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;UIEvent是代表iOS系统中的一个事件,一个事件包含一个或多个的UITouch； 属性 @property(nonatomic,readonly) UIEventType type NS_AVAILABLE_IOS(3_0);//事件类型 123456typedef NS_ENUM(NSInteger, UIEventType) &#123;UIEventTypeTouches,//触摸事件类型 iOS3.0之后可以用UIEventTypeMotion,//摇晃事件类型 iOS3.0之后可以用UIEventTypeRemoteControl,//遥控事件类型 iOS4.0之后可以用UIEventTypePresses NS_ENUM_AVAILABLE_IOS(9_0),//物理按钮事件类型 iOS9.0之后可以用&#125;; @property(nonatomic,readonly) UIEventSubtype subtype NS_AVAILABLE_IOS(3_0);//子事件类型 12345678910111213141516171819typedef NS_ENUM(NSInteger, UIEventSubtype) &#123;//事件没有子类型 iOS3.0之后可以用UIEventSubtypeNone = 0,//iOS3.0之后可以用UIEventSubtypeMotionShake = 1, // 摇晃事件//遥控的事件子类型 iOS4.0之后可以用UIEventSubtypeRemoteControlPlay = 100,//播放UIEventSubtypeRemoteControlPause = 101,//暂停UIEventSubtypeRemoteControlStop = 102,//停止UIEventSubtypeRemoteControlTogglePlayPause = 103,//播放或暂停UIEventSubtypeRemoteControlNextTrack = 104,//下一曲UIEventSubtypeRemoteControlPreviousTrack = 105,//上一曲UIEventSubtypeRemoteControlBeginSeekingBackward = 106,//开始快退UIEventSubtypeRemoteControlEndSeekingBackward = 107,//快退结束UIEventSubtypeRemoteControlBeginSeekingForward = 108,//开始快进UIEventSubtypeRemoteControlEndSeekingForward = 109,//快进结束&#125;; @property(nonatomic,readonly) NSTimeInterval timestamp;//事件发生时间 @property(nonatomic, readonly, nullable) NSSet *allTouches;//所有触摸对象。 API123456789- (nullable NSSet &lt;UITouch *&gt; *)touchesForWindow:(UIWindow *)window;//没用，都是main window才响应- (nullable NSSet &lt;UITouch *&gt; *)touchesForView:(UIView *)view;//返回属于一个给定View的触摸对象。- (nullable NSSet &lt;UITouch *&gt; *)touchesForGestureRecognizer:(UIGestureRecognizer *)gesture NS_AVAILABLE_IOS(3_2);//返回指定的手势触摸对象集合//会将丢失的触摸放到一个新的 UIEvent 数组中，你可以用 coalescedTouchesForTouch(_:) 方法来访问- (nullable NSArray &lt;UITouch *&gt; *)coalescedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0);//辅助UITouch的触摸，预测发生了一系列主要的触摸事件。这些预测可能不完全匹配的触摸的真正的行为，因为它的移动，所以他们应该被解释为一个估计。- (nullable NSArray &lt;UITouch *&gt; *)predictedTouchesForTouch:(UITouch *)touch NS_AVAILABLE_IOS(9_0); 参考 https://developer.apple.com/documentation/uikit/uievent]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITouch简介]]></title>
    <url>%2F2015%2F05%2F24%2FUITouch%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[属性介绍 常见属性 1234567891011121314151617181920212223242526272829// 触摸发生或最后修改的时间@property(nonatomic,readonly) NSTimeInterval timestamp;// 触摸次数@property(nonatomic,readonly) NSUInteger tapCount; // touch down within a certain point within a certain amount of time// 触摸发生的window，一般是main window@property(nullable,nonatomic,readonly,strong) UIWindow *window;// 触摸的view@property(nullable,nonatomic,readonly,strong) UIView *view;// 数组? 试验结果包含系统手势，同一个手势的不同状态等，总之此属性不靠谱@property(nullable,nonatomic,readonly,copy) NSArray &lt;UIGestureRecognizer *&gt; *gestureRecognizers NS_AVAILABLE_IOS(3_2);typedef NS_ENUM(NSInteger, UITouchPhase) &#123;UITouchPhaseBegan, // 手指接触屏幕UITouchPhaseMoved, // 手指在屏幕上移动UITouchPhaseStationary, // 中间态，手指保持接触但没移动UITouchPhaseEnded, // 手指离开屏幕UITouchPhaseCancelled, // 触摸没结束，但需要强制停止追踪触摸事件&#125;;@property(nonatomic,readonly) UITouchPhase phase;typedef NS_ENUM(NSInteger, UITouchType) &#123;UITouchTypeDirect, // 直接触摸屏幕UITouchTypeIndirect, // 间接触摸，遥控器UITouchTypePencil NS_AVAILABLE_IOS(9_1), // 触控笔UITouchTypeStylus NS_AVAILABLE_IOS(9_1) = UITouchTypePencil, &#125; NS_ENUM_AVAILABLE_IOS(9_0);@property(nonatomic,readonly) UITouchType type NS_AVAILABLE_IOS(9_0);// 唯一索引，让你把一个更新的触摸与原来的触摸联系起来。@property(nonatomic,readonly) NSNumber * _Nullable estimationUpdateIndex NS_AVAILABLE_IOS(9_1); 触摸半径 123456// majorRadius and majorRadiusTolerance are in points// The majorRadius will be accurate +/- the majorRadiusTolerance// 触摸半径@property(nonatomic,readonly) CGFloat majorRadius NS_AVAILABLE_IOS(8_0);// 触摸半径偏移量@property(nonatomic,readonly) CGFloat majorRadiusTolerance NS_AVAILABLE_IOS(8_0); 3Dtouch 1234// 触摸力度，均值为1，系统预设@property(nonatomic,readonly) CGFloat force NS_AVAILABLE_IOS(9_0);// 最大触摸力度@property(nonatomic,readonly) CGFloat maximumPossibleForce NS_AVAILABLE_IOS(9_0); API 123456789// 返回值表示触摸在view上的位置， 传入nil就是相对UIWindow的位置- (CGPoint)locationInView:(nullable UIView *)view;// 该方法记录了前一个触摸点的位置- (CGPoint)previousLocationInView:(nullable UIView *)view;//触摸可用时，返回触摸的精确位置- (CGPoint)preciseLocationInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1);//触摸可用时，返回触控的精确先前位置- (CGPoint)precisePreviousLocationInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1); 触笔相关 123456// 触笔弧度，0弧度表示触笔与表面平行。当触笔垂直于表面时，此属性的值为pi/2。@property(nonatomic,readonly) CGFloat altitudeAngle NS_AVAILABLE_IOS(9_1);// 返回手触笔的方位角（弧度）- (CGFloat)azimuthAngleInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1);// 返回指向指针的方位角的单位向量- (CGVector)azimuthUnitVectorInView:(nullable UIView *)view NS_AVAILABLE_IOS(9_1); 参考 https://developer.apple.com/documentation/uikit/uitouch]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[悬浮球代码]]></title>
    <url>%2F2015%2F05%2F16%2F%E6%82%AC%E6%B5%AE%E7%90%83%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145//// ZKDebugFloatView.m// test//// Created by JZK on 2015/5/5.// Copyright © 2015 baidu. All rights reserved.//#import &quot;ZKDebugFloatView.h&quot;#import &quot;AppDelegate.h&quot;@implementation ZKDebugFloatView&#123;//拖动按钮的起始坐标点CGPoint _touchPoint;//起始按钮的x,y值CGFloat _touchBtnX;CGFloat _touchBtnY;&#125;+ (void)show&#123;static dispatch_once_t onceToken;static BFDebugFloatView *floatView = nil;dispatch_once(&amp;onceToken, ^&#123;floatView = [[[NSBundle mainBundle] loadNibNamed:@&quot;ZKDebugFloatView&quot; owner:nil options:nil] firstObject];&#125;);if (!floatView.superview) &#123;floatView.frame = CGRectMake(0, (kScreenHeight - 80)/ 2, 80, 80);floatView.layer.masksToBounds = YES;floatView.layer.cornerRadius = 40;[[UIApplication sharedApplication].keyWindow addSubview:floatView];[[UIApplication sharedApplication].keyWindow bringSubviewToFront:floatView];&#125;&#125;- (void)awakeFromNib &#123;[super awakeFromNib];&#125;#pragma mark - touchMove- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;[super touchesBegan:touches withEvent:event];//按钮刚按下的时候，获取此时的起始坐标UITouch *touch = [touches anyObject];_touchPoint = [touch locationInView:self];_touchBtnX = self.frame.origin.x;_touchBtnY = self.frame.origin.y;&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;UITouch *touch = [touches anyObject];CGPoint currentPosition = [touch locationInView:self];//偏移量(当前坐标 - 起始坐标 = 偏移量)CGFloat offsetX = currentPosition.x - _touchPoint.x;CGFloat offsetY = currentPosition.y - _touchPoint.y;//移动后的按钮中心坐标CGFloat centerX = self.center.x + offsetX;CGFloat centerY = self.center.y + offsetY;self.center = CGPointMake(centerX, centerY);//父试图的宽高CGFloat superViewWidth = self.superview.frame.size.width;CGFloat superViewHeight = self.superview.frame.size.height;CGFloat btnX = self.frame.origin.x;CGFloat btnY = self.frame.origin.y;CGFloat btnW = self.frame.size.width;CGFloat btnH = self.frame.size.height;//x轴左右极限坐标if (btnX &gt; superViewWidth)&#123;//按钮右侧越界CGFloat centerX = superViewWidth - btnW/2;self.center = CGPointMake(centerX, centerY);&#125;else if (btnX &lt; 0)&#123;//按钮左侧越界CGFloat centerX = btnW * 0.5;self.center = CGPointMake(centerX, centerY);&#125;//默认都是有导航条的，有导航条的，父试图高度就要被导航条占据，固高度不够CGFloat defaultNaviHeight = 64;CGFloat judgeSuperViewHeight = superViewHeight - defaultNaviHeight;//y轴上下极限坐标if (btnY &lt;= 0)&#123;//按钮顶部越界centerY = btnH * 0.7;self.center = CGPointMake(centerX, centerY);&#125;else if (btnY &gt; judgeSuperViewHeight)&#123;//按钮底部越界CGFloat y = superViewHeight - btnH * 0.5;self.center = CGPointMake(btnX, y);&#125;&#125;- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123;CGFloat btnWidth = self.frame.size.width;CGFloat btnHeight = self.frame.size.height;CGFloat btnY = self.frame.origin.y;CGFloat btnX = self.frame.origin.x;CGFloat minDistance = 2;//结束move的时候，计算移动的距离是&gt;最低要求，如果没有，就调用按钮点击事件BOOL isOverX = fabs(btnX - _touchBtnX) &gt; minDistance;BOOL isOverY = fabs(btnY - _touchBtnY) &gt; minDistance;if (isOverX || isOverY) &#123;//超过移动范围就不响应点击 - 只做移动操作[self touchesCancelled:touches withEvent:event];&#125;else&#123;[super touchesEnded:touches withEvent:event];&#125;if (self.center.x &gt;= self.superview.frame.size.width/2) &#123;[UIView animateWithDuration:0.5 animations:^&#123;//按钮靠右自动吸边CGFloat btnX = self.superview.frame.size.width - btnWidth;self.frame = CGRectMake(btnX, btnY, btnWidth, btnHeight);&#125;];&#125;else&#123;[UIView animateWithDuration:0.5 animations:^&#123;//按钮靠左吸边CGFloat btnX = 0;self.frame = CGRectMake(btnX, btnY, btnWidth, btnHeight);&#125;];&#125;&#125;- (void)dealloc &#123;&#125;@end]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NS_ENUM&NSOption]]></title>
    <url>%2F2015%2F04%2F26%2FNS-ENUM-NSOption%2F</url>
    <content type="text"><![CDATA[为啥要用枚举? 把别人看不懂的整数起一个别人看起来明白点的名字; 限制整数使用范围 C的枚举 123456enum ZKSwithType &#123;ZKSwithTypeOn,ZKSwithTypeOff&#125;;// 使用方式enum ZKSwithType swithType = ZKSwithTypeOn; iOS推荐写法, 使用更简单 123456789101112typedef NS_ENUM(NSInteger, ZKSwithType) &#123;ZKSwithTypeOn,ZKSwithTypeOff&#125;;// 使用方式ZKSwithType swithType = ZKSwithTypeOn;// iOS推荐写法等同于enum ZKSwithType &#123;ZKSwithTypeOn,ZKSwithTypeOff&#125;;typedef ZKSwithType ZKSwithType; NS_OPTIONS是啥 123456789101112131415typedef NS_OPTIONS(NSUInteger, ZKPosition) &#123;ZKPositionNone = 0,ZKPositionLeft = 1 &lt;&lt; 0,ZKPositionTop = 1 &lt;&lt; 1,ZKPositionRight = 1 &lt;&lt; 2,ZKPositionBottom = 1 &lt;&lt; 4,&#125;;// 等同于，只不过推荐写法更不容易出错typedef enum : NSUInteger &#123;ZKPositionNone = 0,ZKPositionLeft = 1,ZKPositionTop = 2,ZKPositionRight = 4,ZKPositionBottom = 8&#125; ZKPosition;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSAttributedString]]></title>
    <url>%2F2015%2F04%2F18%2FNSAttributedString%2F</url>
    <content type="text"><![CDATA[NSAttributedString NSAttributedString 用于实现富文本效果，可在同一字符串实现不同字体颜色大小等定制化 NSAttributedString继承自NSObject， 和NSString没有任何关系！！！ NSAttributedString 采用Key-Value方式设置富文本属性 NSMutableAttributedString是 NSAttributedString 的子类，可以通过insertAttributedString、appendAttributedString等方法拼接字符串 NSRange使用时必须注意注意再注意，很容易crash！PS:汉字和英文字母等都算1个 NSAttributedString的使用NSAttributedStringKey12345678910111213141516171819202122232425262728293031323334353637383940//字体，value是UIFont对象NSFontAttributeName //设置文本段落排版格式，value是NSParagraphStyle 对象NSParagraphStyleAttributeName//设置字体颜色，value是UIColor对象，默认值为黑色NSForegroundColorAttributeName //设置字体所在区域背景颜色，value是UIColor对象，默认值为nil, 透明色NSBackgroundColorAttributeName //字符连体，value是NSNumber 对象，0 表示没有连体字符，1 表示使用默认的连体字符NSLigatureAttributeName //设置字符间距，value是NSNumber ，正值间距加宽，负值间距变窄NSKernAttributeName //删除线，value是NSNumber，@(NSUnderlineStyle)NSStrikethroughStyleAttributeName //下划线，value是NSNumber，@(NSUnderlineStyle)NSUnderlineStyleAttributeName //描绘边颜色，value是UIColor,默认值为nilNSStrokeColorAttributeName //设置笔画宽度(粗细)，value是NSNumber 对象，负值填充效果，正值中空效果NSStrokeWidthAttributeName //设置阴影属性，value是NSShadow 对象 默认值为nilNSShadowAttributeName //设置文本附件,value是NSTextAttachment对象,常用于文字图片混排,如果附件文档数据指定nil, 那么系统将会默认指定为image对象作为值NSAttachmentAttributeName //链接，value是NSURL or NSString,UILabel不能用，可以用UITextViewNSLinkAttributeName //设置基线偏移值，value是NSNumber,正值上偏，负值下偏, 默认值是0NSBaselineOffsetAttributeName //下划线颜色，value是UIColor对象,默认值为nilNSUnderlineColorAttributeName //删除线颜色，value是UIColor，默认值为黑色NSStrikethroughColorAttributeName //设置字形倾斜度，value是NSNumber,正值右倾，负值左倾, 默认值是0NSObliquenessAttributeName //设置文本横向拉伸属性， value是NSNumber,正值横向拉伸文本，负值横向压缩文本NSExpansionAttributeName //设置文字排版方向，value是NSNumber，0 表示横排文本，1 表示竖排文本 在iOS中, 总是以横向排版NSVerticalGlyphFormAttributeName //设置文字书写方向，从左向右书写或者从右向左书写NSWritingDirectionAttributeName 设置属性方式 整段文字设置属性 initWithString: attributes: 12NSDictionary *attDic = @&#123;NSFontAttributeName:[UIFont systemFontOfSize:30], NSForegroundColorAttributeName:[UIColor redColor]&#125;;NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@&quot;hello, world&quot; attributes:attDic]; NSMutableAttributedString分块设置 1234NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];NSRange range = NSMakeRange(0, 5);[mAttStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:range];[mAttStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:range]; 先用NSAttributedString，再用NSMutableAttributedString去添加 123456// 减少了NSRange计算带来的问题NSAttributedString *helloAttStr = [[NSAttributedString alloc] initWithString:@&quot;hello&quot; attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:30], NSForegroundColorAttributeName:[UIColor redColor]&#125;];NSAttributedString *worldAttStr = [[NSAttributedString alloc] initWithString:@&quot;, world&quot; attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:20], NSForegroundColorAttributeName:[UIColor blackColor]&#125;];NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] init];[mAttStr appendAttributedString:helloAttStr];[mAttStr appendAttributedString:worldAttStr]; 几个特殊的设置 段落设置 123456789101112131415161718192021/*NSParagraphStyle的属性介绍alignment //对齐方式firstLineHeadIndent //首行缩进headIndent //缩进tailIndent //尾部缩进lineBreakMode //断行方式maximumLineHeight //最大行高minimumLineHeight //最低行高lineSpacing //行距paragraphSpacing //段距paragraphSpacingBefore //段首空间baseWritingDirection //句子方向lineHeightMultiple //可变行高,乘因数。hyphenationFactor //连字符属性*/NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];style.firstLineHeadIndent = 10;style.lineSpacing = 10;NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:@&quot;hello, world&quot; attributes:@&#123;NSParagraphStyleAttributeName:style&#125;]; 下划线或删除线 1234567891011121314151617/* 值为整型NSNumber，可取值为 NSUnderlineStyleNSUnderlineStyleNone // 无NSUnderlineStyleSingle //单条细线NSUnderlineStyleThick //单条粗线NSUnderlineStyleDouble //双条条细线NSUnderlinePatternSolid // 连续的实线NSUnderlinePatternDot // 虚线 例 －－－－－－NSUnderlinePatternDash // 破折号，比如这样：—— —— ——NSUnderlinePatternDashDot // 连续的破折号和点，比如这样：——.——.——NSUnderlinePatternDashDotDot // 连续的破折号、点、点，比如：——..——..——..NSUnderlineByWord // 字有线，空格没线*/NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];// 删除线和下滑显示设置方法一样[mAttStr addAttribute:NSStrikethroughStyleAttributeName value:@(NSUnderlineStyleSingle) range:NSMakeRange(0, 5)];// iOS10.3之后需加上以下代码[mAttStr addAttribute:NSBaselineOffsetAttributeName value:@0 range:NSMakeRange(0, 5)]; 阴影 12345NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];NSShadow *shadow = [[NSShadow alloc]init];shadow.shadowOffset = CGSizeMake(10, 10);shadow.shadowColor = [UIColor redColor];[mAttStr addAttribute:NSShadowAttributeName value:shadow range:NSMakeRange(0, 5)]; 超链接,不能用于UILabel 123456789101112131415161718- (void)viewDidLoad &#123;[super viewDidLoad];UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(50, 50, 50, 50)];[self.view addSubview:textView];textView.backgroundColor = [UIColor redColor];NSString *strLink = @&quot;百度一下&quot;;NSAttributedString *attStr = [[NSAttributedString alloc] initWithString:strLink attributes:@&#123;NSLinkAttributeName: [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]&#125;];textView.editable = NO;/* 签订协议, 指定代理人之后. 但点击链接时, 会回调协议方法 (- textView:shouldInteractWithURL:inRange:) */textView.delegate = self;textView.attributedText = attStr;&#125;- (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange &#123;NSLog(@&quot;url: %@&quot;, URL);return YES;&#125; 附件(图文混排) 12345678910111213141516/* 下面实现在百度两个汉字之间插入一个照片 */NSString *str = @&quot;百度&quot;;/*** 关于NSTextAttachment类的简单说明** NSTextAttachment 类有一个指定的初始化方法(- initWithData:ofType:), 需要指定附件文档的数据和附件文件的类型. 如果附件文档数据指定nil, 那么系统将会默认指定为image对象作为值. 因此, 也可以通过这个特性实现图文混排.* 下面就以附件为image对象来说明NSAttachmentAttributeName的使用.**/NSTextAttachment *attach = [[NSTextAttachment alloc] initWithData:nil ofType:nil];attach.bounds = CGRectMake(0, 0, 50, 50);attach.image = [UIImage imageNamed:@&quot;logo&quot;];NSAttributedString *strAtt = [NSAttributedString attributedStringWithAttachment:attach];NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:str];[mAttStr insertAttributedString:strAtt atIndex:1]; 文字书写方向 12345678910NSMutableAttributedString *mAttStr = [[NSMutableAttributedString alloc] initWithString:@&quot;hello, world&quot;];// //取值为包含NSNumber对象的数组. 从左向右书写或者从右向左书写.// // NSArray of NSNumbers representing the nested levels of writing direction overrides as// defined by Unicode LRE, RLE, LRO, and RLO characters. The control characters can be// obtained by masking NSWritingDirection and NSTextWritingDirection values. LRE:// NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE:// NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO:// NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO:// NSWritingDirectionRightToLeft|NSWritingDirectionOverride,[mAttStr addAttribute:NSWritingDirectionAttributeName value:@[@2] range:NSMakeRange(0, 11)];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlite常用语句]]></title>
    <url>%2F2015%2F04%2F07%2Fsqlite%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[SQL 对大小写不敏感 创建数据库 1create database dbname 删除数据库 1drop database dbname 创建新表 123// text 为col对应的数据类型，在iOS中建议都用text，// 因为第一数据量不是很多，不太影响效率；第二避免后端更改数据类型造成的越界等错误create table if not exists tablename(col1 text [not null] [primary key],col2 text [not null],..) 根据已有的表创建新表 12// 不要使用as方式，as方式没索引create table newTable like oldTable 删除新表 1drop table tabname 增加、修改一个列 123增加：alter table tabname add columnName columnType修改：alter table tabname modify columnName columnType删除：千万不要做，宁愿留着不用 查找select,注意iOS里value需要用‘%@’ 12345678910111213141516// 所有select * from table1//过滤掉someKey的重复值elect distinct field1 from table1 // 查找具体项 ,详见本文运算符select * from table1 where field1 = value1// 排序,默认asc升序，desc降序！select * from table1 order by field1 [desc] // 取到升序前5个。注意sqlite没有top语法，但可以通过 limit 5 来实现top效果select * from table1 order by field1 limit 5总数：select count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table1 插入 1插入：insert or replace into table1(field1,field2) values(value1,value2) 删除 1delete from table1 where 范围 更新 1update table1 set field1=value1 where 范围 运算符 123456789101112131415参考：https://www.runoob.com/sqlite/sqlite-operators.html算数运算符 + ，- ，* ，/ , %比较运算符 = , &gt; , &gt;= , &lt; , &lt;= // and 与关系select * from table1 where field1 &gt;= value1 and field2 = value2 // or 或关系select * from table1 where field1 &gt;= value1 for field2 = value2 // [不]在value1和value2之间select * frome table1 where field1 [not] between value1 and value2// [不]是NULL的值select * from table1 where field1 is [not] NULL// like模糊匹配 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用select * frome table1 where field1 like &apos;_ZK%&apos;// [不]在给定范围内select * frome table1 where field1 [not] in (60, 100) 参考：SQL语法]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级快速阅读]]></title>
    <url>%2F2015%2F03%2F30%2F%E8%B6%85%E7%BA%A7%E5%BF%AB%E9%80%9F%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[梳理逻辑脉络，明确宏观定位 面对任何改变，缘脑都是拒绝的，因此万事开头难！除非亲身经历新的行为模式对自己有益无害，缘脑才会做出积极反应！而且当跑步跑到最愉悦的时候放弃，下次更能激发自己去跑步 制作思维导图，梳理出清晰的脉络！制作脑图的那点时间是非常值得，所以一定要做！ 花5分钟快速浏览全书！得到的粗略印象有助于让缘脑感觉更加安全，也能大概知道哪些东西在哪里！在快速浏览过程中，我们的注意力主要集中在标题、副标题、插图、表格以及被加粗或斜体的关键字上 只有同时调动自己的左脑（左脑思维指的是分析思维）与右脑（右脑思维指的是有想象力和创造性的空间与形象思维），激活两种思维模式的时候，才能达到最佳的学习效果！ 主动阅读再思考，学习新知识之前先激活既有的知识网络（即先想想以前的知识有什么用），要记住一条信息，必须将其与既有的知识网络结合在一起，与其从头开始纠结于细节问题，还不如从整体下手，由宏观到微观逐步深入学习。 最关键最难熬的其实是在同一水平层次上停滞不前的那段时间，即平台期。这段时间正是大脑建立神经连接的关键期，即平台期的坚持也是一直在进步的！ 每个人从头开始学习新技能，都要经历4个阶段：A，虽无能力，却也尚未萌生明确的意识，即“不知己不能”；B，意识到自己某种能力的缺乏，即“知己不能之”；C，有能力，即“知己己能之”；D，意识不到自己有能力，即“不知己能之” 只要我们不断练习，总有一天这种新的技能会习惯成自然，变成我们潜意识下的行为方式。 阅读时候一定要学会提问，提问方向很多，例：A，5W1H；B，段落层面，结构；C，主体，矛盾利益，换位思考；D，SWOT；E，内因外因；F，和我关系，有什么用 等等 知道什么时候用速读，什么时候用精读，这个需要慢慢的练习！分块阅读，每块设定目标，当然要通读。。。 无聊的，没有插图和重点的密密麻麻的书，是练习速读的好材料！ 可以计算自己的阅读速读，但仅仅有助于控制自己的阅读速读。 逐字逐句阅读法常见问题：A，低效阅读，越是读的慢的越是理解不充分，捕捉几个关键字就好；B,无法集中注意力，非常慢的逐字逐句阅读中其实在潜意识中开过的小差数不胜数，例：晃脑袋，伸懒腰，揉眼睛等等，大脑处理东西很快，当阅读速度赶不上大脑处理速度时就会开小差；C，视线的下意识游移，双眼天生就善于捕捉动态的东西，而我们自己是感觉不到的，就像眨眼绝大多数是感觉不到的，段落划分最好让眼睛一下就能看完一整行最高效，换行时间占到了整个阅读的三分之一；、 一种非常有效的辅助阅读方法：用铅笔或指尖辅助阅读，还记得眼睛会不自觉地捕捉运动的东西吧，而文字是静态的。而且用手介入了阅读，从感官上就感觉到了自己在读书，也就是仪式感。。。 逐步扩宽视线范围，首先，把视线聚焦到一行的第一个字，然后对焦第二个字，看看能否看清第一个字，然后聚焦第三个字，再看第一个字。。。。练习方法：用手指辅助时，试着从每行的第二个，三个字开始指引，而且提前一两个字把手指挪到第二行，这样为了读入剩余的信息，你的视线范围自然也会随之扩展。 一目十行的3-2-1练习：平时阅读的速度，阅读三分钟，做个标记，然后重复阅读直到2分钟阅读完这段篇幅，在重复阅读直到1分钟阅读完这段篇幅。这个练习要点在于速度，理解是次要的，但平时阅读正好相反！这个练习就是让大脑逐渐适应越来越快的阅读速度，当你以后以充分理解为前提而阅读时，你的大脑对速度的的感知就有了一个新的基准。 整行阅读练习，不透明白纸完全掩盖住某一行内容，然后快速向下拖动一行，紧接着马上遮回去，如此反复几次，越开越好，几次之后闭上眼睛尝试回放看到的画面，尝试回放整行内容 三级跳练习：是3-2-1练习的辅助方法，画几条线，在阅读的时候有意识的让自己的视线停留在这三条竖线上面，熟练以后可以只画两条 一定要画思维导图，思维导图符合大脑神经原理，其实作者把自己的思维转化为线性的文字，而读者从线性的文字中抽象出负责的思维导图，这才是有效的沟通呀！传统的类似这样的记笔记，其实是按照书中的顺序记录作者的观点，而制作思维导图则更具有调整性，文章脉络，提炼文字关键字等等都在主动思考，更能理解与记忆！最主要是省时间，在传统的线性笔记里面90%的文字都是多余的，还不如直接画图省事！！！！！ 分类，按照一定节奏重复复习，组织关键词，产生联想更有助于记忆由于理解！一张图等于100个文字，且更容易理解！对特殊符号，颜色，大脑更容易集中注意力记忆 制作视觉卡牌的三个步骤：A，把握整体行文结构，记住任何一种设计都没有对错之分；B，抽取关键词，尽量避免摘抄大量完整的句子 画出要点间的逻辑关系。脑图不只是树形的，还可能是网状的，这就麻烦了，意味着叶子与叶子之间也会有逻辑问题，看来非得用专业的思维导图才行，脑图一定要横版 释放压力的技巧：自我暗示训练和渐进式肌肉放松；运动疗法；慢慢的深呼吸，慢慢调整节奏和摒气；倾听轻音乐； 3-2-1升级版：3分钟阅读，2分钟总结层次要点；2分钟阅读，1分钟总结层次要点 倒S曲线式快速浏览，慢慢读不一定懂得更多，简单的说就是一次读一行变成一次读两行，读三行等等，阅读完一定要记得弄脑图 第一天适应阅读，第二天拓宽视线范围，第三天练习3-2-1。。。第二周开始使用脑图再练习一周 理解是记忆的重要前提，联想建立在知识网络基础上，想要记住某些东西，一定要充分调动自己的五官，每个人都有自己的主导感官，我是听力，不过多多练习总是能调动更多的感官的 在学习总不断中断又继续的过程中消耗的精力是惊人的。学习控制自己的感官渠道:GEWAR , G：积极的心态；E，放松的状态；W，充足的动力；R：及时复习；A，集中注意力，需要随时随地的训练自己的感官；最好把枯燥的知识改编成有趣的故事 自律分成三部分：明确目标，坚持不懈和自我控制 避免一字一句默念的习惯 合理安排学习时间，学习时间越长获得知识越少！真正的学习理解并非与记忆同步，而是在休息的时候完成的，也就是连续学习40~50分钟以后，大脑已饱和，用一分钟快速总结消化吸收，快速梳理结构，然后休息5分钟，！所谓休息就是让大脑彻底放松，而不是换一个学科，换一个知识！一切关键在于不要给大脑输入新的东西！5分钟后只要稍微回忆一下，就可以开始继续学习了！ 突发情况，例如：如果手头正在写文章，突然来了电话，怎么办？最好是先稍微总结梳理一下做到哪一步了，然后在接电话处理电话的事情！最好写个便签，随时注意切换工作状态，免得太忙的时候忘了 时间管理：A，订立具体明确的目标！都说谁知道5年以后世界是什么样子，但总是要想好自己怎么过的，我们一路奋战不是为了改变世界，只是不让世界改变我们！任何一段都是要有 短 中 长 期目标，不要急功近利！把自己的想法一字一句的记下来，把目标放在眼前，否则内心的惰性就会逐渐占据上风！不断地自我心理暗示目标，身体就会随之而动！设定目标原则：SMART,具体，可衡量，积极，现实和有时间限制； B，记录时间日记，抓住时间窃贼！先记录一下每天都做什么？花多长时间？先认清楚自己是什么样子再说，一定要真实，不管做的是应该还是不应该，浪费不浪费，现在要做的事情就是每天花多少时间都在干啥，而不是要马上立即开始做什么！ C，制定每日计划，利用前一天晚上睡觉前制定计划。大脑预演一遍，创造心理的潜在安全感，从而提高睡眠质量！D，列出重要的事务，每个任务都要问能不能朝目标更进一步，如果不能，尽量不做，即便必须要做也要尽量少的花费时间；E,分清事务轻重缓急，谨记28定律，只要一开始就完成最重要最麻烦的事情，剩下的事情就很简单了！四象限法则，而且一定要预留足够的时间，每天最后要检查完成状态，并总结！ 前进，前进，不择手段的前进！ 系统复习法打造超级记忆！第一次复习，10分钟；第二次，一天；第三次，一个星期；第四次复习，一个月；第五次复习，6个月；而且最好学习当天晚上复习一遍，至少4分之一的时间用来复习，脑图能提高复习效率！记忆文件夹复习法，例：周一1，周一2，周二1，周二2等，所有标记为1的都是前一天复习的内容（第二次复习），所有标记为2的都对应下一周复习内容（第三次复习）]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nil&id&NSObject]]></title>
    <url>%2F2015%2F03%2F17%2Fnil-id-NSObject%2F</url>
    <content type="text"><![CDATA[nil：空对象,发送消息安全 12// 没有内存地址NSString *str = nil; NSNull：值为 空 的对象 12// 内存地址为 Ox101zce9ea8NSNull *null = [NSNull null]; NULL：C的的空指针 12// p是空指针int *p = NULL; id 可指向任何OC类型的指针,而 void * 表示C语言中可指向任何类型的指针 12// str2 内存中就是NSString类型id str2 = @&quot;id一个指针,可指向任何OC类型,且不用加 * 号&quot;; NSObject是OC的基类,但并不是所有OC对象都继承NSObject,例如NSProxy 123// 声明一个NSObject类型的对象,内存地址为Ox600000c2c300NSObject *ob = [[NSObject alloc] init]; NSOjbect还可以是协议,只不过同名罢了 1id&lt;NSObject&gt; obdelegate; // 表示一个遵循NSObject协议的对象]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何阅读一本书]]></title>
    <url>%2F2015%2F03%2F01%2F%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[1 阅读的层次1.1 阅读的活力与艺术 泛滥的资讯属于被动阅读（是不是很有意思，明明是自己没事干，刷 刷 刷 刷出来的），用不着自己思考 阅读越主动，效果越好。参与其中，思考技巧。 一看就懂的属于资讯，看了半天不动的是为了理解。增强理解能力是核心。 1.2 阅读的层次 基础阅读：认识字，能把文段串起来。 检视阅读：一定时间内抓重点，检视目录，最起码知道书叫什么？架构？哪些部分？ 分析阅读：全盘阅读，完整阅读。一种专注活动，要抓紧阅读，直到这本书成为他自己为止。 高层次阅读：主题阅读，涉及面广，读的书多 1.3 基础阅读1.4 检视阅读 有系统的略读或粗读，事实上即便应该精读的书开始也要略读粗读。 略读建议： A，先看书名，快速看序，特别注意副标题等相关说明； B，仔细阅读目录页； C，如果书中附有索引，也要检阅一下，可以快速评估书论述范围，重点引用可能跟论点论据有关； D，如果那是本包着书衣的新书，不妨读一下出版者的介绍。自我介绍都不行，瞎吹，就可以放弃了； E，从你对一本书的目录很概略，甚至有点模糊的印象当中，开始挑几个看来跟主题嘻嘻相关的篇章来看，如果这些篇章在开头或者结尾有摘要说明，就要仔细的阅读这些说明； F，最后一步，把书打开来，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，就用这样的方法把全书翻过一遍，随时寻找主要论点的讯号，留意主题的基本脉动。最重要的是，不要忽略最后的两三页，就算最后有后记，一本书的最后结尾的两三页也还是不可忽视的。 粗浅的阅读：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂得地方不停下来查询或思索。不要被一个看不懂的地方阻挠或泄气，先读一遍再说。 阅读的速度，许多书其实连略读都不值得的，另外一些书只需要快速读过就行了。核心就是，要知道什么时候用什么速度是恰当的。慢不该慢到不值得，快不该快到有损于满足于理解。 逗留与倒退，简单的说就是快速看书，感觉看不清而暂停或回头重看，这是坏习惯！！！事实上大脑可以在“一瞥”间掌握一个句子或段落，只要眼睛能够提供足够的资讯。 训练方法：将大拇指与食指，中指合并在一起，用这个“指针”顺着一行一行的字移动下去，速度要比你的眼睛感觉还要快一点，强迫自己的眼睛跟着手部的动作移动。一旦你的眼睛跟着手部移动，你就能读到那些字句了。 理解的问题，一旦你能跟随自己的手指阅读，就很难打瞌睡，胡思乱想了 1.5 如何做一个自我要求的读者 主动阅读的基础，关于一本书，你一定要提出四个主要问题： A，整体来说，这本书到底在谈些什么？一定要想办法找出主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来； B，作者细部说了什么，怎么说的？一定要想办法找出主要的想法，声明和论点，这些组合成作者想要传达的特殊讯息； C，这本书说的有道理吗？是全部有道理还是部分有道理？ D，这本书跟我有什么关系？ 任何一种超越基础阅读的阅读层次，核心就在你要努力提出问题，然后尽可能的找到答案。 如何让一本书真正属于你自己 最好的方式就是写下来，做笔记，最好有一套自己的标注习惯，笔记习惯！ 还有一个办法，脑图！ 培养阅读习惯：慢慢来 2 阅读的三个层次：分析阅读2.1 一本书的分类 书籍分类的重要性，分析阅读的第一个规则可以这么说，你一定要知道自己在读的是哪一类书，而且越早知道越好，最好在i开始阅读之前就先知道。 区分实用书和理论书，首先要学习去怀疑一切；传统理论书被分类成历史、科学和哲学（如果一本理论书超越你日常生活经验，那就是科学书）等等 2.2 透视一本书 分析阅读的第二个规则：实用一个单一的句子，或最多几句话（一小段话）来叙述整本书的内容。好的作者，总是在帮读者整理，而且最重要的是总结只有好坏之分没有对错之别。 第三个规则可以说成：将书中重要的篇章列举出来，说明他们如何按照顺序组成一个整体的架构。 按照顺序与关系，列出全书的重要部分，将全书的纲要拟出来后，再将各个部分的纲要也一一列出。自己列的提纲不一定与作者列的一样，只是根据自己的理解自己总结的东西罢了。 千万不要在读不出头绪的时候，就认为是自己的问题，也有可能是作者本来就很烂呀！但还是要尽量读出点东西来！ 找出作者在问的问题，或作者想要解决的问题。 2.3 与作者找出共通的词义。 规则四：找出共通的词义 规则五：找出重要的单字，透过它们与作者达成共识。一个字可能表达很多意思，一定要根据上下文推敲此字义和作者要表达的是否一致。找出关键字，作者使用的大多数字都不重要。 规则六：将一本书中最重要的句子圈出来，找出其中的主旨。主旨是表达观点或知识。 规则七：从相关文句的关联中，设法架构出一本书的基本论述。发现读不懂的句子，找出组成关键句的文字，找到顺序，有始有终。“用你自己的话来说”是测验你懂不懂一个句子的主旨的最佳方法。如果可以找出书中说明重要论述的段落。 规则八：找出作者在书中想要解决的主要问题 2.4 批判性阅读 规则九：要求读者先完整的了解一本书，不要急着开始评论 规则十：恳请读者不要争强好辩或盲目反对，谨记争论是在教导和受教，需要很大的耐心 规则十一：要求读者要为自己的不同意见找到理论基础。要区分是对作者还是对书有争论 2.5 怎么说服人 在读者说出：“我了解，但我不同意”之后，他可以用一下概念想作者说明： A，你的知识不足； B，你的知识有错误； C，你不合逻辑，你的推论sh无法使人信服； D，你的分析不够完整。 2.6 不要被别人影响 不建议外在阅读，简单的说就是什么书评，文凭啥的尽量少看，自己去思考自己去想！导读摘要可以看，但也尽量少看！根本原因是，这些东西不一定符合作者的意思，不一定是对的，不一定是完整的！ 2.7 如何阅读实用型的书 任何实用书都不能解决该书所关心的实际问题，只能靠行动来解决！ 这书谈什么？目的？真实？与我何干？如果理解且接受了，那就行动吧！ 2.8 简单的说就是如何做阅读理解第二十章 主题阅读 先检视阅读一下，确定书和主题是否有关，接下来五步 找到相关章节 带着共识 理清问题 界定议题 分体讨论]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIViewController的生命周期]]></title>
    <url>%2F2015%2F02%2F22%2FUIViewController%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[init—&gt;loadView—&gt;viewDidLoad—&gt;viewWillApper—&gt;viewDidApper—&gt;viewWillDisapper—&gt;viewDidDisapper—&gt;—&gt;dealloc VC的生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 非storyBoard(xib或非xib)都走这个方法,一般用不着，不要初始化view- (instancetype)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil &#123;if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) &#123;&#125;NSLog(@&quot;%s&quot;, __func__);return self;&#125;// storyBoard走这个方法，不要初始化view- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;if (self = [super initWithCoder:aDecoder]) &#123;&#125;NSLog(@&quot;%s&quot;, __func__);return self;&#125;// xib 加载完成，可以直接用xib的连线view了- (void)awakeFromNib &#123;[super awakeFromNib];NSLog(@&quot;%s&quot;, __func__);&#125;// 加载视图，不应该直接被调用，在UIViewController对象的view被访问且为空的时候由系统调用- (void)loadView &#123;// 没有调用superself.view = [[UIView alloc] initWithFrame:[UIScreen mainScreen].bounds];self.view.backgroundColor = [UIColor redColor];NSLog(@&quot;%s&quot;, __func__);&#125;// 视图控制器中的视图加载完成，只调用一次- (void)viewDidLoad &#123;[super viewDidLoad];NSLog(@&quot;%s&quot;, __func__);// 可用 isViewLoaded 判断某个VC是否调用了viewdidload方法&#125;// VC即将可见，不稳定状态，不要做复杂或耗时操作- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];NSLog(@&quot;%s&quot;, __func__);&#125;// VC的view调layoutSubviews之前- (void)viewWillLayoutSubviews &#123;[super viewWillLayoutSubviews];NSLog(@&quot;%s&quot;, __func__);&#125;// VC的view调layoutSubviews之后- (void)viewDidLayoutSubviews &#123;[super viewDidLayoutSubviews];NSLog(@&quot;%s&quot;, __func__);&#125;// VC已经全部展示在屏幕上- (void)viewDidAppear:(BOOL)animated &#123;[super viewDidAppear:animated];NSLog(@&quot;%s&quot;, __func__);&#125;// 视图将要消失 dismissed, covered or otherwise hidden- (void)viewWillDisappear:(BOOL)animated &#123;[super viewWillDisappear:animated];NSLog(@&quot;%s&quot;, __func__);&#125;// 视图已经消失 dismissed, covered or otherwise hidden- (void)viewDidDisappear:(BOOL)animated &#123;[super viewDidDisappear:animated];NSLog(@&quot;%s&quot;, __func__);&#125;// 出现内存警告 - (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];NSLog(@&quot;%s&quot;, __func__);&#125;// 视图被销毁- (void)dealloc &#123;NSLog(@&quot;%s&quot;, __func__);&#125;// 注意：viewWillUnload和viewDidUnload 已经被废弃掉了 参考 https://developer.apple.com/documentation/uikit/uiviewcontroller?language=objc]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理XCode]]></title>
    <url>%2F2015%2F02%2F09%2F%E6%B8%85%E7%90%86XCode%2F</url>
    <content type="text"><![CDATA[转载自http://www.cocoachina.com/bbs/read.php?tid=181211 硬盘空间吃紧，清了两三次xcode，无奈没过多长时间又没空间了！最主要的是，查了两三次的清理路径，还是记不住！在此，摘抄下来，以便日后查阅 移除对旧设备的支持 影响：可重新生成；再连接旧设备调试时，会重新自动生成。我移除了4.3.2, 5.0, 5.1等版本的设备支持。 路径：~/Library/Developer/Xcode/iOS DeviceSupport 移除旧版本的模拟器支持 影响：不可恢复；如果需要旧版本的模拟器，就需要重新下载了。我移除了4.3.2, 5.0, 5.1等旧版本的模拟器。 路径：~/Library/Application Support/iPhone Simulator 移除模拟器的临时文件 影响：可重新生成；如果需要保留较新版本的模拟器，但tmp文件夹很大。放心删吧，tmp文件夹里的内容是不重要的。在iOS Device中，存储空间不足时，tmp文件夹是可能被清空的。 路径：~/Library/Application Support/iPhone Simulator/6.1/tmp (以iOS Simulator 6.1为例) 移除DerivedData 影响：可重新生成；会删除build生成的项目索引、build输出以及日志。重新打开项目时会重新生成，大的项目会耗费一些时间。 路径：~/Library/Developer/Xcode/DerivedData]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App的生命周期]]></title>
    <url>%2F2015%2F01%2F31%2FApp%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[应用程序的状态 Not running（未运行），程序没启动 Inactive（未激活），程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态 Active（激活），程序在前台运行而且接收到了事件。这也是前台的一个正常的模式 Backgroud（后台），程序在后台而且能执行代码，大多数程序进入这个状态后会在在这个状态上停留一会。时间到之后会进入挂起状态(Suspended)。有的程序经过特殊的请求后可以长期处于Backgroud状态 Suspended（挂起），程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为前台程序提供更多的内存。 下图是程序状态变化图： 各个程序运行状态时代理的回调：12345678910111213141516// 在App启动时调用表示应用加载进程已经开始,常用来处理应用状态的存储和恢复- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions// 告诉代理启动基本完成程序准备开始运行- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions// 当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了- (void)applicationWillResignActive:(UIApplication *)application// 当应用程序入活动状态执行，这个刚好跟上面那个方法相反- (void)applicationDidBecomeActive:(UIApplication *)application// 当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可- (void)applicationDidEnterBackground:(UIApplication *)application// 当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。- (void)applicationWillEnterForeground:(UIApplication *)application// 当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置UIApplicationExitsOnSuspend的键值。- (void)applicationWillTerminate:(UIApplication *)application// 当程序载入后执行- (void)applicationDidFinishLaunching:(UIApplication*)application 注意问题 iOS8中,App会在根控制器初始化后调用viewDidAppear方法之后才会调用applicationDidBecomeActive 而在iOS7中,App在调用applicationDidBecomeActive方法后才会调用根控制器的viewDidAppear 参考 https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html iOS应用程序生命周期(前后台切换,应用的各种状态)详解]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[index 2 beyond bounds [0 .. 0]]]></title>
    <url>%2F2015%2F01%2F12%2Findex-2-beyond-bounds-0-0%2F</url>
    <content type="text"><![CDATA[结论 空数组就提示empty array [x .. y] x 表示起始索引都是0，y 表示终止索引即count-1 例如 [0 .. 0] 代表数组的起始和终止索引都是0，即一个元素； [0 .. 1]代表数组包含两个元素；[0 .. 2]代表数组包含三个元素 由来&emsp;&emsp;release包突然有个偶现的crash，查看crash日志发现index 2 beyond bounds [0 .. 0]，想当然的以为 空数组 数组越界，然后就费心心思的排查什么情况下会出现空数组！然而折腾半天也没发现会出现空数组的情况，假数据，打log都试了一遍，最少也包含一个对象！最后还是归根到Crash日志上仔细排查，经过试验才发现对 [0 .. 0]理解错了！学艺不精，害人不浅呀！特此记录 实验 空数组, 注意提示的 empty array 123456// 空数组NSMutableArray *photos = [NSMutableArray array];NSLog(@&quot;--- %@&quot;,photos[0]);// Crash// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 0 beyond bounds for empty array&apos; 数组只有一个对象，注意提示 [0 .. 0] 1234567// 数组，包含一个对象NSMutableArray *photos = [NSMutableArray array];[photos addObject:@0];NSLog(@&quot;--- %@&quot;,photos[1]);// Crash// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 1 beyond bounds [0 .. 0] 数组只有两个对象，注意提示 [0 .. 1] 12345678// 数组，包含两个对象NSMutableArray *photos = [NSMutableArray array];[photos addObject:@0];[photos addObject:@1];NSLog(@&quot;--- %@&quot;,photos[2]);// Crash// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 2 beyond bounds [0 .. 1] 数组只有三个对象，注意提示 [0 .. 2] 123456789// 数组，包含三个对象NSMutableArray *photos = [NSMutableArray array];[photos addObject:@0];[photos addObject:@1];[photos addObject:@2];NSLog(@&quot;--- %@&quot;,photos[4]);// Crash// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 4 beyond bounds [0 .. 2]]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2014%2F12%2F26%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018修改支持有道云笔记格式 斜体 删除线 ++下划线++ ==黄色高亮==1级标题2级标题3级标题4级标题5级标题6级标题 分割线 引用 真理就是民兵站在白杨树下迎面吹来一阵东风 分类 二级分类 三级分类 第二分类 第一 第二 待办事项 已完成 html标签 &emsp;&emsp;直接兼容html标签 超链接流程图、时序图和甘特图 mermaid参考 123456// 直接写代码int main(int argc, char * argv[]) &#123;@autoreleasepool &#123;return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125;&#125; 图片 表格header 1 | header 2—|—row 1 col 1 | row 1 col 2row 2 col 1 | row 2 col 2 数学公式1E = mc^2 流程图，练手各种图形和线 TB - top bottom（自上而下）,LR - left right（从左到右）123456789101112graph TBidA(开始) --描述--&gt; idD&#123;判断&#125;idD --YES--&gt;idE[过程2]idD --NO--&gt;idF[异常]idF --&gt; idZ(结束)idE --&gt; idZidF -.虚线辅助.-&gt; idC((没用节点))subgraph 子流程名idC ==&gt; idG[do something]idG ==啥意思==&gt; idM&gt;这是啥图]end 时序图 12345678910sequenceDiagramA-&gt;&gt;B: How about Baidu??B--&gt;&gt;A: baidu is Great!note left of B: B左边的注释note right of A: A右边的注释participant Cloop ask myselfC-&gt;&gt;C: is baidu good？ endnote over C:I am alone 甘特图123456789ganttdateFormat YYYY-MM-DDsection 设计已完成:done,id1, 2014-01-01, 5d正执行:active, idUI,after id1, 2dsection 开发待修正:crit, 2014-01-07, 9dsection 测试原计划: 2014-01-02, 9d]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIImage技巧]]></title>
    <url>%2F2014%2F11%2F28%2FUIImage%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[PNG &amp; JPEG JPEG可以非常好的压缩图片，但是JPEG是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像gzip这样压缩算法的限制，但是压缩算法也更复杂。相对来说，JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间。 对于PNG来说它的压缩是无损的，所以图片相对JPEG来说也大很多，加载时间会比JPEG更长，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。 加载 imageNamed 第一次加载慢点，有缓存，缓存什么时候清除由系统决定 1UIImage *image = [UIImage imageNamed:@&quot;logo&quot;]; imageWithContentsOfFile 用于一次性的本地图片，无缓存，加载快点 12NSString *filePath = [NSString stringWithFormat:@&quot;%@/%@.png&quot;, [[NSBundle mainBundle] resourcePath], @&quot;logo&quot;];UIImage *image = [UIImage imageWithContentsOfFile:filePath]; 内存消耗计算 与分辨率无关，和宽高有关1Width x Height x 4 / 1024 / 1024 （M） contentMode理解1234567891011121314151617/*UIViewContentModeScaleToFill, //图片根据imageView的大小显示，图片会变形UIViewContentModeScaleAspectFit, // 按比例压缩，图片大边缩小策略即图片总能完全显示，空白部分透明UIViewContentModeScaleAspectFill, // 按比例压缩，图片小边放大策略即图片总是显示不完全，图片居中//下面的属性都是不会拉伸图片的UIViewContentModeRedraw, //调用setNeedsDisplay 方法时,就会重新渲染图片UIViewContentModeCenter,//显示图片中间UIViewContentModeTop, //显示图片顶部UIViewContentModeBottom, //显示图片底部UIViewContentModeLeft, //显示图片左边UIViewContentModeRight, //显示图片右边UIViewContentModeTopLeft, //显示图片左上UIViewContentModeTopRight, //显示图片右上UIViewContentModeBottomLeft, //显示图片左下UIViewContentModeBottomRight, //显示图片右下*/imageView.contentMode = UIViewContentModeScaleAspectFit;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block基本使用]]></title>
    <url>%2F2014%2F11%2F09%2FBlock%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Block是啥？ 个人理解：就是一个函数指针，java的代码块 生命周期：block里面代码执行完 参数捕获：block能捕获外部变量，并copy到block内部使用！用__block可破 循环引用：block捕获了self，self又强持有block！用weak strong可破 使用方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#import &quot;ViewController.h&quot;// 声明一种block类型，以后拿来直接用typedef int(^block4Type)(int, int);@interface ViewController ()// 注意block5即是block的“函数名”，也是属性的属性名@property (nonatomic, copy) int(^block5)(int, int);@property (nonatomic, copy) NSString *str;// 当然也可使用block4Type类型@property (nonatomic, copy) block4Type block6;//@property (nonatomic, copy) void(^cycleBlock)(NSString *title);@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view.// 有参数有返回值int (^block1)(int, int) = ^(int num1, int num2) &#123;return num1 + num2;&#125;;NSLog(@&quot;block1：%d&quot;,block1(5,4));// 无返回 voidvoid (^block2)(int, int) = ^(int num1, int num2) &#123;NSLog(@&quot;block2：%d&quot;,num1 + num2);&#125;;block2(4,5);// 注意没参数也要有括号，实现部分有没有参数括号都行int (^block3)() = ^ &#123;return 3;&#125;;NSLog(@&quot;block3：%d&quot;,block3());// 使用声明的block类型，初始化一个block实例block4Type block4 = ^(int num1, int num2) &#123;return num1 + num2;&#125;;NSLog(@&quot;block4：%d&quot;,block4(5,4));// Block作为属性self.block5 = ^(int num1, int num2) &#123;return num1 + num2;&#125;;NSLog(@&quot;block5：%d&quot;,self.block5(5,4));self.block6 = ^(int num1, int num2) &#123;return num1 + num2;&#125;;NSLog(@&quot;block6：%d&quot;,self.block6(5,4));// block捕获外部变量int total7 = 4;int (^block7)(int) = ^(int num)&#123;// total7 += num; // 报错，提示需要__blockreturn total7 + num;&#125;;NSLog(@&quot;block7：%d, total:%d&quot;,block7(4), total7);//__block int total8 = 4;int (^block8)(int) = ^(int num)&#123;total8 += num;return total8;&#125;;NSLog(@&quot;block8：%d, total:%d&quot;,block8(4), total8);// 以下代码会报错误： Capturing &apos;self&apos; strongly in this block is likely to lead to a retain cycle// self.cycleBlock = ^(NSString *title) &#123;// self.title = [NSString stringWithFormat:@&quot;hello, %@&quot;,title];// &#125;;// self.cycleBlock(@&quot;world&quot;);// 破解循环引用__weak typeof(self)weakSelf = self;self.cycleBlock = ^(NSString *title) &#123;// __strong typeof(weakSelf)self = weakSelf; //如果你需要强制有self实例，需打开此注释weakSelf.title = [NSString stringWithFormat:@&quot;hello, %@&quot;,title];&#125;;self.cycleBlock(@&quot;world&quot;);&#125;@end 同步？异步？ 试验11234567NSLog(@&quot;第一行&quot;);void (^firstBlock)(void) = ^&#123;sleep(3);NSLog(@&quot;第二行&quot;);&#125;;firstBlock();NSLog(@&quot;第三行&quot;); &emsp;&emsp;结论：block是同步的，先执行为2，再执行3 试验212345678910111213141516NSLog(@&quot;第4行&quot;);dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;NSLog(@&quot;第5行&quot;);void (^secondBlock)(void) = ^&#123;sleep(3);NSLog(@&quot;第6行&quot;);&#125;;secondBlock();NSLog(@&quot;第7行&quot;);dispatch_async(dispatch_get_main_queue(), ^&#123;sleep(3);NSLog(@&quot;第8行&quot;);&#125;);NSLog(@&quot;第9行&quot;);&#125;);NSLog(@&quot;第10行&quot;); &emsp;&emsp;结论：dispatch_async是异步的]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alpha&Hidden&Opaque]]></title>
    <url>%2F2014%2F10%2F31%2FAlpha-Hidden-Opaque%2F</url>
    <content type="text"><![CDATA[Alpha alpha是不透明度，属性为浮点类型的值，取值范围从0到1.0，表示从完全透明到完全不透明，默认1.0完全不透明。 alpha值会影响到UIView跟其所有subview，如果当前View的alpha为0，则当前View和所有的subview都看不到了 在动画块中设置alpha具有动画效果 当前view的alpha为0时，当前UIView会从响应者链中移除，而响应者链中的下一个会成为第一响应者。 Hidden Hidden属性为BOOL值，用来表示UIView是否隐藏，默认值是NO即不隐藏，隐藏为YES！ 当Hidden为YES时，当前的UIView和subview都会被隐藏，而不管subview的hidden值为多少 当Hidden为YES时，当前UIView会从响应者链中移除，而响应者链中的下一个会成为第一响应者 在动画块中设置hidden没有动画效果 复杂交互中，可以先加载所有subViews，然后根据状态来设置某个view的hidden属性，避免重复开销 Opaque opaque也是表示当前的UIView的不透明度,默认YES,官方文档:alpha为1,则opaque为YES；alpha小于1，opaque为NO，但是如果反了，产生的后果是不可预料的 1An opaque view is expected to fill its bounds with entirely opaque content—that is, the content should have an alpha value of 1.0. If the view is opaque and either does not fill its bounds or contains wholly or partially transparent content,the results are unpredictable. You should always set the value of this property to NO if the view is fully or partially transparent. 当opaque属性被设为YES时，GPU就不会再利用图层颜色合成公式去合成真正的色值，节省性能]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MRC和ARC混编]]></title>
    <url>%2F2014%2F10%2F19%2FMRC%E5%92%8CARC%E6%B7%B7%E7%BC%96%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp; OC中提供了两种内存管理机制MRC（MannulReference Counting）手动引用计数；ARC （Automatic Reference Counting）自动引用计数。 &emsp;&emsp; Xcode4.1及其以前版本只有MRC，我们必须手动管理内存，比如要手动retain、release、autorelease等 &emsp;&emsp; Xcode4.1后的版本可以使用ARC，让系统自己管理内存。 &emsp;&emsp; ARC 和MRC 混编怎么处理？ 如果你的工程使用的MRC 模式，则为 ARC 模式的代码文件加入 -fobjc-arc 标签。 如果你的工程使用的是 ARC 模式，则为MRC 模式的代码文件加入 -fno-objc-arc 标签。 &emsp;&emsp; 位置：打开工程找到target -&gt; Build Phases -&gt; Compile Sources -&gt; 对应的 .m -&gt; 双击CompliperFlags 添加 -fobjc-arc （ARC模式） -fno-objc-arc（MRC模式）-&gt; 保存]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为啥叫发消息]]></title>
    <url>%2F2014%2F10%2F08%2F%E4%B8%BA%E5%95%A5%E5%8F%AB%E5%8F%91%E6%B6%88%E6%81%AF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;从Java转到OC，遇到一个以前不太在意的问题：发消息还是函数调用？刚开始自学的时候认为 [NSObject alloc] 就是函数调用，跟int ret = max(a, b); 或者 System.out.println(“Hello World!”); 没区别，只不过是换汤不换药，换了个马甲而已！直到今天，被同事郑重其事的告诉我：不是函数调用，而是向某某发消息！&emsp;&emsp;究其原因，可能如下： 函数调用是编译时已经确定的，接收方肯定能做出反应；而发消息是编译时只是调用objc_msgSend方法，运行时再确定接收方是否能做出反应 12// objc_msgSend(receiver, selector, arg1, arg2, ...) 函数调用是写死的关系，而发消息时，接受者可以选择转发等操作让别人干活 发消息是不是等同于广播（OC的通知）? 个人认为不是，广播的接受者可以选择无视，也可以选择执行；而OC的发消息，接受者只能选择执行，交给别人执行或者Crash &emsp;&emsp; 以上就是对发消息的个人理解]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[atomic和nonatomic区别]]></title>
    <url>%2F2014%2F10%2F03%2Fatomic%E5%92%8Cnonatomic%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[区别 atomic nonatomic 默认的 非默认，需手写 速度慢，耗性能 速度快，不太耗性能 线程不安全 线程不安全 &emsp;&emsp; atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。如果你自己写 getter/setter，那 atomic/nonatomic/retain/assign/copy 这些关键字只起提示作用，写不写都一样。&emsp;&emsp;对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。&emsp;&emsp;而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。 为什么atomic线程不安全&emsp;&emsp;假设有一个 atomic 的属性 “name”，如果线程 A 调[self setName:@”A”]，线程 B 调[self setName:@”B”]，线程 C 调[self name]，那么所有这些不同线程上的操作都将依次顺序执行——也就是说，如果一个线程正在执行 getter/setter，其他线程就得等待。因此，属性 name 是读/写安全的。但是，如果有另一个线程 D 同时在调[name release]，那可能就会crash，因为 release 不受 getter/setter 操作的限制。也就是说，atomic属性只能说是读/写安全的，但并不是线程安全的，因为别的线程还能进行读写之外的其他操作。线程安全需要开发者自己来保证。如果 name 属性是 nonatomic 的，那么上面例子里的所有线程 A、B、C、D 都可以同时执行，可能导致无法预料的结果。如果是 atomic 的，那么 A、B、C 会串行，而 D 还是并行的。 更新一篇详解 http://mrpeak.cn/blog/ios-thread-safety/ 参考 官方文档 What’s the difference between the atomic and nonatomic attributes?]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用计数引发的感想]]></title>
    <url>%2F2014%2F09%2F23%2F%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[序&emsp;&emsp;由于半道出家，从Java的垃圾回收机制，一下转到了引用计数机制，确实诸多不顺，简单写下我理解。我所知道的内存释放操作基本上有3类：手动释放、自动垃圾回收和引用计数！ 手动释放（C语言） 程序员自己挖坑，自己埋 优点：内存使用率高，性能高 缺点：需要手动malloc 和 free，自己开辟内存，自己释放内存。由于编译器啥也管不了，所以所有的操作都依赖程序员的严谨性，另外需要注意的是，开辟内存和释放内存都必须注意野指针问题 自动垃圾回收（Java） 当创建对象时，GC就开始监视这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理heap（堆）中的素有对象。通过这种方式确定“不可达的”并清除 优点：简单，几乎不用程序员管 缺点：内存利用率低，造成大量碎片化空间，性能消耗高 引用计数（OC） 每个对象保存，持有当前对象的个数，当没人只有当前对象，即引用对象为0时，就释放内存 优点：可靠， 缺点：循环引用，MRC时需要手动更新引用计数，ARC不用手动更新引用计数 更新&emsp;&emsp;以前写的过于肤浅，自动垃圾回收包含引用计数算法，即垃圾回收是概念，引用计数是算法垃圾回收算法。常用的垃圾回收算法有： 引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。引用计数算法实现简单，效率很高，微软的COM技术、ActionScript、Python等都使用了引用计数算法进行内存管理，但是引用计数算法对于对象之间相互循环引用问题难以解决，因此java并没有使用引用计数算法。 根搜索算法：通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea训练套路]]></title>
    <url>%2F2014%2F09%2F10%2Fidea%E8%AE%AD%E7%BB%83%E5%A5%97%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[PS：很多年前copy的，不记得从哪整的了！如果侵犯版权请告诉我 把它颠倒过来 把它摆平 把缩小 把颜色变换一下 把它变为圆形 使它更大 把它变为正方形 使它更小 使它更长 使它闪动 使它更短 使它发出火花 使它可以看到 点燃它 使它逾起一般情况 使它发萤光 把它放进文字里 使它沉重 把它插进音乐里 使它成为引火物 结合文字和音乐 使它成为引火物 结合文字. 音乐和图画 参加竞赛 结合音乐和图画删除文字 参加打赌 不要图画 使它成为年轻型的 不要文字 使它成为壮年型的 沉默无声 把它分割开 使它重复 保守地说 使它变成立体 夸张地说 使它变成平面 当替代品卖 变换它的形态 发现新用途 只变更一部分 减掉它 使它成为一组 撕开它 为捐献或义卖而销售 使它化合 鼓励它 用显而易见的 机动化 把要素重新配置 电气代 降低调子 使它活动 提高调子 使它相反 割开它 它像是某种东西的代替品 混合在一起 使它罗曼蒂克 改用另一种形式表现 增添怀旧的诉求 使它的速度加快 使它看起来流行 使它缓慢下来 使它看起来像未来派 使它飞行 使它成为某种物品的部分代替 使它浮起 使它更强壮 使它滚转 使它更耐久 把它切成片状 运用象征 使它成为粉状 它是写实派 以性欲作诉求 运用新艺术形式 使它凝缩 变为摄影技巧 使它弯曲 变换为图解方式 使它成对 使它变更形式 使它倾斜 用图画说明你的故事 使它悬浮半空中 使用新广告媒体 使它垂直站立 创造新广告媒体 把它由里向外翻转 使它更强烈 把它向旁边转 使它更冷 摇动它 增加香味 把它遮蔽起来 变换气味 使它不对称 把它除臭 使它不对称 将它向儿童诉求 反它隔开 将它向男士诉求 使它与其他相敌对 将它向妇女诉求 使它锐利 价钱更低 变更它的外形 抬高价格 要它绕一周 变更成份 把它框起来 增加新成份 把它卷成一圈 拧搓它 把它填满 使它透明 把它弄成空的 使它不透明 把它打开 用不同背景 把拼错 用不同环境 给它起我上绰号 使它富有魅力 把它封印起来 使用视觉效果 把它移转过来 使用另外的物料 把它捆包起来 增加人的趣味 把它集中起来 变更密度 把它推开 置于不同的货柜 使它成为交替的 变换包装 使它凝固起来 使密度增加 使它溶化 小型化 使成凝胶状 增加至最大限 使它软化 把它除掉 使它硬化 使它轻便 使蒸发变为汽化 使它可以折叠 加上抑扬顿挫 趋向偏激 使它更狭窄 如夏天炎热 使它更宽广 如冬天寒冷 使它更滑稽 使拟人化 使它成为被讽刺的 使它更暗 用简短的文案 使它发光 用冗长的文案 使它灼 发现第二种用途 使它更有营养 使它合成在一起 把它倒进瓶中 把它当作用具来卖 把它倒进罐中 使它清净 把它放进盒中 把它倒进壶中 把它倒进缸中 把它弄直 把它褶曲 把它缠起来 提升声誉 免费提供 以成本价出售 提供特价 增加慰藉的诉求 提供维护服务 运用不同的织法 使它变成香郁宜人 使它变成酸的 使它濡湿 使它脱水 使它干燥 把它冻起来 把它抛出去 使它无刺激性的 使它单纯化 使它具有刺激性的 把以上各项任意组合 其实这些对那些从事平面设计和影视广告设计的技术人员是有很大的帮助的。我有时候就有这种感觉—-思路被困看看这些就会有新的想法。等时间长了以后就不用常看这些了。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沙盒机制]]></title>
    <url>%2F2014%2F08%2F29%2F%E6%B2%99%E7%9B%92%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[沙盒机制是啥？ 根据百度百科：沙盒原理来看，沙盒目的是安全，原理是隔离监控和回滚！但iOS系统上的沙盒机制却不是这样的，iOS系统上的沙盒机制：隔离和权限控制，应用只能访问自己的存储空间不可以访问其他程序存储空间，应用访问系统数据需请求权限，没权限不允许访问！iOS沙盒原理是验签，就是发布APP那一大堆签名证书的作用。 沙盒目录 Documents：保存重要数据，iTunes和icould会自动备份 Library 包含Caches和Preferences⼦目录 Caches：存放缓存文件，需手动清除，不会备份 Preferences 保存应用程序的所有偏好设置。NSUserDefaults存在这，不用管！ tmp：临时数据，可能被自动清除，不要放重要数据，不会备份 xxx.app：应用程序包，手动引入的资源都会打包到这里，不用管 获取方法123456789101112131415161718/*directory：搜索的路径名称,NSDocumentDirectory、NSCacheDirectory等.domainMask：限定了文件的检索范围只在沙箱内部.一般为NSUserDomainMaskexpandTilde：是否展开波浪线符号.展开后才是完整路径,一直为YES.reutrn：数组,在iphone中由于只有一个唯一路径(相对OC而言),所以直接取数组第一个元素即可.*/// NSArray&lt;NSString *&gt; *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde);// 根目录路径NSString*homeDir = NSHomeDirectory();// Documents目录路径NSString*docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) firstObject];// Library的目录路径NSString*libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES) lastObject];// cache目录路径NSString*cachesDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES) firstObject];// tmp目录路径NSString*tmpDir =NSTemporaryDirectory(); Boundle 个人理解其实就是 xxx.app ，即你项目里打包进去的代码、图片、音视频等资源12345NSLog(@&quot;HomeDirectory： %@&quot;,NSHomeDirectory());NSLog(@&quot;bundlePath： %@&quot;,[[NSBundle mainBundle] bundlePath]);// NSBoudle使用NSString *path= [[NSBundle mainBundle] pathForResource:@&quot;xxx&quot; ofType:@&quot;mp3&quot;];UIView *view = [[[NSBundle mainBundle] loadNibNamed:@&quot;ZKXxxView&quot; owner:nil options:nil] firstObject];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Property关键字]]></title>
    <url>%2F2014%2F08%2F17%2FProperty%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[@property是什么 @property声明的属性，默认会自动创建该属性的getter/setter方法 123456@property (nonatomic, copy) NSString *propertyName;// 自动生成如下方法// 注意自动生成setter方法的属性名首字母大写- (void)setPropertyName:(NSString *)propertyName;// 注意自动生成getter方法没有get- (NSString *)propertyName; 不想让系统生成getter和setter方法，要用@dynamic 12// 不要系统生成的getter和setter，例如CoreData@dynamic propertyName; @property声明的属性，会自动生成带下划线的变量 12// 相当于系统帮你写了@synthesize propertyName = _propertyName; property的关键字原子性 atomic:原子性，耗性能而且不保证一定是安全的，所以iOS里不会用！Mac OS倒可以用 nonatomic:非原子性，和atomic含义是相反的，iOS一直用这个 存取控制 readwrite：可读可写，默认值。同时拥有getter和setter方法 readonly：可读不可写，只有getter没有setter方法 setter = xxx， 通过xxx来访问setter方法，属性必须是readwrite getter = xxx， 通过xxx来访问getter方法，经常和readonly配合使用123456@property (nonatomic, copy, getter=pName, setter=setPName) NSString *name;- (void)setPName:(NSString *)name &#123;&#125;- (NSString *)pName &#123;&#125;@property (nonatomic, readonly, assign, getter=isShowed) BOOL showed;- (BOOL)isShowed&#123;&#125; strong | weak | unsafe_unretained | assign | retain | copy 内存管理 assign:用于修饰值类型（基本数据类型），如：int，float，double，CGFloat，NSInteger等。assign修饰的属性不牵涉内存管理，不会被引用计数器管理 retain:表示实例变量对传入的对象要有所有权关系，也就是强引用 strong:强引用, ARC后用于取代retain的，作用等同于retain weak:弱引用。当传入的对象被释放后，用weak声明的属性会指向nil unsafe_unretained:跟assign相似，不同的是可以修饰类，不安全！慎用 copy: 深拷贝，内存拷贝！常用于修饰 NSString，NSArray,NSDictionary等有可变子类型的数据 常见问题unsafe_unretained、weak、assign 的区别？ 三者都不会对引用计数器进行操作，属性和实例对象都没有“强”关系 assign 只能修饰值类型，其它两个可以修饰类 weak属性当实例对象销毁时会自动置为nil不会产生野指针，而assign和unsafe_unretained当实例对象销毁时不做任何操作，可能存在野指针，甚至造成Crash weak是ARC才有的，其它两个一直都有 delegate使用assign还是weak，为什么？理论上来说，两者都是可以使用的，其一，都不会操作delegate的引用计数器，不是强引用对象。其二，在实际开发中，几乎所有场景下，delegate所指向的对象A的生存期都会被delegate变量B自身的生存期覆盖，也就是说A在使用B的过程中，B都是存在的，因此使用assign也不会有问题。但是，由于assign不会处理delegate被释放后的情况，上述的也只是大部分情况，不排除可能会出现delegate被释放了而A还在使用，产生野指针错误，而weak正好会处理这个情况，因此我们一般使用weak来修饰delegate，会更加安全 self对象是被strong，weak还是其他关键字修饰的？通过 查阅clang文档，我们发现了关于self的解释：1234The self parameter variable of an Objective-C method is never actually retained by the implementation. It is undefined behavior, or at least dangerous, to cause an object to be deallocated during a message send to that object.To make this safe, for Objective-C instance methods self is implicitly const unless the method is in the init family. Further, self is always implicitly const within a class method.RationaleThe cost of retaining self in all methods was found to be prohibitive, as it tends to be live across calls, preventing the optimizer from proving that the retain and release are unnecessary — for good reason, as it’s quite possible in theory to cause an object to be deallocated during its execution without this retain and release. Since it’s extremely uncommon to actually do so, even unintentionally, and since there’s no natural way for the programmer to remove this retain/release pair otherwise (as there is for other parameters by, say, making the variable __unsafe_unretained), we chose to make this optimizing assumption and shift some amount of risk to the user. 上述，self既不是strong也不是weak，而是被unsafe_unretained修饰的，因此要求我们调用的时候保证self是存在的，否则可能会引起无法预料的crash。这样设计的原因是因为在对象方法调用时，我们一定是会把self传递进去，并且在绝大部分情况下做为调用方，我们不会把self释放掉，如果为了处理不到1%情况下的异常而在方法执行时增加retain和release进行保护的话，会对性能有重大影响，因此ARC设计也就没有帮我们处理，需要调用方自行保证self的存在。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UITableView使用]]></title>
    <url>%2F2014%2F07%2F22%2FUITableView%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1.UITableView的datasource实现：1234567891011121314151617181920212223242526272829303132//回调获取每个section中的cell的行数- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section//回调获取每个uitableviewcell，只有当需要显示的cell在table的可视区域内才被回调- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath//回调获取table的section数量- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView//回调获取table的每个section的header标题- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section//回调获取table的每个section的footer标题- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section//回调判断指定的cell是否能有编辑状态- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath//回调判断指定的cell能否被移动当进入编辑模式的时候- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath//回调获取table右边的索引栏内容- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView//当点击右边索引栏时执行的回调，可以根据点击的title值返回应该跳到第几个section- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index//当所有相关编辑模式的回调，只实现该回调时默认能滑动cell出现删除按钮。当和其他相关的编辑模式回调混合使用分别有移动，插入，删除等功能- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath//当进入的是移动的编辑模式时，实现该回调进行移动cell和数据的更新- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath 2.UITableView的delegate实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//每个cell将要呈现时回调- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath//每个section的header将要呈现时回调- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)//每个section的footer将要呈现时回调- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)//每个cell呈现完毕后回调- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath NS_AVAILABLE_IOS(6_0)//每个section的header呈现完毕后回调- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)//每个section的footer呈现完毕后回调- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section NS_AVAILABLE_IOS(6_0)//回调设置每行的高度，如果要自适应调整cell的高度，则必须要实现该回调，返回调整后的cell高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath//回调设置每个section的header高度，如果要自适应调整header的高度，则必须要实现该回调，返回调整后的header高度- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section//回调设置每个section的footer高度，如果要自适应调整footer的高度，则必须要实现该回调，返回调整后的footer高度- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section//回调设置每个section的header自定义view- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section//回调设置每个section的footer自定义view- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section//回调设置每行最右边的辅助按钮的样式/*typedef NS_ENUM(NSInteger, UITableViewCellAccessoryType) &#123;UITableViewCellAccessoryNone, // don&apos;t show any accessory viewUITableViewCellAccessoryDisclosureIndicator, // regular chevron. doesn&apos;t trackUITableViewCellAccessoryDetailDisclosureButton, // blue button w/ chevron. tracksUITableViewCellAccessoryCheckmark // checkmark. doesn&apos;t track&#125;;*/- (UITableViewCellAccessoryType)tableView:(UITableView *)tableView accessoryTypeForRowWithIndexPath:(NSIndexPath *)indexPath NS_DEPRECATED_IOS(2_0, 3_0)//回调设置辅助按钮被点击后的事件- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath//回调设置某行是否当被点击后处于高亮状态- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0)//回调当某行处于高亮状态时的行为- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0)//回调当某行失去高亮状态时的行为- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0)//回调某行将要被选中的行为- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath//回调某行将要被取消选中的行为- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0)//回调某行已经被选中点击的行为- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath//回调某行已经取消选中的行为- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0)//回调设置某行进入了哪种编辑模式- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath//回调设置某行进入删除模式的删除按钮名字- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(3_0)//回调设置进入编辑模式的行能否缩进- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath//回调将要进入编辑模式的行为- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath//回调完成编辑模式的行为- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath//回调设置某行的缩进级别- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath//回调设置某行被长按是否出现菜单栏- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(5_0)//回调设置菜单栏是否显示哪些菜单栏选项- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender NS_AVAILABLE_IOS(5_0)//回调点击菜单栏选项触发的事件- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender NS_AVAILABLE_IOS(5_0) 3.UITableView常用成员方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//通过indexpath获取指定行的uitableviewcell[_table cellForRowAtIndexPath:indexPath];//删除某行并带上动画[_table deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];//删除某个section并带上动画[_table deleteSections:[NSIndexSet indexSetWithIndex:1] withRowAnimation:UITableViewRowAnimationMiddle];//取消被选中的某行[_table deselectRowAtIndexPath:indexPath animated:YES];//返回某个section的header自定义view[_table headerViewForSection:indexPath.row];//返回某个section的footer自定义view[_table footerViewForSection:indexPath.row];//通过指定的cell获取cell所在的行数[_table indexPathForCell:cell];//通过在table的位置坐标返回该坐标所在的cell的行数[_table indexPathForRowAtPoint:CGPointMake(0, 0)];//返回被选中的cell的行数[_table indexPathForSelectedRow];//返回table中一个范围区域的cell的行数[_table indexPathsForRowsInRect:CGRectMake(0, 0, 100, 100)];//返回table视觉区域内的cell的行数[_table indexPathsForVisibleRows];//以动画方式在指定的位置插入cell[_table insertRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationLeft];//以动画方式在指定位置插入section[_table insertSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationRight];//返回指定位置的cell的rect属性[_table rectForRowAtIndexPath:indexPath];//重新加载table，重新执行所有回调方法[_table reloadData];//指定重新加载table的某些行，并以动画方式[_table reloadRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationTop];//重新加载索引栏[_table reloadSectionIndexTitles];//指定重新加载table的section，并以动画方式[_table reloadSections:[NSIndexSet indexSetWithIndex:0] withRowAnimation:UITableViewRowAnimationFade];//滑动table到顶部[_table scrollsToTop];//带动画方式滑动table到指定区间[_table scrollRectToVisible:CGRectMake(0, 0, 100, 100) animated:YES];//带动画方式滑动table到指定位置附近[_table scrollToNearestSelectedRowAtScrollPosition:UITableViewScrollPositionBottom animated:YES];//以动画方式从table的哪个指定位置滑动到指定的行[_table scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES];//返回table可视区域内所有的cell[_table visibleCells];//beginupdates和endupdates要成对出现，对于同时操作多个insert，delete，selection的动画操作需要把它们放在beginupdates和endupdates中间执行，这样可以把多个动画合成一个动画来处理，实现原子性，降低出错的机率[_table beginUpdates];[_table endUpdates]; 转载自：https://blog.csdn.net/kingsley_cxz/article/details/9123959]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
</search>
