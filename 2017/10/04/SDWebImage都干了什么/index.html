<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    SDWebImage都干了什么？ |
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-SDWebImage都干了什么" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      SDWebImage都干了什么？
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/10/04/SDWebImage都干了什么/" class="article-date">
  <time datetime="2017-10-03T16:31:35.000Z" itemprop="datePublished">2017-10-04</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        
                            
    <div class="tocbot"></div>





                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>High Level Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="image"></p>
<p>Overall Class Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageClassDiagram.png" alt="image"></p>
<p>Top Level API Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageTopLevelClassDiagram.png" alt="image"></p>
<p>Main Sequence Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageSequenceDiagram.png" alt="image"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><ol>
<li><p>为啥不用NSThread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>SD里大量用到了 @synchronized(self)，另外正在下载中取消了怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // Cancel in progress downloader from queue</span><br><span class="line">        SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">        // 这个协议好，将抽象和实现分离！其实这就是最好的分层解耦</span><br><span class="line">        id&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123;</span><br><span class="line">                // 是不是抽象的非常好，下载、解码、还是存储根本就不用关心</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>学艺不精：怎么设置view的center</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.center = CGPointMake(CGRectGetMidX(self.bounds), CGRectGetMidY(self.bounds));</span><br></pre></td></tr></table></figure>
</li>
<li><p>和2毕竟相似，最基础的解耦思想：协议+抽象。 注意协议的定义以及requair的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_startImageIndicator &#123;</span><br><span class="line">    id&lt;SDWebImageIndicator&gt; imageIndicator = self.sd_imageIndicator;</span><br><span class="line">    if (!imageIndicator) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        // SDWebImageActivityIndicator、SDWebImageProgressIndicator等等</span><br><span class="line">        [imageIndicator startAnimatingIndicator];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 再看协议是怎么定义的</span><br><span class="line">/**</span><br><span class="line"> A protocol to custom the indicator during the image loading.</span><br><span class="line"> All of these methods are called from main queue.</span><br><span class="line"> */</span><br><span class="line">@protocol SDWebImageIndicator &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/**</span><br><span class="line"> The view associate to the indicator.</span><br><span class="line"></span><br><span class="line"> @return The indicator view</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) UIView *indicatorView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Start the animating for indicator.</span><br><span class="line"> */</span><br><span class="line">- (void)startAnimatingIndicator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Stop the animating for indicator.</span><br><span class="line"> */</span><br><span class="line">- (void)stopAnimatingIndicator;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">/**</span><br><span class="line"> Update the loading progress (0-1.0) for indicator. Optional</span><br><span class="line"> </span><br><span class="line"> @param progress The progress, value between 0 and 1.0</span><br><span class="line"> */</span><br><span class="line">- (void)updateIndicatorProgress:(double)progress;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property 的属性class，表示给类增加一个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, class, nullable) id&lt;SDImageCache&gt; defaultImageCache;</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">static id&lt;SDImageCache&gt; _defaultImageCache;</span><br><span class="line"></span><br><span class="line">+ (id&lt;SDImageCache&gt;)defaultImageCache &#123;</span><br><span class="line">    return _defaultImageCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setDefaultImageCache:(id&lt;SDImageCache&gt;)defaultImageCache &#123;</span><br><span class="line">    if (defaultImageCache &amp;&amp; ![defaultImageCache conformsToProtocol:@protocol(SDImageCache)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _defaultImageCache = defaultImageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>io队列是串行队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承 NSCache的正确方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; &lt;SDMemoryCache&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>像不像手动实现MVVM？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void * SDMemoryCacheContext = &amp;SDMemoryCacheContext;</span><br><span class="line"></span><br><span class="line">- (void)commonInit &#123;</span><br><span class="line">    SDImageCacheConfig *config = self.config;</span><br><span class="line">    self.totalCostLimit = config.maxMemoryCost;</span><br><span class="line">    self.countLimit = config.maxMemoryCount;</span><br><span class="line">    </span><br><span class="line">    [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCost)) options:0 context:SDMemoryCacheContext];</span><br><span class="line">    [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCount)) options:0 context:SDMemoryCacheContext];</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if (context == SDMemoryCacheContext) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(maxMemoryCost))]) &#123;</span><br><span class="line">            self.totalCostLimit = self.config.maxMemoryCost;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(maxMemoryCount))]) &#123;</span><br><span class="line">            self.countLimit = self.config.maxMemoryCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strong weak Cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</span><br><span class="line"></span><br><span class="line">self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line"></span><br><span class="line">// NSMapTable线程不安全，用锁</span><br><span class="line">#ifndef SD_LOCK</span><br><span class="line">#define SD_LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef SD_UNLOCK</span><br><span class="line">#define SD_UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件按MD5存的，注意文件名是有长度限制的，超长就不加扩展名了！注意检查的时候也要检查扩展名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#define SD_MAX_FILE_EXTENSION_LENGTH (NAME_MAX - CC_MD5_DIGEST_LENGTH * 2 - 1)</span><br><span class="line"></span><br><span class="line">static inline NSString * _Nonnull SDDiskCacheFileNameForKey(NSString * _Nullable key) &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    // File system has file name length limit, we need to check if ext is too long, we don&apos;t add it to the filename</span><br><span class="line">    if (ext.length &gt; SD_MAX_FILE_EXTENSION_LENGTH) &#123;</span><br><span class="line">        ext = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)containsDataForKey:(NSString *)key &#123;</span><br><span class="line">    NSParameterAssert(key);</span><br><span class="line">    NSString *filePath = [self cachePathForKey:key];</span><br><span class="line">    BOOL exists = [self.fileManager fileExistsAtPath:filePath];</span><br><span class="line">    </span><br><span class="line">    // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</span><br><span class="line">    // checking the key with and without the extension</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        exists = [self.fileManager fileExistsAtPath:filePath.stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>wirteToUrl,苹果推荐使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// get cache Path for image key</span><br><span class="line">NSString *cachePathForKey = [self cachePathForKey:key];</span><br><span class="line">// transform to NSUrl</span><br><span class="line">NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">[data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line"></span><br><span class="line">// disable iCloud backup</span><br><span class="line">if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">    // ignore iCloud backup resource value error</span><br><span class="line">    [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optionsProcessor是strong</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> The options processor is used, to have a global control for all the image request options and context option for current manager.</span><br><span class="line"> @note If you use `transformer`, `cacheKeyFilter` or `cacheSerializer` property of manager, the input context option already apply those properties before passed. This options processor is a better replacement for those property in common usage.</span><br><span class="line"> For example, you can control the global options, based on the URL or original context option like the below code.</span><br><span class="line"> </span><br><span class="line"> @code</span><br><span class="line"> SDWebImageManager.sharedManager.optionsProcessor = [SDWebImageOptionsProcessor optionsProcessorWithBlock:^SDWebImageOptionsResult * _Nullable(NSURL * _Nullable url, SDWebImageOptions options, SDWebImageContext * _Nullable context) &#123;</span><br><span class="line">     // Only do animation on `SDAnimatedImageView`</span><br><span class="line">     if (!context[SDWebImageContextAnimatedImageClass]) &#123;</span><br><span class="line">        options |= SDWebImageDecodeFirstFrameOnly;</span><br><span class="line">     &#125;</span><br><span class="line">     // Do not force decode for png url</span><br><span class="line">     if ([url.lastPathComponent isEqualToString:@&quot;png&quot;]) &#123;</span><br><span class="line">        options |= SDWebImageAvoidDecodeImage;</span><br><span class="line">     &#125;</span><br><span class="line">     // Always use screen scale factor</span><br><span class="line">     SDWebImageMutableContext *mutableContext = [NSDictionary dictionaryWithDictionary:context];</span><br><span class="line">     mutableContext[SDWebImageContextImageScaleFactor] = @(UIScreen.mainScreen.scale);</span><br><span class="line">     context = [mutableContext copy];</span><br><span class="line"> </span><br><span class="line">     return [[SDWebImageOptionsResult alloc] initWithOptions:options context:context];</span><br><span class="line"> &#125;];</span><br><span class="line"> @endcode</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) id&lt;SDWebImageOptionsProcessor&gt; optionsProcessor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SD是怎么限制字典配制项的？比钱包强了不止一个档次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef NSString * SDWebImageContextOption NS_EXTENSIBLE_STRING_ENUM;</span><br><span class="line">typedef NSDictionary&lt;SDWebImageContextOption, id&gt; SDWebImageContext;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A String to be used as the operation key for view category to store the image load operation. This is used for view instance which supports different image loading process. If nil, will use the class name as operation key. (NSString *)</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT SDWebImageContextOption _Nonnull const SDWebImageContextSetImageOperationKey;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A SDWebImageManager instance to control the image download and cache process using in UIImageView+WebCache category and likes. If not provided, use the shared manager (SDWebImageManager *)</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT SDWebImageContextOption _Nonnull const SDWebImageContextCustomManager;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@weakify(operation); 和 @strongify(operation); <a href="https://blog.csdn.net/ryansuan/article/details/51941702" target="_blank" rel="noopener">https://blog.csdn.net/ryansuan/article/details/51941702</a>  和  <a href="https://www.cnblogs.com/fengmin/p/5870554.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengmin/p/5870554.html</a></p>
</li>
</ol>
<ol start="15">
<li><p>大量IO操作应该放到@autoreleasepool里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载状态和锁，分细一点还是有好处的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载通过栈排序还是堆排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (self.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        // Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation</span><br><span class="line">        // This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations</span><br><span class="line">        // Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder</span><br><span class="line">        for (NSOperation *pendingOperation in self.downloadQueue.operations) &#123;</span><br><span class="line">            [pendingOperation addDependency:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载会不会死锁？哪里用到锁？加到队列后自动调用start开始下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SD_LOCK(self.operationsLock);</span><br><span class="line">    id downloadOperationCancelToken;</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    // There is a case that the operation may be marked as finished or cancelled, but not been removed from `self.URLOperations`.</span><br><span class="line">    if (!operation || operation.isFinished || operation.isCancelled) &#123;</span><br><span class="line">        operation = [self createDownloaderOperationWithUrl:url options:options context:context];</span><br><span class="line">        if (!operation) &#123;</span><br><span class="line">            SD_UNLOCK(self.operationsLock);</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadOperation userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloader operation is nil&quot;&#125;];</span><br><span class="line">                completedBlock(nil, nil, error, YES);</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        @weakify(self);</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            if (!self) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            SD_LOCK(self.operationsLock);</span><br><span class="line">            [self.URLOperations removeObjectForKey:url];</span><br><span class="line">            SD_UNLOCK(self.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        self.URLOperations[url] = operation;</span><br><span class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</span><br><span class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">        downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // When we reuse the download operation to attach more callbacks, there may be thread safe issue because the getter of callbacks may in another queue (decoding queue or delegate queue)</span><br><span class="line">        // So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.</span><br><span class="line">        @synchronized (operation) &#123;</span><br><span class="line">            downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        if (!operation.isExecuting) &#123;</span><br><span class="line">            if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">            &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityNormal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD_UNLOCK(self.operationsLock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么在自己的类里开始后台下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    __weak typeof(self) wself = self;</span><br><span class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        [wself cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不设NSURLSession的delegateQueue竟然默认串行队列回调! 注意这里回调会通过操作转给内部的task从而实现解码缓存啥的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">        NSURLSession *session = self.unownedSession;</span><br><span class="line">        if (!session) &#123;</span><br><span class="line">            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             *  Create the session for this task</span><br><span class="line">             *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span><br><span class="line">             *  method calls and completion handler calls.</span><br><span class="line">             */</span><br><span class="line">            session = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:self</span><br><span class="line">                                               delegateQueue:nil];</span><br><span class="line">            self.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当网络请求成功或失败需要调用 done表示此操作已完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// make sure to call `[self done]` to mark operation as finished</span><br><span class="line">if (error) &#123;</span><br><span class="line">    // custom error instead of URLSession error</span><br><span class="line">    if (self.responseError) &#123;</span><br><span class="line">        error = self.responseError;</span><br><span class="line">    &#125;</span><br><span class="line">    [self callCompletionBlocksWithError:error];</span><br><span class="line">    [self done];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两个Data是否相等，用什么？既不用 == ，也不用isEqualTo，而是isEqualToData</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.cachedData isEqualToData:imageData]</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的总长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line">    NSInteger expected = (NSInteger)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; 0 ? expected : 0;</span><br><span class="line">    self.expectedSize = expected;</span><br><span class="line">    self.response = response;</span><br><span class="line">    NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200;</span><br><span class="line">    BOOL valid = statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400;</span><br><span class="line">    if (!valid) &#123;</span><br><span class="line">        self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadStatusCode userInfo:@&#123;SDWebImageErrorDownloadStatusCodeKey : @(statusCode)&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    //&apos;304 Not Modified&apos; is an exceptional one</span><br><span class="line">    //URLSession current behavior will return 200 status code when the server respond 304 and URLCache hit. But this is not a standard behavior and we just add a check</span><br><span class="line">    if (statusCode == 304 &amp;&amp; !self.cachedData) &#123;</span><br><span class="line">        valid = NO;</span><br><span class="line">        self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCacheNotModified userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, expected, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Status code invalid and marked as cancelled. Do not call `[self.dataTask cancel]` which may mass up URLSession life cycle</span><br><span class="line">        disposition = NSURLSessionResponseCancel;</span><br><span class="line">    &#125;</span><br><span class="line">    __block typeof(self) strongSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已经下载的长度，注意解码问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    if (!self.imageData) &#123;</span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">    </span><br><span class="line">    self.receivedSize = self.imageData.length;</span><br><span class="line">    if (self.expectedSize == 0) &#123;</span><br><span class="line">        // Unknown expectedSize, immediately call progressBlock and return</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(self.receivedSize, self.expectedSize, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get the finish status</span><br><span class="line">    BOOL finished = (self.receivedSize &gt;= self.expectedSize);</span><br><span class="line">    // Get the current progress</span><br><span class="line">    double currentProgress = (double)self.receivedSize / (double)self.expectedSize;</span><br><span class="line">    double previousProgress = self.previousProgress;</span><br><span class="line">    double progressInterval = currentProgress - previousProgress;</span><br><span class="line">    // Check if we need callback progress</span><br><span class="line">    if (!finished &amp;&amp; (progressInterval &lt; self.minimumProgressInterval)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.previousProgress = currentProgress;</span><br><span class="line"></span><br><span class="line">    if (self.options &amp; SDWebImageDownloaderProgressiveLoad) &#123;</span><br><span class="line">        // Get the image data</span><br><span class="line">        NSData *imageData = [self.imageData copy];</span><br><span class="line">        </span><br><span class="line">        // progressive decode the image in coder queue</span><br><span class="line">        dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                UIImage *image = SDImageLoaderDecodeProgressiveImageData(imageData, self.request.URL, finished, self, [[self class] imageOptionsFromDownloaderOptions:self.options], self.context);</span><br><span class="line">                if (image) &#123;</span><br><span class="line">                    // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</span><br><span class="line">                    </span><br><span class="line">                    [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(self.receivedSize, self.expectedSize, self.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>token的多继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloadToken : NSObject &lt;SDWebImageOperation&gt;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/10/04/SDWebImage都干了什么/" data-id="ckd90jol90039xc51ptmgx4p3" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2017/10/08/AFN都干了什么/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            AFN都干了什么？
          
        </div>
      </a>
    
    
      <a href="/2017/10/01/Aspects都干了什么/" class="article-nav-link">
        <strong class="article-nav-caption">Older</strong>
        <div class="article-nav-title">Aspects都干了什么？</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>