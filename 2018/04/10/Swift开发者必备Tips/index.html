<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="原创,基础,">










<meta name="description" content="柯里化: 通过模板来批量生成方法 123456func greaterThan(_ comparer: Int) -&amp;gt; (Int) -&amp;gt; Bool &amp;#123;return &amp;#123; $0 &amp;gt; comparer&amp;#125;&amp;#125;let greaterThan10 = greaterThan(10)greaterThan10(13) // truegreaterThan">
<meta name="keywords" content="原创,基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift开发者必备Tips">
<meta property="og:url" content="http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/index.html">
<meta property="og:site_name" content="焦正奎的博客">
<meta property="og:description" content="柯里化: 通过模板来批量生成方法 123456func greaterThan(_ comparer: Int) -&amp;gt; (Int) -&amp;gt; Bool &amp;#123;return &amp;#123; $0 &amp;gt; comparer&amp;#125;&amp;#125;let greaterThan10 = greaterThan(10)greaterThan10(13) // truegreaterThan">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-07-30T15:06:42.655Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift开发者必备Tips">
<meta name="twitter:description" content="柯里化: 通过模板来批量生成方法 123456func greaterThan(_ comparer: Int) -&amp;gt; (Int) -&amp;gt; Bool &amp;#123;return &amp;#123; $0 &amp;gt; comparer&amp;#125;&amp;#125;let greaterThan10 = greaterThan(10)greaterThan10(13) // truegreaterThan">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/">





  <title>Swift开发者必备Tips | 焦正奎的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">焦正奎的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不要怕！不要悔！慢慢来！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jiaozhengkui@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="焦正奎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Swift开发者必备Tips</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T00:20:23+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index">
                    <span itemprop="name">swift</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ol>
<li><p>柯里化: 通过模板来批量生成方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;</span><br><span class="line">return &#123; $0 &gt; comparer&#125;</span><br><span class="line">&#125;</span><br><span class="line">let greaterThan10 = greaterThan(10)</span><br><span class="line">greaterThan10(13) // true</span><br><span class="line">greaterThan10(0) // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>将protocol的方法声明为mutating：mutating关键字是为了能在该方法里修改struct或enum变量，另外使用class实现protocol时，可以不用加mutating，因class可随意改变量，mutating对于class时完全透明的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">protocol Vehicle &#123;</span><br><span class="line">var color: UIColor &#123;get set&#125;</span><br><span class="line">mutating func changeColor()</span><br><span class="line">&#125;</span><br><span class="line">struct MyCar: Vehicle &#123;</span><br><span class="line">var color = UIColor.blue</span><br><span class="line">mutating func changeColor() &#123;</span><br><span class="line">color = .red</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环可用于实现了Sequence的类型上，要实现Sequence需要先实现IteratorProtocol协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ReverseIterator&lt;T&gt;: IteratorProtocol &#123;</span><br><span class="line">typealias Element = T</span><br><span class="line">var array:[Element]</span><br><span class="line">var currentIndex = 0</span><br><span class="line">init(array:[Element]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">currentIndex = array.count - 1</span><br><span class="line">&#125;</span><br><span class="line">func next() -&gt; Element? &#123;</span><br><span class="line">if currentIndex &lt; 0 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;else &#123;</span><br><span class="line">let element = array[currentIndex]</span><br><span class="line">currentIndex -= 1</span><br><span class="line">return element</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct ReverseSequence&lt;T&gt;: Sequence &#123;</span><br><span class="line">var array:[T]</span><br><span class="line">init(array:[T]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">&#125;</span><br><span class="line">typealias Iterator = ReverseIterator&lt;T&gt;</span><br><span class="line">func makeIterator() -&gt; ReverseIterator&lt;T&gt; &#123;</span><br><span class="line">return ReverseIterator(array: self.array)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [2,3,4,5,7,6]</span><br><span class="line">for (index, value) in ReverseSequence(array: arr).enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(value)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func swap&lt;T&gt;(a: inout T, b: inout T) &#123;</span><br><span class="line">(a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2</span><br><span class="line">var b = 3</span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">print(&quot;a is \(a) b is \(b)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@autoclosure 是把形如 ()-&gt;T 的一句表达式（无参数，就一句）自动封装成闭包，var c = a ?? b,表示a非nil时c=a，nil时c=b，其实跟连着写的?: 是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func logIfTure(_ predicate: ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure (&#123; () -&gt; Bool in</span><br><span class="line">return 2 &gt; 1</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure (&#123;</span><br><span class="line">return 3 &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123; 4 &gt; 3 &#125;)</span><br><span class="line">logIfTure &#123; 5 &gt; 4 &#125;</span><br><span class="line"></span><br><span class="line">func logIfTureAutoclosure(_ predicate:@autoclosure ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意是小括号</span><br><span class="line">logIfTureAutoclosure(6&gt;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@escaping逃逸闭包，异步回调那种函数执行完了闭包还需要执行，注意循环引用使用weak self unowned self；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 逃逸闭包</span><br><span class="line">func testEscapingFunc(printNum: @escaping (_ num: Int) -&gt; ())&#123;</span><br><span class="line">print(&quot;testEscapingFunc begin&quot;)</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">printNum(66)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;testEscapingFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testEscapingFunc &#123; (num) in</span><br><span class="line">print(&quot;Escaping colsure begin&quot;)</span><br><span class="line">print(&quot;Escaping num is \(num)&quot;)</span><br><span class="line">print(&quot;Escaping colsure end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 非逃逸闭包</span><br><span class="line">func testNoescapeFunc(printNum: (_ num: Int) -&gt; ()) &#123;</span><br><span class="line">print(&quot;testNoescapeFunc begin&quot;)</span><br><span class="line">printNum(77)</span><br><span class="line">print(&quot;testNoescapeFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testNoescapeFunc &#123; (num) in</span><br><span class="line">print(&quot;Noescape colsure begin&quot;)</span><br><span class="line">print(&quot;Noescape num is \(num)&quot;)</span><br><span class="line">print(&quot;Noescape colsure end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional chaining ，返回的都是最后一个的可选类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Pet &#123;</span><br><span class="line">let name: String</span><br><span class="line">init(name: String) &#123;</span><br><span class="line">self.name = name</span><br><span class="line">&#125;</span><br><span class="line">func play() -&gt; (String) &#123;</span><br><span class="line">return &quot;playing&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child &#123;</span><br><span class="line">var pet: Pet?</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = Child()</span><br><span class="line">xiaoming.pet = Pet(name: &quot;dog&quot;)</span><br><span class="line">if let petName = xiaoming.pet?.name &#123;</span><br><span class="line">print(&quot;xiaoming pet name is \(petName)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if let p = xiaoming.pet?.play() &#123;</span><br><span class="line">print(&quot;xiaoming pet is \(p)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载操作符，慎用避免冲突，应该是公开的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">var x = 0</span><br><span class="line">var y = 0</span><br><span class="line">&#125;</span><br><span class="line">func +(left:Vector2D, right:Vector2D) -&gt; Vector2D&#123;</span><br><span class="line">return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">&#125;</span><br><span class="line">let v1 = Vector2D(x: 1, y: 2)</span><br><span class="line">let v2 = Vector2D(x: 3, y: 4)</span><br><span class="line">let v3 = v1 + v2</span><br><span class="line">print(&quot;v3 is \(v3)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>func的参数修饰，默认参数都是copy的，inout关键字可以直接修改参数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func incrementor1(x: Int) -&gt; Int &#123;</span><br><span class="line">x + 1</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;参数不可变 \(incrementor1(x: 1))&quot;)</span><br><span class="line">func incrementor2(x: inout Int) &#123;</span><br><span class="line">x = x + 1</span><br><span class="line">&#125;</span><br><span class="line">var x = 1</span><br><span class="line">incrementor2(x: &amp;x)</span><br><span class="line">print(&quot;参数可变 \(x)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字面量表达式，实现类似ExpressibleByBooleanLiteral的协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 以下就是字面量表达式，思考为啥写个true编译器就知道是BOOL类型的</span><br><span class="line">var aBool = true</span><br><span class="line">var aString = &quot;this is a string&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下标，数组下标注意越界，字典下标返回可选类型。可以重写数组或字典下标，也可以自定义下标,实现subscript方法，延伸阅读<a href="https://www.cnblogs.com/ludashi/p/5179275.html" target="_blank" rel="noopener">窥探Swift之数组安全索引与数组切片</a></p>
</li>
<li><p>方法嵌套，更清晰不用在别的地方调用一堆小方法了都在函数里面呢，访问权限更易管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer(add: Int) -&gt; (inout Int) -&gt; Void &#123;</span><br><span class="line">func incrementer(x : inout Int) -&gt; Void &#123;</span><br><span class="line">x = x + add</span><br><span class="line">&#125;</span><br><span class="line">return incrementer;</span><br><span class="line">&#125;</span><br><span class="line">let incrementer2 = makeIncrementer(add: 2)</span><br><span class="line">var y = 3</span><br><span class="line">incrementer2(&amp;y)</span><br><span class="line">print(&quot;\(y)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空间。基于module的而不是直接再代码中显示指明的，进行app开发时，默认添加app的主target里的内容都在同一命名空间里，即同一target里名称不能相同。</p>
</li>
<li><p>typealias，指定类型重命名。当实现多个协议时，也可以用 &amp; 连接多协议，用typealias重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol Dog &#123;</span><br><span class="line">func watch() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">protocol Cat &#123;</span><br><span class="line">func sleep() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">typealias Pet = Dog &amp; Cat</span><br></pre></td></tr></table></figure>
</li>
<li><p>associatedtype 如果有多个协议，它们的方法和属性都一样，只有协议中用到的类型不同，则可合并为一个使用关联类型(associatedtype)进行区分。实现时自定义typealias相应类型即可。延伸阅读<a href="https://www.cnblogs.com/muzijie/p/6596164.html" target="_blank" rel="noopener">Swift—–协议Protocol</a></p>
</li>
<li>可变参数<br><a href="https://www.jianshu.com/p/5a1178f3c36f" target="_blank" rel="noopener">OC的可变参数</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 注意可变参数必须是最后一个参数，且name后面有一个英文逗号</span><br><span class="line">- (void)testMultiplePramar:(NSString *)name, ... &#123;</span><br><span class="line">// 一个字符类型的指针，指针指向当前的参数，需要通过这个指针取参数。</span><br><span class="line">va_list arg_list;</span><br><span class="line">// 初始化字符指针的函数，将把arg_list指针指向name这个可变形参的第一个位置</span><br><span class="line">va_start(arg_list, name);</span><br><span class="line">NSLog(@&quot;第一个 ： %@&quot;, name);</span><br><span class="line">while(YES)&#123;</span><br><span class="line">// 这是一个取参数的函数，这个函数需要两个参数，第一个参数是字符指针va_list，第二个参数是我们需要取的可变参数的数据类型</span><br><span class="line">// 这个函数需要做两件事：1：取到指定数据类型的参数。2：将指针ap指向下一个可变参数的地址。</span><br><span class="line">NSString * obj=va_arg(arg_list,NSString *);</span><br><span class="line">// 取完所有参数之后，跳出循环</span><br><span class="line">if(obj==nil)break;</span><br><span class="line">NSLog(@&quot;--- %@&quot;,obj);</span><br><span class="line">&#125;</span><br><span class="line">// 最后要将指针ap指向NULL。避免野指针。和va_start成对使用。</span><br><span class="line">va_end(arg_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Swift版可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 只能有一个可变参数，位置不限类型相同</span><br><span class="line">func myFunc(numbers:Int..., str: String) &#123;</span><br><span class="line">numbers.forEach &#123; (i) in</span><br><span class="line">print(&quot;\(str)，第\(i)个&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunc(numbers: 1,2,3,4,5, str: &quot;hello&quot;)</span><br><span class="line">Swift版的stringformat方法 init(format:NSString, _ args: CVarArgType...)</span><br></pre></td></tr></table></figure></p>
<ol start="17">
<li><p>初始化方法顺序<br>明确一个问题<a href="https://stackoverflow.com/questions/8056188/should-i-refer-to-self-property-in-the-init-method-with-arc" target="_blank" rel="noopener">不要在init初始化方法里使用self.property</a> <br><br>A，OC是先初始化父类在初始化子类成员变量<br><br>B，1，先初始化子类成员变量，<br><br>2调用父类初始化，（若没第3步，可不写编译器自己加）<br><br>3对父类中需要改变的成员进行设定<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">// Designated 指定的 init初始化方法</span><br><span class="line">// 也可以加上required关键字以确保子类对其实现</span><br><span class="line">init(num: Int) &#123;</span><br><span class="line">numA = num; //可对let的实例常量赋值</span><br><span class="line">&#125;</span><br><span class="line">// 所有的便利构造器都必须调同一类中Designated初始化完成设置，且不能被子类重写或从子类中以super的方式调用</span><br><span class="line">convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 1000 : 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassB: ClassA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">override init(num: Int) &#123;</span><br><span class="line">numB = num + 2</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let bObj = ClassB(bigNum: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化返回nil<br>OC初始化失败可以返回nil，但swift没有return，因此swif中用 init? 表示返回可选值，即可能失败</p>
</li>
<li><a href="https://www.jianshu.com/p/c2c95c1c593d" target="_blank" rel="noopener">static 和 class</a>， 注意cpoy on write</li>
<li>容器(Array, Dictionary, Set)只能放同一类型元素，如果想放不同类型怎么办？<br><br>A。类型转换，信息损失十分危险，最好不要用！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">let mixed: [Any] = [1, &quot;Two&quot;,3]; // Any类型可以隐式转换</span><br><span class="line">// 转换为[NSObject]</span><br><span class="line">let objectArray = [1 as NSObject, &quot;two&quot; as NSObject, 3 as NSObject]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>B。如果有共同特征，可以添加实现同一协议的类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">let mixed2 : [CustomStringConvertible] = [1, &quot;two&quot;, 3]</span><br><span class="line">for obj in mixed2 &#123;</span><br><span class="line">print(obj.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C。将类型信息封装到enum中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">enum IntOrString &#123;</span><br><span class="line">case IntValue(Int)</span><br><span class="line">case StringValue(String)</span><br><span class="line">&#125;</span><br><span class="line">let mixed = [IntOrString.IntValue(1), IntOrString.StringValue(&quot;two&quot;), IntOrString.IntValue(3)]</span><br><span class="line">for value in mixed &#123;</span><br><span class="line">switch value &#123;</span><br><span class="line">case let .IntValue(i):</span><br><span class="line">print(i)</span><br><span class="line">case let .StringValue(str):</span><br><span class="line">print(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="21">
<li><p>default参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String = &quot;JZK&quot;, str:String)&#123;</span><br><span class="line">print(name+&quot; &quot;+str)</span><br><span class="line">&#125;</span><br><span class="line">hello(str: &quot;hello world&quot;)</span><br><span class="line">hello(name: &quot;dxm&quot;, str: &quot;hello world&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式。自定义符号还是麻烦，其实用OC的是最省事的，<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a>，<a href="https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149" target="_blank" rel="noopener">8个常用正则</a></p>
</li>
<li><p>模式匹配,没看懂好像就是switch的使用而已呀，重载~/ 跟switch有啥子关系。。。</p>
</li>
<li><p>… 和 ..&lt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 包含3，即输出0 1 2 3</span><br><span class="line">for i in 0...3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 小于3（不含3），即输出0 1 2</span><br><span class="line">for i in 0..&lt;3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 还可以通过 ... 或 ..&lt; 来连接两个字符串</span><br><span class="line">// 但经过试验发现很难用，例&quot;0&quot;...&quot;10&quot; 包含&quot;1&quot;但不包含&quot;2&quot;, 还有校验ASCII码 \0...~ 确实正确的</span><br></pre></td></tr></table></figure>
</li>
<li><p>AnyClass, 元类型和 .self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// swift中能够表示“任意”这个概念的除了 Any 和 AnyObject 外，还有AnyClass , AnyClass = AnyObject.Type</span><br><span class="line">// .Type 表示的是某个类型的元类型。.Protocol表示某个协议的元类型</span><br><span class="line">// 类型.self 表示获得该类型Class， 实例.self表示获得该实例对象</span><br><span class="line">import UIKit</span><br><span class="line">class AVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">class BVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 强转成AnyClass，类似工厂方法</span><br><span class="line">let VCTypes : [AnyClass] = [AVC.self, BVC.self]</span><br><span class="line">for type in VCTypes &#123;</span><br><span class="line">if type is UIViewController.Type &#123;</span><br><span class="line">// 想想为什么可以调init 类方法？</span><br><span class="line">let vc = (type as! UIViewController.Type).init()</span><br><span class="line">print(&quot;vc实例类型为：\(vc)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议和类方法中的Self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 协议没自己的上下文信息，也不知道谁实现。当我们希望在协议中使用的就是实现这个协议本身的类型的话，就需要使用Self（注意首字母大写）进行指代，此时Self不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态类型和多方法<br><a href="https://www.jianshu.com/p/7eb4053d339e" target="_blank" rel="noopener">dynamicType废除，用type(of:)代替</a></p>
</li>
<li>属性观察<br>存储型属性 willSet 和 didSet 方法中newValue表示将要设定的，oldValue表示已经设定的。注意初始化时不会调属性观察。计算形型属性只有get和set方法</li>
<li>final 表示不允许继承或重写。</li>
<li><p>lazy修饰符和lazy方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">// class或struct 的变量属性，且需指明类型</span><br><span class="line">lazy var str : String = &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">// lazy 也能修饰方法,对于可能提前退出情况，性能优化明显</span><br><span class="line">let arr = 1...3</span><br><span class="line">let result = arr.lazy.map &#123; (i: Int) -&gt; Int in</span><br><span class="line">print(&quot;map \(i)&quot;)</span><br><span class="line">return i * 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;begin&quot;)</span><br><span class="line">for i in result &#123;</span><br><span class="line">print(&quot;result \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>refection 和 mirror , 知道有反射就行了，最好不用</p>
</li>
<li>强制解包，少用才好，多用可选链！</li>
<li><p>多重optional</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var aNil : String? = nil</span><br><span class="line">var anotherNil : String?? = aNil</span><br><span class="line">var literalNil : String?? = nil</span><br><span class="line">if anotherNil != nil &#123;</span><br><span class="line">print(&quot;anotherNil&quot;) // 输出</span><br><span class="line">&#125;</span><br><span class="line">if literalNil != nil &#123;</span><br><span class="line">print(&quot;literalNil&quot;) //</span><br><span class="line">&#125;</span><br><span class="line">// 但用po输出时，anotherNil和literalNil 都是nil，因lldb已经将optional展开了</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional map ，没啥用</p>
</li>
<li><p>协议扩展 protocol extension， 可以为协议中定义的方法提供一个默认的实现</p>
</li>
<li><p>where 和模式匹配</p>
</li>
<li>indirect 和嵌套enum</li>
<li>swift的#selector 和OC的@selector一样，swift4中默认所有的swift方法在OC中都不可见，所以需要在方法前加上@objc 关键字。使用#selector时，swift的同名方法需要强制转化</li>
<li><p>实例方法动态调用，挺好玩的，虽然我也没想到有什么用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">func method(num: Int) -&gt; Int &#123;</span><br><span class="line">return num + 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化MyClass对象，再调用method方法就限定死了类型</span><br><span class="line">// 但swift中可直接用 Type.instanceMethod的语法生成一个可以柯里化的方法，只适用于实例方法，对getter或setter无效,同名方法需对 f 加上类型加以区别</span><br><span class="line">let f = MyClass.method</span><br><span class="line">let object = MyClass()</span><br><span class="line">let result = f(object)(1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 设置init方法为private来覆盖默认public的方法，保证其他地方不能init实例</span><br><span class="line">//方法一</span><br><span class="line">class AppShared &#123;</span><br><span class="line">private static let _sharedInstance = AppShared()</span><br><span class="line">class func sharedInstance() -&gt;AppShared&#123;</span><br><span class="line">return _sharedInstance</span><br><span class="line">&#125;</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方法二</span><br><span class="line">class AppShared2 &#123;</span><br><span class="line">static let sharedInstance = AppShared2()</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// swift中没有宏，实质上是一些全局常量和函数</span><br><span class="line">//#if condition //注意condition大小写敏感</span><br><span class="line">//#endif</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>延伸阅读<a href="https://www.cnblogs.com/Bob-wei/p/5237761.html" target="_blank" rel="noopener">Swift中如何使用 #if DEBUG</a><br>condition  | 可选参数<br>—|—<br>os() | macOS,iOS,tvOS,watchOS,Linux<br>arch() | x86_64, arm, arm64, i386<br>swift() | &gt;= 某个版本</p>
<ol start="42">
<li>编译标记OC的#param，在swift中用 // MARK:- 代替（注意大写），此外还有// TODO: 和 // FIXME: , 但没有#warning的替代品</li>
<li>@UIApplicationMain， 和OC的main函数是一样的，如果我们想使用UIApplicaiton的子类(例如监听所有的点击事件)，就可以创建main.swift</li>
<li>@objc 和 dynamic，swift写的类继承自NSObject的话，swift会自动为所有非private的类和成员加上@objc，但@objc并不意味着会变成动态派发，动态派发需用dynamic关键字。延伸阅读<a href="https://www.jianshu.com/p/37f720df43ac" target="_blank" rel="noopener">iOS OC与Swift混编</a>，注意和OC的@dynamic没任何关系，@dynamic表示不用编译器自动生成getter和setter方法</li>
<li>可选协议和协议扩展</li>
<li>内存管理，weak和unowned，如果再在访问时不会被释放的话，尽量用unowned，如果存在被释放的课鞥呢，那就用weak</li>
<li>@autoreleasepool在swift中已经没有了, swift提倡用初始化方法而不是用类方法来生成对象</li>
<li>值类型和引用类型，swift中所有的内建类型都是值类型，甚至String，array以及Dictionary都是值类型，值类型复制值发生在内容发生改变时</li>
<li>String 还是 NSString？能用String尽量用String，但使用Range时还是NSString更好用</li>
<li><p>UnsafePointer, 用于对C语言的指针进行转换，C中的基本类型在swift中对应的类型都有统一的命名规则：前面加上 C 且首字母大写，例如int 对应的类型为 CInt，int的指针转换到swift中对应的就是UnsafePointer<cint>, C的指针不可变用UnsafePointer,可变指针用UnsafeMutablePointer</cint></p>
</li>
<li><p>C指针的内存管理，无法使用ARC，deallocate与deinitialize应该要和allocate与initialize成对出现。malloc和calloc要与free匹配</p>
</li>
<li>C中指向函数的指针可转为闭包，不过需要加上@convention标注</li>
<li>GCD和延时调用, <a href="https://www.jianshu.com/p/51fd1362249e" target="_blank" rel="noopener">OC多线程</a> 和 <a href="https://www.cnblogs.com/csdnIOS/p/6874839.html" target="_blank" rel="noopener">swift的GCD</a></li>
<li>获取对象类型 type(of:)</li>
<li>OC的 isKindOfClass 和 isMemberOfClass 在swift中继承自NSObject的依然可以使用，swift还有 is 关键字等同于isKindOfClass，但也可以用于struct或enum进行类型判断。as 关键字向上转型；as！向下转型；as？向下转型，如果失败返回nil</li>
<li><p>swift中的KVO实现, 延伸：可用属性观察自己实现，也可<a href="http://chris.eidhof.nl/post/references/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">// 继承自NSObject</span><br><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">// 要检测的属性必须标注 @objc dynamic</span><br><span class="line">@objc dynamic var date = Date()</span><br><span class="line">&#125;</span><br><span class="line">class KvoClass: NSObject &#123;</span><br><span class="line">var myObject : MyClass!</span><br><span class="line">var observation: NSKeyValueObservation?</span><br><span class="line">override init() &#123;</span><br><span class="line">myObject = MyClass()</span><br><span class="line">print(&quot;初始化时间：\(Date())&quot;)</span><br><span class="line">observation = myObject.observe(\MyClass.date, options: [.new], changeHandler: &#123; (_, change) in</span><br><span class="line">if let newDate = change.newValue &#123;</span><br><span class="line">print(&quot;变化时间：\(Date())&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var kvoObject = KvoClass()</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123;</span><br><span class="line">kvoObject.myObject.date = Date()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部scope，隔离代码的好方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// OC中使用方法</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// 局部scope</span><br><span class="line">&#123;</span><br><span class="line">UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 100, 44)];</span><br><span class="line">label1.text = @&quot;first label&quot;;</span><br><span class="line">[self.view addSubview:label1];</span><br><span class="line">&#125;</span><br><span class="line">// GNU C的声明扩展</span><br><span class="line">UILabel *label2 = (&#123;</span><br><span class="line">UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 200, 100, 44)];</span><br><span class="line">tempLabel.text = @&quot;second label&quot;;</span><br><span class="line">tempLabel; // 注意没有return</span><br><span class="line">&#125;);</span><br><span class="line">[self.view addSubview:label2];</span><br><span class="line">&#125;</span><br><span class="line">// swift不允许直接使用大括号，和闭包冲突。而且没有GNU C的声明扩展</span><br><span class="line">// 但可以使用匿名闭包</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">let titleLabel : UILabel = &#123;</span><br><span class="line">let label = UILabel(frame: CGRect(x: 0, y: 100, width: 100, height: 44))</span><br><span class="line">label.text = &quot;匿名闭包&quot;</span><br><span class="line">return label</span><br><span class="line">&#125;()</span><br><span class="line">self.view.addSubview(titleLabel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中==表示判断两个对象是否指向同一块内存，在swift中对应为 === ，而swift中的 == 是一个操作符声明，在 Equatable 协议里声明，可重载，没重载的话就是 isEqual </p>
</li>
<li>哈希</li>
<li>类簇，swift中使用工厂方法模式来实现，因swift中初始化方法只能得到完成所有配置的当前类实例，即不可能在公共类中返回子类信息</li>
<li>swift中直接使用C代码或库是不可能的，因此使用C库最好的办法是使用OC文件封装，通过 工程名-Bridging-Header.h 桥接文件来调OC的代码</li>
<li><p>输出格式化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">var b = 1.234567890</span><br><span class="line">print(&quot;b is \(b)&quot;)</span><br><span class="line">let formatB = String(format: &quot;%.2f&quot;, b)</span><br><span class="line">print(&quot;保留两位小数 b is \(formatB)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NS_ENUM对应swift的enum，OC的NS_OPTIONS被映射为满足OptionSet协议的struct类型，以及一组静态的get属性，对不需要选项的可以用[]空集合表示，可以参照 AnimationOptions </p>
</li>
<li><p>数组的enumerated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (index, item) in [2,4,1,4,5].enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(item)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中可以通过@encode来获取类型编码，swift中可以通过转换为NSValue类型，使用objCType获取类型编码。类型编码这个运行时还是比较有用的</p>
</li>
<li>@asmname可直接将C函数映射为swift函数，但可能会有命名冲突，慎用</li>
<li><p>swift的protocol可以被class，struct，enum等类型遵守。而想要在swift中声明weak delegate，就最要将protocol限制在class内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将protocol限制在class内</span><br><span class="line">// 1,在protocol声明前加上@objc</span><br><span class="line">@objc protocol MyClassDelegate &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br><span class="line">// 更好的办法</span><br><span class="line">// 2，在protocol声明后加上class</span><br><span class="line">protocol ClassDelegate : class &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>associated object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private var key : Void?</span><br><span class="line">extension AppDelegate &#123;&apos;</span><br><span class="line">var associatedObject: String? &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return objc_getAssociatedObject(self, &amp;key) as? String</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_COPY)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中没有 @synchronized ，但可以自己实现一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// OC的@synchronized，也是调objc_sync_enter和objc_sync_exit，外加异常判断</span><br><span class="line">func syncchronized(_ lock: AnyObject, closure:()-&gt;())&#123;</span><br><span class="line">objc_sync_enter(lock) </span><br><span class="line">closure()</span><br><span class="line">objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC与CoreFoundation的转化规则：<strong>bridge转换OC和CF，不涉及内存；</strong>bridge_retained或CFBridgingRetain 将OC转换到CF，需要手动调用CFRelease来释放对象内存；__bridge_transfer或CFBridgingRelease将CF转化为OC，ARC负责释放对象。对于CF系API，如果API名字中含有Create，Copy或Retain的话，使用完成后要手动调CFRelease来释放内存。但在swift中，与CF的转化可以省掉了，也不用调CFRelease释放内存了，一个字：爽</p>
</li>
<li>swift命令号工具</li>
<li><p>随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// let num = Int(arc4random()) % 5 + 1 ;  iphone4，5上可能crash</span><br><span class="line">// 因swift的Int和CPU架构有关，在32位CPU上是Int32，64位CPU上是Int64，而arc4random不论什么平台上都是UInt32，故可能越界crash</span><br><span class="line">// 可用arc4random_uniform 实现相同效果</span><br><span class="line">let num = Int(arc4random_uniform()) % 5 + 1 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CustomStringConvertible 和 CustomDebugStringConvertible 协议可以格式化print样式</p>
</li>
<li><p>要throws另一个throws时，应将前者改为rethrows。<a href="https://www.cnblogs.com/junhuawang/p/6231084.html" target="_blank" rel="noopener">Swift异常处理</a> 和 <a href="https://www.jianshu.com/p/a71d87d92459" target="_blank" rel="noopener">swift的defer</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">//try? 抛出异常则返回nil,没抛出正常返回；try！肯定不会抛异常。但抛出异常就crash，慎用 </span><br><span class="line">//try somthing</span><br><span class="line">//try somthing</span><br><span class="line">&#125; catch let err as NSError &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NSAssert宏 在swift中对应为assert函数</p>
</li>
<li>fatalError可以在release和debug下终止程序，类似于Debug下NSAssert(NO, @”说明”);的作用</li>
<li>代码组织和Framework</li>
<li><p>安全的资源组织方式，OC时经常将资源名称定义为宏，这样可相对集中的管理和修改。swift可以用enum和extension来处理资源，原理如下。<a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener">SwiftGen</a> 和 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 可扫描文件自动生成对应的enum或struct文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ImageName: String &#123;</span><br><span class="line">case myImage = &quot;my_image&quot;</span><br><span class="line">&#125;</span><br><span class="line">extension UIImage &#123;</span><br><span class="line">convenience init?(imageName: ImageName)&#123;</span><br><span class="line">self.init(named: imageName.rawValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let image = UIImage(imageName: .myImage)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Playground延时运行有问题，需要引入PlaygroundSupport框架</p>
</li>
<li>Playground与项目协作</li>
<li>Playground的可视化开发</li>
<li>NaN 是not a number的意思，很特殊，但好像没啥用！ isNaN 判断是否是NaN</li>
<li>swift4以后可以用Codable协议进行json解析，序列化和反序列化操作</li>
<li>swift中NSNull会默认通过可选链转化为nil</li>
<li>在方法或属性上面使用快捷键（ alt+cmd+/ ）快速生成注释。也可使用<a href="https://github.com/realm/jazzy" target="_blank" rel="noopener">jazzy</a></li>
<li>swift由于类型安全，性能比较高！</li>
<li><p>log输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// #file 文件路径，#line 行号，#function 方法名</span><br><span class="line">func Log&lt;T&gt;(_ message: T, file: String = #file, method:String = #function, line:Int = #line)&#123;</span><br><span class="line">print(&quot;\((file as NSString).lastPathComponent)[\(line)],\(method): \(message)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中可以通过 &amp;+，&amp;-，&amp;*，&amp;/, &amp;% 来忽略溢出的错误</p>
</li>
<li>swift中没有宏定义，使用let 或 get属性来替代宏定义</li>
<li>属性访问控制：open (跨模块) &gt; public（本模块） &gt; interal（本模块内部用） &gt; fileprivate（本文件可用） &gt; private（本类可用）</li>
<li>swift中的测试</li>
<li>swift的CoreData使用</li>
<li>闭包很好用，最好写全了，别用乱七八糟的简写</li>
</ol>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    jiaozhengkui@163.com
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/" title="Swift开发者必备Tips">http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/原创/" rel="tag"><i class="fa fa-tag"></i> 原创</a>
          
            <a href="/tags/基础/" rel="tag"><i class="fa fa-tag"></i> 基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/28/复习swift：Swift-tips-tricks笔记下/" rel="next" title="复习swift：Swift tips & tricks笔记下">
                <i class="fa fa-chevron-left"></i> 复习swift：Swift tips & tricks笔记下
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/01/Flutter入门学习步骤/" rel="prev" title="Flutter入门学习步骤">
                Flutter入门学习步骤 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/author.jpg" alt="jiaozhengkui@163.com">
            
              <p class="site-author-name" itemprop="name">jiaozhengkui@163.com</p>
              <p class="site-description motion-element" itemprop="description">焦正奎的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">130</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiaozhengkui@163.com</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
