<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Swift开发者必备Tips |
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  <article id="post-Swift开发者必备Tips" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h1 class="article-title" itemprop="name">
      Swift开发者必备Tips
    </h1>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/04/10/Swift开发者必备Tips/" class="article-date">
  <time datetime="2018-04-09T16:20:23.000Z" itemprop="datePublished">2018-04-10</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        
                            




                                

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ol>
<li><p>柯里化: 通过模板来批量生成方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;</span><br><span class="line">return &#123; $0 &gt; comparer&#125;</span><br><span class="line">&#125;</span><br><span class="line">let greaterThan10 = greaterThan(10)</span><br><span class="line">greaterThan10(13) // true</span><br><span class="line">greaterThan10(0) // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>将protocol的方法声明为mutating：mutating关键字是为了能在该方法里修改struct或enum变量，另外使用class实现protocol时，可以不用加mutating，因class可随意改变量，mutating对于class时完全透明的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">protocol Vehicle &#123;</span><br><span class="line">var color: UIColor &#123;get set&#125;</span><br><span class="line">mutating func changeColor()</span><br><span class="line">&#125;</span><br><span class="line">struct MyCar: Vehicle &#123;</span><br><span class="line">var color = UIColor.blue</span><br><span class="line">mutating func changeColor() &#123;</span><br><span class="line">color = .red</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环可用于实现了Sequence的类型上，要实现Sequence需要先实现IteratorProtocol协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ReverseIterator&lt;T&gt;: IteratorProtocol &#123;</span><br><span class="line">typealias Element = T</span><br><span class="line">var array:[Element]</span><br><span class="line">var currentIndex = 0</span><br><span class="line">init(array:[Element]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">currentIndex = array.count - 1</span><br><span class="line">&#125;</span><br><span class="line">func next() -&gt; Element? &#123;</span><br><span class="line">if currentIndex &lt; 0 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;else &#123;</span><br><span class="line">let element = array[currentIndex]</span><br><span class="line">currentIndex -= 1</span><br><span class="line">return element</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct ReverseSequence&lt;T&gt;: Sequence &#123;</span><br><span class="line">var array:[T]</span><br><span class="line">init(array:[T]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">&#125;</span><br><span class="line">typealias Iterator = ReverseIterator&lt;T&gt;</span><br><span class="line">func makeIterator() -&gt; ReverseIterator&lt;T&gt; &#123;</span><br><span class="line">return ReverseIterator(array: self.array)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [2,3,4,5,7,6]</span><br><span class="line">for (index, value) in ReverseSequence(array: arr).enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(value)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func swap&lt;T&gt;(a: inout T, b: inout T) &#123;</span><br><span class="line">(a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2</span><br><span class="line">var b = 3</span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">print(&quot;a is \(a) b is \(b)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@autoclosure 是把形如 ()-&gt;T 的一句表达式（无参数，就一句）自动封装成闭包，var c = a ?? b,表示a非nil时c=a，nil时c=b，其实跟连着写的?: 是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func logIfTure(_ predicate: ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure (&#123; () -&gt; Bool in</span><br><span class="line">return 2 &gt; 1</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure (&#123;</span><br><span class="line">return 3 &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123; 4 &gt; 3 &#125;)</span><br><span class="line">logIfTure &#123; 5 &gt; 4 &#125;</span><br><span class="line"></span><br><span class="line">func logIfTureAutoclosure(_ predicate:@autoclosure ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意是小括号</span><br><span class="line">logIfTureAutoclosure(6&gt;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@escaping逃逸闭包，异步回调那种函数执行完了闭包还需要执行，注意循环引用使用weak self unowned self；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 逃逸闭包</span><br><span class="line">func testEscapingFunc(printNum: @escaping (_ num: Int) -&gt; ())&#123;</span><br><span class="line">print(&quot;testEscapingFunc begin&quot;)</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">printNum(66)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;testEscapingFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testEscapingFunc &#123; (num) in</span><br><span class="line">print(&quot;Escaping colsure begin&quot;)</span><br><span class="line">print(&quot;Escaping num is \(num)&quot;)</span><br><span class="line">print(&quot;Escaping colsure end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 非逃逸闭包</span><br><span class="line">func testNoescapeFunc(printNum: (_ num: Int) -&gt; ()) &#123;</span><br><span class="line">print(&quot;testNoescapeFunc begin&quot;)</span><br><span class="line">printNum(77)</span><br><span class="line">print(&quot;testNoescapeFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testNoescapeFunc &#123; (num) in</span><br><span class="line">print(&quot;Noescape colsure begin&quot;)</span><br><span class="line">print(&quot;Noescape num is \(num)&quot;)</span><br><span class="line">print(&quot;Noescape colsure end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional chaining ，返回的都是最后一个的可选类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Pet &#123;</span><br><span class="line">let name: String</span><br><span class="line">init(name: String) &#123;</span><br><span class="line">self.name = name</span><br><span class="line">&#125;</span><br><span class="line">func play() -&gt; (String) &#123;</span><br><span class="line">return &quot;playing&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child &#123;</span><br><span class="line">var pet: Pet?</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = Child()</span><br><span class="line">xiaoming.pet = Pet(name: &quot;dog&quot;)</span><br><span class="line">if let petName = xiaoming.pet?.name &#123;</span><br><span class="line">print(&quot;xiaoming pet name is \(petName)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if let p = xiaoming.pet?.play() &#123;</span><br><span class="line">print(&quot;xiaoming pet is \(p)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载操作符，慎用避免冲突，应该是公开的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">var x = 0</span><br><span class="line">var y = 0</span><br><span class="line">&#125;</span><br><span class="line">func +(left:Vector2D, right:Vector2D) -&gt; Vector2D&#123;</span><br><span class="line">return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">&#125;</span><br><span class="line">let v1 = Vector2D(x: 1, y: 2)</span><br><span class="line">let v2 = Vector2D(x: 3, y: 4)</span><br><span class="line">let v3 = v1 + v2</span><br><span class="line">print(&quot;v3 is \(v3)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>func的参数修饰，默认参数都是copy的，inout关键字可以直接修改参数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func incrementor1(x: Int) -&gt; Int &#123;</span><br><span class="line">x + 1</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;参数不可变 \(incrementor1(x: 1))&quot;)</span><br><span class="line">func incrementor2(x: inout Int) &#123;</span><br><span class="line">x = x + 1</span><br><span class="line">&#125;</span><br><span class="line">var x = 1</span><br><span class="line">incrementor2(x: &amp;x)</span><br><span class="line">print(&quot;参数可变 \(x)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字面量表达式，实现类似ExpressibleByBooleanLiteral的协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 以下就是字面量表达式，思考为啥写个true编译器就知道是BOOL类型的</span><br><span class="line">var aBool = true</span><br><span class="line">var aString = &quot;this is a string&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下标，数组下标注意越界，字典下标返回可选类型。可以重写数组或字典下标，也可以自定义下标,实现subscript方法，延伸阅读<a href="https://www.cnblogs.com/ludashi/p/5179275.html" target="_blank" rel="noopener">窥探Swift之数组安全索引与数组切片</a></p>
</li>
<li><p>方法嵌套，更清晰不用在别的地方调用一堆小方法了都在函数里面呢，访问权限更易管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer(add: Int) -&gt; (inout Int) -&gt; Void &#123;</span><br><span class="line">func incrementer(x : inout Int) -&gt; Void &#123;</span><br><span class="line">x = x + add</span><br><span class="line">&#125;</span><br><span class="line">return incrementer;</span><br><span class="line">&#125;</span><br><span class="line">let incrementer2 = makeIncrementer(add: 2)</span><br><span class="line">var y = 3</span><br><span class="line">incrementer2(&amp;y)</span><br><span class="line">print(&quot;\(y)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空间。基于module的而不是直接再代码中显示指明的，进行app开发时，默认添加app的主target里的内容都在同一命名空间里，即同一target里名称不能相同。</p>
</li>
<li><p>typealias，指定类型重命名。当实现多个协议时，也可以用 &amp; 连接多协议，用typealias重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol Dog &#123;</span><br><span class="line">func watch() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">protocol Cat &#123;</span><br><span class="line">func sleep() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">typealias Pet = Dog &amp; Cat</span><br></pre></td></tr></table></figure>
</li>
<li><p>associatedtype 如果有多个协议，它们的方法和属性都一样，只有协议中用到的类型不同，则可合并为一个使用关联类型(associatedtype)进行区分。实现时自定义typealias相应类型即可。延伸阅读<a href="https://www.cnblogs.com/muzijie/p/6596164.html" target="_blank" rel="noopener">Swift—–协议Protocol</a></p>
</li>
<li>可变参数<br><a href="https://www.jianshu.com/p/5a1178f3c36f" target="_blank" rel="noopener">OC的可变参数</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 注意可变参数必须是最后一个参数，且name后面有一个英文逗号</span><br><span class="line">- (void)testMultiplePramar:(NSString *)name, ... &#123;</span><br><span class="line">// 一个字符类型的指针，指针指向当前的参数，需要通过这个指针取参数。</span><br><span class="line">va_list arg_list;</span><br><span class="line">// 初始化字符指针的函数，将把arg_list指针指向name这个可变形参的第一个位置</span><br><span class="line">va_start(arg_list, name);</span><br><span class="line">NSLog(@&quot;第一个 ： %@&quot;, name);</span><br><span class="line">while(YES)&#123;</span><br><span class="line">// 这是一个取参数的函数，这个函数需要两个参数，第一个参数是字符指针va_list，第二个参数是我们需要取的可变参数的数据类型</span><br><span class="line">// 这个函数需要做两件事：1：取到指定数据类型的参数。2：将指针ap指向下一个可变参数的地址。</span><br><span class="line">NSString * obj=va_arg(arg_list,NSString *);</span><br><span class="line">// 取完所有参数之后，跳出循环</span><br><span class="line">if(obj==nil)break;</span><br><span class="line">NSLog(@&quot;--- %@&quot;,obj);</span><br><span class="line">&#125;</span><br><span class="line">// 最后要将指针ap指向NULL。避免野指针。和va_start成对使用。</span><br><span class="line">va_end(arg_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Swift版可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 只能有一个可变参数，位置不限类型相同</span><br><span class="line">func myFunc(numbers:Int..., str: String) &#123;</span><br><span class="line">numbers.forEach &#123; (i) in</span><br><span class="line">print(&quot;\(str)，第\(i)个&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunc(numbers: 1,2,3,4,5, str: &quot;hello&quot;)</span><br><span class="line">Swift版的stringformat方法 init(format:NSString, _ args: CVarArgType...)</span><br></pre></td></tr></table></figure></p>
<ol start="17">
<li><p>初始化方法顺序<br>明确一个问题<a href="https://stackoverflow.com/questions/8056188/should-i-refer-to-self-property-in-the-init-method-with-arc" target="_blank" rel="noopener">不要在init初始化方法里使用self.property</a> <br><br>A，OC是先初始化父类在初始化子类成员变量<br><br>B，1，先初始化子类成员变量，<br><br>2调用父类初始化，（若没第3步，可不写编译器自己加）<br><br>3对父类中需要改变的成员进行设定<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">// Designated 指定的 init初始化方法</span><br><span class="line">// 也可以加上required关键字以确保子类对其实现</span><br><span class="line">init(num: Int) &#123;</span><br><span class="line">numA = num; //可对let的实例常量赋值</span><br><span class="line">&#125;</span><br><span class="line">// 所有的便利构造器都必须调同一类中Designated初始化完成设置，且不能被子类重写或从子类中以super的方式调用</span><br><span class="line">convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 1000 : 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassB: ClassA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">override init(num: Int) &#123;</span><br><span class="line">numB = num + 2</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let bObj = ClassB(bigNum: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化返回nil<br>OC初始化失败可以返回nil，但swift没有return，因此swif中用 init? 表示返回可选值，即可能失败</p>
</li>
<li><a href="https://www.jianshu.com/p/c2c95c1c593d" target="_blank" rel="noopener">static 和 class</a>， 注意cpoy on write</li>
<li>容器(Array, Dictionary, Set)只能放同一类型元素，如果想放不同类型怎么办？<br><br>A。类型转换，信息损失十分危险，最好不要用！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">let mixed: [Any] = [1, &quot;Two&quot;,3]; // Any类型可以隐式转换</span><br><span class="line">// 转换为[NSObject]</span><br><span class="line">let objectArray = [1 as NSObject, &quot;two&quot; as NSObject, 3 as NSObject]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>B。如果有共同特征，可以添加实现同一协议的类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">let mixed2 : [CustomStringConvertible] = [1, &quot;two&quot;, 3]</span><br><span class="line">for obj in mixed2 &#123;</span><br><span class="line">print(obj.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C。将类型信息封装到enum中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">enum IntOrString &#123;</span><br><span class="line">case IntValue(Int)</span><br><span class="line">case StringValue(String)</span><br><span class="line">&#125;</span><br><span class="line">let mixed = [IntOrString.IntValue(1), IntOrString.StringValue(&quot;two&quot;), IntOrString.IntValue(3)]</span><br><span class="line">for value in mixed &#123;</span><br><span class="line">switch value &#123;</span><br><span class="line">case let .IntValue(i):</span><br><span class="line">print(i)</span><br><span class="line">case let .StringValue(str):</span><br><span class="line">print(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="21">
<li><p>default参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String = &quot;JZK&quot;, str:String)&#123;</span><br><span class="line">print(name+&quot; &quot;+str)</span><br><span class="line">&#125;</span><br><span class="line">hello(str: &quot;hello world&quot;)</span><br><span class="line">hello(name: &quot;dxm&quot;, str: &quot;hello world&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式。自定义符号还是麻烦，其实用OC的是最省事的，<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a>，<a href="https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149" target="_blank" rel="noopener">8个常用正则</a></p>
</li>
<li><p>模式匹配,没看懂好像就是switch的使用而已呀，重载~/ 跟switch有啥子关系。。。</p>
</li>
<li><p>… 和 ..&lt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 包含3，即输出0 1 2 3</span><br><span class="line">for i in 0...3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 小于3（不含3），即输出0 1 2</span><br><span class="line">for i in 0..&lt;3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 还可以通过 ... 或 ..&lt; 来连接两个字符串</span><br><span class="line">// 但经过试验发现很难用，例&quot;0&quot;...&quot;10&quot; 包含&quot;1&quot;但不包含&quot;2&quot;, 还有校验ASCII码 \0...~ 确实正确的</span><br></pre></td></tr></table></figure>
</li>
<li><p>AnyClass, 元类型和 .self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// swift中能够表示“任意”这个概念的除了 Any 和 AnyObject 外，还有AnyClass , AnyClass = AnyObject.Type</span><br><span class="line">// .Type 表示的是某个类型的元类型。.Protocol表示某个协议的元类型</span><br><span class="line">// 类型.self 表示获得该类型Class， 实例.self表示获得该实例对象</span><br><span class="line">import UIKit</span><br><span class="line">class AVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">class BVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 强转成AnyClass，类似工厂方法</span><br><span class="line">let VCTypes : [AnyClass] = [AVC.self, BVC.self]</span><br><span class="line">for type in VCTypes &#123;</span><br><span class="line">if type is UIViewController.Type &#123;</span><br><span class="line">// 想想为什么可以调init 类方法？</span><br><span class="line">let vc = (type as! UIViewController.Type).init()</span><br><span class="line">print(&quot;vc实例类型为：\(vc)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议和类方法中的Self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 协议没自己的上下文信息，也不知道谁实现。当我们希望在协议中使用的就是实现这个协议本身的类型的话，就需要使用Self（注意首字母大写）进行指代，此时Self不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态类型和多方法<br><a href="https://www.jianshu.com/p/7eb4053d339e" target="_blank" rel="noopener">dynamicType废除，用type(of:)代替</a></p>
</li>
<li>属性观察<br>存储型属性 willSet 和 didSet 方法中newValue表示将要设定的，oldValue表示已经设定的。注意初始化时不会调属性观察。计算形型属性只有get和set方法</li>
<li>final 表示不允许继承或重写。</li>
<li><p>lazy修饰符和lazy方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">// class或struct 的变量属性，且需指明类型</span><br><span class="line">lazy var str : String = &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">// lazy 也能修饰方法,对于可能提前退出情况，性能优化明显</span><br><span class="line">let arr = 1...3</span><br><span class="line">let result = arr.lazy.map &#123; (i: Int) -&gt; Int in</span><br><span class="line">print(&quot;map \(i)&quot;)</span><br><span class="line">return i * 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;begin&quot;)</span><br><span class="line">for i in result &#123;</span><br><span class="line">print(&quot;result \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>refection 和 mirror , 知道有反射就行了，最好不用</p>
</li>
<li>强制解包，少用才好，多用可选链！</li>
<li><p>多重optional</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var aNil : String? = nil</span><br><span class="line">var anotherNil : String?? = aNil</span><br><span class="line">var literalNil : String?? = nil</span><br><span class="line">if anotherNil != nil &#123;</span><br><span class="line">print(&quot;anotherNil&quot;) // 输出</span><br><span class="line">&#125;</span><br><span class="line">if literalNil != nil &#123;</span><br><span class="line">print(&quot;literalNil&quot;) //</span><br><span class="line">&#125;</span><br><span class="line">// 但用po输出时，anotherNil和literalNil 都是nil，因lldb已经将optional展开了</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional map ，没啥用</p>
</li>
<li><p>协议扩展 protocol extension， 可以为协议中定义的方法提供一个默认的实现</p>
</li>
<li><p>where 和模式匹配</p>
</li>
<li>indirect 和嵌套enum</li>
<li>swift的#selector 和OC的@selector一样，swift4中默认所有的swift方法在OC中都不可见，所以需要在方法前加上@objc 关键字。使用#selector时，swift的同名方法需要强制转化</li>
<li><p>实例方法动态调用，挺好玩的，虽然我也没想到有什么用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">func method(num: Int) -&gt; Int &#123;</span><br><span class="line">return num + 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化MyClass对象，再调用method方法就限定死了类型</span><br><span class="line">// 但swift中可直接用 Type.instanceMethod的语法生成一个可以柯里化的方法，只适用于实例方法，对getter或setter无效,同名方法需对 f 加上类型加以区别</span><br><span class="line">let f = MyClass.method</span><br><span class="line">let object = MyClass()</span><br><span class="line">let result = f(object)(1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 设置init方法为private来覆盖默认public的方法，保证其他地方不能init实例</span><br><span class="line">//方法一</span><br><span class="line">class AppShared &#123;</span><br><span class="line">private static let _sharedInstance = AppShared()</span><br><span class="line">class func sharedInstance() -&gt;AppShared&#123;</span><br><span class="line">return _sharedInstance</span><br><span class="line">&#125;</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方法二</span><br><span class="line">class AppShared2 &#123;</span><br><span class="line">static let sharedInstance = AppShared2()</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// swift中没有宏，实质上是一些全局常量和函数</span><br><span class="line">//#if condition //注意condition大小写敏感</span><br><span class="line">//#endif</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>延伸阅读<a href="https://www.cnblogs.com/Bob-wei/p/5237761.html" target="_blank" rel="noopener">Swift中如何使用 #if DEBUG</a><br>condition  | 可选参数<br>—|—<br>os() | macOS,iOS,tvOS,watchOS,Linux<br>arch() | x86_64, arm, arm64, i386<br>swift() | &gt;= 某个版本</p>
<ol start="42">
<li>编译标记OC的#param，在swift中用 // MARK:- 代替（注意大写），此外还有// TODO: 和 // FIXME: , 但没有#warning的替代品</li>
<li>@UIApplicationMain， 和OC的main函数是一样的，如果我们想使用UIApplicaiton的子类(例如监听所有的点击事件)，就可以创建main.swift</li>
<li>@objc 和 dynamic，swift写的类继承自NSObject的话，swift会自动为所有非private的类和成员加上@objc，但@objc并不意味着会变成动态派发，动态派发需用dynamic关键字。延伸阅读<a href="https://www.jianshu.com/p/37f720df43ac" target="_blank" rel="noopener">iOS OC与Swift混编</a>，注意和OC的@dynamic没任何关系，@dynamic表示不用编译器自动生成getter和setter方法</li>
<li>可选协议和协议扩展</li>
<li>内存管理，weak和unowned，如果再在访问时不会被释放的话，尽量用unowned，如果存在被释放的课鞥呢，那就用weak</li>
<li>@autoreleasepool在swift中已经没有了, swift提倡用初始化方法而不是用类方法来生成对象</li>
<li>值类型和引用类型，swift中所有的内建类型都是值类型，甚至String，array以及Dictionary都是值类型，值类型复制值发生在内容发生改变时</li>
<li>String 还是 NSString？能用String尽量用String，但使用Range时还是NSString更好用</li>
<li><p>UnsafePointer, 用于对C语言的指针进行转换，C中的基本类型在swift中对应的类型都有统一的命名规则：前面加上 C 且首字母大写，例如int 对应的类型为 CInt，int的指针转换到swift中对应的就是UnsafePointer<cint>, C的指针不可变用UnsafePointer,可变指针用UnsafeMutablePointer</cint></p>
</li>
<li><p>C指针的内存管理，无法使用ARC，deallocate与deinitialize应该要和allocate与initialize成对出现。malloc和calloc要与free匹配</p>
</li>
<li>C中指向函数的指针可转为闭包，不过需要加上@convention标注</li>
<li>GCD和延时调用, <a href="https://www.jianshu.com/p/51fd1362249e" target="_blank" rel="noopener">OC多线程</a> 和 <a href="https://www.cnblogs.com/csdnIOS/p/6874839.html" target="_blank" rel="noopener">swift的GCD</a></li>
<li>获取对象类型 type(of:)</li>
<li>OC的 isKindOfClass 和 isMemberOfClass 在swift中继承自NSObject的依然可以使用，swift还有 is 关键字等同于isKindOfClass，但也可以用于struct或enum进行类型判断。as 关键字向上转型；as！向下转型；as？向下转型，如果失败返回nil</li>
<li><p>swift中的KVO实现, 延伸：可用属性观察自己实现，也可<a href="http://chris.eidhof.nl/post/references/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">// 继承自NSObject</span><br><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">// 要检测的属性必须标注 @objc dynamic</span><br><span class="line">@objc dynamic var date = Date()</span><br><span class="line">&#125;</span><br><span class="line">class KvoClass: NSObject &#123;</span><br><span class="line">var myObject : MyClass!</span><br><span class="line">var observation: NSKeyValueObservation?</span><br><span class="line">override init() &#123;</span><br><span class="line">myObject = MyClass()</span><br><span class="line">print(&quot;初始化时间：\(Date())&quot;)</span><br><span class="line">observation = myObject.observe(\MyClass.date, options: [.new], changeHandler: &#123; (_, change) in</span><br><span class="line">if let newDate = change.newValue &#123;</span><br><span class="line">print(&quot;变化时间：\(Date())&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var kvoObject = KvoClass()</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123;</span><br><span class="line">kvoObject.myObject.date = Date()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部scope，隔离代码的好方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// OC中使用方法</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// 局部scope</span><br><span class="line">&#123;</span><br><span class="line">UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 100, 44)];</span><br><span class="line">label1.text = @&quot;first label&quot;;</span><br><span class="line">[self.view addSubview:label1];</span><br><span class="line">&#125;</span><br><span class="line">// GNU C的声明扩展</span><br><span class="line">UILabel *label2 = (&#123;</span><br><span class="line">UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 200, 100, 44)];</span><br><span class="line">tempLabel.text = @&quot;second label&quot;;</span><br><span class="line">tempLabel; // 注意没有return</span><br><span class="line">&#125;);</span><br><span class="line">[self.view addSubview:label2];</span><br><span class="line">&#125;</span><br><span class="line">// swift不允许直接使用大括号，和闭包冲突。而且没有GNU C的声明扩展</span><br><span class="line">// 但可以使用匿名闭包</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">let titleLabel : UILabel = &#123;</span><br><span class="line">let label = UILabel(frame: CGRect(x: 0, y: 100, width: 100, height: 44))</span><br><span class="line">label.text = &quot;匿名闭包&quot;</span><br><span class="line">return label</span><br><span class="line">&#125;()</span><br><span class="line">self.view.addSubview(titleLabel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中==表示判断两个对象是否指向同一块内存，在swift中对应为 === ，而swift中的 == 是一个操作符声明，在 Equatable 协议里声明，可重载，没重载的话就是 isEqual </p>
</li>
<li>哈希</li>
<li>类簇，swift中使用工厂方法模式来实现，因swift中初始化方法只能得到完成所有配置的当前类实例，即不可能在公共类中返回子类信息</li>
<li>swift中直接使用C代码或库是不可能的，因此使用C库最好的办法是使用OC文件封装，通过 工程名-Bridging-Header.h 桥接文件来调OC的代码</li>
<li><p>输出格式化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">var b = 1.234567890</span><br><span class="line">print(&quot;b is \(b)&quot;)</span><br><span class="line">let formatB = String(format: &quot;%.2f&quot;, b)</span><br><span class="line">print(&quot;保留两位小数 b is \(formatB)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NS_ENUM对应swift的enum，OC的NS_OPTIONS被映射为满足OptionSet协议的struct类型，以及一组静态的get属性，对不需要选项的可以用[]空集合表示，可以参照 AnimationOptions </p>
</li>
<li><p>数组的enumerated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (index, item) in [2,4,1,4,5].enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(item)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中可以通过@encode来获取类型编码，swift中可以通过转换为NSValue类型，使用objCType获取类型编码。类型编码这个运行时还是比较有用的</p>
</li>
<li>@asmname可直接将C函数映射为swift函数，但可能会有命名冲突，慎用</li>
<li><p>swift的protocol可以被class，struct，enum等类型遵守。而想要在swift中声明weak delegate，就最要将protocol限制在class内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将protocol限制在class内</span><br><span class="line">// 1,在protocol声明前加上@objc</span><br><span class="line">@objc protocol MyClassDelegate &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br><span class="line">// 更好的办法</span><br><span class="line">// 2，在protocol声明后加上class</span><br><span class="line">protocol ClassDelegate : class &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>associated object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private var key : Void?</span><br><span class="line">extension AppDelegate &#123;&apos;</span><br><span class="line">var associatedObject: String? &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return objc_getAssociatedObject(self, &amp;key) as? String</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_COPY)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中没有 @synchronized ，但可以自己实现一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// OC的@synchronized，也是调objc_sync_enter和objc_sync_exit，外加异常判断</span><br><span class="line">func syncchronized(_ lock: AnyObject, closure:()-&gt;())&#123;</span><br><span class="line">objc_sync_enter(lock) </span><br><span class="line">closure()</span><br><span class="line">objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC与CoreFoundation的转化规则：<strong>bridge转换OC和CF，不涉及内存；</strong>bridge_retained或CFBridgingRetain 将OC转换到CF，需要手动调用CFRelease来释放对象内存；__bridge_transfer或CFBridgingRelease将CF转化为OC，ARC负责释放对象。对于CF系API，如果API名字中含有Create，Copy或Retain的话，使用完成后要手动调CFRelease来释放内存。但在swift中，与CF的转化可以省掉了，也不用调CFRelease释放内存了，一个字：爽</p>
</li>
<li>swift命令号工具</li>
<li><p>随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// let num = Int(arc4random()) % 5 + 1 ;  iphone4，5上可能crash</span><br><span class="line">// 因swift的Int和CPU架构有关，在32位CPU上是Int32，64位CPU上是Int64，而arc4random不论什么平台上都是UInt32，故可能越界crash</span><br><span class="line">// 可用arc4random_uniform 实现相同效果</span><br><span class="line">let num = Int(arc4random_uniform()) % 5 + 1 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CustomStringConvertible 和 CustomDebugStringConvertible 协议可以格式化print样式</p>
</li>
<li><p>要throws另一个throws时，应将前者改为rethrows。<a href="https://www.cnblogs.com/junhuawang/p/6231084.html" target="_blank" rel="noopener">Swift异常处理</a> 和 <a href="https://www.jianshu.com/p/a71d87d92459" target="_blank" rel="noopener">swift的defer</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">//try? 抛出异常则返回nil,没抛出正常返回；try！肯定不会抛异常。但抛出异常就crash，慎用 </span><br><span class="line">//try somthing</span><br><span class="line">//try somthing</span><br><span class="line">&#125; catch let err as NSError &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NSAssert宏 在swift中对应为assert函数</p>
</li>
<li>fatalError可以在release和debug下终止程序，类似于Debug下NSAssert(NO, @”说明”);的作用</li>
<li>代码组织和Framework</li>
<li><p>安全的资源组织方式，OC时经常将资源名称定义为宏，这样可相对集中的管理和修改。swift可以用enum和extension来处理资源，原理如下。<a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener">SwiftGen</a> 和 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 可扫描文件自动生成对应的enum或struct文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ImageName: String &#123;</span><br><span class="line">case myImage = &quot;my_image&quot;</span><br><span class="line">&#125;</span><br><span class="line">extension UIImage &#123;</span><br><span class="line">convenience init?(imageName: ImageName)&#123;</span><br><span class="line">self.init(named: imageName.rawValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let image = UIImage(imageName: .myImage)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Playground延时运行有问题，需要引入PlaygroundSupport框架</p>
</li>
<li>Playground与项目协作</li>
<li>Playground的可视化开发</li>
<li>NaN 是not a number的意思，很特殊，但好像没啥用！ isNaN 判断是否是NaN</li>
<li>swift4以后可以用Codable协议进行json解析，序列化和反序列化操作</li>
<li>swift中NSNull会默认通过可选链转化为nil</li>
<li>在方法或属性上面使用快捷键（ alt+cmd+/ ）快速生成注释。也可使用<a href="https://github.com/realm/jazzy" target="_blank" rel="noopener">jazzy</a></li>
<li>swift由于类型安全，性能比较高！</li>
<li><p>log输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// #file 文件路径，#line 行号，#function 方法名</span><br><span class="line">func Log&lt;T&gt;(_ message: T, file: String = #file, method:String = #function, line:Int = #line)&#123;</span><br><span class="line">print(&quot;\((file as NSString).lastPathComponent)[\(line)],\(method): \(message)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中可以通过 &amp;+，&amp;-，&amp;*，&amp;/, &amp;% 来忽略溢出的错误</p>
</li>
<li>swift中没有宏定义，使用let 或 get属性来替代宏定义</li>
<li>属性访问控制：open (跨模块) &gt; public（本模块） &gt; interal（本模块内部用） &gt; fileprivate（本文件可用） &gt; private（本类可用）</li>
<li>swift中的测试</li>
<li>swift的CoreData使用</li>
<li>闭包很好用，最好写全了，别用乱七八糟的简写</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/" data-id="ckd90jolb003fxc515w9xz9yv" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    
        
  <nav class="article-nav">
    
      <a href="/2018/09/10/Shell复习/" class="article-nav-link">
        <strong class="article-nav-caption">Newer</strong>
        <div class="article-nav-title">
          
            Shell复习
          
        </div>
      </a>
    
    
      <a href="/2018/03/28/复习swift：Swift-tips-tricks笔记下/" class="article-nav-link">
        <strong class="article-nav-caption">Older</strong>
        <div class="article-nav-title">复习swift：Swift tips &amp; tricks笔记下</div>
      </a>
    
  </nav>


            

                
                    
                        
                            

</article>
</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
    <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>