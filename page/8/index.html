<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">焦正奎的博客</a></h1>
      <p>不要怕！不要悔！慢慢来！</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="焦正奎的博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-模态视图的半透明背景问题" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/08/03/模态视图的半透明背景问题/">模态视图的半透明背景问题</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/08/03/模态视图的半透明背景问题/" class="article-date">
  <time datetime="2016-08-03T10:14:18.000Z" itemprop="datePublished">2016-08-03</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;这两天做一个需求，弹出picker控件，本来很简单的需求，但开发过程中遇到一个坑：背景色怎么弄都没有半透明效果？查来查去才发现是presentViewController的坑</p>
<h3 id="模态视图相关"><a href="#模态视图相关" class="headerlink" title="模态视图相关"></a>模态视图相关</h3><ul>
<li><p>弹出和消失方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)presentViewController:(UIViewController *)viewControllerToPresent animated: (BOOL)flag completion:(void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);</span><br><span class="line">// The completion handler, if provided, will be invoked after the dismissed controller&apos;s viewDidDisappear: callback is invoked.</span><br><span class="line">- (void)dismissViewControllerAnimated: (BOOL)flag completion: (void (^ __nullable)(void))completion NS_AVAILABLE_IOS(5_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>弹出模态视图相关属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Defines the transition style that will be used for this view controller when it is presented modally. Set</span><br><span class="line">this property on the view controller to be presented, not the presenter.  Defaults to</span><br><span class="line">UIModalTransitionStyleCoverVertical.</span><br><span class="line">*/</span><br><span class="line">// 弹出模态ViewController时的四种动画风格</span><br><span class="line">typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123;</span><br><span class="line">// 从底部滑入</span><br><span class="line">UIModalTransitionStyleCoverVertical = 0,</span><br><span class="line">// 水平翻转</span><br><span class="line">UIModalTransitionStyleFlipHorizontal __TVOS_PROHIBITED,</span><br><span class="line">// 交叉溶解</span><br><span class="line">UIModalTransitionStyleCrossDissolve,</span><br><span class="line">// 翻页效果</span><br><span class="line">UIModalTransitionStylePartialCurl NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</span><br><span class="line">&#125;;</span><br><span class="line">@property(nonatomic,assign) UIModalTransitionStyle modalTransitionStyle NS_AVAILABLE_IOS(3_0);</span><br><span class="line"></span><br><span class="line">// 弹出模态ViewController时弹出风格</span><br><span class="line">typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123;</span><br><span class="line">// 由下到上,全屏覆盖</span><br><span class="line">UIModalPresentationFullScreen = 0,</span><br><span class="line">// 设备横屏，VC的显示方式则从横屏下方开始</span><br><span class="line">UIModalPresentationPageSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</span><br><span class="line">// VC显示都是从底部，宽度和屏幕宽度一样</span><br><span class="line">UIModalPresentationFormSheet NS_ENUM_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED,</span><br><span class="line">// VC的弹出方式和VC父VC的弹出方式相同</span><br><span class="line">UIModalPresentationCurrentContext NS_ENUM_AVAILABLE_IOS(3_2),</span><br><span class="line">// 自定义视图展示风格,</span><br><span class="line">UIModalPresentationCustom NS_ENUM_AVAILABLE_IOS(7_0),</span><br><span class="line">// 如果视图没有被填满,底层视图可以透过</span><br><span class="line">UIModalPresentationOverFullScreen NS_ENUM_AVAILABLE_IOS(8_0),</span><br><span class="line">// 视图全部被透过</span><br><span class="line">UIModalPresentationOverCurrentContext NS_ENUM_AVAILABLE_IOS(8_0),</span><br><span class="line">UIModalPresentationPopover NS_ENUM_AVAILABLE_IOS(8_0) __TVOS_PROHIBITED,</span><br><span class="line">UIModalPresentationNone NS_ENUM_AVAILABLE_IOS(7_0) = -1,</span><br><span class="line">&#125;;</span><br><span class="line">@property(nonatomic,assign) UIModalPresentationStyle modalPresentationStyle NS_AVAILABLE_IOS(3_2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：弹出半透明的模态视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// presentViewController并且需要半透明时</span><br><span class="line">UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:VC];</span><br><span class="line">[VC setModalPresentationStyle:UIModalPresentationCustom];</span><br><span class="line">[nav setModalPresentationStyle:UIModalPresentationCustom];</span><br><span class="line">self.modalPresentationStyle = UIModalPresentationCustom;</span><br><span class="line">[self presentViewController:nav animated:NO completion:nil];</span><br><span class="line">// presentViewController必须手写，使用xib或story都会有不可预测bug</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/08/03/模态视图的半透明背景问题/" data-id="ckd90jont009nxc515rcjsp9u" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-高效程序员的45个习惯" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/07/31/高效程序员的45个习惯/">高效程序员的45个习惯</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/07/31/高效程序员的45个习惯/" class="article-date">
  <time datetime="2016-07-31T10:14:18.000Z" itemprop="datePublished">2016-07-31</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="态度决定一切"><a href="#态度决定一切" class="headerlink" title="态度决定一切"></a>态度决定一切</h4><ol>
<li>做事，把矛头对准问题的解决办法，而不是人，这是真正有用处的正面效应</li>
<li>欲速则不达，要投入时间和精力保持代码的整洁、敞亮</li>
<li>对事不对人，让我们骄傲的应该是解决了问题，而不是比较出谁的主意更好</li>
<li>排除万难，奋勇前进，要诚实有勇气去说出实情，有时候这样做很困难，所以我们需要有足够的勇气</li>
</ol>
<h4 id="学无止境"><a href="#学无止境" class="headerlink" title="学无止境"></a>学无止境</h4><ol start="5">
<li>跟踪变化，不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯</li>
<li>对团队投资，通过午餐会议可以增进每个人的知识和技能，并帮助大家聚集在一起进行沟通交流。唤起人们对技术和技巧的激情，将会对项目大有裨益。</li>
<li>懂得丢弃，在学习一门新技术的时候，要丢去会阻止你前进的旧习惯。毕竟，汽车要比马车强得多。</li>
<li>打破沙锅问到底，不能只满足与别人告诉你的表面现象。要不停地提问直到你明白问题的根源。</li>
<li>把握开发节奏，保持时间之间稳定重复的间隔，更容易解决常见的重复任务</li>
</ol>
<h4 id="交付用户想要的软件"><a href="#交付用户想要的软件" class="headerlink" title="交付用户想要的软件"></a>交付用户想要的软件</h4><ol start="10">
<li>让客户做决定，开发者、经理或者业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。</li>
<li>让设计指导而不是操纵开发，设计指引你向正确的方向前进，它不是殖民地，它不应该标识具体的路线。你不要被设计（或者设计师）操控。</li>
<li>首先决定什么是你需要的，接着为这些具体的问题评估使用技术，对任何要使用的技术，多问一些挑剔的问题，并真实地作出回答。新技术就应该像是新的工具，可以帮助你更好地工作，她自己不应该是成为你的工作。</li>
<li>保持可以发布，保证你的系统随时可以编译、运行、测试并立即部署。</li>
<li>提早集成，频繁集成，代码集成式主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。</li>
<li>提早实现自动化部署，使用部署系统安装你的应用，在不同的机器上用不同的配置文件测试依赖问题。质量保证人员要像测试应用一样测试部署。</li>
<li>使用演示获得频繁反馈，在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有客户，给他们演示最新完成的功能，积极获得他们的反馈。</li>
<li>使用短迭代，增量发布，发布带有最小却可用功能块的产品。每个增量开发中，使用1~4周左右的迭代周期。</li>
<li>固定的价格就意味着背叛承诺，让团队和客户一起，真正地在当前项目中工作，做具体实际的评估。由客户控制他们要的功能和预算。</li>
</ol>
<h4 id="敏捷反馈"><a href="#敏捷反馈" class="headerlink" title="敏捷反馈"></a>敏捷反馈</h4><ol start="19">
<li>守护天使，好的单元测试能够为你的代码问题提供及时的警报。如果没有到位的单元测试，不要进行任何的设计和代码修改。</li>
<li>先用它再实现它，使用测试驱动开发作为设计工具，它会为你带来更简单更实效的设计。</li>
<li>环境中运行单元测试。要积极地寻找问题，为不是等问题来找你。</li>
<li>自动验收测试，为核心的业务逻辑创建测试，让你的客户单独验证这些测试，要让它们像一般的测试一样可以自动运行。</li>
<li>度量真实的进度，不要用不恰当的度量来欺骗自己或者团队。要评估那些需要完成的待办事项。</li>
<li>倾听用户的声音，每一个抱怨的背后都隐藏了一个事实，找出真相，修复真正的问题。</li>
</ol>
<h4 id="敏捷编码"><a href="#敏捷编码" class="headerlink" title="敏捷编码"></a>敏捷编码</h4><ol start="25">
<li>代码要清晰地表达意图，向代码阅读者明确表明你的意图。可读性差的代码一点也不聪明。</li>
<li>用代码沟通，使用细心选择的、有意义的命名。用注释描述代码意图和约束。注释不能替代优秀的代码。</li>
<li>动态评估取舍，考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。</li>
<li>增量式编程，在很短的编辑/构建/测试循环中编写代码，这要比花费长时间仅仅做编写代码的工作好得多。可以创建更加清晰、简单、易于维护的代码。</li>
<li>保持简单，除非有不可辩驳的原因，否则不要使用模式、原则和高难度技术之类的东西。</li>
<li>编写内聚的代码，让类的功能尽量集中，让组件尽量小。要避免创建很大的类或组件，也不要创建无所不包的大杂烩类。</li>
<li>告知，不要询问，不要抢别的对象或者是组件的工作。告诉它做什么，然后盯着你自己的指责就好了。</li>
<li>根据契约进行替换，通过替换遵循接口契约的类，来添加并改进功能特性。要使用更多的委托而不是继承。</li>
</ol>
<h4 id="敏捷调试"><a href="#敏捷调试" class="headerlink" title="敏捷调试"></a>敏捷调试</h4><ol start="33">
<li>记录问题解决日志，保留解决方案是修复问题过程的一部分，以后发生相同或类似问题时，就可以很快找到并使用了。</li>
<li>警告就是错误，签入带有警告的代码，就跟签入有错误或者没有通过测试的代码一样，都是极差的做法。签入构建工具中的代码不应该产生任何警告信息。</li>
<li>对问题各个击破，在解决问题时，要将问题域与周边隔离开。特别是在大型应用中。</li>
<li>报告所有的异常，不要将它们压制不管，就算是临时这样做也不行，在写代码时要估计到会发生的问题。</li>
<li>提供有用的错误信息，提供更多易于查找错误细节的方式，发生问题时，要展示出尽量多的支持细节，不过别让用户陷入其中。</li>
</ol>
<h4 id="敏捷协作"><a href="#敏捷协作" class="headerlink" title="敏捷协作"></a>敏捷协作</h4><ol start="38">
<li>定期安排会面时间。使用立会(站着开的会议)可以让团队达成共识。保证会议短小精悍不跑题。</li>
<li>架构师必须写代码。优秀的设计从积极的程序员那里开始演化。积极的编程可以带来深入的理解。不要使用不愿意编程的架构师——不知道系统的真实情况。是无法展开设计的。</li>
<li>实行代码集体所有制。让开发人员轮换完成系统不同领域中不同模块的不同任务。</li>
<li>成为指导者。分享自己的知识很有趣——付出的同时便有收获。还可以激励别人获得更好的成果，而且提升了整个团队的实力。</li>
<li>允许大家自己想办法。指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西。</li>
<li>准备好后再共享代码。绝对不要提交尚未完成的代码。故意签入编译未通过或是没有通过单元测试的代码，对项目来说，应该被视作为玩忽职守的犯罪行为。</li>
<li>做代码复查。对于提升代码质量和降低错误率来说，代码复查是无价之宝。如果以正确的方式进行，复查可以产生非常实用而高效的成果。要让不同的开发人员在每个任务完成后复查代码。</li>
<li>及时通报进展与问题。发布进展状况，新的想法和目前正在关注的主题。不要等着别人来问项目状态如何。</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/07/31/高效程序员的45个习惯/" data-id="ckd90jooi00bexc51jj6p33ds" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-CoreText练习" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/07/26/CoreText练习/">CoreText练习</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/07/26/CoreText练习/" class="article-date">
  <time datetime="2016-07-26T10:14:18.000Z" itemprop="datePublished">2016-07-26</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;前两天看到一篇文章<a href="http://www.cocoachina.com/articles/17050" target="_blank" rel="noopener">基于 CoreText 实现的高性能 UITableView</a>，思路比较清奇！以前水过NSAttributedString的使用，一般的文字排版已经能满足需求。但更复杂的文字排版就用到了CoreText，正好这块也不是很熟悉，正好学习一下</p>
<h3 id="1-CoreText简介"><a href="#1-CoreText简介" class="headerlink" title="1 CoreText简介"></a>1 CoreText简介</h3><p>&emsp;&emsp;CoreText是用于处理文字和字体的底层技术。工作在Core Graphics之上。Quartz能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此CoreText具有更高效的排版功能。详细内容参考<a href="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005533-CH1-SW1" target="_blank" rel="noopener">About Core Text</a></p>
<p>&emsp;&emsp;CoreText和UIWebview两种排版方案对比</p>
<ol>
<li>CoreText占用内存更少，渲染速度更快，UIWebView占用内存多，渲染速度慢。</li>
<li>CoreText在渲染界面前就可以精确地获得显示内容的高度（只要有了CTFrame即可），而UIWebView只有渲染出内容后，才能获得内容的高度（而且还需要通过JavaScript代码来获取）。</li>
<li>CoreText的CTFrame可以在后台线程渲染，UIWebView的内容只能在主线程（UI线程）渲染。</li>
<li>CoreText只支持渲染不支持长按复制，UIWebview可以支持</li>
</ol>
<h3 id="2-文字排版的基础概念"><a href="#2-文字排版的基础概念" class="headerlink" title="2 文字排版的基础概念"></a>2 文字排版的基础概念</h3><p>&emsp;&emsp;盗图<a href="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/FontHandling/FontHandling.html#//apple_ref/doc/uid/TP40009459-CH5-SW1" target="_blank" rel="noopener">官网</a><br><img src="https://developer.apple.com/library/archive/documentation/TextFonts/Conceptual/CocoaTextArchitecture/Art/glyph_metrics_2x.png" alt="image"></p>
<ul>
<li>字体(Font)：需要注意的是粗体、斜体等都是不同字体，这也解释了为啥UI自定义字体时要给好几套，粗体斜体都有对应的字体文件</li>
<li>字体集(Font family):是一组相关字体</li>
<li>字符(Character)和字形(Glyphs)：字符就是字面意一般就是指某种编码，如Unicode编码，而字形则是这些编码对应的图片</li>
<li>边框(Bounding Box)：一个假想的边框，尽可能地容纳整个字形。</li>
<li>磅值(Weight):用于描述字体粗度</li>
<li>基线(Baseline)：一条假想的参照线，以此为基础进行字形的渲染。一般来说是一条横线。</li>
<li>基础原点(Origin)：基线上最左侧的点。</li>
<li>上行高度(Ascent)和下行高度(Decent)：一个字形最高点和最低点到基线的距离，前者为正数，而后者为负数。lineHeight = Ascent + |Decent| + Leading。</li>
<li>x高度(X height):指小写字母的平均高度(以x为基准)。磅值相同的两字母,x高度越大的字母看起来比x高度小的字母要大</li>
<li>Cap高度(Cap height):与x高度相似。指大写字母的平均高度(以C为基准)</li>
<li>描边(Stroke):组成字符的线或曲线。可以加粗或改变字符形状</li>
<li>行间距(Leading)：行与行之间的间距。</li>
<li>字间距(Kerning)：字与字之间的距离，为了排版的美观，并不是所有的字形之间的距离都是一致的，但是这个基本步影响到我们的文字排版。</li>
</ul>
<h3 id="3-CoreText中常用类"><a href="#3-CoreText中常用类" class="headerlink" title="3 CoreText中常用类"></a>3 CoreText中常用类</h3><ul>
<li><a href="https://developer.apple.com/documentation/coretext/ctfont?language=objc" target="_blank" rel="noopener">CTFont</a> | Core Text字体对象。字体对象表示应用程序的字体，提供对字体特征的访问，例如磅值，变换矩阵和其他属性</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctframe?language=objc" target="_blank" rel="noopener">CTFrame</a> | 想象成画布，可包含多行文本</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctframesetter?language=objc" target="_blank" rel="noopener">CTFramesetter</a> | CTFrame的一个Factory，通过传入CGPath生成相应的CTFrame并使用它进行渲染</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctline?language=objc" target="_blank" rel="noopener">CTLine</a> | 表示一行文本。</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctparagraphstyle?language=objc" target="_blank" rel="noopener">CTParagraphStyle</a> | 段落属性</li>
<li><a href="https://developer.apple.com/documentation/coretext/ctrun?language=objc" target="_blank" rel="noopener">CTRun</a> | 绘制的最小单元，<a href="https://developer.apple.com/documentation/coretext/ctrundelegate?language=objc" target="_blank" rel="noopener">CTRunDelegate</a>实现图文混排的原理：用一个空白字符作为图片的占位符，设好Delegate，占好位置，然后用CoreGraphics进行图片的绘制</li>
</ul>
<p>&emsp;&emsp;一个CTFrame是由一行一行的CLine组成，每个CTLine又会包含若干个CTRun(既字形绘制的最小单元)，通过相应的方法可以获取到不同位置的CTRun和CTLine，以实现对不同位置touch事件的响应。注意：你不需要自己创建CTRun，CoreText将根据NSAttributedString的属性来自动创建CTRun。</p>
<p><img src="https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/CoreText_Programming/Art/core_text_arch_2x.png" alt="image"></p>
<h3 id="4-绘制"><a href="#4-绘制" class="headerlink" title="4 绘制"></a>4 绘制</h3><h4 id="4-1-常用文本绘制"><a href="#4-1-常用文本绘制" class="headerlink" title="4.1 常用文本绘制"></a>4.1 常用文本绘制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetTextMatrix(context , CGAffineTransformIdentity);</span><br><span class="line">CGContextTranslateCTM(context , 0 ,self.bounds.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0 ,-1.0);</span><br><span class="line"></span><br><span class="line">NSString *str = @&quot;core text dome string. 富文本测试&quot;;</span><br><span class="line">NSMutableAttributedString *mabstring = [[NSMutableAttributedString alloc]initWithString:str];</span><br><span class="line"></span><br><span class="line">[mabstring beginEditing];</span><br><span class="line">/*</span><br><span class="line">kCTCharacterShapeAttributeName;//字体形状属性  必须是CFNumberRef对象默认为0，非0则对应相应的字符形状定义，如1表示传统字符形状</span><br><span class="line">kCTFontAttributeName;//字体属性   必须是CTFont对象</span><br><span class="line">kCTKernAttributeName;//字符间隔属性 必须是CFNumberRef对象</span><br><span class="line">kCTForegroundColorAttributeName; //字体颜色属性  必须是CGColor对象，默认为black</span><br><span class="line">kCTForegroundColorFromContextAttributeName //上下文的字体颜色属性 必须为CFBooleanRef 默认为False,</span><br><span class="line">kCTParagraphStyleAttributeName //段落样式属性 必须是CTParagraphStyle对象 默认为NIL</span><br><span class="line">kCTStrokeWidthAttributeName //笔画线条宽度 必须是CFNumberRef对象，默为0.0f，标准为3.0f</span><br><span class="line">kCTStrokeColorAttributeName //笔画的颜色属性 必须是CGColorRef 对象，默认为前景色</span><br><span class="line">kCTSuperscriptAttributeName //设置字体的上下标属性 必须是CFNumberRef对象 默认为0,可为-1为下标,1为上标，需要字体支持才行。如排列组合的样式Cn1</span><br><span class="line">kCTUnderlineColorAttributeName //字体下划线颜色属性 必须是CGColorRef对象，默认为前景色</span><br><span class="line">kCTUnderlineStyleAttributeName //字体下划线样式属性 必须是CFNumberRef对象,默为kCTUnderlineStyleNone 可以通过CTUnderlineStypleModifiers 进行修改下划线风格</span><br><span class="line">kCTVerticalFormsAttributeName//文字的字形方向属性 必须是CFBooleanRef 默认为false，false表示水平方向，true表示竖直方向</span><br><span class="line">kCTGlyphInfoAttributeName //字体信息属性 必须是CTGlyphInfo对象</span><br><span class="line">kCTRunDelegateAttributeName //CTRun 委托属性 必须是CTRunDelegate对象</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *attributes = [NSMutableDictionary dictionaryWithObject:(id)[UIColor redColor].CGColor forKey:(id)kCTForegroundColorAttributeName];</span><br><span class="line">CTFontRef font = CTFontCreateWithName((CFStringRef)[UIFont italicSystemFontOfSize:40].fontName, 40, NULL);</span><br><span class="line">[attributes setObject:(__bridge id)font forKey:(id)kCTFontAttributeName];</span><br><span class="line">[attributes setObject:(id)[NSNumber numberWithInt:kCTUnderlineStyleDouble] forKey:(id)kCTUnderlineStyleAttributeName];</span><br><span class="line">[mabstring addAttributes:attributes range:NSMakeRange(0, 4)];</span><br><span class="line"></span><br><span class="line">[mabstring endEditing];</span><br><span class="line"></span><br><span class="line">CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)mabstring);</span><br><span class="line">CGMutablePathRef Path = CGPathCreateMutable();</span><br><span class="line">CGPathAddRect(Path, NULL ,CGRectMake(0 , 0 ,self.bounds.size.width , self.bounds.size.height));</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), Path, NULL);</span><br><span class="line">CGContextSaveGState(context);</span><br><span class="line">CTFrameDraw(frame,context);</span><br><span class="line"></span><br><span class="line">CGPathRelease(Path);</span><br><span class="line">CFRelease(framesetter);</span><br><span class="line">UIGraphicsPushContext(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-图文混排"><a href="#4-2-图文混排" class="headerlink" title="4.2 图文混排"></a>4.2 图文混排</h4><p>&emsp;&emsp;以下代码摘自<a href="https://www.jianshu.com/p/6db3289fb05d" target="_blank" rel="noopener">CoreText实现图文混排</a>！直接看代码吧不难，核心：用一个空白字符作为图片的占位符，设好Delegate，占好位置，然后用CoreGraphics进行图片的绘制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">-(void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">[super drawRect:rect];</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetTextMatrix(context, CGAffineTransformIdentity);    CGContextTranslateCTM(context, 0, self.bounds.size.height);</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">NSMutableAttributedString * attributeStr = [[NSMutableAttributedString alloc] initWithString:@&quot;\n这里在测试图文混排，\n我是一个富文本&quot;];</span><br><span class="line">CTRunDelegateCallbacks callBacks;</span><br><span class="line">callBacks.version = kCTRunDelegateVersion1;</span><br><span class="line">callBacks.getAscent = ascentCallBacks;</span><br><span class="line">callBacks.getDescent = descentCallBacks;</span><br><span class="line">callBacks.getWidth = widthCallBacks;</span><br><span class="line">NSDictionary * dicPic = @&#123;@&quot;height&quot;:@129,@&quot;width&quot;:@400&#125;;</span><br><span class="line">CTRunDelegateRef delegate = CTRunDelegateCreate(&amp; callBacks, (__bridge void *)dicPic);</span><br><span class="line">unichar placeHolder = 0xFFFC;</span><br><span class="line">NSString * placeHolderStr = [NSString stringWithCharacters:&amp;placeHolder length:1];</span><br><span class="line">NSMutableAttributedString * placeHolderAttrStr = [[NSMutableAttributedString alloc] initWithString:placeHolderStr];</span><br><span class="line">CFAttributedStringSetAttribute((CFMutableAttributedStringRef)placeHolderAttrStr, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate);</span><br><span class="line">CFRelease(delegate);</span><br><span class="line">[attributeStr insertAttributedString:placeHolderAttrStr atIndex:12];</span><br><span class="line">CTFramesetterRef frameSetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attributeStr);</span><br><span class="line">CGMutablePathRef path = CGPathCreateMutable();</span><br><span class="line">CGPathAddRect(path, NULL, self.bounds);</span><br><span class="line">NSInteger length = attributeStr.length;</span><br><span class="line">CTFrameRef frame = CTFramesetterCreateFrame(frameSetter, CFRangeMake(0, length), path, NULL);</span><br><span class="line">CTFrameDraw(frame, context);</span><br><span class="line"></span><br><span class="line">UIImage * image = [UIImage imageNamed:@&quot;bd_logo1&quot;];</span><br><span class="line">CGRect imgFrm = [self calculateImageRectWithFrame:frame];</span><br><span class="line">CGContextDrawImage(context,imgFrm, image.CGImage);</span><br><span class="line">CFRelease(frame);</span><br><span class="line">CFRelease(path);</span><br><span class="line">//    CFRelease(frameSetter);</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat ascentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;height&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat descentCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">static CGFloat widthCallBacks(void * ref)</span><br><span class="line">&#123;</span><br><span class="line">return [(NSNumber *)[(__bridge NSDictionary *)ref valueForKey:@&quot;width&quot;] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-(CGRect)calculateImageRectWithFrame:(CTFrameRef)frame</span><br><span class="line">&#123;</span><br><span class="line">NSArray * arrLines = (NSArray *)CTFrameGetLines(frame);</span><br><span class="line">NSInteger count = [arrLines count];</span><br><span class="line">CGPoint points[count];</span><br><span class="line">CTFrameGetLineOrigins(frame, CFRangeMake(0, 0), points);</span><br><span class="line">for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">CTLineRef line = (__bridge CTLineRef)arrLines[i];</span><br><span class="line">NSArray * arrGlyphRun = (NSArray *)CTLineGetGlyphRuns(line);</span><br><span class="line">for (int j = 0; j &lt; arrGlyphRun.count; j ++) &#123;</span><br><span class="line">CTRunRef run = (__bridge CTRunRef)arrGlyphRun[j];</span><br><span class="line">NSDictionary * attributes = (NSDictionary *)CTRunGetAttributes(run);</span><br><span class="line">CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[attributes valueForKey:(id)kCTRunDelegateAttributeName];</span><br><span class="line">if (delegate == nil) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">NSDictionary * dic = CTRunDelegateGetRefCon(delegate);</span><br><span class="line">if (![dic isKindOfClass:[NSDictionary class]]) &#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">CGPoint point = points[i];</span><br><span class="line">CGFloat ascent;</span><br><span class="line">CGFloat descent;</span><br><span class="line">CGRect boundsRun;</span><br><span class="line">boundsRun.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL);</span><br><span class="line">boundsRun.size.height = ascent + descent;</span><br><span class="line">CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL);</span><br><span class="line">boundsRun.origin.x = point.x + xOffset;</span><br><span class="line">boundsRun.origin.y = point.y - descent;</span><br><span class="line">CGPathRef path = CTFrameGetPath(frame);</span><br><span class="line">CGRect colRect = CGPathGetBoundingBox(path);</span><br><span class="line">CGRect imageBounds = CGRectOffset(boundsRun, colRect.origin.x, colRect.origin.y);</span><br><span class="line">return imageBounds;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return CGRectZero;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.jianshu.com/p/6db3289fb05d" target="_blank" rel="noopener">CoreText实现图文混排</a></li>
<li><a href="http://www.cocoachina.com/articles/17050" target="_blank" rel="noopener">基于 CoreText 实现的高性能 UITableView</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/07/26/CoreText练习/" data-id="ckd90joki0019xc51qcz1zi9k" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-CoreGraphics2：进阶" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/07/19/CoreGraphics2：进阶/">CoreGraphics2：进阶</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/07/19/CoreGraphics2：进阶/" class="article-date">
  <time datetime="2016-07-19T10:14:18.000Z" itemprop="datePublished">2016-07-19</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="3-3-Quartz变换函数"><a href="#3-3-Quartz变换函数" class="headerlink" title="3.3 Quartz变换函数"></a>3.3 Quartz变换函数</h4><ul>
<li><p>平移绘图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextTranslateCTM(context, 100, 200);</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转绘图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextRotateCTM(context, M_PI_4);</span><br></pre></td></tr></table></figure>
</li>
<li><p>缩放绘图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextScaleCTM(context, 0.5, 0.8);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要即平移又旋转怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">CGAffineTransform 处理形变的类,二维坐标系,即向右为x轴正方向,向上为y轴正方向</span><br><span class="line">方法简介：</span><br><span class="line">CGAffineTransformTranslate // x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformScale // x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformRotate // 逆时针旋转弧度,M_PI=180角度)</span><br><span class="line"></span><br><span class="line">以下都是针对视图的原定最初位置的中心点为起始参照进行相应操作的，</span><br><span class="line">CGAffineTransformMakeTranslation // 将坐标系统x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformMakeScale // 将坐标系统x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformMakeRotation // 将坐标系统逆时针旋转弧度,M_PI=180角度)</span><br><span class="line">*/</span><br><span class="line">CGAffineTransform transform = CGAffineTransformIdentity;</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, newSize.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI);</span><br><span class="line">// 得到一个倒置矩阵。应用倒置矩阵将抵消原矩阵的变换效果。</span><br><span class="line">// CGAffineTransform invertTransform = CGAffineTransformInvert(transform);</span><br><span class="line">// 判断仿射变换是否相等。</span><br><span class="line">// CGAffineTransformEqualToTransform(invertTransform, transform) </span><br><span class="line">// 判断仿射变换是否为单位变换。单位变换没有平移、缩放和旋转操作。</span><br><span class="line">// CGAffineTransformIsIdentity(invertTransform)</span><br><span class="line"></span><br><span class="line">// 合并多个变换函数</span><br><span class="line">CGContextConcatCTM(context, invertTransform);</span><br><span class="line"></span><br><span class="line">// 在操作结束之后可对设置量进行还原：</span><br><span class="line">view.transform＝CGAffineTransformIdentity;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-4-颜色与颜色空间"><a href="#3-4-颜色与颜色空间" class="headerlink" title="3.4 颜色与颜色空间"></a>3.4 颜色与颜色空间</h4><ul>
<li><p>创建设备依赖颜色空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建设备依赖RGB颜色空间。</span><br><span class="line">// CGColorSpaceCreateDeviceGray(); CGColorSpaceCreateDeviceCMYK();</span><br><span class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">// 设置填充的颜色空间</span><br><span class="line">CGContextSetFillColorSpace(context, colorSpace);</span><br><span class="line">// 设置描边的颜色空间</span><br><span class="line">CGContextSetStrokeColorSpace(context, colorSpace);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建并填充颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1, 使用颜色空间创建颜色</span><br><span class="line">CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">CGFloat components[] = &#123;250/255.0, 100/255.0, 70/255.0, 1.0&#125;;</span><br><span class="line">CGColorRef color = CGColorCreate(colorspace, components);</span><br><span class="line">CGContextSetStrokeColorWithColor(context, color);</span><br><span class="line">CGContextSetFillColorWithColor(context, color);</span><br><span class="line"></span><br><span class="line">// 2，快速设置依赖RGB颜色的颜色值。</span><br><span class="line">CGContextSetRGBStrokeColor(context, 1, 0, 0, 1);</span><br><span class="line">CGContextSetRGBFillColor(context, 1, 0, 0, 1);</span><br><span class="line"></span><br><span class="line">// 3, 使用UI函数设置颜色值</span><br><span class="line">CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-5-阴影"><a href="#3-5-阴影" class="headerlink" title="3.5 阴影"></a>3.5 阴影</h4><ul>
<li>阴影被设置后，任何绘制的对象都有一个阴影，如果需多个阴影投射在一起，可使用一个透明层；该图层类似一个先是叠加所有绘图然后加上阴影的一个子上下文</li>
<li>关闭阴影：如果在设置阴影之前保存了图形状态，就可以通过恢复图形状态来关闭阴影。也可以通过设置阴影颜色为 NULL 来关闭阴影。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 阴影的位置表示为CGSize，如果CGSize的两个值都是正数，则表示阴影是朝下和朝右的。模糊度被表示为任何一个正数</span><br><span class="line">CGContextSetShadowWithColor(myContext, CGSizeMake(15, 20), 5, [UIColor redColor].CGColor);</span><br><span class="line">// 默认颜色 RGBA 值 &#123;0, 0, 0, 1.0 / 3.0&#125;</span><br><span class="line">CGContextSetShadow(context, CGSizeMake(15, 20), 5);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-渐变"><a href="#3-6-渐变" class="headerlink" title="3.6 渐变"></a>3.6 渐变</h4><ul>
<li><p>CGGradient 绘制径向和轴向渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 绘制渐变</span><br><span class="line">// 颜色数组和位置数组必须一一对应，最少两个：起点和终点</span><br><span class="line">CGFloat locs[3] = &#123; 0.0, 0.5, 1.0 &#125;;</span><br><span class="line">CGFloat colors[12] = &#123;</span><br><span class="line">0.3,0.3,0.3,0.8, // 开始颜色</span><br><span class="line">0.0,0.0,0.0,1.0, // 中间颜色</span><br><span class="line">0.3,0.3,0.3,0.8 // 末尾颜色</span><br><span class="line">&#125;;</span><br><span class="line">CGColorSpaceRef sp = CGColorSpaceCreateDeviceRGB();</span><br><span class="line">CGGradientRef grad = CGGradientCreateWithColorComponents (sp, colors, locs, 3);</span><br><span class="line">// 绘制轴向渐变</span><br><span class="line">/*</span><br><span class="line">CGContextRef cg_nullable c,</span><br><span class="line">CGGradientRef cg_nullable gradient,</span><br><span class="line">CGPoint startPoint, 起点</span><br><span class="line">CGPoint endPoint,   终点</span><br><span class="line">CGGradientDrawingOptions options</span><br><span class="line">kCGGradientDrawsBeforeStartLocation 向外渐变</span><br><span class="line">kCGGradientDrawsAfterEndLocation 向里渐变</span><br><span class="line">*/</span><br><span class="line">//    CGContextDrawLinearGradient(context, grad, CGPointMake(50,0), CGPointMake(100,0), 0);</span><br><span class="line"></span><br><span class="line">// 绘制径向渐变</span><br><span class="line">/*</span><br><span class="line">CGContextRef cg_nullable c,</span><br><span class="line">CGGradientRef cg_nullable gradient,</span><br><span class="line">CGPoint startCenter, 外圈中心点</span><br><span class="line">CGFloat startRadius, 外圈半径</span><br><span class="line">CGPoint endCenter,   内圈中心点</span><br><span class="line">CGFloat endRadius,   内圈半径</span><br><span class="line">CGGradientDrawingOptions options</span><br><span class="line">*/</span><br><span class="line">CGContextDrawRadialGradient(context, grad, CGPointMake(100, 200), 5, CGPointMake(100, 200), 50, 0);</span><br><span class="line">CGColorSpaceRelease(sp);</span><br><span class="line">CGGradientRelease(grad);</span><br></pre></td></tr></table></figure>
</li>
<li><p>CGShading 绘制径向和轴向渐变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// to do</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-7-透明层"><a href="#3-7-透明层" class="headerlink" title="3.7 透明层"></a>3.7 透明层</h4><ul>
<li>透明层通过组合两个或多个对象来生成一个组合图形。把它当场一个单独对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 给两个圆组成的大眼睛绘制阴影</span><br><span class="line">CGContextSetShadowWithColor(context, CGSizeZero, 10, [UIColor grayColor].CGColor);</span><br><span class="line">// 开始透明层，begin和end之间的当做一个单独对象对待</span><br><span class="line">CGContextBeginTransparencyLayer(context, NULL);</span><br><span class="line">// 添点料</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);</span><br><span class="line">CGContextFillEllipseInRect(context, CGRectMake(100, 150, 100, 100));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor blueColor].CGColor);</span><br><span class="line">CGContextFillEllipseInRect(context, CGRectMake(150, 150, 100, 100));</span><br><span class="line">// 结束透明层，生成一个组合图层，begin和end必须一一对应</span><br><span class="line">CGContextEndTransparencyLayer(context);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-8-抗锯齿"><a href="#3-8-抗锯齿" class="headerlink" title="3.8 抗锯齿"></a>3.8 抗锯齿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextSetShouldAntialias(context, YES); // 打开抗锯齿</span><br></pre></td></tr></table></figure>
<h4 id="3-9模板"><a href="#3-9模板" class="headerlink" title="3.9模板"></a>3.9模板</h4><ul>
<li>模板表示为CGPattern（具体类型为CGPatternRef）。你可以创建一个模板并使用它进行描边或填充。跟帖瓷砖差不多<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void drawTile(void *info,CGContextRef context) &#123;</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor redColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(0, 0, 30, 30));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor grayColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(0, 30, 30, 30));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor blueColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(30, 0, 30, 30));</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor purpleColor].CGColor);</span><br><span class="line">CGContextFillRect(context, CGRectMake(30, 30, 30, 30));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">//填充模式回调函数结构体</span><br><span class="line">/*</span><br><span class="line">version 回调结构体的版本号，可以设置为 0</span><br><span class="line">drawPattern 指向绘制回调的指针。</span><br><span class="line">releaseInfo 该回调在释放 CGPatternRef 对象时被调用，如果不用可传NULL</span><br><span class="line">*/ </span><br><span class="line">CGPatternCallbacks callback = &#123;0,drawTile,NULL&#125;;</span><br><span class="line"></span><br><span class="line">//设置砖块样式</span><br><span class="line">/*</span><br><span class="line">void *infoCGRect</span><br><span class="line">bounds    每块瓷砖的大小</span><br><span class="line">CGAffineTransform matrix     变换矩阵，如果不用变换可以传入CGAffineTransformIdentity</span><br><span class="line">CGFloat xStep, CGFloat yStep  指定瓷砖块横向和纵向的间距，如果大于瓷砖大小，瓷砖间会有间隙</span><br><span class="line">CGPatternTiling tiling  平铺模式 kCGPatternTilingNoDistortion 无失真,kCGPatternTilingConstantSpacingMinimalDistortion 恒定间距的最小失真,kCGPatternTilingConstantSpacing恒定间距平铺</span><br><span class="line">bool isColored    瓷砖是否有颜色</span><br><span class="line">const CGPatternCallbacks *callbacks   回调函数结构体</span><br><span class="line">*/</span><br><span class="line">CGPatternRef pattern = CGPatternCreate(NULL, CGRectMake(0, 0, 60, 60), CGAffineTransformIdentity, 60, 60, kCGPatternTilingNoDistortion, true, &amp;callback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置颜色空间</span><br><span class="line">//设备无关的颜色空间 CGColorSpaceCreateDeviceRGB();</span><br><span class="line">//模式填充颜色空间,注意对于有颜色填充模式，这里传NULL</span><br><span class="line">CGColorSpaceRef colorSpace = CGColorSpaceCreatePattern(NULL);</span><br><span class="line">CGContextSetFillColorSpace(context, colorSpace);</span><br><span class="line">CGContextSetStrokeColorSpace(context, colorSpace);</span><br><span class="line"></span><br><span class="line">float alpha = 1;</span><br><span class="line">////最后一个参数对于有颜色瓷砖指定为透明度的参数地址，对于无颜色瓷砖则指定当前颜色空间对应的颜色数组</span><br><span class="line">CGContextSetFillPattern(context, pattern, &amp;alpha);</span><br><span class="line">CGContextSetStrokePattern(context, pattern, &amp;alpha);</span><br><span class="line"></span><br><span class="line">//绘制</span><br><span class="line">CGContextFillRect(context, CGRectMake(0, 20, 155, 155));</span><br><span class="line">CGContextStrokeRectWithWidth(context, CGRectMake(165,20, 155, 155), 5);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-10-怎么绘制1像素的线"><a href="#3-10-怎么绘制1像素的线" class="headerlink" title="3.10 怎么绘制1像素的线"></a>3.10 怎么绘制1像素的线</h4><ul>
<li>Core Graphics做了大量操作，一般不需要关注x y坐标中点和实际上屏幕显示的像素关系！</li>
<li>像素到点的转化，可以通过 除以 UIView的contentScaleFactor属性</li>
<li>最精确的方式绘制一条水平或垂直的线条的方式不是描边路径，而是填充路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextFillRect(context, CGRectMake(0,0,1.0/self.contentScaleFactor,100));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-11-每次都setNeedsDisplay好烦呀"><a href="#3-11-每次都setNeedsDisplay好烦呀" class="headerlink" title="3.11 每次都setNeedsDisplay好烦呀"></a>3.11 每次都setNeedsDisplay好烦呀</h4><ul>
<li><p>可以通过修改view的contentMode为UIViewContentModeRedraw，这将引起缓存内容的自动缩放和重定位被关闭，最终结果是视图的setNeedsDisplay方法将被调用，触发drawRect：方法重绘视图内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View.contentMode = UIViewContentModeRedraw;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只是暂时调整大小，例如动画变大再还原，正确设置contentMode的值是UIViewContentModeScaleToFill，被伸缩的内容仅仅是视图内容的一副缓存图片，所以它运行起来十分的高效</p>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/07/19/CoreGraphics2：进阶/" data-id="ckd90jokf000zxc51kzpxkzt9" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-CoreGraphics1：基础" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/07/17/CoreGraphics1：基础/">CoreGraphics1：基础</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/07/17/CoreGraphics1：基础/" class="article-date">
  <time datetime="2016-07-17T10:14:18.000Z" itemprop="datePublished">2016-07-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="序：CoreGraphics-与-Quartz-2D"><a href="#序：CoreGraphics-与-Quartz-2D" class="headerlink" title="序：CoreGraphics 与 Quartz 2D"></a>序：CoreGraphics 与 Quartz 2D</h3><ul>
<li>Core Graphic框架是一组基于C的API，UIKit用Core Graphics将“显示”绘制在屏幕上</li>
<li>Quartz 2D API是Core Graphic框架的一部分，因此其中的很多数据类型和方法都是以CG开头的。会经常见到Quartz 2D（Quartz）和Core Graphics两个术语交互使用！Quartz 2D与分辨率和设备无关，因此在使用Quartz 2D绘图时，无需考虑最终绘图的目标设备</li>
<li>Core Graphic是线程安全的，可以异步绘制回调刷新</li>
<li><a href="https://developer.apple.com/library/archive/samplecode/QuartzDemo/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007531" target="_blank" rel="noopener">官方dome</a></li>
</ul>
<h3 id="1-Quartz-2D数据类型"><a href="#1-Quartz-2D数据类型" class="headerlink" title="1 Quartz 2D数据类型"></a>1 Quartz 2D数据类型</h3><h4 id="1-1-常用类型解释"><a href="#1-1-常用类型解释" class="headerlink" title="1.1 常用类型解释"></a>1.1 常用类型解释</h4><ul>
<li>CGPathRef：用于向量图，可创建路径，并进行填充或描画(stroke)</li>
<li>CGImageRef：用于表示bitmap图像和基于采样数据的bitmap图像遮罩</li>
<li>CGLayerRef：用于表示可用于重复绘制(如背景)和幕后 (offscreen)绘制的绘画层</li>
<li>CGShadingRef、CGGradientRef：用于绘制渐变</li>
<li>CGFunctionRef：用于定义回调函数，该函数包含一个随机的浮点值参数。当为阴影创建渐变时使用该类型</li>
<li>CGColorRef, CGColorSpaceRef：一般用[UIColor redColor].CGColor之类</li>
<li>CGImageSourceRef,CGImageDestinationRef：用于在Quartz中移入移出数据</li>
<li>CGFontRef：用于绘制文本</li>
<li>CGPatternRef：用于重绘图</li>
</ul>
<h4 id="1-2-内存管理"><a href="#1-2-内存管理" class="headerlink" title="1.2 内存管理"></a>1.2 内存管理</h4><ul>
<li>谁开辟谁释放（类似MRC原则），使用含有”Create”或“Copy”单词的函数获取一个对象，当使用完后必须释放 xxxRelease。其它情况不用释放</li>
<li>也可以用过 retain和release 来持有一个对象</li>
<li>不能传NULL值来释放，必须通过对应的release方法</li>
</ul>
<h3 id="2-上下文"><a href="#2-上下文" class="headerlink" title="2 上下文"></a>2 上下文</h3><h4 id="2-1-注意事项"><a href="#2-1-注意事项" class="headerlink" title="2.1 注意事项"></a>2.1 注意事项</h4><ul>
<li>Quartz提供了 5 种类型的 Graphics Context。Bitmap Graphics Context、PDF Graphics Context、Window Graphics Context、Layer Context、Post Graphics Context。</li>
<li>使用Core Graphics之前需要指定一个用于绘图的图形上下文（CGContextRef）</li>
<li>通过drawRect、drawRect: inContext 可用UIGraphicsGetCurrentContext获得当前UIView的绘图上下文，直接绘图</li>
<li>使用UIGraphicsBeginImageContextWithOptions时，不仅创建了一个绘图上下文，并且该上下文也属于当前上下文</li>
<li>回调方法所持有的context：参数并不会让任何上下文成为当前图形上下文。只是引用了一下。</li>
<li>如果想持有一个别人的context时，必须通过UIGraphicsPushContext 将该上下文转化为当前上下文，最后通过UIGraphicsPopContext恢复上下文环境</li>
</ul>
<h4 id="2-2-获取上下文的方式"><a href="#2-2-获取上下文的方式" class="headerlink" title="2.2 获取上下文的方式"></a>2.2 获取上下文的方式</h4><ul>
<li>drawRect获取</li>
<li>不应该手动调用drawRect：方法</li>
<li>在UIView子类的drawRect：方法中无需调用super</li>
<li>如果你想调用drawRect：方法更新视图，只需发送setNeedsDisplay方法</li>
<li>不要覆盖drawRect：例，在UIImageView子类中覆盖drawRect：方法是不合法的，你将得不到你绘制的图形。</li>
<li><p>当视图的backgroundColor为nil并且opaque属性为YES，视图的背景颜色就会变成黑色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void) drawRect: (CGRect) rect &#123; </span><br><span class="line">CGContextRef con = UIGraphicsGetCurrentContext();// 用不到可不获取，例如直接用UIBezierPath画个圈</span><br><span class="line"></span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIGraphicsBeginImageContextWithOptions</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// size区域大小，opaque是否透明，scale屏幕分辨率, 0表示 [UIScreen mainScreen].scale</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(CGSizeMake(100,100), NO, 0); </span><br><span class="line">// UIGraphicsBeginImageContext(CGSize size);方法相当于opaque参数为NO,scale为1.0。</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();// 用不到可不获取，例如直接用UIBezierPath画个圈</span><br><span class="line"></span><br><span class="line">// do something</span><br><span class="line"></span><br><span class="line">// only return a 8-bit per channel context in the DeviceRGB color space.</span><br><span class="line">UIImage* im = UIGraphicsGetImageFromCurrentImageContext(); </span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
</li>
<li><p>drawLayer:inContext：没用过</p>
</li>
</ul>
<h4 id="2-3-坐标问题"><a href="#2-3-坐标问题" class="headerlink" title="2.3 坐标问题"></a>2.3 坐标问题</h4><ul>
<li>Core Graphics源于Mac OS X系统，在Mac OS X中Y轴是朝上的，而在iOS中Y轴是朝下的，正好相反！需用CTM转换到目标设备</li>
<li>以下情况不要CTM，不需要转换</li>
<li>别人给你的，即当做参数传过来的，包括系统创建的</li>
<li>使用 UIGraphicsBeginImageContextWithOptions 返回的绘图</li>
<li>[UIImage imageWithCGImage:];返回的绘图</li>
</ul>
<h3 id="3-绘图"><a href="#3-绘图" class="headerlink" title="3 绘图"></a>3 绘图</h3><h4 id="3-1-一般绘图模式"><a href="#3-1-一般绘图模式" class="headerlink" title="3.1 一般绘图模式"></a>3.1 一般绘图模式</h4><ul>
<li>绘图的一般过程是先设定好图形上下文参数，然后绘图。比方说，要画一根红线，接着画一根蓝线。那么首先需要将上下文的线条颜色属性设定为为红色，然后画红线；接着设置上下文的线条颜色属性为蓝色，再画出蓝线。表面上看,红线和蓝线是分开的，但事实上，在你画每一条线时，线条颜色却是整个上下文的属性</li>
<li>在绘图之前调用CGContextSaveGState函数保存当前状态，接着根据需要设置某些上下文状态，然后绘图，最后调用CGContextRestoreGState函数将当前状态恢复到绘图之前的状态。要注意的是，CGContextSaveGState函数和CGContextRestoreGState函数必须成对出现，否则绘图很可能出现意想不到的错误，这里有一个简单的做法避免这种情况。代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSaveGState(ctx);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">// 绘图代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGContextRestoreGState(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-path"><a href="#3-2-path" class="headerlink" title="3.2 path"></a>3.2 path</h4><ul>
<li><p>设置起点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGContextMoveToPoint(context, 0, 0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加几条直线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGContextAddLineToPoint(context, 200, 0);</span><br><span class="line">CGPoint point2 = CGPointMake(200, 200);</span><br><span class="line">CGPoint point3 = CGPointMake(200, 0);</span><br><span class="line">CGPoint points[2] = &#123;point2, point3&#125;;</span><br><span class="line">CGContextAddLines(context, points, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置虚线样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGFloat dashWidth = 5; // 线宽度</span><br><span class="line">CGFloat spaceWidth = 3; // 间隔宽度</span><br><span class="line">CGFloat lengths[2] = &#123;dashWidth, spaceWidth&#125;;</span><br><span class="line">// phase表示在第一个虚线绘制的时候跳过多少个点, lengths 绘制规则，count 表示lengths数组count</span><br><span class="line">CGContextSetLineDash(context, 0, lengths, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>画圆形或矩形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 画一个椭圆或圆形</span><br><span class="line">CGContextAddEllipseInRect(context, CGRectMake(0, 0, 100, 200));</span><br><span class="line">// 画一个矩形</span><br><span class="line">CGContextAddRect(context, CGRectMake(200, 400, 100, 200));</span><br><span class="line">// CGContextAddRects</span><br></pre></td></tr></table></figure>
</li>
<li><p>画圆弧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 根据圆形和弧度画弧线</span><br><span class="line">CGContextAddArc(context, 200, 200, 100, 0, M_PI_2, 0);</span><br><span class="line">// 当前点到(x1, y1)，当前点到(x2, y2)的两条切线 和 圆弧半径画弧线</span><br><span class="line">CGContextAddArcToPoint(context, 200, 400, 400, 400, 100);</span><br></pre></td></tr></table></figure>
</li>
<li><p>画贝塞尔曲线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过一个控点画贝塞尔曲线</span><br><span class="line">CGContextAddQuadCurveToPoint(context, 0, 100, 200, 100);</span><br><span class="line">// 通过两个控点画贝塞尔曲线</span><br><span class="line">CGContextAddCurveToPoint(context, 100, 400, 200, 300, 100, 200);</span><br></pre></td></tr></table></figure>
</li>
<li><p>画虚线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGFloat dashWidth = 5; // 线宽度</span><br><span class="line">CGFloat spaceWidth = 3; // 间隔宽度</span><br><span class="line">CGFloat lengths[2] = &#123;dashWidth, spaceWidth&#125;;</span><br><span class="line">// phase表示在第一个虚线绘制的时候跳过多少个点, lengths 绘制规则，count 表示lengths数组count</span><br><span class="line">CGContextSetLineDash(context, 0, lengths, 2);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 设置线宽</span><br><span class="line">CGContextSetLineWidth(context, 20);</span><br><span class="line"></span><br><span class="line">// 设置线帽，即线条的起始点样式</span><br><span class="line">//    kCGLineCapButt：无端点</span><br><span class="line">//    kCGLineCapRound：圆形端点</span><br><span class="line">//    kCGLineCapSquare：方形端点（样式上和kCGLineCapButt是一样的，但是比kCGLineCapButt长一点）</span><br><span class="line">CGContextSetLineCap(context, kCGLineCapButt);</span><br><span class="line"></span><br><span class="line">//设置线条的拐角的样式</span><br><span class="line">//    kCGLineJoinMiter, 尖角</span><br><span class="line">//    kCGLineJoinRound, 圆角</span><br><span class="line">//    kCGLineJoinBevel  缺角</span><br><span class="line">CGContextSetLineJoin(context, kCGLineJoinRound);</span><br><span class="line">//</span><br><span class="line">//    kCGLineJoinMiter 下最大倾斜长度，边角的角度越小，斜接长度就会越大</span><br><span class="line">CGContextSetMiterLimit(context, 10);</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充颜色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 线条颜色(描边)</span><br><span class="line">// CGContextSetRGBStrokeColor、CGContextSetGrayStrokeColor没用过</span><br><span class="line">CGContextSetStrokeColorWithColor(context, [UIColor redColor].CGColor);</span><br><span class="line">// 填充颜色</span><br><span class="line">// CGContextSetRGBFillColor、CGContextSetGrayFillColor</span><br><span class="line">CGContextSetFillColorWithColor(context, [UIColor yellowColor].CGColor);</span><br><span class="line">// 设置颜色混合模式</span><br><span class="line">CGContextSetBlendMode(context, kCGBlendModeNormal);</span><br></pre></td></tr></table></figure>
</li>
<li><p>透明度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 整体透明度</span><br><span class="line">CGContextSetAlpha(context, 0.5);</span><br><span class="line">// 擦除一个区域内的所有已存在的绘图,上下文颜色如果不是透明的，剪切区域显示黑色，如果是透明的，则显示透明的</span><br><span class="line">CGContextClearRect(context, CGRectMake(10, 10, 100, 200));</span><br></pre></td></tr></table></figure>
</li>
<li><p>填充路径规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//    使用奇偶规则填充当前路径,等于CGContextDrawPath(context, kCGPathFill);</span><br><span class="line">//    CGContextEOFillPath(context);</span><br><span class="line">//    使用非零绕数规则填充当前路径</span><br><span class="line">//    CGContextFillPath(context);</span><br><span class="line">// 注意：CGContextStrokePath(context) 和 CGContextFillPath(context) 不能同时使用。</span><br><span class="line">CGContextStrokePath(context);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">kCGPathFill 填充路径</span><br><span class="line">kCGPathEOFill 使用奇偶规则填充路径</span><br><span class="line">kCGPathStroke 描边路径</span><br><span class="line">kCGPathFillStroke 填充并描边路径</span><br><span class="line">kCGPathEOFillStroke 使用奇偶规则填充并描边</span><br><span class="line">*/</span><br><span class="line">CGContextDrawPath(context, kCGPathStroke);</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭合路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 闭合路径，如果你打算填充一段路径，那么就不需要使用该命令，因为该命令会被自动调用。</span><br><span class="line">CGContextClosePath(context); </span><br><span class="line">// 当画完一部分，需抬起画笔画另一部分的时候（例：同心圆）需</span><br><span class="line">CGContextBeginPath(context);</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后别忘了释放内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// xxxRelease</span><br><span class="line">CGColorRelease(color);</span><br><span class="line">CGFontRelease(cgFont);</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/07/17/CoreGraphics1：基础/" data-id="ckd90joke000wxc51frr9nnh9" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-UIBezierPath详解" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/07/10/UIBezierPath详解/">UIBezierPath详解</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/07/10/UIBezierPath详解/" class="article-date">
  <time datetime="2016-07-10T10:14:18.000Z" itemprop="datePublished">2016-07-10</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="UIBezierPath"><a href="#UIBezierPath" class="headerlink" title="UIBezierPath"></a>UIBezierPath</h3><p>&emsp;&emsp;iOS里涉及到“路径”绕不开UIBezierPath，UIBezierPath已经满足了绝大部分的开发需求，建议大家自己动手去实验一下，看看到底什么效果！</p>
<p>&emsp;&emsp;一般自定义试图的都需要重写drawRect方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;</span><br><span class="line">// Drawing code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)bezierPath;</span><br><span class="line"></span><br><span class="line">// 初始化一个矩形</span><br><span class="line">+ (instancetype)bezierPathWithRect:(CGRect)rect;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">初始化一个椭圆</span><br><span class="line">rect的width和height分别表示椭圆的长轴和短轴，当然宽高相等意味着圆形</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithOvalInRect:(CGRect)rect;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">初始化一个所有角都是圆角的矩形</span><br><span class="line">cornerRadius表示圆角半径</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius; // rounds all corners with the same horizontal and vertical radius</span><br><span class="line">/*</span><br><span class="line">初始化一个指定角（一个或多个）是圆角的矩形，</span><br><span class="line">corners是圆角的位置，</span><br><span class="line">cornerRadius表示圆角半径</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">指定中心化画圆弧</span><br><span class="line">center 圆心</span><br><span class="line">radius 圆的半径</span><br><span class="line">startAngle 和 endAngle 开始和结束的弧度，一般都用 M_PI 即180度来计算！水平向右是0度，水平向左就是180度即M_PI</span><br><span class="line">clockwise clock时钟，clockwise用于表示顺时针方向还是逆时针方向绘制</span><br><span class="line">*/ </span><br><span class="line">+ (instancetype)bezierPathWithArcCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise;</span><br><span class="line"></span><br><span class="line">+ (instancetype)bezierPathWithCGPath:(CGPathRef)CGPath;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-构造path"><a href="#1-2-构造path" class="headerlink" title="1.2 构造path"></a>1.2 构造path</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">当前有正在绘制的子路径, 该方法则会隐式的结束当前路径，并将当前点设置为终点</span><br><span class="line">当上一条子路径被终止, 该方法并不会去闭合上一条子路径，即子路径起点终点没连接</span><br><span class="line">大部分情况下绘制直线或曲线之前, 需要先调用这个方法.</span><br><span class="line">*/ </span><br><span class="line">- (void)moveToPoint:(CGPoint)point;</span><br><span class="line"></span><br><span class="line">// 添加一条直线，唯一需要注意的是起点是上文提供的，上文的终点即此次的起点</span><br><span class="line">- (void)addLineToPoint:(CGPoint)point;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">以下两个方法是用于绘制贝塞尔曲线！</span><br><span class="line">说实话，网上其他的介绍都是盗图直接上，谈不上理解！而我高数早就还给老师了，不献丑了</span><br><span class="line">但分享一个css的调试网站：https://cubic-bezier.com/#.17,.67,.83,.67</span><br><span class="line">*/ </span><br><span class="line">- (void)addCurveToPoint:(CGPoint)endPoint controlPoint1:(CGPoint)controlPoint1 controlPoint2:(CGPoint)controlPoint2;</span><br><span class="line">- (void)addQuadCurveToPoint:(CGPoint)endPoint controlPoint:(CGPoint)controlPoint;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">添加一段圆弧</span><br><span class="line">center 圆心</span><br><span class="line">radius 圆的半径</span><br><span class="line">startAngle 和 endAngle 开始和结束的弧度，一般都用 M_PI 即180度来计算！水平向右是0度，水平向左就是180度即M_PI</span><br><span class="line">clockwise clock时钟，clockwise用于表示顺时针方向还是逆时针方向绘制</span><br><span class="line">*/ </span><br><span class="line">- (void)addArcWithCenter:(CGPoint)center radius:(CGFloat)radius startAngle:(CGFloat)startAngle endAngle:(CGFloat)endAngle clockwise:(BOOL)clockwise NS_AVAILABLE_IOS(4_0);</span><br><span class="line"></span><br><span class="line">// 闭合路径，终点和起点连一条直线</span><br><span class="line">- (void)closePath;</span><br><span class="line"></span><br><span class="line">// 移除所有的控制点，也就是删除了所有的子路径</span><br><span class="line">- (void)removeAllPoints;</span><br><span class="line"></span><br><span class="line">// 添加另一个路径。很重要的方法</span><br><span class="line">- (void)appendPath:(UIBezierPath *)bezierPath;</span><br><span class="line"></span><br><span class="line">// 反转路径：形状一样，绘制方向相反</span><br><span class="line">- (UIBezierPath *)bezierPathByReversingPath NS_AVAILABLE_IOS(6_0);</span><br><span class="line"></span><br><span class="line">// 用指定的仿射变换矩阵变换路径的所有点</span><br><span class="line">- (void)applyTransform:(CGAffineTransform)transform;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-Path-info"><a href="#1-3-Path-info" class="headerlink" title="1.3 Path info"></a>1.3 Path info</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Returns an immutable CGPathRef which is only valid until the UIBezierPath is further mutated.</span><br><span class="line">// Setting the path will create an immutable copy of the provided CGPathRef, so any further mutations on a provided CGMutablePathRef will be ignored.</span><br><span class="line">/*</span><br><span class="line">官方解释很清楚了</span><br><span class="line">1、CGPath的getter其实是当前这一刻的路径信息</span><br><span class="line">2、CGPath可理解为copy修饰的不可变对象</span><br><span class="line">*/</span><br><span class="line">@property(nonatomic) CGPathRef CGPath;</span><br><span class="line">- (CGPathRef)CGPath NS_RETURNS_INNER_POINTER CF_RETURNS_NOT_RETAINED;</span><br><span class="line"></span><br><span class="line">// 路径是否为空。需要注意的是就算只调用了 moveToPoint 方法当前路径也不为空.</span><br><span class="line">@property(readonly,getter=isEmpty) BOOL empty;</span><br><span class="line"></span><br><span class="line">// 一个能覆盖所有控制点的最小矩形，包括贝塞尔曲线的控制点1、2</span><br><span class="line">@property(nonatomic,readonly) CGRect bounds;</span><br><span class="line"></span><br><span class="line">// 当前点，用笔画画，当前笔尖的位置！每次move、add和append等都会更新currentPoint</span><br><span class="line">@property(nonatomic,readonly) CGPoint currentPoint;</span><br><span class="line"></span><br><span class="line">// 闭合路径是否包含（边框和内部）某个点，开放路径只检测是否在边框上</span><br><span class="line">- (BOOL)containsPoint:(CGPoint)point;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-Drawing-properties"><a href="#1-4-Drawing-properties" class="headerlink" title="1.4 Drawing properties"></a>1.4 Drawing properties</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 线宽</span><br><span class="line">@property(nonatomic) CGFloat lineWidth;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">线头样式</span><br><span class="line">kCGLineCapButt,  // 默认</span><br><span class="line">kCGLineCapRound, // 圆角</span><br><span class="line">kCGLineCapSquare // 正方形</span><br><span class="line">*/</span><br><span class="line">@property(nonatomic) CGLineCap lineCapStyle;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line">线连接处样式</span><br><span class="line">kCGLineJoinMiter, // 默认</span><br><span class="line">kCGLineJoinRound, // 圆润</span><br><span class="line">kCGLineJoinBevel  // 斜角</span><br><span class="line">*/</span><br><span class="line">@property(nonatomic) CGLineJoin lineJoinStyle;</span><br><span class="line">// 最大斜接长度 只在lineJoinStyle 是 kCGLineJoinMiter时使用</span><br><span class="line">@property(nonatomic) CGFloat miterLimit; </span><br><span class="line"></span><br><span class="line">// 弯曲路径的渲染精度，默认为0.6，越小精度越高，相应的更加消耗性能。</span><br><span class="line">@property(nonatomic) CGFloat flatness;</span><br><span class="line"></span><br><span class="line">// 单双数圈规则是否用于绘制路径，默认是NO</span><br><span class="line">@property(nonatomic) BOOL usesEvenOddFillRule; // Default is NO. When YES, the even-odd fill rule is used for drawing, clipping, and hit testing.</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">设置虚线</span><br><span class="line">pattern C语言类型的数组</span><br><span class="line">count pattern数组的个数</span><br><span class="line">phase 起始位置</span><br><span class="line">*/</span><br><span class="line">- (void)setLineDash:(nullable const CGFloat *)pattern count:(NSInteger)count phase:(CGFloat)phase;</span><br><span class="line">// 检索线段类型</span><br><span class="line">- (void)getLineDash:(nullable CGFloat *)pattern count:(nullable NSInteger *)count phase:(nullable CGFloat *)phase;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-其他"><a href="#1-5-其他" class="headerlink" title="1.5 其他"></a>1.5 其他</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 填充颜色</span><br><span class="line">- (void)fill;</span><br><span class="line"></span><br><span class="line">// 路径绘制</span><br><span class="line">- (void)stroke;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// These methods do not affect the blend mode or alpha of the current graphics context</span><br><span class="line">// 用指定的混合模式和透明度值来描绘受接收路径所包围的区域</span><br><span class="line">- (void)fillWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;</span><br><span class="line">// 使用指定的混合模式和透明度值沿着接收器路径。绘制一行</span><br><span class="line">- (void)strokeWithBlendMode:(CGBlendMode)blendMode alpha:(CGFloat)alpha;</span><br><span class="line"></span><br><span class="line">// 剪切被接收者路径包围的区域该路径是带有剪切路径的当前绘图上下文。使得其成为我们当前的剪切路径</span><br><span class="line">- (void)addClip;</span><br></pre></td></tr></table></figure>
<h3 id="CGPath"><a href="#CGPath" class="headerlink" title="CGPath"></a>CGPath</h3><p>&emsp;&emsp;CGPath的大部分用法和UIBezierPath差不多，感兴趣的童鞋可以自己去看看！一眼就能看懂，个别需要注意的：1、由于CG没有ARC，需要手动释放CGRelease；2、CGMutablePathRef才能进行move、add等操作；</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/07/10/UIBezierPath详解/" data-id="ckd90jolc003jxc51xyc64g9l" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-手势2：进阶" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/06/24/手势2：进阶/">手势2：进阶</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/06/24/手势2：进阶/" class="article-date">
  <time datetime="2016-06-24T10:14:18.000Z" itemprop="datePublished">2016-06-24</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-UIGestureRecognizer"><a href="#1-UIGestureRecognizer" class="headerlink" title="1 UIGestureRecognizer"></a>1 UIGestureRecognizer</h3><p>&emsp;&emsp;手势识别器，前面介绍的基本手势的父类，注意UIGestureRecognizer : NSObject</p>
<h4 id="UIGestureRecognizerState"><a href="#UIGestureRecognizerState" class="headerlink" title="UIGestureRecognizerState"></a>UIGestureRecognizerState</h4><ul>
<li><p>官方注释翻译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIGestureRecognizerStatePossible,   // 默认，还没识别，可能正在遍历runloop</span><br><span class="line">UIGestureRecognizerStateBegan,      // 手势开始被识别，下个runloop会回调方法</span><br><span class="line">UIGestureRecognizerStateChanged,    // 手势识别发生改变的状态，下个runloop会回调方法</span><br><span class="line">UIGestureRecognizerStateEnded,      // 手势识别结束，下个runloop会回调方法，重置为UIGestureRecognizerStatePossible</span><br><span class="line">UIGestureRecognizerStateCancelled,  // 手势识别取消，下个runloop会回调方法，重置为UIGestureRecognizerStatePossible</span><br><span class="line">UIGestureRecognizerStateFailed,     // 识别失败，方法将不会被调用，重置为UIGestureRecognizerStatePossible</span><br><span class="line">UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIGestureRecognizerStateChanged为啥总调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://stackoverflow.com/questions/14227465/whats-the-different-between-uigesturerecognizerstatechanged-and-touchesmoved?r=SearchResults</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否手势都有UIGestureRecognizerStateBegan？否</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// UITapGestureRecognizer 只有一个UIGestureRecognizerStateEnded状态</span><br><span class="line"></span><br><span class="line">// UIGestureRecognizerState的官方解释如下</span><br><span class="line">// Discrete Gestures – gesture recognizers that recognize a discrete event but do not report changes (for example, a tap) do not transition through the Began and Changed states and can not fail or be cancelled</span><br><span class="line">// 非连续手势没有begin，changed的过渡，也不能失败或取消</span><br><span class="line"></span><br><span class="line">// 事实上UIGestureRecognizerState表示可能的状态，不要被begin，changed，end等字眼迷惑</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="几个容易乱的属性"><a href="#几个容易乱的属性" class="headerlink" title="几个容易乱的属性"></a>几个容易乱的属性</h4><ul>
<li>@property(nullable, nonatomic,readonly) UIView *view; // 表示添加手势的view，并不是响应连上的view</li>
<li>@property(nonatomic) BOOL cancelsTouchesInView; // 默认YES，即一旦响应手势就终止响应连</li>
<li>@property(nonatomic) BOOL delaysTouchesBegan;// 默认为NO，不会延迟响应触摸事件，如果我们设置为YES，在手势没有被识别失败前，都不会给事件传递链发送消息。</li>
<li>@property(nonatomic) BOOL delaysTouchesEnded;//默认为YES，手势识别失败立马调用touchEnd:withEvent。设置为NO，会等待一个很短的时间，如果没有接收到新的手势识别任务，才会发送touchesEnded消息到事件传递链。</li>
</ul>
<h4 id="iOS9之后的"><a href="#iOS9之后的" class="headerlink" title="iOS9之后的"></a>iOS9之后的</h4><ul>
<li>@property(nonatomic, copy) NSArray<nsnumber *> *allowedTouchTypes NS_AVAILABLE_IOS(9_0); // Array of UITouchTypes as NSNumbers.</nsnumber></li>
<li><p>@property(nonatomic, copy) NSArray<nsnumber *> *allowedPressTypes NS_AVAILABLE_IOS(9_0); // Array of UIPressTypes as NSNumbers.</nsnumber></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UITouchType) &#123;</span><br><span class="line">UITouchTypeDirect,                       // A direct touch from a finger (on a screen)</span><br><span class="line">UITouchTypeIndirect,                     // An indirect touch (not a screen)</span><br><span class="line">UITouchTypePencil NS_AVAILABLE_IOS(9_1), // Add pencil name variant</span><br><span class="line">UITouchTypeStylus NS_AVAILABLE_IOS(9_1) = UITouchTypePencil, // A touch from a stylus (deprecated name, use pencil)</span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(9_0);</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property (nonatomic) BOOL requiresExclusiveTouchType NS_AVAILABLE_IOS(9_2); // defaults to YES</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Indicates whether the gesture recognizer will consider touches of different touch types simultaneously.</span><br><span class="line">// If NO, it receives all touches that match its allowedTouchTypes.</span><br><span class="line">// NO, 同一时刻接收所有允许的触摸类型</span><br><span class="line">// If YES, once it receives a touch of a certain type, it will ignore new touches of other types, until it is reset to UIGestureRecognizerStatePossible.</span><br><span class="line">// YES, 同一时刻只接受一种触摸类型</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h4><ul>
<li><p>设置手势优先级 requireGestureRecognizerToFail</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// [A requireGestureRecognizerToFail：B] 优先响应B，再尝试响应A，都失败的话则响应失败</span><br><span class="line"></span><br><span class="line">// 实现一个View，即响应双击，又响应单击</span><br><span class="line">// 参考：https://stackoverflow.com/questions/8876202/uitapgesturerecognizer-single-tap-and-double-tap?r=SearchResults</span><br><span class="line">- (void)addSingleAndDoubleTapGestureRecognizersToView:(UIView *)view &#123;</span><br><span class="line">// single tap    </span><br><span class="line">UITapGestureRecognizer *singleTapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget: tableViewController action: @selector(handleSingleTapOnView:)]; // must set 1                           </span><br><span class="line">[singleTapRecognizer setNumberOfTouchesRequired:1];</span><br><span class="line">[view addGestureRecognizer: singleTapRecognizer];</span><br><span class="line"></span><br><span class="line">// double tap </span><br><span class="line">UITapGestureRecognizer *doubleTapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget: tableViewController action: @selector (handleDoubleTapOnView:)]; // must set 2</span><br><span class="line">[doubleTapRecognizer setNumberOfTouchesRequired:2];         </span><br><span class="line">[singleTapRecognizer requireGestureRecognizerToFail: doubleTapRecognizer];</span><br><span class="line">[view addGestureRecognizer: doubleTapRecognizer];         </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleSingleTapOnView:(id)sender&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)handleDoubleTapOnView:(id)sender&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>手指在view中的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 单点位置</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];</span><br><span class="line">[imageView addGestureRecognizer:tap];</span><br><span class="line">- (void)tap:(UITapGestureRecognizer *)tapGesture &#123;</span><br><span class="line">CGPoint location = [tapGesture locationInView:self.view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多根手指</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];</span><br><span class="line">tap.numberOfTouchesRequired = 2;</span><br><span class="line">[imageView addGestureRecognizer:tap];</span><br><span class="line">- (void)tap:(UITapGestureRecognizer *)tapGesture &#123;</span><br><span class="line">NSInteger touchsCount = [tapGesture numberOfTouches];</span><br><span class="line">for (int index = 0; index &lt; touchsCount; index++) &#123;</span><br><span class="line">CGPoint point = [tapGesture locationOfTouch:index inView:self.view];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-UIGestureRecognizerDelegate"><a href="#2-UIGestureRecognizerDelegate" class="headerlink" title="2 UIGestureRecognizerDelegate"></a>2 UIGestureRecognizerDelegate</h3><ul>
<li><p>是否识别手势</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//将要开始时调用（Possible将要变成Began），返回NO，则手势识别失败</span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;</span><br><span class="line"></span><br><span class="line">// touchesBegan:withEvent:之前调用，返回NO，则手势不识别这个touch</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch;</span><br><span class="line"></span><br><span class="line">// pressesBegan:withEvent:之前调用，返回NO，则手势不识别这个press</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceivePress:(UIPress *)press;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多手势冲突怎么办</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//是否支持同时多个手势触发,默认NO</span><br><span class="line">//返回YES，则可以多个手势一起触发方法，返回NO则为互斥, 但不保证一定互斥，因为otherGestureRecognizer可能返回YES</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer </span><br><span class="line">shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)</span><br><span class="line">otherGestureRecognizer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//返回YES，第二个手势的优先级高于第一个手势</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer </span><br><span class="line">shouldRequireFailureOfGestureRecognizer:(UIGestureRecognizer *)</span><br><span class="line">otherGestureRecognizer </span><br><span class="line"></span><br><span class="line">//返回YES，第一个手势的优先级高于第二个手势</span><br><span class="line">- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer </span><br><span class="line">shouldBeRequiredToFailByGestureRecognizer:(UIGestureRecognizer *)</span><br><span class="line">otherGestureRecognizer</span><br><span class="line"></span><br><span class="line">// 所以为什么要设置两个方法呢？一个方法返回YES或NO不就行了？因为返回YES能保证优先级改变，但返回NO不保证优先级，因为其他的可能返回NO</span><br><span class="line">// note: returning YES is guaranteed to set up the failure requirement. returning NO does not guarantee that there will not be a failure requirement as the other gesture&apos;s counterpart delegate or subclass methods may return YES</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="自定义手势"><a href="#自定义手势" class="headerlink" title="自定义手势"></a>自定义手势</h3><h4 id="1-组合"><a href="#1-组合" class="headerlink" title="1 组合"></a>1 组合</h4><ul>
<li>通过组合多手势和优先级实现复杂手势操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 略，参见上文 requireGestureRecognizerToFail 部分代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-扩展"><a href="#2-扩展" class="headerlink" title="2 扩展"></a>2 扩展</h4><ul>
<li>实现一个只能横向或纵向的拖动手势<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 参考：https://stackoverflow.com/questions/7100884/uipangesturerecognizer-only-vertical-or-horizontal?r=SearchResults</span><br><span class="line"></span><br><span class="line">UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</span><br><span class="line">pan.delegate = self;</span><br><span class="line">[imageView addGestureRecognizer:pan];</span><br><span class="line"></span><br><span class="line">- (void)pan:(UIPanGestureRecognizer *)panGesture &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)panGestureRecognizer &#123;</span><br><span class="line">CGPoint velocity = [panGestureRecognizer velocityInView:self.view];</span><br><span class="line">return fabs(velocity.y) &gt; fabs(velocity.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-自定义"><a href="#3-自定义" class="headerlink" title="3 自定义"></a>3 自定义</h4><ul>
<li><p>主要步骤</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个UIGestureRecognizer的子类</span><br><span class="line">2、包含头文件#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span><br><span class="line">3、使用touch相关方法判断手指轨迹</span><br><span class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;</span><br><span class="line">4、轨迹完成后设置self.state = UIGestureRecognizerStateEnded;就会自动调用相关回调</span><br></pre></td></tr></table></figure>
</li>
<li><p>例：实现一个松开调用的tap类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 参考: https://stackoverflow.com/questions/15628133/uitapgesturerecognizer-make-it-work-on-touch-down-not-touch-up?r=SearchResults</span><br><span class="line">TouchDownGestureRecognizer.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface TouchDownGestureRecognizer : UIGestureRecognizer</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">TouchDownGestureRecognizer.m</span><br><span class="line"></span><br><span class="line">#import &quot;TouchDownGestureRecognizer.h&quot;</span><br><span class="line">#import &lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation TouchDownGestureRecognizer</span><br><span class="line">-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">if (self.state == UIGestureRecognizerStatePossible) &#123;</span><br><span class="line">self.state = UIGestureRecognizerStateRecognized;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">self.state = UIGestureRecognizerStateFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event&#123;</span><br><span class="line">self.state = UIGestureRecognizerStateFailed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">implementation:</span><br><span class="line"></span><br><span class="line">#import &quot;TouchDownGestureRecognizer.h&quot;</span><br><span class="line">TouchDownGestureRecognizer *touchDown = [[TouchDownGestureRecognizer alloc] initWithTarget:self action:@selector(handleTouchDown:)];</span><br><span class="line">[yourView addGestureRecognizer:touchDown];</span><br><span class="line"></span><br><span class="line">-(void)handleTouchDown:(TouchDownGestureRecognizer *)touchDown&#123;</span><br><span class="line">NSLog(@&quot;Down&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/06/24/手势2：进阶/" data-id="ckd90jonj008zxc5175w68fu2" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-手势1：常用" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/06/23/手势1：常用/">手势1：常用</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/06/23/手势1：常用/" class="article-date">
  <time datetime="2016-06-23T10:14:18.000Z" itemprop="datePublished">2016-06-23</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="1-点按手势-UITapGestureRecognizer"><a href="#1-点按手势-UITapGestureRecognizer" class="headerlink" title="1 点按手势 UITapGestureRecognizer"></a>1 点按手势 UITapGestureRecognizer</h4><ul>
<li><p>创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 创建两根手指，连续点击三次的手势，常用于调出调试页面等</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tap:)];</span><br><span class="line">// 点击数，Default is 1.</span><br><span class="line">tap.numberOfTapsRequired = 3;</span><br><span class="line">// 手指数，Default is 1..</span><br><span class="line">tap.numberOfTouchesRequired = 2;</span><br><span class="line">[view addGestureRecognizer:tap];</span><br></pre></td></tr></table></figure>
</li>
<li><p>回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)tap:(UITapGestureRecognizer *)tapGesture&#123;</span><br><span class="line">NSLog(@&quot;调出调试页面&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-拖拽手势-UIPanGestureRecognizer"><a href="#2-拖拽手势-UIPanGestureRecognizer" class="headerlink" title="2 拖拽手势 UIPanGestureRecognizer"></a>2 拖拽手势 UIPanGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</span><br><span class="line">// default is 1. the minimum number of touches required to match</span><br><span class="line">pan.minimumNumberOfTouches = 1;</span><br><span class="line">// default is UINT_MAX. the maximum number of touches that can be down</span><br><span class="line">pan.maximumNumberOfTouches = 1;</span><br><span class="line">[view addGestureRecognizer:pan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)pan:(UIPanGestureRecognizer *)panGesture &#123;</span><br><span class="line">// translationInView : 手指在视图上移动的偏移量</span><br><span class="line">CGPoint point1 = [panGesture translationInView:self.view];</span><br><span class="line">NSLog(@&quot;translationInView x: %f y:%f&quot;,point1.x , point1.y);</span><br><span class="line">// locationInView ： 手指在视图上的位置</span><br><span class="line">CGPoint point2 = [panGesture locationInView:self.view];</span><br><span class="line">NSLog(@&quot;locationInView x: %f y:%f&quot;,point2.x , point2.y);</span><br><span class="line">// velocityInView： 手指在视图上移动的速度, 正负也是代表方向，</span><br><span class="line">CGPoint point3 = [panGesture velocityInView:self.view];</span><br><span class="line">NSLog(@&quot;velocityInView x: %f y:%f&quot;,point3.x , point3.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-清扫手势-UISwipeGestureRecognizer"><a href="#3-清扫手势-UISwipeGestureRecognizer" class="headerlink" title="3 清扫手势 UISwipeGestureRecognizer"></a>3 清扫手势 UISwipeGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UISwipeGestureRecognizer *swipeUp = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];</span><br><span class="line">//    手指数，default is 1</span><br><span class="line">swipeUp.numberOfTouchesRequired = 1;</span><br><span class="line">// 注意，手势方向虽然是NS_OPTIONS，但不要使用 或 方式设置，网上都是错的</span><br><span class="line">// https://stackoverflow.com/questions/3319209/setting-direction-for-uiswipegesturerecognizer</span><br><span class="line">//    swipeUp.direction = UISwipeGestureRecognizerDirectionUp | UISwipeGestureRecognizerDirectionDown;</span><br><span class="line">// 手势方向只是识别一个方向，需要多个方向可设置多个清扫手势，实现一个代理</span><br><span class="line">swipeUp.direction = UISwipeGestureRecognizerDirectionUp | UISwipeGestureRecognizerDirectionDown;</span><br><span class="line">[view addGestureRecognizer: swipeUp];</span><br><span class="line"></span><br><span class="line">UISwipeGestureRecognizer *swipeDown = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:@selector(swipe:)];</span><br><span class="line">swipeDown.direction = UISwipeGestureRecognizerDirectionDown;</span><br><span class="line">[view addGestureRecognizer: swipeDown];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)swipe:(UISwipeGestureRecognizer *)swipeGesture&#123;</span><br><span class="line">switch (swipeGesture.direction) &#123;</span><br><span class="line">case UISwipeGestureRecognizerDirectionLeft:</span><br><span class="line">NSLog(@&quot;向左清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">case UISwipeGestureRecognizerDirectionRight:</span><br><span class="line">NSLog(@&quot;向右清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">case UISwipeGestureRecognizerDirectionUp:</span><br><span class="line">NSLog(@&quot;向上清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">case UISwipeGestureRecognizerDirectionDown:</span><br><span class="line">NSLog(@&quot;向下清扫&quot;);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-长按手势-UILongPressGestureRecognizer"><a href="#4-长按手势-UILongPressGestureRecognizer" class="headerlink" title="4 长按手势 UILongPressGestureRecognizer"></a>4 长按手势 UILongPressGestureRecognizer</h4><ul>
<li><p>实现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];</span><br><span class="line">// 识别长按手势前需要点击几次，Default is 0， PS:从没见过这个属性的使用</span><br><span class="line">longPress.numberOfTapsRequired = 1;</span><br><span class="line">// 手指数</span><br><span class="line">longPress.numberOfTouchesRequired = 1;</span><br><span class="line">// 最短按多长时间才识别长按手势 Default is 0.5秒</span><br><span class="line">longPress.minimumPressDuration = 1;</span><br><span class="line">// 识别长按手势前允许的最大移动距离，Default is 10，手势识别后无效</span><br><span class="line">longPress.allowableMovement = 20;</span><br><span class="line"></span><br><span class="line">[view addGestureRecognizer:longPress];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 注意回调处理</span><br><span class="line">- (void)longPress:(UILongPressGestureRecognizer *)longPressGesture &#123;</span><br><span class="line">if (sender.state == UIGestureRecognizerStateEnded) &#123;</span><br><span class="line">// 结束</span><br><span class="line">&#125;</span><br><span class="line">else if (sender.state == UIGestureRecognizerStateBegan)&#123;</span><br><span class="line">// 开始</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-旋转手势-UIRotationGestureRecognizer"><a href="#5-旋转手势-UIRotationGestureRecognizer" class="headerlink" title="5 旋转手势 UIRotationGestureRecognizer"></a>5 旋转手势 UIRotationGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIRotationGestureRecognizer *rotation = [[UIRotationGestureRecognizer alloc] initWithTarget:self action:@selector(rotation:)];</span><br><span class="line">[view addGestureRecognizer:rotation];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)rotation:(UIRotationGestureRecognizer *)rotationGesture &#123;</span><br><span class="line">//获取旋转的角度</span><br><span class="line">CGFloat scale = rotationGesture.rotation;</span><br><span class="line">//获取旋转的速度 radians/second</span><br><span class="line">NSLog(@&quot;转速： %f&quot;, rotationGesture.velocity);</span><br><span class="line">// 设置view的角度,使用transform设置</span><br><span class="line">rotationGesture.view.transform = CGAffineTransformRotate(rotationGesture.view.transform, scale);</span><br><span class="line">// 复位,否则旋转角度会叠加，会疯狂转圈</span><br><span class="line">rotationGesture.rotation = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-缩放-UIPinchGestureRecognizer"><a href="#6-缩放-UIPinchGestureRecognizer" class="headerlink" title="6 缩放 UIPinchGestureRecognizer"></a>6 缩放 UIPinchGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc] initWithTarget:self action:@selector(pinch:)];</span><br><span class="line">[view addGestureRecognizer:pinch];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)pinch:(UIPinchGestureRecognizer *)pinchGesture &#123;</span><br><span class="line">CGFloat scale = pinchGesture.scale;</span><br><span class="line">pinchGesture.view.transform = CGAffineTransformScale(pinchGesture.view.transform, scale, scale);</span><br><span class="line">// 复位</span><br><span class="line">pinchGesture.state = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-屏幕边缘轻扫-UIScreenEdgePanGestureRecognizer"><a href="#7-屏幕边缘轻扫-UIScreenEdgePanGestureRecognizer" class="headerlink" title="7 屏幕边缘轻扫 UIScreenEdgePanGestureRecognizer"></a>7 屏幕边缘轻扫 UIScreenEdgePanGestureRecognizer</h4><ul>
<li><p>实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIScreenEdgePanGestureRecognizer *screenPan = [[UIScreenEdgePanGestureRecognizer alloc]initWithTarget:self action:@selector(screenEdgePan:)];</span><br><span class="line">[view addGestureRecognizer:screenPan];</span><br></pre></td></tr></table></figure>
</li>
<li><p>代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建边缘事件</span><br><span class="line">-(void)screenEdgePan:(UIScreenEdgePanGestureRecognizer *)screenEdgePanGesture &#123;</span><br><span class="line">NSLog(@&quot;边缘&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/06/23/手势1：常用/" data-id="ckd90joni008wxc51e2zp7rnw" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-图片处理2：CGImage" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/06/15/图片处理2：CGImage/">图片处理2：CGImage</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/06/15/图片处理2：CGImage/" class="article-date">
  <time datetime="2016-06-15T10:14:18.000Z" itemprop="datePublished">2016-06-15</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="序-UIImage、CGImage与CIImage"><a href="#序-UIImage、CGImage与CIImage" class="headerlink" title="序 UIImage、CGImage与CIImage"></a>序 UIImage、CGImage与CIImage</h3><ul>
<li>UIImage：UIKit的封装，最常用</li>
<li>CGImage：UIImage类的Core Graphics版本的结构体指针，用C语言编写，只能表示位图</li>
<li>CIImage：并不是一张图片。它包含了所有生成一张图片所有的必要信息。CIImage对象通常用在CIFilter,CIContext,CIColor,CIVector。跟GPU的处理相关。 </li>
</ul>
<h3 id="CGImage"><a href="#CGImage" class="headerlink" title="CGImage"></a>CGImage</h3><h4 id="绘制图片的方式"><a href="#绘制图片的方式" class="headerlink" title="绘制图片的方式"></a>绘制图片的方式</h4><ol>
<li><p>根据数据源创建位图CGImageCreate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">// 图片宽度，单位像素, CGImageGetWidth(imageRef);</span><br><span class="line">size_t width</span><br><span class="line">// 图片高度，单位像素, CGImageGetHeight(imageRef);</span><br><span class="line">size_t height</span><br><span class="line">// 每个颜色的比特数，在rgba-32模式下为 8, CGImageGetBitsPerComponent(imageRef)</span><br><span class="line">size_t bitsPerComponent</span><br><span class="line">// 每个像素的总比特数，The number of bytes per pixel is equal to `(bitsPerComponent * number of components + 7)/8&apos; ，参照CGBitmapContextCreate的注释， CGImageGetBitsPerPixel(imageRef)</span><br><span class="line">size_t bitsPerPixel,</span><br><span class="line">// 每一行占用的字节数，注意单位是字节,`bytesPerRow&apos; bytes, which must be at least width * bytes per pixel&apos; bytes 即 width * bitsPerPixel / BYTE_SIZE ，参照CGBitmapContextCreate的注释，通常1字节=8位,CGImageGetBytesPerRow(imageRef)</span><br><span class="line">size_t bytesPerRow,</span><br><span class="line">// 颜色空间,iOS中一般为CGColorSpaceCreateDeviceRGB， CGImageGetColorSpace(imageRef)</span><br><span class="line">CGColorSpaceRef cg_nullable space,</span><br><span class="line">// 位图的布局信息，iOS上一般为小端32位序，获取方式参见 备注2</span><br><span class="line">CGBitmapInfo bitmapInfo,</span><br><span class="line">// 数据提供者 ，CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</span><br><span class="line">CGDataProviderRef cg_nullable provider,</span><br><span class="line">// 固定为NULL，即不允许重新映射颜色值</span><br><span class="line">const CGFloat * __nullable decode,</span><br><span class="line">// 固定为false，即不采用插值算法，高分辨率上可能会显示锯齿</span><br><span class="line">bool shouldInterpolate,</span><br><span class="line">// 渲染意图，kCGRenderingIntentDefault</span><br><span class="line">CGColorRenderingIntent intent</span><br><span class="line">*/</span><br><span class="line">CGImageRef image = CGImageCreate(width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, YYCGColorSpaceGetDeviceRGB(), bitmapInfo, provider, NULL, false, kCGRenderingIntentDefault);</span><br><span class="line"></span><br><span class="line">// 备注1：size_t 在64位机器上为8字节，32位机器上为4字节</span><br><span class="line">// 备注2：直接使用CGImageGetBitmapInfo(imageRef)获得的CGBitmapInfo 位图布局信息是不准的，以下是AFNetwork的代码</span><br><span class="line">//    CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</span><br><span class="line">//    CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(imageRef);</span><br><span class="line">//</span><br><span class="line">//    if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</span><br><span class="line">//        uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</span><br><span class="line">//#pragma clang diagnostic push</span><br><span class="line">//#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</span><br><span class="line">//        if (alpha == kCGImageAlphaNone) &#123;</span><br><span class="line">//            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">//            bitmapInfo |= kCGImageAlphaNoneSkipFirst;</span><br><span class="line">//        &#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</span><br><span class="line">//            bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">//            bitmapInfo |= kCGImageAlphaPremultipliedFirst;</span><br><span class="line">//        &#125;</span><br><span class="line">//#pragma clang diagnostic pop</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上下文创建位图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 同时设data为NULL、bytesPerRow为0 （必须两个都设），表示系采用统会自动分配一段合适的内存，保存位图数据</span><br><span class="line">CGContextRef context = CGBitmapContextCreate(NULL, width, height, 8, 0, YYCGColorSpaceGetDeviceRGB(), bitmapInfo);</span><br><span class="line">if (!context) return NULL;</span><br><span class="line">CGContextDrawImage(context, CGRectMake(0, 0, width, height), imageRef); // decode</span><br><span class="line">CGImageRef newImage = CGBitmapContextCreateImage(context);</span><br><span class="line">CFRelease(context);</span><br><span class="line">// 如果有图像数据了，当然用CGImageCreate，毕竟用CGBitmapContextCreate还需要拷贝啥的比较耗时</span><br></pre></td></tr></table></figure>
</li>
<li><p>UIGraphicsBeginImageContext</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 生成纯色图片</span><br><span class="line">CGRect rect=CGRectMake(0,0, 1, 1);</span><br><span class="line">UIGraphicsBeginImageContext(rect.size);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextSetFillColorWithColor(context, [color CGColor]);</span><br><span class="line">CGContextFillRect(context, rect);</span><br><span class="line">UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h4><ul>
<li><p>蒙层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建mask图片图层,参数和CGImageCreate一样</span><br><span class="line">CGImageMaskCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow,CGDataProviderRef cg_nullable provider, const CGFloat * __nullable decode, bool shouldInterpolate)</span><br><span class="line">//调用CGImageCreateWithMask并指定图像作为蒙版，则必须使用设备灰色颜色空间定义图像。</span><br><span class="line">CGImageCreateWithMask(CGImageRef cg_nullable image, CGImageRef cg_nullable mask)</span><br></pre></td></tr></table></figure>
</li>
<li><p>截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CGImageCreateWithImageInRect(CGImageRef cg_nullable image, CGRect rect)</span><br></pre></td></tr></table></figure>
</li>
<li><p>从NSData生成CGImageRef</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 以下为AFNetwork源码</span><br><span class="line">CGImageRef imageRef = NULL;</span><br><span class="line">CGDataProviderRef dataProvider = CGDataProviderCreateWithCFData((__bridge CFDataRef)data);</span><br><span class="line"></span><br><span class="line">if ([response.MIMEType isEqualToString:@&quot;image/png&quot;]) &#123;</span><br><span class="line">imageRef = CGImageCreateWithPNGDataProvider(dataProvider,  NULL, true, kCGRenderingIntentDefault);</span><br><span class="line">&#125; else if ([response.MIMEType isEqualToString:@&quot;image/jpeg&quot;]) &#123;</span><br><span class="line">imageRef = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, true, kCGRenderingIntentDefault);</span><br><span class="line"></span><br><span class="line">if (imageRef) &#123;</span><br><span class="line">CGColorSpaceRef imageColorSpace = CGImageGetColorSpace(imageRef);</span><br><span class="line">CGColorSpaceModel imageColorSpaceModel = CGColorSpaceGetModel(imageColorSpace);</span><br><span class="line"></span><br><span class="line">// CGImageCreateWithJPEGDataProvider does not properly handle CMKY, so fall back to AFImageWithDataAtScale</span><br><span class="line">if (imageColorSpaceModel == kCGColorSpaceModelCMYK) &#123;</span><br><span class="line">CGImageRelease(imageRef);</span><br><span class="line">imageRef = NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/06/15/图片处理2：CGImage/" data-id="ckd90jomt0077xc51sw6we0to" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-图片处理1：常用工具" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/06/12/图片处理1：常用工具/">图片处理1：常用工具</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/06/12/图片处理1：常用工具/" class="article-date">
  <time datetime="2016-06-12T10:14:18.000Z" itemprop="datePublished">2016-06-12</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  UIImage+tool.m</span><br><span class="line">//  test</span><br><span class="line">//</span><br><span class="line">//  Created by JZK on 2016/7/4.</span><br><span class="line">//  Copyright © 2016 test. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;UIImage+tool.h&quot;</span><br><span class="line"></span><br><span class="line">static inline CGFloat DegreesToRadians(CGFloat degrees) &#123;</span><br><span class="line">return M_PI * (degrees / 180.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation UIImage (tool)</span><br><span class="line"></span><br><span class="line">#pragma mark 裁剪</span><br><span class="line"></span><br><span class="line">- (UIImage *)clipInRect:(CGRect)rect &#123;</span><br><span class="line">CGImageRef imageRef = CGImageCreateWithImageInRect([self CGImage], rect);</span><br><span class="line">UIImage *croppedImage = [UIImage imageWithCGImage:imageRef];</span><br><span class="line">CGImageRelease(imageRef);</span><br><span class="line">return croppedImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 缩放</span><br><span class="line">//</span><br><span class="line">- (UIImage *)scaleToSize:(CGSize)size &#123;</span><br><span class="line">UIGraphicsBeginImageContext(size);</span><br><span class="line">[self drawInRect:CGRectMake(0 ,0 ,size.width ,size.height)];</span><br><span class="line">UIImage *result = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">// 整体缩放等比缩放</span><br><span class="line">- (UIImage *) scaleImageByScale:(float)scaleSize &#123;</span><br><span class="line">UIGraphicsBeginImageContext(CGSizeMake(self.size.width * scaleSize, self.size.height * scaleSize));</span><br><span class="line">[self drawInRect:CGRectMake(0, 0, self.size.width * scaleSize, self.size.height * scaleSize)];</span><br><span class="line">UIImage *scaledImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return scaledImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据给定bound画最高质量的图片</span><br><span class="line">- (UIImage *)resizedImageInBounds:(CGSize)bounds &#123;</span><br><span class="line">return [self resizedImageInBounds:bounds quality:kCGInterpolationHigh];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)resizedImageInBounds:(CGSize)bounds quality:(CGInterpolationQuality)quality &#123;</span><br><span class="line">// UIViewContentModeScaleAspectFit</span><br><span class="line">CGFloat horizontalRatio = bounds.width / self.size.width;</span><br><span class="line">CGFloat verticalRatio = bounds.height / self.size.height;</span><br><span class="line">CGFloat ratio = MIN(horizontalRatio, verticalRatio);</span><br><span class="line">CGSize newSize = CGSizeMake(self.size.width * ratio, self.size.height * ratio);</span><br><span class="line"></span><br><span class="line">CGAffineTransform transform = [self transformForOrientation:newSize];</span><br><span class="line"></span><br><span class="line">CGRect newRect = CGRectIntegral(CGRectMake(0, 0, newSize.width, newSize.height));</span><br><span class="line">CGRect toRect = CGRectMake(0, 0, newRect.size.height, newRect.size.width);</span><br><span class="line">CGImageRef imageRef = self.CGImage;</span><br><span class="line"></span><br><span class="line">CGContextRef bitmap = CGBitmapContextCreate(NULL,</span><br><span class="line">newRect.size.width,</span><br><span class="line">newRect.size.height,</span><br><span class="line">8,</span><br><span class="line">0,</span><br><span class="line">CGImageGetColorSpace(imageRef),</span><br><span class="line">kCGImageAlphaNoneSkipLast);</span><br><span class="line">CGContextConcatCTM(bitmap, transform);</span><br><span class="line">CGContextSetInterpolationQuality(bitmap, quality);</span><br><span class="line">CGContextDrawImage(bitmap, toRect, imageRef);</span><br><span class="line">// 或 UIGraphicsGetImageFromCurrentImageContext</span><br><span class="line">CGImageRef newImageRef = CGBitmapContextCreateImage(bitmap);</span><br><span class="line">UIImage *newImage = [UIImage imageWithCGImage:newImageRef];</span><br><span class="line"></span><br><span class="line">CGContextRelease(bitmap);</span><br><span class="line">CGImageRelease(newImageRef);</span><br><span class="line"></span><br><span class="line">return newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 拉伸</span><br><span class="line">// 使用中心点拉伸</span><br><span class="line">- (UIImage *)stretchableImageByCenter &#123;</span><br><span class="line">CGFloat leftCapWidth = floorf(self.size.width / 2);</span><br><span class="line">if (leftCapWidth == self.size.width / 2) &#123;</span><br><span class="line">leftCapWidth--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGFloat topCapHeight = floorf(self.size.height / 2);</span><br><span class="line">if (topCapHeight == self.size.height / 2) &#123;</span><br><span class="line">topCapHeight--;</span><br><span class="line">&#125;</span><br><span class="line">return [self stretchableImageWithLeftCapWidth:leftCapWidth</span><br><span class="line">topCapHeight:topCapHeight];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">注意事项：</span><br><span class="line">1，UIEdgeInsets 上 左 下 右</span><br><span class="line">2，UIImageResizingMode 解释</span><br><span class="line">UIImageResizingModeTile：平铺模式，通过 重复 UIEdgeInsets指定的矩形区域来填充图</span><br><span class="line">UIImageResizingModeStretch：拉伸模式，通过 拉伸 UIEdgeInsets指定的矩形区域来填充图片</span><br><span class="line"></span><br><span class="line">[originImage resizableImageWithCapInsets:UIEdgeInsetsMake(10, 10, 10, 10) resizingMode:UIImageResizingModeStretch];</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark 旋转图片</span><br><span class="line">/*</span><br><span class="line">UIImageOrientationUp,            // 默认方向</span><br><span class="line">UIImageOrientationDown,          // 让默认方向旋转180度</span><br><span class="line">UIImageOrientationLeft,          // 让默认方向逆时针旋转90度</span><br><span class="line">UIImageOrientationRight,         // 让默认方向顺时针旋转90度</span><br><span class="line">UIImageOrientationUpMirrored,    // 默认方向的竖线镜像</span><br><span class="line">//（即以原图的左(或右)边的竖线为对称轴，对原图进行对称投影得到的镜像）</span><br><span class="line">UIImageOrientationDownMirrored,  // 让镜像旋转180度</span><br><span class="line">UIImageOrientationLeftMirrored,  // 让镜像逆时针旋转90度</span><br><span class="line">UIImageOrientationRightMirrored, // 让镜像顺时针旋转90度</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 按方向旋转图片</span><br><span class="line">- (UIImage *)rotatedByOrientation:(UIImageOrientation)orientation &#123;</span><br><span class="line">return [UIImage imageWithCGImage:self.CGImage scale:self.scale orientation:orientation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 按角度旋转图片</span><br><span class="line">- (UIImage *)rotatedByDegrees:(CGFloat)degrees&#123;</span><br><span class="line"></span><br><span class="line">UIView *rotatedViewBox = [[UIView alloc] initWithFrame:CGRectMake(0,0,self.size.width, self.size.height)];</span><br><span class="line">// 逆时针旋转angle弧度</span><br><span class="line">CGAffineTransform t = CGAffineTransformMakeRotation(DegreesToRadians(degrees));</span><br><span class="line">rotatedViewBox.transform = t;</span><br><span class="line"></span><br><span class="line">CGSize rotatedSize = rotatedViewBox.frame.size;</span><br><span class="line">UIGraphicsBeginImageContext(rotatedSize);</span><br><span class="line">CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">CGContextTranslateCTM(context, rotatedSize.width/2, rotatedSize.height/2);</span><br><span class="line">CGContextRotateCTM(context, DegreesToRadians(degrees));</span><br><span class="line">CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">CGContextDrawImage(context, CGRectMake(-self.size.width / 2, -self.size.height / 2, self.size.width, self.size.height), [self CGImage]);</span><br><span class="line">UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return newImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark 修正图片方向</span><br><span class="line">- (UIImage *)imageFixOrientation &#123;</span><br><span class="line">if (self.imageOrientation == UIImageOrientationUp) return self;</span><br><span class="line"></span><br><span class="line">CGAffineTransform transform =  [self transformForOrientation:self.size];</span><br><span class="line">CGFloat width = self.size.width;</span><br><span class="line">CGFloat height = self.size.height;</span><br><span class="line">size_t bits = CGImageGetBitsPerComponent(self.CGImage);</span><br><span class="line">CGColorSpaceRef colorSpace = CGImageGetColorSpace(self.CGImage);</span><br><span class="line">CGColorSpaceModel colorSpaceModel = CGColorSpaceGetModel(colorSpace);</span><br><span class="line">CGBitmapInfo bitmapInfo = CGImageGetBitmapInfo(self.CGImage);</span><br><span class="line"></span><br><span class="line">if (colorSpaceModel == kCGColorSpaceModelRGB) &#123;</span><br><span class="line">uint32_t alpha = (bitmapInfo &amp; kCGBitmapAlphaInfoMask);</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wassign-enum&quot;</span><br><span class="line">if (alpha == kCGImageAlphaNone) &#123;</span><br><span class="line">bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">bitmapInfo |= kCGImageAlphaNoneSkipFirst;</span><br><span class="line">&#125; else if (!(alpha == kCGImageAlphaNoneSkipFirst || alpha == kCGImageAlphaNoneSkipLast)) &#123;</span><br><span class="line">bitmapInfo &amp;= ~kCGBitmapAlphaInfoMask;</span><br><span class="line">bitmapInfo |= kCGImageAlphaPremultipliedFirst;</span><br><span class="line">&#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">&#125;</span><br><span class="line">CGContextRef ctx = CGBitmapContextCreate(NULL, width, height, bits, 0, colorSpace, bitmapInfo);</span><br><span class="line">if (ctx == NULL) &#123;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">CGContextConcatCTM(ctx, transform);</span><br><span class="line">switch (self.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">// Grr...</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// And now we just create a new UIImage from the drawing context</span><br><span class="line">CGImageRef cgimg = CGBitmapContextCreateImage(ctx);</span><br><span class="line">UIImage *img = [UIImage imageWithCGImage:cgimg];</span><br><span class="line">CGContextRelease(ctx);</span><br><span class="line">CGImageRelease(cgimg);</span><br><span class="line">return img;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">- (CGAffineTransform)transformForOrientation:(CGSize)newSize &#123;</span><br><span class="line">/*</span><br><span class="line">CGAffineTransform 处理形变的类,二维坐标系,即向右为x轴正方向,向上为y轴正方向</span><br><span class="line">方法简介：</span><br><span class="line">CGAffineTransformTranslate // x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformScale // x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformRotate // 逆时针旋转弧度,M_PI=180角度)</span><br><span class="line"></span><br><span class="line">以下都是针对视图的原定最初位置的中心点为起始参照进行相应操作的，</span><br><span class="line">CGAffineTransformMakeTranslation // 将坐标系统x轴方向上平移x单位,在y轴方向上平移y单位</span><br><span class="line">CGAffineTransformMakeScale // 将坐标系统x轴方向上缩放x倍,在y轴方向上缩放y倍</span><br><span class="line">CGAffineTransformMakeRotation // 将坐标系统逆时针旋转弧度,M_PI=180角度)</span><br><span class="line">在操作结束之后可对设置量进行还原：</span><br><span class="line">view.transform＝CGAffineTransformIdentity;</span><br><span class="line">*/</span><br><span class="line">CGAffineTransform transform = CGAffineTransformIdentity;</span><br><span class="line"></span><br><span class="line">switch(self.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationDown:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, newSize.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, 0);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI_2);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, 0, newSize.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, -M_PI_2);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch(self.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationUpMirrored:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.width, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, newSize.height, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return transform;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 生成image</span><br><span class="line"></span><br><span class="line">+ (UIImage *)createImageWithView:(UIView *)view&#123;</span><br><span class="line">// size区域大小，opaque是否透明，屏幕分辨率 0表示 [UIScreen mainScreen].scale</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.opaque, 0.0);</span><br><span class="line">// 将view的layer渲染到当前的绘制的上下文中</span><br><span class="line">[view.layer renderInContext:UIGraphicsGetCurrentContext()];</span><br><span class="line">UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return image;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 水印</span><br><span class="line"></span><br><span class="line">// 图片水印</span><br><span class="line">- (UIImage *)waterImage:(UIImage *)otherImage &#123;</span><br><span class="line">// 右下角</span><br><span class="line">CGFloat x = self.size.width - (self.size.width - otherImage.size.width)/2;</span><br><span class="line">CGFloat y = self.size.height - (self.size.height - otherImage.size.height)/2;</span><br><span class="line">return [self mergeImage:otherImage center:CGPointMake(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)mergeImage:(UIImage *)otherImage center:(CGPoint)center&#123;</span><br><span class="line">UIGraphicsBeginImageContext(self.size);</span><br><span class="line">[self drawInRect:CGRectMake(0, 0, self.size.width, self.size.height)];</span><br><span class="line">CGFloat width = otherImage.size.width;</span><br><span class="line">CGFloat height = otherImage.size.height;</span><br><span class="line">[otherImage drawInRect:CGRectMake(center.x - width/2, center.y - height/2, width, height)];</span><br><span class="line">UIImage *resultingImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return resultingImage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#warning TODO：实现一个文字版水印效果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/06/12/图片处理1：常用工具/" data-id="ckd90jomu007axc51wdft57nd" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/page/7/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/9/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>