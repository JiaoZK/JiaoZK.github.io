<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">焦正奎的博客</a></h1>
      <p>不要怕！不要悔！慢慢来！</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="焦正奎的博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-消息传递2：机制" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/05/22/消息传递2：机制/">消息传递2：机制</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/05/22/消息传递2：机制/" class="article-date">
  <time datetime="2016-05-22T10:14:18.000Z" itemprop="datePublished">2016-05-22</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;刚学OC时水过一次为啥叫消息发送，具体就不贴了！看了看实在是水的不行！前些天专门写了点消息发送的方式以及注意事项！今天就水一水，消息发送的机制是什么</p>
<h3 id="1-动态绑定VS静态绑定"><a href="#1-动态绑定VS静态绑定" class="headerlink" title="1 动态绑定VS静态绑定"></a>1 动态绑定VS静态绑定</h3><h4 id="1-1-静态绑定"><a href="#1-1-静态绑定" class="headerlink" title="1.1 静态绑定"></a>1.1 静态绑定</h4><p>-就是编译时已经写死了调用函数，硬编码的，不会变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/***********  例1 静态绑定   ***********/</span><br><span class="line">#import &lt;stdio.h&gt;</span><br><span class="line">void printHello() &#123;</span><br><span class="line">printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printGoodbye() &#123;</span><br><span class="line">printf(&quot;Goodbye, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void saySomething(int type) &#123;</span><br><span class="line">/*</span><br><span class="line">重点不是if，而是写死的printHello();和printGoodbye();</span><br><span class="line">这两个函数在编译时已经硬编码进了程序，是不会改变的</span><br><span class="line">*/ </span><br><span class="line">if (type == 0) &#123;</span><br><span class="line">printHello();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">printGoodbye();</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="1-2-动态绑定"><a href="#1-2-动态绑定" class="headerlink" title="1.2 动态绑定"></a>1.2 动态绑定</h4><ul>
<li>是运行时再绑定实际的调用函数，OC就是通过消息传递的方式来动态绑定的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/***********  例2 动态绑定   ***********/</span><br><span class="line">#import &lt;stdio.h&gt;</span><br><span class="line">void printHello() &#123;</span><br><span class="line">printf(&quot;Hello, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void printGoodbye() &#123;</span><br><span class="line">printf(&quot;Goodbye, world!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void saySomething(int type)  &#123;</span><br><span class="line">/*</span><br><span class="line">通过函数指针的方式调用printHello();和printGoodbye();函数将具体调用哪个函数推迟到了运行时再确定，我们可修改函数指针指向一个printLog();函数来实现动态效果，而不需要修改硬编码</span><br><span class="line">*/ </span><br><span class="line">void (*func)();</span><br><span class="line">if (type == 0) &#123;</span><br><span class="line">func = printHello;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">func = printGoodbye;</span><br><span class="line">&#125;</span><br><span class="line">func();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-PS-函数指针和指针函数"><a href="#1-3-PS-函数指针和指针函数" class="headerlink" title="1.3 PS:函数指针和指针函数"></a>1.3 PS:函数指针和指针函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 函数指针：函数的指针</span><br><span class="line">int (*fun)(int x,int y);</span><br><span class="line">// 指针函数：指针两字在前面，所以返回值是指针</span><br><span class="line">int * fun(int x,int y)；</span><br></pre></td></tr></table></figure>
<h3 id="2-objc-msgSend"><a href="#2-objc-msgSend" class="headerlink" title="2 objc_msgSend"></a>2 objc_msgSend</h3><h4 id="2-1-向某个OC对象发送消息"><a href="#2-1-向某个OC对象发送消息" class="headerlink" title="2.1 向某个OC对象发送消息"></a>2.1 向某个OC对象发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// OC写法</span><br><span class="line">id returnValue = [someObject messageName:parameter];</span><br><span class="line">// 编译器转化为C语言调用</span><br><span class="line">id returnValue = objc_msgSend(someObject,</span><br><span class="line">@selector(messageName:),</span><br><span class="line">parameter);</span><br></pre></td></tr></table></figure>
<h4 id="2-2-objc-msgSend原型，"><a href="#2-2-objc-msgSend原型，" class="headerlink" title="2.2 objc_msgSend原型，"></a>2.2 objc_msgSend原型，</h4><ul>
<li>参考: <a href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm.s.auto.html" target="_blank" rel="noopener">https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm.s.auto.html</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// self表示调用函数的实例对象</span><br><span class="line">// SEL表示调用的函数指针</span><br><span class="line">// ...表示对应的参数，支持多参数</span><br><span class="line">id objc_msgSend(id self, SEL _cmd, ...);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-消息传递流程"><a href="#3-消息传递流程" class="headerlink" title="3 消息传递流程"></a>3 消息传递流程</h3><h4 id="3-1-一般流程"><a href="#3-1-一般流程" class="headerlink" title="3.1 一般流程"></a>3.1 一般流程</h4><p>&emsp;&emsp;由于动态绑定需在运行时确定具体函数地址，也就存在一个查找内存地址的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 从方法缓存里找！为啥要缓存？当时是为了加快检索速度，毕竟常用方法就那么几个，每次都遍历一遍所有方法很耗时耗性能的</span><br><span class="line">2. 从类的所有方法形成的列表里找！找到则写入缓存，方便下次查找</span><br><span class="line">3. 沿着继承链从父类类中查找</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;正常流程下，如果遍历了所有父类依然没有找到对应的方法就会Crash，并给出unrecognized selector sent to instance的Crash信息，但OC贴心的为我们提供了补救措施</p>
<h4 id="3-2-补救措施"><a href="#3-2-补救措施" class="headerlink" title="3.2 补救措施"></a>3.2 补救措施</h4><ul>
<li><ol>
<li>动态方法解析，OC提供了两个方法用于处理找不到方法的情况<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 用于解决类方法找不到的情况</span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line">// 用于解决实例方法找不到的情况</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br><span class="line"></span><br><span class="line">// 示例</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line"></span><br><span class="line">[self performSelector:@selector(unrecognizedSelector)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line"></span><br><span class="line">NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">if ([selectorString isEqualToString:@&quot;unrecognizedSelector&quot;]) &#123;</span><br><span class="line">// 将sel的函数指针指向recognizedOtherSelector的地址</span><br><span class="line">class_addMethod(self,sel,(IMP)recognizedOtherSelector,&quot;&quot;);</span><br><span class="line"></span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void recognizedOtherSelector() &#123;</span><br><span class="line">NSLog(@&quot;----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="2">
<li>没有实现动态方法解析，则查看有没有备用接受者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 其实就是找个能响应aSelector方法的替死鬼</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">NSString *selectorString = NSStringFromSelector(aSelector);</span><br><span class="line">if ([selectorString isEqualToString:@&quot;unrecognizedSelector&quot;]) &#123;</span><br><span class="line">return @&quot;能够响应unrecognizedSelector的对象&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><ol start="3">
<li>消息转发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">必须要覆盖两个方法在methodSignatureForSelector和forwardInvocation</span><br><span class="line"></span><br><span class="line">// 创建一个有效的签名</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</span><br><span class="line">if (!signature) &#123;</span><br><span class="line">return [NSMethodSignature signatureWithObjCTypes:&quot;v@:@&quot;];</span><br><span class="line">&#125;</span><br><span class="line">return signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 转发给某个方法</span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line"></span><br><span class="line">[anInvocation setSelector:@selector(forwardTo:)];</span><br><span class="line">NSString *arg1;</span><br><span class="line">[anInvocation getArgument:&amp;arg1 atIndex:2];</span><br><span class="line">[anInvocation invokeWithTarget:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)forwardTo:(NSString *)arg1 &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;,arg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>&emsp;&emsp;调用一个<code></code>objc_msgSend(id theReceiver, SEL selectot,……)`方法系统执行的步骤为:</p>
<ol>
<li><p>判断receiver是否为nil，如果是nil的话则不往下执行，返回nil，这就是为什么在oc中一个nil发送消息不会引起奔溃。</p>
</li>
<li><p>从方法的缓存中查找被调用过的方法会存在缓存里面，每个类都会有一个表来存被调用过的方法，以便下次更快的调用。</p>
</li>
<li><p>从本类的方法表中查找方法寻找selector，找到则写入缓存，返回方法。否则再从父类中查找方法，如此往复，直到达到基类。如果找不到则执行方法的动态解析。</p>
</li>
<li><p>方法的动态解析： 调用+(BOOL)resolveInstanceMethod:(SEL)sel方法来查看是否能够返回一个selector，如果存在则返回selector。不存在进入下一步。</p>
</li>
<li><p>备用接受者 - (id)forwardingTargetForSelector:(SEL)aSelector这个方法来询问是否有接受者可以接受这个方法呀。如果有人接受，则交给它处理，就好像一切都没发生过一样。</p>
</li>
<li><p>方法的转发： 如果到这一步还不能够找到相应的Selector的话，就要进行完整的方法转发过程。调用方法(void)forwardInvocation:(NSInvocation *)anInvocation</p>
</li>
<li><p>最后还是没有找到的话就只有呵呵了，这时候unrecognized selector sent to instance 0x100111df0’的错误就来了。</p>
</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.jianshu.com/p/64ed325c1f19" target="_blank" rel="noopener">https://www.jianshu.com/p/64ed325c1f19</a></li>
<li><a href="https://www.zybuluo.com/MicroCai/note/64270" target="_blank" rel="noopener">https://www.zybuluo.com/MicroCai/note/64270</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/05/22/消息传递2：机制/" data-id="ckd90jony009zxc51dcbzae9o" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-消息传递1：方式" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/05/20/消息传递1：方式/">消息传递1：方式</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/05/20/消息传递1：方式/" class="article-date">
  <time datetime="2016-05-20T10:14:18.000Z" itemprop="datePublished">2016-05-20</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;前几天做CR时发现，一个同事特别喜欢Block，甚至在Base里添加了几个方法，把tableview的常用代理方法都用block实现了一遍，我对此提出了异议！但其他同事觉得没什么，个人喜好而已！你不喜欢可以不用呀！额……好吧，我不喜欢，我可以不用……。那么咱们就讨论一下iOS里一共有几种消息传递方式？各自的优缺点以及使用场景？</p>
<h3 id="1-常见方式以及介绍"><a href="#1-常见方式以及介绍" class="headerlink" title="1 常见方式以及介绍"></a>1 常见方式以及介绍</h3><h4 id="1-1-KVO"><a href="#1-1-KVO" class="headerlink" title="1.1 KVO"></a>1.1 KVO</h4><ul>
<li>含义：属性观察器，当对象中的某个属性值发生了改变，可以对这些值的观察者做出通知。</li>
<li>优点：</li>
<li>简单的方法实现映射关系，很方便的实现“联动”效果</li>
<li>能够对非“我族类“进行观察观测，方便进行调试或及时响应</li>
<li>能够观察嵌套的属性，方便窥探私有属性。例如CAAnimation可用@”transform.scale”的方式进行缩放</li>
<li>耦合低，因被观察属性根本就不知道已经被偷窥了</li>
<li>缺点：</li>
<li>keyPath必须是NSString，很容易写错且XCode不会检查</li>
<li>观察多个属性时，if处理逻辑非常复杂，容易出错</li>
<li>依赖被观察属性，一旦改名就没用了</li>
<li>不能重复addObserver, dealloc时必须removeObserver</li>
<li>没有返回值，当然也不需要</li>
<li>注意事项：不能重复addObserver, dealloc时必须removeObserver</li>
</ul>
<h4 id="1-2-Notification"><a href="#1-2-Notification" class="headerlink" title="1.2 Notification"></a>1.2 Notification</h4><ul>
<li>含义：通知（广播），典型的”管杀不管埋“</li>
<li>优点：</li>
<li>解耦，最解耦的消息传递方式</li>
<li>简单，一个[NSNotificationCenter defaultCenter]走天下</li>
<li>一对多</li>
<li>参数传递比较简单，默认提供一个id类型的object，也可以用过aUserInfo字典传递</li>
<li>缺点：</li>
<li>没有编译检查,虽然可以通过NSString <em> const name = @”name”;extern NSString </em> const name; 的方式减少失误 </li>
<li>同一个线程调用，常见问题是异步线程postNotification，主线程接收造成UI绘制出问题</li>
<li>同步调用，注意NSNotificaiton是同步调用</li>
<li>无论通过id类型的object还是通过userInfo字典传递参数都必须做”苛刻“的参数校验，否则很容易出现类型转换问题</li>
<li>没有返回值，通知（广播）甚至都不关心是否有”人“响应</li>
<li>dealloc必须移除observer</li>
<li>注意事项：同一线程同步调用，dealloc必须移除observer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notTest) name:@&quot;notTest&quot; object:nil];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">NSLog(@&quot;------ 1&quot;);</span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;notTest&quot; object:nil];</span><br><span class="line">NSLog(@&quot;------ 3&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)notTest &#123;</span><br><span class="line">NSLog(@&quot;------ 2&quot;);</span><br><span class="line">NSLog(@&quot;current queue:%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[[NSNotificationCenter defaultCenter] removeObserver:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-协议delegate（代理）"><a href="#1-3-协议delegate（代理）" class="headerlink" title="1.3 协议delegate（代理）"></a>1.3 协议delegate（代理）</h4><ul>
<li>已经是设计模式了</li>
<li>优点：</li>
<li>强制性编译器检查，默认都是@required，除非特殊标明@optional</li>
<li>代码可读性好，一般都按照UITableViewDataSource的格式写，而且一般都会将sender作为第一个参数传回去</li>
<li>参数以及返回值类型明确，是的可以有返回值</li>
<li>没有循环引用，因为一般delegate都设置为weak属性</li>
<li>调试比较方便，因为”数据“流向很清晰</li>
<li>耦合度比较低</li>
<li>缺点：</li>
<li>书写复杂，比较考验命名以及方法的拆分能力</li>
<li>发送对象和回调方法在代码上是”分开“的，不能一眼就看出来逻辑关系</li>
<li>delegate一般用weak修饰，避免野指针问题</li>
<li>@optional方法需要判断delegate是否实现</li>
<li>注意事项：@optional方法需要判断delegate是否实现，delegate一般用weak修饰</li>
</ul>
<h4 id="1-4-Block"><a href="#1-4-Block" class="headerlink" title="1.4 Block"></a>1.4 Block</h4><ul>
<li>代码块</li>
<li>优点</li>
<li>简单，不需要提前声明，不需要addObserver</li>
<li>类型安全，block声明时已经指定了参数和返回值类型，对可以有返回值</li>
<li>可读性强，更有连贯性</li>
<li>减少命名恐惧症，因为可以不命名</li>
<li>与GCD配合解决多线程问题</li>
<li>缺点</li>
<li>小心循环引用问题</li>
<li>多层bloc嵌套时，逻辑比较乱</li>
<li>小心block的捕获外部变量行为</li>
<li>作为属性时需要用copy修饰</li>
<li>耦合度高</li>
<li>需要判断block是否为nil</li>
<li>注意事项：循环引用问题</li>
</ul>
<h4 id="1-5-Target-Action"><a href="#1-5-Target-Action" class="headerlink" title="1.5 Target-Action"></a>1.5 Target-Action</h4><ul>
<li>Target-Action主要被用于响应用户界面事件时所需要传递的消息中。</li>
<li>iOS中的UIControl和Mac中的NSControl/NSCell都支持这种机制。Target-Action在消息的发送者和接收者之间建立了一个非常松散耦合。消息的接收者不知道发送者，甚至消息的发送者不需要预先知道消息的接收者。如果target是nil，action会在响应链(responder chain)中被传递，知道找到某个能够响应该aciton的对象。在iOS中，每个控件都能关联多个target-action。</li>
<li>基于target-action消息传递的机制有一个局限就是发送的消息不能携带自定义的payload。在Mac的action方法中，接收者总是被放在第一个参数中。而在iOS中，可以选择性的将发送者和和触发action的事件作为参数。除此之外，没有别的办法可以对发送action消息内容做控制。</li>
</ul>
<h3 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2 使用方式"></a>2 使用方式</h3><h4 id="2-1-其它博客推荐方式"><a href="#2-1-其它博客推荐方式" class="headerlink" title="2.1 其它博客推荐方式"></a>2.1 其它博客推荐方式</h4><ul>
<li>以下图片是破船翻译的Communication Patterns，已经给出了详细的设计方向，可精读。参考：<a href="http://www.cocoachina.com/articles/7543" target="_blank" rel="noopener">http://www.cocoachina.com/articles/7543</a><br><img src="http://cdn.cocimg.com/cms/uploads/allimg/131216/4196_131216091606_1.png" alt="image"></li>
</ul>
<h4 id="2-2-个人总结"><a href="#2-2-个人总结" class="headerlink" title="2.2 个人总结"></a>2.2 个人总结</h4><ul>
<li>KVO：属性观察器、反射</li>
<li>Notification：跨层级通信、一对多通信</li>
<li>协议delegate：通信事件比较多、强制用户实现</li>
<li>Block：一次性使用、简单的传值操作</li>
<li>Target-Action：UI控件、自定义控件专用</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>&emsp;&emsp;综上所述，我认为在Base里把tableview的常用代理方法都用block实现了一遍是得不偿失的，撇开Base更加臃肿和可能存在的循环引用不谈！用block代替tableview的delegate方法并不能保证调用者一会实现你的block，增加了调用者使用难度</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://www.cocoachina.com/articles/7543" target="_blank" rel="noopener">http://www.cocoachina.com/articles/7543</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/05/20/消息传递1：方式/" data-id="ckd90joo000a2xc516ls0weix" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Category原理" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/05/19/Category原理/">Category原理</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/05/19/Category原理/" class="article-date">
  <time datetime="2016-05-19T10:14:18.000Z" itemprop="datePublished">2016-05-19</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-Category结构"><a href="#1-Category结构" class="headerlink" title="1 Category结构"></a>1 Category结构</h3><p>&emsp;&emsp;先看rutnime里category_t的<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">源码</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct category_t &#123;</span><br><span class="line">const char *name; // 类的名字</span><br><span class="line">classref_t cls;   // 类</span><br><span class="line">struct method_list_t *instanceMethods; // 实例方法</span><br><span class="line">struct method_list_t *classMethods;    // 类方法</span><br><span class="line">struct protocol_list_t *protocols;     // 协议</span><br><span class="line">struct property_list_t *instanceProperties; // 属性</span><br><span class="line">// Fields below this point are not always present on disk.</span><br><span class="line">struct property_list_t *_classProperties;</span><br><span class="line"></span><br><span class="line">method_list_t *methodsForMeta(bool isMeta) &#123;</span><br><span class="line">if (isMeta) return classMethods;</span><br><span class="line">else return instanceMethods;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;待测试代码h文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject &#123;</span><br><span class="line">NSString *clsIvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *clsProperty1;</span><br><span class="line">@property (nonatomic, copy) NSString *clsProperty2;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Person (MyTest)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *clsProperty1;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">static NSString *kClsProperty1 = @&quot;kClsProperty1&quot;;</span><br><span class="line">static NSString *kClsProperty3 = @&quot;kClsProperty3&quot;;</span><br><span class="line">@interface Person () &#123;</span><br><span class="line">NSString *_extensionIvar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSString *extensionProperty;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">NSLog(@&quot;method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method2 &#123;</span><br><span class="line">NSLog(@&quot;method2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Person (MyTest)</span><br><span class="line"></span><br><span class="line">- (void)method1 &#123;</span><br><span class="line">NSLog(@&quot;category method1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)method3 &#123;</span><br><span class="line">NSLog(@&quot;category method3&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setClsProperty1:(NSString*)propertyValue &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty1, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)clsProperty1 &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty1);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setClsProperty3:(NSString*)propertyValue &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty3, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)clsProperty3 &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty3);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;查看编译后文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br></pre></td><td class="code"><pre><span class="line">static NSString *kClsProperty1 = (NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_0;</span><br><span class="line">static NSString *kClsProperty3 = (NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_1;</span><br><span class="line">/** interface Person () &#123;</span><br><span class="line">NSString *_extensionIvar;</span><br><span class="line">**/ </span><br><span class="line"></span><br><span class="line">// @property (nonatomic, copy) NSString *extensionProperty;</span><br><span class="line"></span><br><span class="line">/* @end */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// @implementation Person</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_method1(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_method2(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_clsProperty1(Person * self, SEL _cmd) &#123; return (*(NSString * _Nonnull __strong *)((char *)self + OBJC_IVAR_$_Person$_clsProperty1)); &#125;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) void objc_setProperty (id, SEL, long, id, bool, bool);</span><br><span class="line"></span><br><span class="line">static void _I_Person_setClsProperty1_(Person * self, SEL _cmd, NSString * _Nonnull clsProperty1) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _clsProperty1), (id)clsProperty1, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_clsProperty2(Person * self, SEL _cmd) &#123; return (*(NSString * _Nonnull __strong *)((char *)self + OBJC_IVAR_$_Person$_clsProperty2)); &#125;</span><br><span class="line">static void _I_Person_setClsProperty2_(Person * self, SEL _cmd, NSString * _Nonnull clsProperty2) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _clsProperty2), (id)clsProperty2, 0, 1); &#125;</span><br><span class="line"></span><br><span class="line">static NSString * _I_Person_extensionProperty(Person * self, SEL _cmd) &#123; return (*(NSString *__strong *)((char *)self + OBJC_IVAR_$_Person$_extensionProperty)); &#125;</span><br><span class="line">static void _I_Person_setExtensionProperty_(Person * self, SEL _cmd, NSString *extensionProperty) &#123; objc_setProperty (self, _cmd, __OFFSETOFIVAR__(struct Person, _extensionProperty), (id)extensionProperty, 0, 1); &#125;</span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">// @implementation Person (MyTest)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_method1(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_method3(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_38d560_mi_5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_setClsProperty1_(Person * self, SEL _cmd, NSString *__strong  _Nonnull propertyValue) &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty1, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_MyTest_clsProperty1(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty1);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void _I_Person_MyTest_setClsProperty3_(Person * self, SEL _cmd, NSString *__strong  _Nonnull propertyValue) &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kClsProperty3, propertyValue, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static NSString * _Nonnull _I_Person_MyTest_clsProperty3(Person * self, SEL _cmd) &#123;</span><br><span class="line">NSString *value = objc_getAssociatedObject(self, &amp;kClsProperty3);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// @end</span><br><span class="line"></span><br><span class="line">struct _prop_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">const char *attributes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _protocol_t;</span><br><span class="line"></span><br><span class="line">struct _objc_method &#123;</span><br><span class="line">struct objc_selector * _cmd;</span><br><span class="line">const char *method_type;</span><br><span class="line">void  *_imp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _protocol_t &#123;</span><br><span class="line">void * isa;  // NULL</span><br><span class="line">const char *protocol_name;</span><br><span class="line">const struct _protocol_list_t * protocol_list; // super protocols</span><br><span class="line">const struct method_list_t *instance_methods;</span><br><span class="line">const struct method_list_t *class_methods;</span><br><span class="line">const struct method_list_t *optionalInstanceMethods;</span><br><span class="line">const struct method_list_t *optionalClassMethods;</span><br><span class="line">const struct _prop_list_t * properties;</span><br><span class="line">const unsigned int size;  // sizeof(struct _protocol_t)</span><br><span class="line">const unsigned int flags;  // = 0</span><br><span class="line">const char ** extendedMethodTypes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _ivar_t &#123;</span><br><span class="line">unsigned long int *offset;  // pointer to ivar offset location</span><br><span class="line">const char *name;</span><br><span class="line">const char *type;</span><br><span class="line">unsigned int alignment;</span><br><span class="line">unsigned int  size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _class_ro_t &#123;</span><br><span class="line">unsigned int flags;</span><br><span class="line">unsigned int instanceStart;</span><br><span class="line">unsigned int instanceSize;</span><br><span class="line">unsigned int reserved;</span><br><span class="line">const unsigned char *ivarLayout;</span><br><span class="line">const char *name;</span><br><span class="line">const struct _method_list_t *baseMethods;</span><br><span class="line">const struct _objc_protocol_list *baseProtocols;</span><br><span class="line">const struct _ivar_list_t *ivars;</span><br><span class="line">const unsigned char *weakIvarLayout;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _class_t &#123;</span><br><span class="line">struct _class_t *isa;</span><br><span class="line">struct _class_t *superclass;</span><br><span class="line">void *cache;</span><br><span class="line">void *vtable;</span><br><span class="line">struct _class_ro_t *ro;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct _category_t &#123;</span><br><span class="line">const char *name;</span><br><span class="line">struct _class_t *cls;</span><br><span class="line">const struct _method_list_t *instance_methods;</span><br><span class="line">const struct _method_list_t *class_methods;</span><br><span class="line">const struct _protocol_list_t *protocols;</span><br><span class="line">const struct _prop_list_t *properties;</span><br><span class="line">&#125;;</span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct objc_cache _objc_empty_cache;</span><br><span class="line">#pragma warning(disable:4273)</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$clsIvar __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, clsIvar);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_extensionIvar __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _extensionIvar);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_clsProperty1 __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _clsProperty1);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_clsProperty2 __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _clsProperty2);</span><br><span class="line">extern &quot;C&quot; unsigned long int OBJC_IVAR_$_Person$_extensionProperty __attribute__ ((used, section (&quot;__DATA,__objc_ivar&quot;))) = __OFFSETOFIVAR__(struct Person, _extensionProperty);</span><br><span class="line"></span><br><span class="line">static struct /*_ivar_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count;</span><br><span class="line">struct _ivar_t ivar_list[5];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_VARIABLES_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_ivar_t),</span><br><span class="line">5,</span><br><span class="line">&#123;&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$clsIvar, &quot;clsIvar&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_extensionIvar, &quot;_extensionIvar&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_clsProperty1, &quot;_clsProperty1&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_clsProperty2, &quot;_clsProperty2&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;,</span><br><span class="line">&#123;(unsigned long int *)&amp;OBJC_IVAR_$_Person$_extensionProperty, &quot;_extensionProperty&quot;, &quot;@\&quot;NSString\&quot;&quot;, 3, 8&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[8];</span><br><span class="line">&#125; _OBJC_$_INSTANCE_METHODS_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">8,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;method1&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_method1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;method2&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_method2&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty1&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_clsProperty1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty1:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setClsProperty1_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty2&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_clsProperty2&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty2:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setClsProperty2_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;extensionProperty&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_extensionProperty&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setExtensionProperty:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_setExtensionProperty_&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[2];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">2,</span><br><span class="line">&#123;&#123;&quot;clsProperty1&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_clsProperty1&quot;&#125;,</span><br><span class="line">&#123;&quot;clsProperty2&quot;,&quot;T@\&quot;NSString\&quot;,C,N,V_clsProperty2&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct _class_ro_t _OBJC_METACLASS_RO_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">1, sizeof(struct _class_t), sizeof(struct _class_t), </span><br><span class="line">(unsigned int)0, </span><br><span class="line">0, </span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">0, </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct _class_ro_t _OBJC_CLASS_RO_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">0, __OFFSETOFIVAR__(struct Person, clsIvar), sizeof(struct Person_IMPL), </span><br><span class="line">(unsigned int)0, </span><br><span class="line">0, </span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_INSTANCE_METHODS_Person,</span><br><span class="line">0, </span><br><span class="line">(const struct _ivar_list_t *)&amp;_OBJC_$_INSTANCE_VARIABLES_Person,</span><br><span class="line">0, </span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_METACLASS_$_NSObject;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_METACLASS_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_data&quot;))) = &#123;</span><br><span class="line">0, // &amp;OBJC_METACLASS_$_NSObject,</span><br><span class="line">0, // &amp;OBJC_METACLASS_$_NSObject,</span><br><span class="line">0, // (void *)&amp;_objc_empty_cache,</span><br><span class="line">0, // unused, was (void *)&amp;_objc_empty_vtable,</span><br><span class="line">&amp;_OBJC_METACLASS_RO_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllimport) struct _class_t OBJC_CLASS_$_NSObject;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person __attribute__ ((used, section (&quot;__DATA,__objc_data&quot;))) = &#123;</span><br><span class="line">0, // &amp;OBJC_METACLASS_$_Person,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_NSObject,</span><br><span class="line">0, // (void *)&amp;_objc_empty_cache,</span><br><span class="line">0, // unused, was (void *)&amp;_objc_empty_vtable,</span><br><span class="line">&amp;_OBJC_CLASS_RO_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CLASS_SETUP_$_Person(void ) &#123;</span><br><span class="line">OBJC_METACLASS_$_Person.isa = &amp;OBJC_METACLASS_$_NSObject;</span><br><span class="line">OBJC_METACLASS_$_Person.superclass = &amp;OBJC_METACLASS_$_NSObject;</span><br><span class="line">OBJC_METACLASS_$_Person.cache = &amp;_objc_empty_cache;</span><br><span class="line">OBJC_CLASS_$_Person.isa = &amp;OBJC_METACLASS_$_Person;</span><br><span class="line">OBJC_CLASS_$_Person.superclass = &amp;OBJC_CLASS_$_NSObject;</span><br><span class="line">OBJC_CLASS_$_Person.cache = &amp;_objc_empty_cache;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CLASS_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CLASS_SETUP_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[6];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">6,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;method1&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_MyTest_method1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;method3&quot;, &quot;v16@0:8&quot;, (void *)_I_Person_MyTest_method3&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty1:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_MyTest_setClsProperty1_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty1&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_MyTest_clsProperty1&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;setClsProperty3:&quot;, &quot;v24@0:8@16&quot;, (void *)_I_Person_MyTest_setClsProperty3_&#125;,</span><br><span class="line">&#123;(struct objc_selector *)&quot;clsProperty3&quot;, &quot;@16@0:8&quot;, (void *)_I_Person_MyTest_clsProperty3&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[2];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">2,</span><br><span class="line">&#123;&#123;&quot;clsProperty1&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;,</span><br><span class="line">&#123;&quot;clsProperty3&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_Person;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_Person_$_MyTest __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = </span><br><span class="line">&#123;</span><br><span class="line">&quot;Person&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_Person,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_MyTest,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_Person_$_MyTest,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_Person_$_MyTest(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_Person_$_MyTest.cls = &amp;OBJC_CLASS_$_Person;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_Person_$_MyTest,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_Person,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_Person_$_MyTest,</span><br><span class="line">&#125;;</span><br><span class="line">static struct IMAGE_INFO &#123; unsigned version; unsigned flag; &#125; _OBJC_IMAGE_INFO = &#123; 0, 2 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;通过观察编译代码得知</p>
<ol>
<li>extension不是匿名Category，两者无关！extension是编译到类里的</li>
<li>使用category的方法需要引入对应的头文件，因为category是单独编译（如果把MyTest单独成一个文件，编译Person的时候是看不到MyTest相关代码的）</li>
<li>Category是运行期决议的，因为如果编译阶段就决议必然会有重名错误问题</li>
<li>category不能添加ivar, category_t数据结构里没有，编译后代码也没相关逻辑</li>
<li>所有类和category编译后都是struct结构体，在DATA段下有 <strong>objc_classlist 和 </strong>objc_catlist ，再通过<em>OBJC</em>$_CATEGORY_Person_$_MyTest.cls = &amp;OBJC_CLASS_$_Person;方式指明category和类的关系</li>
<li>category的h文件声明的属性如果没手动实现getter和setter方法会报错的原因就是编译器没自动生成（废话，但这次是从源码角度看的）</li>
</ol>
<h3 id="2-Category加载"><a href="#2-Category加载" class="headerlink" title="2 Category加载"></a>2 Category加载</h3><p>&emsp;&emsp;category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images中有对category的处理，源码太长了, 只贴把category的实例方法、协议以及属性添加到类上的代码,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Process this category.</span><br><span class="line">// First, register the category with its target class.</span><br><span class="line">// Then, rebuild the class&apos;s method lists (etc) if</span><br><span class="line">// the class is realized.</span><br><span class="line">bool classExists = NO;</span><br><span class="line">if (cat-&gt;instanceMethods ||  cat-&gt;protocols</span><br><span class="line">||  cat-&gt;instanceProperties)</span><br><span class="line">&#123;</span><br><span class="line">// addUnattachedCategoryForClass只是把类和category做一个关联映射</span><br><span class="line">addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">if (cls-&gt;isRealized()) &#123;</span><br><span class="line">remethodizeClass(cls);</span><br><span class="line">classExists = YES;</span><br><span class="line">&#125;</span><br><span class="line">if (PrintConnecting) &#123;</span><br><span class="line">_objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">cls-&gt;nameForLogging(), cat-&gt;name,</span><br><span class="line">classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//接下来是把category的类方法和协议添加到类的metaclass上的代码，逻辑一样参数改成cls-&gt;ISA()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;remethodizeClass最后会把Category的method、properties和protocols添加到cls里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Attach method lists and properties and protocols from categories to a class.</span><br><span class="line">// Assumes the categories in cats are all loaded and sorted by load order, </span><br><span class="line">// oldest categories first.</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的是</p>
<ol>
<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</li>
</ol>
<h3 id="3-关联对象"><a href="#3-关联对象" class="headerlink" title="3 关联对象"></a>3 关联对象</h3><p>&emsp;&emsp;上面说到category没法添加ivar，而我们都知道可以通过关联对象的方式给category添加“实例变量”，它是怎么实现的？从runtime的objc_setAssociatedObject和objc_getAssociatedObject两个函数入手查看源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) &#123;</span><br><span class="line">_object_set_associative_reference(object, (void *)key, value, policy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">// retain the new value (if any) outside the lock.</span><br><span class="line">ObjcAssociation old_association(0, nil);</span><br><span class="line">id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">&#123;</span><br><span class="line">AssociationsManager manager;</span><br><span class="line">AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">if (new_value) &#123;</span><br><span class="line">// break any existing association.</span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i != associations.end()) &#123;</span><br><span class="line">// secondary table exists</span><br><span class="line">ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123;</span><br><span class="line">old_association = j-&gt;second;</span><br><span class="line">j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// create the new association (first time).</span><br><span class="line">ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">associations[disguised_object] = refs;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">object-&gt;setHasAssociatedObjects();</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// setting the association to nil breaks the association.</span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">if (i !=  associations.end()) &#123;</span><br><span class="line">ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">if (j != refs-&gt;end()) &#123;</span><br><span class="line">old_association = j-&gt;second;</span><br><span class="line">refs-&gt;erase(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// release the old value (outside of the lock).</span><br><span class="line">if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 不用看异常逻辑，代码很简单，直接copy美团的结论吧！所有的关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。</p>
<p>&emsp;&emsp; 对象的销毁逻辑里面也会清除关联对象</p>
<h3 id="4-其它问题"><a href="#4-其它问题" class="headerlink" title="4 其它问题"></a>4 其它问题</h3><h4 id="4-1-在类和category中都可以有-load方法，那么有两个问题："><a href="#4-1-在类和category中都可以有-load方法，那么有两个问题：" class="headerlink" title="4.1 在类和category中都可以有+load方法，那么有两个问题："></a>4.1 在类和category中都可以有+load方法，那么有两个问题：</h4><ol>
<li>在类的+load方法调用的时候，我们可以调用category中声明的方法么？可以调用，因为附加category到类的工作会先于+load方法的执行</li>
<li>这么些个+load方法，调用顺序是咋样的呢？ +load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的</li>
</ol>
<h4 id="4-2-怎么调用到原来类中被category覆盖掉的方法？"><a href="#4-2-怎么调用到原来类中被category覆盖掉的方法？" class="headerlink" title="4.2 怎么调用到原来类中被category覆盖掉的方法？"></a>4.2 怎么调用到原来类中被category覆盖掉的方法？</h4><p>&emsp;&emsp; 对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</p>
<h4 id="4-3-initialize方法什么时候调用"><a href="#4-3-initialize方法什么时候调用" class="headerlink" title="4.3 +initialize方法什么时候调用"></a>4.3 +initialize方法什么时候调用</h4><p>&emsp;&emsp; initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次！initialize先初始化父类，之后再初始化子类。如果分类实现了+initialize，就覆盖类本身的+initialize调用</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>&emsp;&emsp;美团的<a href="https://tech.meituan.com/2015/03/03/diveintocategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>，差距真的不是一点点！美团童鞋在15年就研究过相关问题了，我到17年才看到…</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/05/19/Category原理/" data-id="ckd90jok9000ixc517m7v3tll" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-响应链" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/05/03/响应链/">响应链</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/05/03/响应链/" class="article-date">
  <time datetime="2016-05-03T10:14:18.000Z" itemprop="datePublished">2016-05-03</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;响应链是啥？我也说不清，不管了，我就写点我知道的吧</p>
<p>&emsp;&emsp;最简单的查看响应链的方法就是递归打印nextResponder, 可见顺序是当前view一直到UIApplication的顺序，有view响应则此链中断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">UIButton *btn1 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 300, 500)];</span><br><span class="line">btn1.backgroundColor = [UIColor redColor];</span><br><span class="line">[self.view addSubview:btn1];</span><br><span class="line">UIButton *btn2 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 250, 400)];</span><br><span class="line">btn2.backgroundColor = [UIColor blueColor];</span><br><span class="line">[btn1 addSubview:btn2];</span><br><span class="line">UIButton *btn3 = [[UIButton alloc] initWithFrame:CGRectMake(0, 0, 200, 300)];</span><br><span class="line">btn3.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[btn2 addSubview:btn3];</span><br><span class="line"></span><br><span class="line">NSArray *arr = @[btn1, btn2, btn3];</span><br><span class="line">for (UIButton *btn in arr) &#123;</span><br><span class="line">[btn addTarget:self action:@selector(btnClick:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (void)btnClick:(UIButton *)btn &#123;</span><br><span class="line">[self logNextResponder:btn];</span><br><span class="line">&#125;</span><br><span class="line">- (void)logNextResponder:(UIResponder *)responder &#123;</span><br><span class="line">NSLog(@&quot;responder:%@&quot;,responder);</span><br><span class="line">UIResponder *next = responder.nextResponder;</span><br><span class="line">if (next) &#123;</span><br><span class="line">[self logNextResponder:next];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;再说事件传递，就是点了下屏幕，系统时怎么知道“点击”的？点击之后，由UIApplication管理事件，然后递归查找最合适的view类接收事件！对的，跟nextResponder的顺序相反！但系统怎么知道到底是哪个view呢？毕竟UIApplication最“大”，点击的那个view只是大量subviews中的一个！这时需要借助两个UIView的函数：</p>
<ul>
<li>pointInside: withEvent: 用于判断某个事件是否在某个view的bound范围内</li>
<li>hitTest: withEvent: 用于判断某个view是否响应某个事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">//首先判断是否可以接收事件</span><br><span class="line">if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</span><br><span class="line">//然后判断点是否在当前视图上</span><br><span class="line">if ([self pointInside:point withEvent:event] == NO) return nil;</span><br><span class="line">//循环遍历所有子视图，查找是否有最合适的视图</span><br><span class="line">for (NSInteger i = self.subviews.count - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">UIView *childView = self.subviews[i];</span><br><span class="line">//转换点到子视图坐标系上</span><br><span class="line">CGPoint childPoint = [self convertPoint:point toView:childView];</span><br><span class="line">//递归查找是否存在最合适的view</span><br><span class="line">UIView *fitView = [childView hitTest:childPoint withEvent:event];</span><br><span class="line">//如果返回非空，说明子视图中找到了最合适的view，那么返回它</span><br><span class="line">if (fitView) &#123;</span><br><span class="line">return fitView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//循环结束，仍旧没有合适的子视图可以处理事件，那么就认为自己是最合适的view</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;pointInside: withEvent:的妙用，可控制view的响应范围</p>
<ul>
<li>例如扩大button的点击范围<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event &#123;</span><br><span class="line">CGRect bounds = self.bounds;</span><br><span class="line">CGFloat widthDelta = MAX(100.0 , bounds.size.height);;</span><br><span class="line">CGFloat heightDelta = MAX(100.0 , bounds.size.height);</span><br><span class="line">bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);</span><br><span class="line">return CGRectContainsPoint(bounds, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;hitTest: withEvent:的妙用，常用于事件透传或转发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</span><br><span class="line">CGPoint yellowPoint = [self convertPoint:point toView:_yellowView];</span><br><span class="line">if ([_yellowView pointInside:yellowPoint withEvent:event]) &#123;</span><br><span class="line">return _yellowView;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;说实话，我很怀疑有些同志问的问题自己都说不清：你知道响应链吗？响应链是啥？呵呵，响应链是啥这种问题，叫我怎么回答？响应链要我说就是view的事件响应优先级！不过这么回答，肯定错了！他们想知道的是：为啥用hittest、pointinside，以及怎么用。。。。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.jianshu.com/p/36d2eb74fb23" target="_blank" rel="noopener">https://www.jianshu.com/p/36d2eb74fb23</a></li>
<li><a href="https://www.jianshu.com/p/2f664e71c527" target="_blank" rel="noopener">https://www.jianshu.com/p/2f664e71c527</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/05/03/响应链/" data-id="ckd90joms0074xc51z9hieb9x" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/">UI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-多线程2：NSOperation、NSThread和pthread" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/04/21/多线程2：NSOperation、NSThread和pthread/">多线程2：NSOperation、NSThread和pthread</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/04/21/多线程2：NSOperation、NSThread和pthread/" class="article-date">
  <time datetime="2016-04-21T10:14:18.000Z" itemprop="datePublished">2016-04-21</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-操作队列"><a href="#1-操作队列" class="headerlink" title="1 操作队列"></a>1 操作队列</h3><p>&emsp;&emsp;NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象！更高级意味着</p>
<ul>
<li>可以添加依赖关系，便于控制执行顺序，</li>
<li>可以设定优先级</li>
<li>监控操作状态（isExecuteing、isFinished、isCancelled）</li>
<li>可以实现completionBlock来实现完成时自动回调</li>
</ul>
<p>&emsp;&emsp;个人理解：使用NSOperationQueue才真正的创建新线程，NSOperation就相当于就是GCD里面的block！还有就是我们只能“创建”线程，但具体到底创建了几个线程，是由系统决定的……好坑！不过一般情况下不用关心线程数量</p>
<p>&emsp;&emsp;另外需要注意的是：cancel某个操作（或操作队列），并不代表操作立即取消，只是设置个标志位告诉系统这个操作（或操作队列）需要cancel，系统去决定什么时候cancel</p>
<h4 id="1-1-NSOperation使用"><a href="#1-1-NSOperation使用" class="headerlink" title="1.1 NSOperation使用"></a>1.1 NSOperation使用</h4><ul>
<li><p>NSBlockOperation的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *opearation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;];</span><br><span class="line">// 添加额外子操作，等所有子操作(包括do something)都完成，才认为这次操作完成了</span><br><span class="line">[opearation addExecutionBlock:^&#123;</span><br><span class="line">// other something</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 以下为NSOperation属性以及解释</span><br><span class="line">opearation.name = @&quot;name可做标志位&quot;;</span><br><span class="line">opearation.completionBlock = ^&#123;</span><br><span class="line">NSLog(@&quot;已完成&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">// 开启任务</span><br><span class="line">[opearation start];</span><br><span class="line">// 是否正在执行</span><br><span class="line">[opearation isExecuting];</span><br><span class="line">// 是否执行完了</span><br><span class="line">[opearation isFinished];</span><br><span class="line">// 当前操作是否执行完了</span><br><span class="line">[opearation isAsynchronous];</span><br><span class="line">// 是否准备好去执行</span><br><span class="line">[opearation isReady];</span><br><span class="line">// 添加依赖, 就是要等beferOpearation完成，才执行opearation</span><br><span class="line">// 注意一定不要创建一个循环依赖，A依赖B，B依赖A，这样会造成死锁</span><br><span class="line">// [opearation addDependency:beferOpearation];</span><br><span class="line">// 移除依赖</span><br><span class="line">// [opearation removeDependency:beferOpearation];</span><br><span class="line">// 阻塞当前线程，直到该操作结束, GCD的栅栏效果</span><br><span class="line">[opearation waitUntilFinished];</span><br><span class="line">// 取消</span><br><span class="line">if (![opearation isCancelled]) &#123;</span><br><span class="line">[opearation cancel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSInvocationOperation的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSInvocationOperation *opearation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(test) object:nil];</span><br><span class="line">[opearation start];</span><br><span class="line"></span><br><span class="line">- (void)test &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>NSOperation的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface MyOperation: NSOperation</span><br><span class="line">@end</span><br><span class="line">@implementation MyOperation</span><br><span class="line">- (void)main &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">MyOperation *operation = [[MyOperation alloc] init];</span><br><span class="line">[operation start];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-2-NSOperationQueue使用"><a href="#1-2-NSOperationQueue使用" class="headerlink" title="1.2 NSOperationQueue使用"></a>1.2 NSOperationQueue使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">NSBlockOperation *opearation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;];</span><br><span class="line">// 创建队列</span><br><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">// 添加操作，操作顺序有依赖关系和qualityOfService决定，并不一定是FIFO</span><br><span class="line">[queue addOperation:opearation];</span><br><span class="line">// 添加一组操作，并阻塞线程到这一组操作都完成</span><br><span class="line">[queue addOperations:@[opearation] waitUntilFinished:YES];</span><br><span class="line">// 添加一个新操作</span><br><span class="line">[queue addOperationWithBlock:^&#123;</span><br><span class="line">// new opearation will do something</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;当前所有的操作：%@，注意操作完成后会自动从数组中移除&quot;, queue.operations);</span><br><span class="line">NSLog(@&quot;当前所有的操作数量：%i&quot;, queue.operationCount);</span><br><span class="line">/*</span><br><span class="line">最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。</span><br><span class="line">不等于并发线程的数量，线程个数是系统决定的，而且一个操作也有可能不止再一个线程执行</span><br><span class="line">当然maxConcurrentOperationCount为1，即表示串行队列</span><br><span class="line">*/</span><br><span class="line">queue.maxConcurrentOperationCount = 1;</span><br><span class="line">// 暂停或开启所有操作</span><br><span class="line">if (queue.suspended) &#123;</span><br><span class="line">[queue setSuspended:NO];</span><br><span class="line">&#125;</span><br><span class="line">// 阻塞当前线程，直到队列中的操作全部执行完毕</span><br><span class="line">[queue waitUntilAllOperationsAreFinished];</span><br><span class="line">// 取消所有操作</span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure>
<h3 id="2-NSThread"><a href="#2-NSThread" class="headerlink" title="2 NSThread"></a>2 NSThread</h3><p>&emsp;&emsp;NSThread和pthread很不常用，而且需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销!</p>
<ul>
<li><p>创建线程方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1 创建线程并启动</span><br><span class="line">[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];   </span><br><span class="line"></span><br><span class="line">// 2 创建线程，但需要手动启动</span><br><span class="line">NSThread* myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];   </span><br><span class="line">[myThread setName=@&quot;调试用&quot;];</span><br><span class="line">[myThread setThreadPriority:NSQualityOfServiceDefault];// 设置优先级</span><br><span class="line">[myThread start]; // 启动</span><br><span class="line">[myThread cancel]; // 取消</span><br><span class="line">[myThread exit]; // 退出</span><br><span class="line"></span><br><span class="line">// 3 系统会创建一个子线程并启动</span><br><span class="line">[self performSelectorInBackground:@selector(threadRun) withObject:self];</span><br><span class="line">// 一般配合使用来更新UI</span><br><span class="line">[self performSelectorOnMainThread:@selector(updateUI:) withObject:image waitUntilDone:YES]; </span><br><span class="line"></span><br><span class="line">// 4 继承NSThread需重写main方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前线程</span><br><span class="line">[NSThread currentThread]</span><br><span class="line">// 当前线程是不是主线程</span><br><span class="line">[[NSThread currentThread] isMainThread]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-1：主线程检测的最标准写法"><a href="#2-1：主线程检测的最标准写法" class="headerlink" title="2.1：主线程检测的最标准写法"></a>2.1：主线程检测的最标准写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// RAC源码</span><br><span class="line">+ (BOOL)isOnMainThread &#123;</span><br><span class="line">return [NSOperationQueue.currentQueue isEqual:NSOperationQueue.mainQueue] || [NSThread isMainThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-pthread"><a href="#3-pthread" class="headerlink" title="3 pthread"></a>3 pthread</h3><ul>
<li>转载自：<a href="https://github.com/ming1016/study/wiki/iOS并发编程" target="_blank" rel="noopener">https://github.com/ming1016/study/wiki/iOS并发编程</a></li>
<li><p>下面是并发4个线程在一百万个数字中找最小值和最大值的pthread例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">struct threadInfo &#123;</span><br><span class="line">uint32_t * inputValues;</span><br><span class="line">size_t count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct threadResult &#123;</span><br><span class="line">uint32_t min;</span><br><span class="line">uint32_t max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void * findMinAndMax(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">struct threadInfo const * const info = (struct threadInfo *) arg;</span><br><span class="line">uint32_t min = UINT32_MAX;</span><br><span class="line">uint32_t max = 0;</span><br><span class="line">for (size_t i = 0; i &lt; info-&gt;count; ++i) &#123;</span><br><span class="line">uint32_t v = info-&gt;inputValues[i];</span><br><span class="line">min = MIN(min, v);</span><br><span class="line">max = MAX(max, v);</span><br><span class="line">&#125;</span><br><span class="line">free(arg);</span><br><span class="line">struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result));</span><br><span class="line">result-&gt;min = min;</span><br><span class="line">result-&gt;max = max;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">size_t const count = 1000000;</span><br><span class="line">uint32_t inputValues[count];</span><br><span class="line"></span><br><span class="line">// 使用随机数字填充 inputValues</span><br><span class="line">for (size_t i = 0; i &lt; count; ++i) &#123;</span><br><span class="line">inputValues[i] = arc4random();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 开始4个寻找最小值和最大值的线程</span><br><span class="line">size_t const threadCount = 4;</span><br><span class="line">pthread_t tid[threadCount];</span><br><span class="line">for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info));</span><br><span class="line">size_t offset = (count / threadCount) * i;</span><br><span class="line">info-&gt;inputValues = inputValues + offset;</span><br><span class="line">info-&gt;count = MIN(count - offset, count / threadCount);</span><br><span class="line">int err = pthread_create(tid + i, NULL, &amp;findMinAndMax, info);</span><br><span class="line">NSCAssert(err == 0, @&quot;pthread_create() failed: %d&quot;, err);</span><br><span class="line">&#125;</span><br><span class="line">// 等待线程退出</span><br><span class="line">struct threadResult * results[threadCount];</span><br><span class="line">for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">int err = pthread_join(tid[i], (void **) &amp;(results[i]));</span><br><span class="line">NSCAssert(err == 0, @&quot;pthread_join() failed: %d&quot;, err);</span><br><span class="line">&#125;</span><br><span class="line">// 寻找 min 和 max</span><br><span class="line">uint32_t min = UINT32_MAX;</span><br><span class="line">uint32_t max = 0;</span><br><span class="line">for (size_t i = 0; i &lt; threadCount; ++i) &#123;</span><br><span class="line">min = MIN(min, results[i]-&gt;min);</span><br><span class="line">max = MAX(max, results[i]-&gt;max);</span><br><span class="line">free(results[i]);</span><br><span class="line">results[i] = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;min = %u&quot;, min);</span><br><span class="line">NSLog(@&quot;max = %u&quot;, max);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用NSThread来写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@interface FindMinMaxThread : NSThread</span><br><span class="line">@property (nonatomic) NSUInteger min;</span><br><span class="line">@property (nonatomic) NSUInteger max;</span><br><span class="line">- (instancetype)initWithNumbers:(NSArray *)numbers;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FindMinMaxThread &#123;</span><br><span class="line">NSArray *_numbers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithNumbers:(NSArray *)numbers</span><br><span class="line">&#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">_numbers = numbers;</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)main</span><br><span class="line">&#123;</span><br><span class="line">NSUInteger min;</span><br><span class="line">NSUInteger max;</span><br><span class="line">// 进行相关数据的处理</span><br><span class="line">self.min = min;</span><br><span class="line">self.max = max;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">//启动一个新的线程，创建一个线程对象</span><br><span class="line">NSMutableSet *threads = [NSMutableSet set];</span><br><span class="line">NSUInteger numberCount = self.numbers.count;</span><br><span class="line">NSUInteger threadCount = 4;</span><br><span class="line">for (NSUInteger i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">NSUInteger offset = (count / threadCount) * i;</span><br><span class="line">NSUInteger count = MIN(numberCount - offset, numberCount / threadCount);</span><br><span class="line">NSRange range = NSMakeRange(offset, count);</span><br><span class="line">NSArray *subset = [self.numbers subarrayWithRange:range];</span><br><span class="line">FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset];</span><br><span class="line">[threads addObject:thread];</span><br><span class="line">[thread start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/04/21/多线程2：NSOperation、NSThread和pthread/" data-id="ckd90jon3007yxc51b4zq5wy4" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-多线程1：概念和GCD" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/04/17/多线程1：概念和GCD/">多线程1：概念和GCD</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/04/17/多线程1：概念和GCD/" class="article-date">
  <time datetime="2016-04-17T10:14:18.000Z" itemprop="datePublished">2016-04-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    
                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/04/17/多线程1：概念和GCD/" data-id="ckd90jon1007sxc51n9ji88q9" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-定时器" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/03/30/定时器/">定时器</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/03/30/定时器/" class="article-date">
  <time datetime="2016-03-30T10:14:18.000Z" itemprop="datePublished">2016-03-30</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-NSTimer"><a href="#1-NSTimer" class="headerlink" title="1 NSTimer"></a>1 NSTimer</h3><h4 id="1-1-NSTimer准不准？"><a href="#1-1-NSTimer准不准？" class="headerlink" title="1.1 NSTimer准不准？"></a>1.1 NSTimer准不准？</h4><ul>
<li>无论是单次执行的NSTimer还是重复执行的NSTimer都不是准时的</li>
<li>原因</li>
<li>只添加到了runloop的defaultmode里，当scrollView滑动时runloop会切换到UITrackingRunLoopMode下，造成NSTimer延后</li>
<li>当前线程阻塞或正在进行大量数据计算，NSTimer会延后处理</li>
<li></li>
</ul>
<h4 id="1-2-创建NSTimer需要加到runloop里"><a href="#1-2-创建NSTimer需要加到runloop里" class="headerlink" title="1.2 创建NSTimer需要加到runloop里"></a>1.2 创建NSTimer需要加到runloop里</h4><ul>
<li>默认NSTimer加到runloop是NSDefaultRunLoopMode模式，此模式下scrollview滑动时会切换到UITrackingRunLoopMode下暂停NSTimer，因此需要让NSTimer都响应，需要使用NSRunLoopCommonModes</li>
<li>故runloop强持有NSTimer，来保证timer按时触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSTimer *bTimer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(automaticCountDown) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:bTimer forMode:NSRunLoopCommonModes];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-scheduledTimerWith和timerWith的区别"><a href="#1-3-scheduledTimerWith和timerWith的区别" class="headerlink" title="1.3 scheduledTimerWith和timerWith的区别"></a>1.3 scheduledTimerWith和timerWith的区别</h4><ul>
<li>timerWith创建的NSTimer需要手动添加到runloop里</li>
<li>scheduledTimerWith创建的NSTimer已经自动添加到当前runloop的NSDefaultRunLoopMode模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/// Creates and returns a new NSTimer object initialized with the specified block object. This timer needs to be scheduled on a run loop (via -[NSRunLoop addTimer:]) before it will fire.</span><br><span class="line">/// - parameter:  timeInterval  The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span><br><span class="line">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span><br><span class="line">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span><br><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br><span class="line">/// Creates and returns a new NSTimer object initialized with the specified block object and schedules it on the current run loop in the default mode.</span><br><span class="line">/// - parameter:  ti    The number of seconds between firings of the timer. If seconds is less than or equal to 0.0, this method chooses the nonnegative value of 0.1 milliseconds instead</span><br><span class="line">/// - parameter:  repeats  If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.</span><br><span class="line">/// - parameter:  block  The execution body of the timer; the timer itself is passed as the parameter to this block when executed to aid in avoiding cyclical references</span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-4-NSTimer内存泄漏"><a href="#1-4-NSTimer内存泄漏" class="headerlink" title="1.4 NSTimer内存泄漏"></a>1.4 NSTimer内存泄漏</h4><ul>
<li><p>NSTimer的target是strong强持有的，即NSTimer持有target！如果target强持有NSTimer，就会形成循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target： The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to this object until it (the timer) is invalidated.</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak修饰NSTimer不管用，只能解除target对NSTimer的强持有！一般情况下循环引用只要断掉一环就可以释放了，但runloop还引用着NSTimer，NSTimer又引用target，因此也无法解决内存泄漏问题</p>
</li>
<li><p>很多时候使用retain或strong修饰，更多是提醒开发者需要手动处理NSTimer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if (self) &#123;</span><br><span class="line">_timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerRun) userInfo:nil repeats:YES];</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)timerRun &#123;</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[self.timer invalidate];</span><br><span class="line">NSLog(@&quot;%s&quot;, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用block解除引用，参考《Effective Objective-C》第52条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">__weak id weakSelf = self;</span><br><span class="line">NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer *timer) &#123;</span><br><span class="line">NSLog(@&quot;block %@&quot;,weakSelf);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@implementation NSTimer(BlockTimer)</span><br><span class="line">+ (NSTimer*)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats blockTimer:(void (^)(NSTimer *))block&#123;</span><br><span class="line">NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:interval target:self selector:@selector(timered:) userInfo:[block copy] repeats:repeats];</span><br><span class="line">return timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)timered:(NSTimer*)timer &#123;</span><br><span class="line">void (^block)(NSTimer *timer)  = timer.userInfo;</span><br><span class="line">block(timer);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意当repeats=NO时执行完定时任务，会自动执行invalidate操作，即不会有循环引用</p>
</li>
</ul>
<h4 id="1-5-销毁NSTimer"><a href="#1-5-销毁NSTimer" class="headerlink" title="1.5 销毁NSTimer"></a>1.5 销毁NSTimer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)invalidateTimer &#123;</span><br><span class="line">[_timer invalidate];</span><br><span class="line">_timer = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-6-立即执行"><a href="#1-6-立即执行" class="headerlink" title="1.6 立即执行"></a>1.6 立即执行</h4><ul>
<li>NSTimer无论是循环repeats=YES，还是延迟repeats=NO，第一次调用都是X时间后，如果想立即执行，可采用fire方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_timer fire];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-7-创建和销毁要在同一线程"><a href="#1-7-创建和销毁要在同一线程" class="headerlink" title="1.7 创建和销毁要在同一线程"></a>1.7 创建和销毁要在同一线程</h4><ul>
<li>因为创建Timer要把Timer加入到该线程对应的RunLoop中，故在同一个线程中才能cancel这个Timer<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 创建</span><br><span class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];</span><br><span class="line">[thread start];</span><br><span class="line">- (void)newThread &#123;</span><br><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line">_timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(addTime) userInfo:nil repeats:YES];</span><br><span class="line">// 即便是scheduledTimerWith方法也需手动加入runloop</span><br><span class="line">[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">// 子线程需手动开启runloop</span><br><span class="line">[[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 销毁</span><br><span class="line">[self performSelector:@selector(invalidateTimer) onThread:thread withObject:nil waitUntilDone:YES];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-CADisplayLink"><a href="#2-CADisplayLink" class="headerlink" title="2 CADisplayLink"></a>2 CADisplayLink</h3><ul>
<li>CADisplayLink是用于同步屏幕刷新频率的计时器，ios都是60hz，即每秒60次回调selector，回调频率通过frameInterval属性设置，CADisplayLink的selector每秒调用次数=60/frameInterval</li>
<li>精准度比较高,但并不保证都是60hz的刷新频率，例如主线程卡顿</li>
</ul>
<h4 id="2-1-重要属性介绍"><a href="#2-1-重要属性介绍" class="headerlink" title="2.1 重要属性介绍"></a>2.1 重要属性介绍</h4><ul>
<li>frameInterval 标识间隔多少帧调用一次selector方法，默认值是1，即每帧都调用一次。官方文档中强调，当该值被设定小于1时，结果是不可预知的。</li>
<li>duration 表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在target的selector被首次调用以后才会被赋值。selector的调用间隔时间计算方式是：时间=duration×frameInterval。</li>
<li>timestamp 当前帧的时间戳</li>
</ul>
<h4 id="2-2-示例"><a href="#2-2-示例" class="headerlink" title="2.2 示例"></a>2.2 示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) CADisplayLink* displayLink;</span><br><span class="line"></span><br><span class="line">- (void)startDisplayLink &#123;</span><br><span class="line">_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkProc)];</span><br><span class="line">[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopDisplayLink &#123;</span><br><span class="line">[_displayLink setPaused:YES];</span><br><span class="line">[_displayLink removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">[_displayLink invalidate];</span><br><span class="line">_displayLink = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)displayLinkProc &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-GCD实现timer"><a href="#3-GCD实现timer" class="headerlink" title="3 GCD实现timer"></a>3 GCD实现timer</h3><ul>
<li><p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) dispatch_source_t countDownTimer;</span><br><span class="line">// 开启timer</span><br><span class="line">- (void)startTimer &#123;</span><br><span class="line">if (!_timer) &#123;</span><br><span class="line">// 设置时间间隔，每秒执行</span><br><span class="line">NSTimeInterval period = 1.0;</span><br><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">/*</span><br><span class="line">dispatch_walltime 可以让计时器按照真实时间间隔进行计时，但使用dispatch_time 或者 DISPATCH_TIME_NOW 时当系统休眠的时候计时器会停止</span><br><span class="line">*/ </span><br><span class="line">dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), period * NSEC_PER_SEC, 0);</span><br><span class="line">/*</span><br><span class="line">dispatch_source_set_event_handler 这个函数在执行完之后，block 会立马执行一遍,相当于NSTimer fire</span><br><span class="line">*/ </span><br><span class="line">dispatch_source_set_event_handler(_timer, ^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;);</span><br><span class="line">dispatch_resume(_timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 关闭timer</span><br><span class="line">- (void)stopTimer &#123;</span><br><span class="line">if (_timer) &#123;</span><br><span class="line">dispatch_source_cancel(_timer);</span><br><span class="line">_timer = nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意挂起后不得释放timer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_suspend(_timer);</span><br><span class="line">_timer = nil; // EXC_BAD_INSTRUCTION 崩溃</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://skyline75489.github.io/post/2016-7-19_dispatch_source_timer_intro.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">参考</a></p>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/03/30/定时器/" data-id="ckd90jon8008exc514ntfy3q8" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-解决快速push的崩溃" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/03/06/解决快速push的崩溃/">解决快速push的崩溃</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/03/06/解决快速push的崩溃/" class="article-date">
  <time datetime="2016-03-06T10:14:18.000Z" itemprop="datePublished">2016-03-06</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ul>
<li>Crash详情：Can’t add self as subview crash</li>
<li><p>原理就是当前有跳转动画就抛弃其它VC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@implementation NSObject (Hook)</span><br><span class="line"></span><br><span class="line">#pragma mark hook</span><br><span class="line"></span><br><span class="line">+ (void)hookWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">Class class = [self class];</span><br><span class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">originalSelector,</span><br><span class="line">method_getImplementation(swizzledMethod),</span><br><span class="line">method_getTypeEncoding(swizzledMethod));</span><br><span class="line">if (didAddMethod) &#123;</span><br><span class="line">class_replaceMethod(class,</span><br><span class="line">swizzledSelector,</span><br><span class="line">method_getImplementation(originalMethod),</span><br><span class="line">method_getTypeEncoding(originalMethod));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>UINavigationController &amp; UIViewController</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UINavigationController+Safely.h&quot;</span><br><span class="line">#import &quot;NSObject+Hook.h&quot;</span><br><span class="line"></span><br><span class="line">static char const * const kViewTransitionInProgress = &quot;kViewTransitionInProgress&quot;;</span><br><span class="line"></span><br><span class="line">@implementation UINavigationController (Safely)</span><br><span class="line"></span><br><span class="line">- (void)setViewTransitionInProgress:(BOOL)property &#123;</span><br><span class="line">NSNumber *number = [NSNumber numberWithBool:property];</span><br><span class="line">objc_setAssociatedObject(self, kViewTransitionInProgress, number , OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)viewTransitionInProgress &#123;</span><br><span class="line">NSNumber *number = objc_getAssociatedObject(self, kViewTransitionInProgress);</span><br><span class="line">return [number boolValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(pushViewController:animated:) swizzledSelector:@selector(safe_PushViewController:animated:)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(popViewControllerAnimated:) swizzledSelector:@selector(safe_PopViewControllerAnimated:)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(popToViewController:animated:) swizzledSelector:@selector(safe_PopToViewController:animated:)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(popToRootViewControllerAnimated:) swizzledSelector:@selector(safe_PopToRootViewControllerAnimated:)];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - hookSelecter</span><br><span class="line"></span><br><span class="line">- (NSArray *)safe_PopToRootViewControllerAnimated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (animated) &#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">NSArray *VCArray = [self safe_PopToRootViewControllerAnimated:animated];</span><br><span class="line">if (VCArray.count == 0) &#123;</span><br><span class="line">self.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">return VCArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSArray *)safe_PopToViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (animated)&#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">NSArray *VCArray = [self safe_PopToViewController:viewController animated:animated];</span><br><span class="line">if (VCArray.count == 0) &#123;</span><br><span class="line">self.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">return VCArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIViewController *)safe_PopViewControllerAnimated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress) &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">if (animated) &#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">UIViewController *VC = [self safe_PopViewControllerAnimated:animated];</span><br><span class="line">if (VC == nil) &#123;</span><br><span class="line">self.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">return VC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safe_PushViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;</span><br><span class="line">if (self.viewTransitionInProgress == NO) &#123;</span><br><span class="line">[self safe_PushViewController:viewController animated:animated];</span><br><span class="line">if (animated) &#123;</span><br><span class="line">self.viewTransitionInProgress = YES;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Safely)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">method_exchangeImplementations(class_getInstanceMethod(self, @selector(safe_ViewDidAppear:)),</span><br><span class="line">class_getInstanceMethod(self, @selector(viewDidAppear:)));</span><br><span class="line">method_exchangeImplementations(class_getInstanceMethod(self, @selector(safe_ViewDidDisappear:)),</span><br><span class="line">class_getInstanceMethod(self, @selector(viewDidDisappear:)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safe_ViewDidAppear:(BOOL)animated &#123;</span><br><span class="line">if (self.navigationController) &#123;</span><br><span class="line">self.navigationController.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">[self safe_ViewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)safe_ViewDidDisappear:(BOOL)animated &#123;</span><br><span class="line">if (self.navigationController) &#123;</span><br><span class="line">self.navigationController.viewTransitionInProgress = NO;</span><br><span class="line">&#125;</span><br><span class="line">[self safe_ViewDidDisappear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/03/06/解决快速push的崩溃/" data-id="ckd90joof00b8xc51441jyhq2" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-NSDate使用" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/02/25/NSDate使用/">NSDate使用</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/02/25/NSDate使用/" class="article-date">
  <time datetime="2016-02-25T10:14:18.000Z" itemprop="datePublished">2016-02-25</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;今天开发时遇到需要获取当前是星期几的需求！虽然NSDate经常在用，但这个需求确实不知道，百度了一下，其实挺简单！顺便总结一下NSDate的使用，于是乎又水了一篇</p>
<h3 id="1-概念理解"><a href="#1-概念理解" class="headerlink" title="1 概念理解"></a>1 概念理解</h3><ul>
<li>NSDate获取的都是当前机器的时间，用户是可以改的！NSDate所获取到的时间, 都是相对于GMT的, 即格林威治标准时间</li>
</ul>
<h4 id="1-1-时区问题"><a href="#1-1-时区问题" class="headerlink" title="1.1 时区问题"></a>1.1 时区问题</h4><ul>
<li><p>当前时区的时间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 零时区时间</span><br><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">// 如果没有指定NSDateFormatter的时区，NSDateFormatter默认是当前时区的时间</span><br><span class="line">NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSString *time = [dateFormat stringFromDate:date];</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定时区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NSDate *date = [NSDate date];</span><br><span class="line">NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];</span><br><span class="line">[dateFormat setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;];</span><br><span class="line">NSLog(@&quot;系统时区：%@&quot;, [NSTimeZone systemTimeZone]);</span><br><span class="line">dateFormat.timeZone = [NSTimeZone timeZoneWithName:@&quot;Asia/Shanghai&quot;];</span><br><span class="line">// 还可用GMT+0800 加8小时, GMT-0800减8小时来表示</span><br><span class="line">//    dateFormat.timeZone =  [NSTimeZone timeZoneWithName:@&quot;GMT+0800&quot;];</span><br><span class="line">// 相对0时区的 秒 数</span><br><span class="line">//    dateFormat.timeZone = [NSTimeZone timeZoneForSecondsFromGMT:28800];</span><br><span class="line">NSString *time = [dateFormat stringFromDate:date];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-2-时间比较"><a href="#1-2-时间比较" class="headerlink" title="1.2 时间比较"></a>1.2 时间比较</h4><ul>
<li>唯一需要注意的：需要转化为同一时区，不同时区时间比价没有意义<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSDate *)earlierDate:(NSDate *)anotherDate;</span><br><span class="line">- (NSDate *)laterDate:(NSDate *)anotherDate;</span><br><span class="line">- (NSComparisonResult)compare:(NSDate *)other;</span><br><span class="line">- (BOOL)isEqualToDate:(NSDate *)otherDate;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="1-3-timeIntervalSinceXXX"><a href="#1-3-timeIntervalSinceXXX" class="headerlink" title="1.3 timeIntervalSinceXXX"></a>1.3 timeIntervalSinceXXX</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 以下三个方法默认都是0时区时间，中国要 + 8个小时</span><br><span class="line">// 自2001年1月1日晚上12点</span><br><span class="line">NSDate *date1 = [NSDate dateWithTimeIntervalSinceReferenceDate:0];</span><br><span class="line">// 自19070年1月1日晚上12点</span><br><span class="line">NSDate *date2 = [NSDate dateWithTimeIntervalSince1970:0];</span><br><span class="line">// now</span><br><span class="line">NSDate *date3 = [NSDate dateWithTimeIntervalSinceNow:0];</span><br></pre></td></tr></table></figure>
<h3 id="2常见用法"><a href="#2常见用法" class="headerlink" title="2常见用法"></a>2常见用法</h3><h4 id="2-1-NSDate与NSString转化"><a href="#2-1-NSDate与NSString转化" class="headerlink" title="2.1 NSDate与NSString转化"></a>2.1 NSDate与NSString转化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// NSDateFormatter是线程安全的，而且使用起来开销非常大，故可以只初始化一次即可</span><br><span class="line">static NSDateFormatter *dateFormatter = nil;</span><br><span class="line">NSDateFormatter *shareDateFormatter() &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">dateFormatter = [[NSDateFormatter alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return dateFormatter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation NSDate (String)</span><br><span class="line"></span><br><span class="line">- (NSString *)dateStringWithFormat:(NSString *)format &#123;</span><br><span class="line">[shareDateFormatter() setDateFormat:format];</span><br><span class="line">return [shareDateFormatter() stringFromDate:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSString (Date)</span><br><span class="line"></span><br><span class="line">- (NSDate *)dateWithFormat:(NSString *)format &#123;</span><br><span class="line">[getDateFormatter() setDateFormat:format];</span><br><span class="line">return [getDateFormatter() dateFromString:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://stackoverflow.com/questions/24777496/how-can-i-convert-string-date-to-nsdate?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/24777496/how-can-i-convert-string-date-to-nsdate?r=SearchResults</a></li>
</ul>
<h4 id="2-2-现在是星期几"><a href="#2-2-现在是星期几" class="headerlink" title="2.2 现在是星期几"></a>2.2 现在是星期几</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">+ (NSDateComponents *)dateComponentsFromDate:(NSDate* )date&#123;</span><br><span class="line">NSDateComponents *components = [[NSDateComponents alloc] init];</span><br><span class="line">// 可获得很多信息，自己看吧</span><br><span class="line">NSInteger unitFlags = NSCalendarUnitYear | NSCalendarUnitMonth | NSCalendarUnitDay |  NSCalendarUnitWeekday | NSCalendarUnitWeekOfMonth | NSCalendarUnitWeekOfYear;</span><br><span class="line">NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">calendar.locale = [[NSLocale alloc] initWithLocaleIdentifier:@&quot;zh_CN&quot;];</span><br><span class="line">components = [calendar components:unitFlags fromDate:date];</span><br><span class="line">return components;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意在西方周日是第一天</span><br><span class="line">+ (NSString *)getWeekDayFromDateComponents:(NSDateComponents *) comps&#123;</span><br><span class="line">NSString *weekDayStr = @&quot;&quot;;</span><br><span class="line">switch ([comps weekday]) &#123;</span><br><span class="line">case 1:</span><br><span class="line">weekDayStr = @&quot;周日&quot;;</span><br><span class="line">break;</span><br><span class="line">case 2:</span><br><span class="line">weekDayStr = @&quot;周一&quot;;</span><br><span class="line">break;</span><br><span class="line">case 3:</span><br><span class="line">weekDayStr = @&quot;周二&quot;;</span><br><span class="line">break;</span><br><span class="line">case 4:</span><br><span class="line">weekDayStr = @&quot;周三&quot;;</span><br><span class="line">break;</span><br><span class="line">case 5:</span><br><span class="line">weekDayStr = @&quot;周四&quot;;</span><br><span class="line">break;</span><br><span class="line">case 6:</span><br><span class="line">weekDayStr = @&quot;周五&quot;;</span><br><span class="line">break;</span><br><span class="line">case 7:</span><br><span class="line">weekDayStr = @&quot;周六&quot;;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">return weekDayStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://stackoverflow.com/questions/3694867/nsdate-get-year-month-day?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/3694867/nsdate-get-year-month-day?r=SearchResults</a></li>
</ul>
<h4 id="2-3-获取当前时间若干年、月、日之后的时间"><a href="#2-3-获取当前时间若干年、月、日之后的时间" class="headerlink" title="2.3  获取当前时间若干年、月、日之后的时间"></a>2.3  获取当前时间若干年、月、日之后的时间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (NSDate *)dateWithFromDate:(NSDate *)date years:(NSInteger)years months:(NSInteger)months days:(NSInteger)days&#123;</span><br><span class="line">NSDate  * latterDate;</span><br><span class="line">if (date) &#123;</span><br><span class="line">latterDate = date;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">latterDate = [NSDate date];</span><br><span class="line">&#125;</span><br><span class="line">NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</span><br><span class="line">NSDateComponents *comps = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay|NSCalendarUnitHour|NSCalendarUnitMinute</span><br><span class="line">fromDate:latterDate];</span><br><span class="line"></span><br><span class="line">[comps setYear:years];</span><br><span class="line">[comps setMonth:months];</span><br><span class="line">[comps setDay:days];</span><br><span class="line"></span><br><span class="line">return [calendar dateByAddingComponents:comps toDate:latterDate options:0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://stackoverflow.com/questions/5067785/how-do-i-add-1-day-to-an-nsdate?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/5067785/how-do-i-add-1-day-to-an-nsdate?r=SearchResults</a></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html" target="_blank" rel="noopener">https://www.cnblogs.com/wayne23/archive/2013/03/25/2981009.html</a></li>
<li><a href="https://stackoverflow.com/questions/5965044/how-to-compare-two-nsdates-which-is-more-recent/5965106?r=SearchResults#5965106" target="_blank" rel="noopener">https://stackoverflow.com/questions/5965044/how-to-compare-two-nsdates-which-is-more-recent/5965106?r=SearchResults#5965106</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/02/25/NSDate使用/" data-id="ckd90jokz002lxc514anqqvgc" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-创业36条军规" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/02/01/创业36条军规/">创业36条军规</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/02/01/创业36条军规/" class="article-date">
  <time datetime="2016-02-01T10:14:18.000Z" itemprop="datePublished">2016-02-01</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="军规1-不是每个人都适合创业"><a href="#军规1-不是每个人都适合创业" class="headerlink" title="军规1 不是每个人都适合创业"></a>军规1 不是每个人都适合创业</h4><ul>
<li>创业很难，成功者寥寥无几！就像俞敏洪说的，很多人死在了第二天晚上</li>
<li>创业是做未知的事，不可能出发前就想清楚所有的事，创业者需要在前进的过程中随机应变</li>
<li>创业路上，最常见的不是成功或失败，而是长时间的苦苦挣扎</li>
<li>创业的机会成本很高，开始创业之前一定要认清自己，战略规划在前</li>
<li>创业者要过非人的生活</li>
<li>创业者的时间表上没有生活时间</li>
<li>创业者要给所有人交代！必须承担所有的责任，很简单因为没得选！但请记住没有选择往往是最好的选择</li>
<li>只有不到十分之一的人适合创业</li>
<li>打工和创业所需能力不一样</li>
<li>领军人物应具备4个素质：1、目标高远，意志坚定；2、心胸开阔，情商要高；3、企业利益放第一位；4、学习能力强，爱学习而且会学习</li>
<li>创业者应具备4个素质：1、事业心，是否把企业当做命根子来做；2、眼光和境界，要比别人想得多，要比别人看得远；3、心理素质，能否百折不挠处变不惊；4、学习能力。是否已学习为生活方式，有无及时复盘的习惯</li>
<li>接受正规的职业化训练是非常必要的。</li>
</ul>
<h4 id="军规2-梦想是唯一的创业理由"><a href="#军规2-梦想是唯一的创业理由" class="headerlink" title="军规2 梦想是唯一的创业理由"></a>军规2 梦想是唯一的创业理由</h4><ul>
<li>创业就是一个逐梦的过程</li>
<li>人的时间是有限的，所以不要按照别人的意愿去活，这是浪费时间！做你想做的事！</li>
<li>拒绝行尸走肉，人的梦想是不会终结的</li>
<li>越是被别人嘲笑的梦想，越有实现的价值！</li>
<li>创业是一个不断试错的过程</li>
<li>一切都是未知的，比的是耐力、智慧和运气，这也正是创业的魅力所在</li>
<li>坚持与放弃，源于战略规划、战术智慧和冷静决断的结合！优柔寡断不可取，刚愎自用更不可取</li>
<li>创业没什么高不可攀</li>
<li>创业并不神秘也不高不可攀，只是一个生活方式</li>
<li>不要想得太复杂，也不用给自己界定太明确是具体成功时点，只是拼尽全力去做</li>
<li>早开始一点没坏处，不要幻想把一切都准备好再出发，因为你永远都准备不完，创业是一步一步干出来的，不是想出来的</li>
<li>关于创业的三个错误观念</li>
<li>不要把上市当做创业目标，实际上99%的企业上不了市，还有很多企业根本不适合上市</li>
<li>不要有为了就业而创业的思想。就业 = 安逸，创业就要做好思想准备</li>
<li>不要为了那些美丽的大道理去创业。那是“果”，不是“因”</li>
</ul>
<h4 id="军规3-学先进，傍大款，走正道"><a href="#军规3-学先进，傍大款，走正道" class="headerlink" title="军规3 学先进，傍大款，走正道"></a>军规3 学先进，傍大款，走正道</h4><ul>
<li>创业必须走正道</li>
<li>要善于向优秀的同行学习，要追求与强者合作，要坚守规范经营的原则。投机取巧看似占便宜，实则吃大亏，出来混早晚是要换的</li>
<li>有所为，有所不为，是为有为</li>
<li>对手不正当竞争，不等于你也可以不正当竞争。面对对手死缠烂打，第一要淡定，要冷静应付，不能自乱阵脚；第二，多做实事反击是在市场上，能不说就不说，能少说就少说，不得不说的时候要高举用户利益的大旗，重复正确的话，不回应攻击者，也不反击攻击者，切记言多必失，对攻击者的蔑视是最好的反击，切记不要去争论和回应对方的具体问题。最后坚持桌面上出牌</li>
<li>学先进要全盘学习</li>
<li>坚守自己的道德底线</li>
<li>学先进必须要先僵化，再固化，再优化。国情不同我们是特殊的，这绝对是个陷阱；绝大多数的事，绝大多数时候，没有谁特殊！进步的捷径就是直接学习那些已经成功的企业和人，学习他们已经被验证了的行之有效的方法！落后的组织，落后的人怎么会有水平判断先进方法的对错？所以必须先僵化的学习，教条似的做，等做熟练了，再坐下来复盘研究是否有优化之处</li>
<li>傍大款不是靠大款</li>
<li>和好的最强者合作发展，好处多多！正向激励 + 资源保证 + 流程优化 等等</li>
<li>傍大款是为了提升自己，互惠互利</li>
</ul>
<h4 id="军规4-创新是最好的武器"><a href="#军规4-创新是最好的武器" class="headerlink" title="军规4 创新是最好的武器"></a>军规4 创新是最好的武器</h4><ul>
<li>伟大不是模仿来的</li>
<li>再小的创新，再小的分支细节，放到14亿人口里都是一个非常可观的成功</li>
<li>模仿是不是成功的捷径！即便复制美国创新东西，也要先跟踪先复制，最后还要本土化创新</li>
<li>小公司尤其不可能通过模仿生存。大公司对市场的反应必然会慢半拍，小公司必须敢于冒险，勇于创新，快速反应才有机会。只有差异化才有市场空间</li>
<li>个人认为：模仿就是copy，因为很多差异化都体现在很小的细节</li>
<li>只有创新才有机会</li>
<li>每个成功的企业都是一系列创新的结果。做企业就是两件事–创新和营销。创新分为两类，一类发现新大陆，一类打破常规</li>
<li>企业的每个角落都需要不断地创新。产品创新很重要，但并不是企业创新的全部，这是每个创业者必须明确的理念。</li>
<li>一把手要为创新构建一个环境</li>
<li>创新者一定是少数派，会遭到大多数普通人的质疑；创新必然会经过艰难的探索，甚至不断地失败；创新会触犯很多既得利益者或市场领先者。这些都决定了创新是很艰难的，而这也正式创新的意义所在</li>
</ul>
<h4 id="军规5-放下身段死缠烂打"><a href="#军规5-放下身段死缠烂打" class="headerlink" title="军规5 放下身段死缠烂打"></a>军规5 放下身段死缠烂打</h4><ul>
<li>每一个成功都是拼出来的</li>
<li>成功有规律，走正道、创新和死缠烂打这三个普世成立的真理，可以帮助你更好的成功</li>
<li>成功者不找借口！逮住机会就死缠烂打，别太把自己当回事！成功者该放下身段时都能放下身段，放下身段从最基础的业务做起！对于创业公司，最基础的业务是最迫切的业务</li>
<li>成功者都善于调整自己的心态；他们往往缺乏过程感，急躁冒进，幻想一夜成功，把小公司当大公司来做，过分关注战略，规划，制度，流程等大公司的东西，提高了成本又降低了效率</li>
<li>成功者都有极强的意志力，再难也能咬牙扛过去！（可怜我总嚷嚷怕什么天塌下来大不了用脑袋顶着）</li>
<li>成功者风光的背后是和你一样的坎坷，都是雨里泥里爬出来的，只是你没有看到</li>
<li>伟大都是熬出来的</li>
<li>剩者为王，俞敏洪说很多人都死在了第二天晚上！所以首先要活下去，慢慢熬</li>
<li>成功的关键在于多坚持5分钟！你筋疲力尽时也是对手筋疲力尽的时候，虽然对手表面装的不累！</li>
<li>把每个机会都当做最后一根稻草才能成功</li>
<li>机会太多的人往往不容易成功，因为他们很容易放弃，遇阻则推，不愿坚持，心想反正还有下一个机会！ </li>
<li>成功与否主要还是看自己！不否认客观因素存在，那是事实，你没得选，唯一能做的就是想尽办法去克服</li>
</ul>
<h4 id="军规6-凡事只能靠自己"><a href="#军规6-凡事只能靠自己" class="headerlink" title="军规6 凡事只能靠自己"></a>军规6 凡事只能靠自己</h4><ul>
<li>任何时候创始人都不能放弃</li>
<li>创始人别无退路：凡事只能靠自己，万事皆有解且有唯一正解，凡是你担心的事一定会发生，享受创业过程</li>
<li>创业初期最难的三件事只能靠创始人自己</li>
<li>三座大山基本上只能靠你自己爬：找方向，找人和找钱</li>
<li>自己不会做的事不要指望下属创造惊喜</li>
<li>不是说创始人不需要合伙人、团队，而是说所有结果都由你自己负全责，所以你只能靠自己做决定</li>
<li>不要指望别人来救你</li>
<li>顾问公司只能帮锦上添花的忙</li>
<li>随时准备自救才能长命百岁，所有人都喜欢锦上添花，如果你自己都不竭尽全力，别人更不会伸出援手</li>
<li>不能以授权为名推卸自己的责任</li>
</ul>
<h4 id="军规7-领导要有预见性"><a href="#军规7-领导要有预见性" class="headerlink" title="军规7 领导要有预见性"></a>军规7 领导要有预见性</h4><ul>
<li>预见未来是领军者的责任</li>
<li>只有预见未来才能做对的事，对未来预见的越早越清晰，你就越可能做正确的事。永远要比别人多思考一点，永远要做好最坏的打算、最全面的准备</li>
<li>只有预见未来才能走的更远，要站得高，看得远还要理的清！要留意新兴事务，要开阔眼界还要跳出具体业务细节看事情的能力</li>
<li>早做布局，早5分钟行动</li>
<li>快速决策，快速行动。要善于决断，敢于取舍！问题不会自己解决，“拖”着只能让事变的更糟 - 早做布局。居安思危，早作打算！先发优势不容小觑！</li>
<li>留两分余力，随时准备自救</li>
<li>任何时候都不要孤注一掷！赌博中输的最惨的就是拼一把</li>
<li>越是顺风顺水，越要警惕。越要克制冲动和贪婪，睡觉都得睁半只眼！</li>
</ul>
<h4 id="军规8-心力强大者胜"><a href="#军规8-心力强大者胜" class="headerlink" title="军规8 心力强大者胜"></a>军规8 心力强大者胜</h4><ul>
<li>所有的比拼最终都是精神的比拼，必须拥有强大的心理素质和自我复盘学习的能力</li>
<li>什么奇迹都可能出现，前提是你不能认输！</li>
<li>创业者要不断强大自己的心力！凡是不能消灭你的，都只能让你变得更强！</li>
<li>领导者必须树立远大的理想！记住取法其上，得乎其中</li>
<li>创始人必须志存高远，有远大的理想且意志坚定，要知道绝大多数人是没有主意的！</li>
<li>远大理想是鼓舞团队奋斗的动力！没有理想的队伍就是一盘散沙</li>
<li>领导者必须有必胜的信念</li>
<li>必胜的信念是创业者最宝贵的品质。你都不能破釜沉舟必胜而还的信念，下属为什么要跟着你？再说你的极限也是对手的极限，成功往往在于多坚持5分钟</li>
<li>只要肉体没被消灭，精神就不应该垮掉！必须的有股子狠劲！</li>
</ul>
<h4 id="军规9-要敢于冒险"><a href="#军规9-要敢于冒险" class="headerlink" title="军规9 要敢于冒险"></a>军规9 要敢于冒险</h4><ul>
<li>有五成把握就要开始行动</li>
<li>敢于打破常规才有机会！敢于质疑，敢于说不，敢于行动！</li>
<li>所有的成功都是突破常规的结果。天鹅肉从来都是被第一个敢张嘴的蛤蟆吃掉的。现实生活中，绝大多数的雷池是我们自己想象出来的！</li>
<li>敢于冒险才有胜机</li>
<li>成功总是青睐那些具有探险精神的人，宁愿失败也不要平庸！</li>
<li>小公司只能靠冒险寻求生存空间</li>
<li>大公司必须以规避风险为主，追求稳步发展少犯错</li>
<li>我们失去的只是锁链，一旦成功，我们获得的将是整个世界</li>
</ul>
<h4 id="军规10-相信直觉"><a href="#军规10-相信直觉" class="headerlink" title="军规10 相信直觉"></a>军规10 相信直觉</h4><ul>
<li>与直觉相悖的事不要干</li>
<li>根据直觉先做一个大胆假设，然后小心求证</li>
<li>别人的建议尤其是具体建议要慎听，永远不要用集体决策代替自己的决策</li>
<li>建议和经验要贴合自身实际而慎重选择</li>
<li>直觉是上天赐给创业者的礼物</li>
<li>大胆假设，小心求证。</li>
</ul>
<h4 id="军规11-创业要靠团队"><a href="#军规11-创业要靠团队" class="headerlink" title="军规11 创业要靠团队"></a>军规11 创业要靠团队</h4><ul>
<li>一个人包打天下的时代已经过去了</li>
<li>创业需要一个团队，一个志同道合、优势互补、紧密配合、把公司当做命根子 </li>
<li>团队强大才能打胜仗</li>
<li>没有合适的人做“1”，再多的“0”也没用！管理者的能力是找到对的人</li>
<li>每个团队都有基因。扩张新业务需要新基因</li>
<li>建立高效的团队：1，头是唯一的；2，组织结构要清晰；3，令行禁止；4，个人利益服从整体利益；5，互相补台</li>
<li>团队要协同作战：1，共同的愿景和价值观；2，彼此信任；3，注重沟通技巧</li>
<li>需要主次配合，主动去理解领导意图，积极去贯彻领导意图，是团队成员素质基础！领导对错，小兵说了不算，那还不如提高执行力</li>
<li>团队必须有唯一的“头”儿</li>
<li>必须有领导者，否则就是一盘散沙，领军人物的威信只能在战斗中形成 </li>
</ul>
<h4 id="军规12-干部要靠自己培养"><a href="#军规12-干部要靠自己培养" class="headerlink" title="军规12 干部要靠自己培养"></a>军规12 干部要靠自己培养</h4><ul>
<li>下决心自己培养干部</li>
<li>培养干部是革命的首要问题！提拔个排长当团长，也比空降个师长当团长好！外来的和尚未必会念经！</li>
<li>人才标准需要一把手亲自制定，优秀干部标准：1，理解上意；2，有意见和见解可以表达，但一旦做了决策，就必须马上忘记自己的分歧，坚决彻底的贯彻决议；3，做任何一件事，都要和上级明晰目标、结构规划和里程碑，宁可不做，不要做错；4，及时汇报，多汇报没坏处</li>
<li>建立起人才的培养机制， 企业选材标准：1，悟性，能举一反三分析出事物的本质；2，心胸宽广；3，有大局观；4，学习能力强，勤于思考，逻辑清楚，善于归纳总结提炼 </li>
<li>创业不要用职业经理人</li>
<li>职业经理人是创业公司的天敌。职业经理人注定短视，注重流程且道德堪忧，再苦再难也不要请！</li>
<li>慎用空降兵</li>
<li>空降兵的误区：1，如果真厉害早就自己干了，为啥给你干；2，和你的基因不一定相符，且不一定接受低的职位；3，他的经验不一定有用，反而可能有害；4，外来的和尚未必会念你的经，未必会执着的念你的经</li>
<li>空降兵尤其不适合创业期</li>
</ul>
<h4 id="军规13-选对股东"><a href="#军规13-选对股东" class="headerlink" title="军规13 选对股东"></a>军规13 选对股东</h4><ul>
<li>股东对企业至关重要</li>
<li>股东是企业的基因，慎重选择，优劣势是啥？ </li>
<li>企业要处理好三个圈子：股东圈、员工圈和朋友圈</li>
<li>企业垮掉一半以上是因为股东问题</li>
<li>股东有问题企业很难持久，股东常常是可以共患难不可以共富贵</li>
<li>如何选择股东？1，志同道合；2，认同合体规则；3，出资，不要给干股；4，优先选择有资源有经验的</li>
<li>创业者选股东的四个误区：1，用股份来激励员工；2，让短期能帮上忙的朋友成功股东；3，让亲朋好友当股东；4，吸收不好的“战略投资者”</li>
</ul>
<h4 id="军规14-搭好治理结构"><a href="#军规14-搭好治理结构" class="headerlink" title="军规14 搭好治理结构"></a>军规14 搭好治理结构</h4><ul>
<li>企业的治理结构很关键</li>
<li>两个核心问题：1，公司股东的构成及其相互比例关系；2，董事会和管理层之间的权利分配</li>
<li>治理结构有问题公司很难成功</li>
<li>企业必须有主人</li>
<li>股东层面，企业要有大股东</li>
<li>经营层面，管理层必须有“主人翁”意识，可以给股权，也可给激励</li>
<li>理想的股东结构是怎样的？</li>
</ul>
<h4 id="军规15-事先要签股东协议"><a href="#军规15-事先要签股东协议" class="headerlink" title="军规15 事先要签股东协议"></a>军规15 事先要签股东协议</h4><ul>
<li>定好规则才能合作长久</li>
<li>认可规则和遵守规则是成为股东的前提。先小人后君子，规则一定要说出来</li>
<li>股东协议要约定哪些事？</li>
<li>约定股东义务，最好不要把业务对象发展为股东</li>
<li>约定退出机制。</li>
<li>约定决策机制。</li>
<li>约定公司方向</li>
</ul>
<h4 id="军规16-做最肥的市场"><a href="#军规16-做最肥的市场" class="headerlink" title="军规16 做最肥的市场"></a>军规16 做最肥的市场</h4><ul>
<li>选对创业方向最重要</li>
<li>正确的创业方向让你事半功倍！创业最常犯的错误是“会啥做啥”，最好是自己爱好、自己特长和用户需求三大因素的平衡点来创业</li>
<li>盯住用户的真需求</li>
<li>围绕用户需求创业，目标用户是谁？解决哪些痛点？学会取舍</li>
<li>区分真假需求。无关痛痒的和超出实际的都是假需求；创业者容易吧自己的爱好当做用户需求，把个别需求当普遍需求；有人需要你跟有市场是两回事</li>
<li>盯住最肥的市场</li>
<li>选择创业方向的原则：1，市场应该足够大，利用率应该足够高；2，事情本省应该是有意义的；3，事情应该是有所创新的</li>
<li>小池塘养不出大鱼；看五年，想三年，认认真真做好一两年</li>
</ul>
<h4 id="军规17-做减法"><a href="#军规17-做减法" class="headerlink" title="军规17 做减法"></a>军规17 做减法</h4><ul>
<li>成功是做了一件事。砍掉鸡肋项目，抓住用户的一个需求把它做到极致</li>
<li>遍地开花不可能成功。任何一个领域，只要深入进去都会发现机会遍地，但这只是表象！如果找不到切入点，形不成用户规模，哪个机会都是理论上的机会，形不成你的市场</li>
<li>做好一件事好过做了很多事</li>
<li>应该时刻提醒自己“做减法”，很多技术性企业都希望把产品的功能做到极致和全面，但想要打开市场，抓好一个点就够了！关键不在于技术上有多么高深，而在于你能不能解决用户的某个迫切需求</li>
<li>资源永远是稀缺的</li>
<li>天下没有免费的午餐！分配好有限的资源，聚焦聚焦再聚焦 </li>
<li>专注于一件事更容易成功</li>
<li>创业期企业要做到四个“最小”：1，只确定最关键点的战略，集中力量突破一点；2，只设最低限度指标，指标多重点必然分散，核心指标达成了其他指标自然合格；3，只用最不得不用的人，不胜任要换人而不是加人；4，只管到最低程度，给下属留出发展空间；</li>
</ul>
<h4 id="军规18-好的商业模式是成功的一半"><a href="#军规18-好的商业模式是成功的一半" class="headerlink" title="军规18 好的商业模式是成功的一半"></a>军规18 好的商业模式是成功的一半</h4><ul>
<li>商业模式是企业的核心</li>
<li>商业模式就是你的赚钱方式，核心四个问题：你的用户是谁？你为他们解决了什么问题？你用什么产品解决他们的问题？如何收费？</li>
<li>何为好的商业模式</li>
<li>好的商业模式特点：1，产品简单；2，前提要简单；3，一次创意型；4，可低成本扩张；5，要有一定的门槛</li>
<li>商业模式是否成立需要验证</li>
<li>尽早验证你的商业模式</li>
</ul>
<h4 id="军规19-集中兵力突破重点"><a href="#军规19-集中兵力突破重点" class="headerlink" title="军规19 集中兵力突破重点"></a>军规19 集中兵力突破重点</h4><ul>
<li>创业期公司要关注业务问题</li>
<li>在公司没有找到方向之前，公司的主要矛盾就是找方向</li>
<li>找到方向后先验证商业模式，再找到有效的业务推广方法。创业公司要抓开源而非节流，抓业务突破而非管理的规范化</li>
<li>突破重点才能解决问题</li>
<li>要想成功必须打赢“命运之战”，决定目标是否达成的一定是一两个关键项目，创业者需要学会舍得，必须保持头脑清醒，禁得住诱惑，时刻牢记你的主战场是什么</li>
<li>创业公司唯一的战略就是突破重点</li>
<li>找到突破点，突破突破点。创业头两年的公司不要考虑什么宏伟的战略规划，那东西只有坏处没有益处</li>
</ul>
<h4 id="军规20-先赚到钱再考虑发展"><a href="#军规20-先赚到钱再考虑发展" class="headerlink" title="军规20 先赚到钱再考虑发展"></a>军规20 先赚到钱再考虑发展</h4><ul>
<li>赢利的公司有的是发展机会。</li>
<li>要性感还是要赚钱？小钱都挣不了，怎么挣大钱！赚钱才是企业的头等大事</li>
<li>能赚钱和赚到钱是两码事。</li>
<li>烧钱的发展模式不可取</li>
<li>烧钱的发展模式是特例 </li>
<li>赚不赚钱是衡量公司好坏的第一标准</li>
<li>估值不是衡量公司好坏的核心标准。企业的核心价值是满足用户需求，为用户创造价值。 </li>
<li>赚钱的公司最优秀</li>
<li>公司初创时要有愿景，但是具体的伟大战略都是在公司在市场上站稳脚跟，衣食无忧后才规划的 </li>
</ul>
<h4 id="军规21-为公司找一个好的总经理"><a href="#军规21-为公司找一个好的总经理" class="headerlink" title="军规21 为公司找一个好的总经理"></a>军规21 为公司找一个好的总经理</h4><ul>
<li>好的总经理是成功的一半</li>
<li>每个伟大的企业都有一个伟大的总经理</li>
<li>不是每个人都适合当总经理，创始人如果不适合，最好三顾茅庐找到合适的总经理并让贤</li>
<li>创业公司的总经理必须是股东，因为屁股决定脑袋</li>
<li>总经理需要具备什么素质？</li>
<li>总经理要什么素质？1，有事业心；2，有战略水平；3，有胸怀；4，心理素质好；5，学习能力强</li>
<li>技术专家做总经理非常危险，技术专家易陷误区：1，技术自负，把技术等同于经营；2，藐视管理，崇尚自由，拒绝规范；3，独享心态，不认同产业链，妄图自己全部自力更生；4，拒绝授权，只愿意自己把握航向自己决策，不愿意授权</li>
<li>如何当总经理</li>
<li>总经理的职责：1，对行业的认知；2，打造企业文化；3，设计管理工具；4，建班子、定战略、带队伍；</li>
</ul>
<h4 id="军规22-企业文化必须一开始就建立：制度早建、规矩早定、丑话早说"><a href="#军规22-企业文化必须一开始就建立：制度早建、规矩早定、丑话早说" class="headerlink" title="军规22 企业文化必须一开始就建立：制度早建、规矩早定、丑话早说"></a>军规22 企业文化必须一开始就建立：制度早建、规矩早定、丑话早说</h4><ul>
<li>企业文化要尽早建立</li>
<li>没有好的企业文化就没有好的企业，企业文化包括企业的核心价值观、方法论以及战术原则</li>
<li>企业文化特征：1，为愿景使命服务的；2，是品牌的重要组成部分；3，因时而变，因势而变，与时俱进</li>
<li>生存重要还是文化重要？越是小公司、越是创业公司，越需要企业文化；你要带领一群人去未知的远方，人家凭什么？ </li>
<li>文化是企业战斗力的倍增器</li>
<li>核心价值观创造企业的凝聚力</li>
<li>方法论提升我们的工作能力。拉卡拉的方法论：先问目的，再做推演，亲自打样，及时复盘</li>
<li>战术原则提高我们的工作水平</li>
<li>企业文化需要大力宣传</li>
<li>提出来，明确价值观，并分解为易于理解和执行的几个角度</li>
<li>天天讲，</li>
<li>身体力行：1,企业和领导正在做什么？2，已经做了什么？3，怎么做的？4，未来要做什么</li>
</ul>
<h4 id="军规23-管理是一门专业"><a href="#军规23-管理是一门专业" class="headerlink" title="军规23 管理是一门专业"></a>军规23 管理是一门专业</h4><ul>
<li>没有人生来就是管理者</li>
<li>创业最大的难题是创始人不懂管理</li>
<li>管理方法的核心就是三大要素：建班子、定战略、带队伍</li>
<li>不同阶段的企业用不同的方法管理</li>
<li>创业期公司的关键是抓业务，最忌讳的就是小公司大做</li>
<li>小公司的6个管理天条：1，由点及面式定战略，执行战略不撞南墙不回头；2，跟我冲而不是给我上；3，只做最低限度的规范化管理，以奖惩分明作为管理核心；4，精兵简政，聚焦目标做减法，给精兵发一个半人的钱让他做两个人的事；5，老事定指标精细化管理，新事设目标鼓励试错；6，先打样再推广，打样不怕慢，推广必须快</li>
<li>大公司管人</li>
<li>大公司管理的核心是通过管人来管事</li>
<li>分权管理，授权的核心：授对人，授对事，授对法</li>
</ul>
<h4 id="军规24-建班子是管理的首要问题"><a href="#军规24-建班子是管理的首要问题" class="headerlink" title="军规24 建班子是管理的首要问题"></a>军规24 建班子是管理的首要问题</h4><ul>
<li>一个好汉三个帮</li>
<li>班子领导非常重要，领导班子的核心是一把手</li>
<li>建班子是管理的首要问题</li>
<li>如何建班子</li>
<li>班子成员需要什么素质？1，把公司当命根子做；2，身经百战，有把聪明转化为智慧的能力；3，互补和团结</li>
<li>建班子四部曲：选对人、定核心、塑文化、建机制</li>
<li>一把手建班子注意问题：1，避免一言堂；2，充分调动班子成员的积极性；3，班子的调整机制</li>
</ul>
<h4 id="军规25-坚持战略和定战略同样重要"><a href="#军规25-坚持战略和定战略同样重要" class="headerlink" title="军规25 坚持战略和定战略同样重要"></a>军规25 坚持战略和定战略同样重要</h4><ul>
<li>定战略意义重大，核心是确定打法和领军人物！</li>
<li>四不做：1，没有合适领军人物的项目不做；2，没有下决心死磕的项目不做；3，不掌握主动权的项目不做；4，无法复制的项目不做</li>
<li>如何定战略 </li>
<li>联想的战略七步法：1，设定愿景；2，设定战略目标；3，制定战略路线，要有清晰的打法；4，确定领军人物，千万不要“凑合”；5，战术分解，沙盘上推演不出的结果，实战中根本不可能达成；6，确定组织结构和预算；7，考核激励，及时复盘调整</li>
<li>执行战略的过程就是坚持战略的过程</li>
<li>经常复盘校正战略</li>
<li>撞了南墙再考虑调整战略</li>
</ul>
<h4 id="军规26-打造一支铁军"><a href="#军规26-打造一支铁军" class="headerlink" title="军规26 打造一支铁军"></a>军规26 打造一支铁军</h4><ul>
<li>带出一支铁军才能战无不胜</li>
<li>让员工“入模”</li>
<li>打胜仗只能靠我们自己的队伍，不要相信外来的和尚会念经，一定要清楚引入新人是对我们队伍的补充而非代替，引入新人必须要融入队伍。</li>
<li>选好材才能带好兵</li>
<li>“三心”用人标准，员工必须要有责任心，中层干部要有上进心，核心高管必须要有事业心 </li>
<li>什么样的人有潜力：事业心、有韧劲和善总结 </li>
<li>如何带队伍</li>
<li>建立有效的组织结构</li>
<li>建立管理模式，拉卡拉管理模式：设目标，做计划，抓考评和理规范</li>
<li>宣贯文化</li>
<li>建立培训体系</li>
</ul>
<h4 id="军规27-物质激励是第一位的"><a href="#军规27-物质激励是第一位的" class="headerlink" title="军规27 物质激励是第一位的"></a>军规27 物质激励是第一位的</h4><ul>
<li>人人都需要激励，都喜欢激励</li>
<li>多激励少惩罚。激励业务，惩治违规</li>
<li>公司必须建立起一套激励体系</li>
<li>比较通用的激励方法：中低级岗位现金激励，中高级岗位现金+期权，高级岗位期权激励</li>
<li>激励的三大误区</li>
<li>误区1，只讲物质激励，特别是只讲钱</li>
<li>误区2，学而优则仕式奖励，记住并不是所有人都有管理控制他人的能力和欲望</li>
<li>误区3，江湖式分配，记住革命不是靠自觉</li>
<li>激励的三大原则</li>
<li>公平是激励的第一原则，要杜绝大锅饭</li>
<li>红包式激励不可取，激励必须是可预见的，可计算的</li>
<li>激励必须和严格的目标考评配套</li>
<li>高效激励的4个原则</li>
<li>1，物质激励与精神激励相结合</li>
<li>2，当期激励与远期激励相结合，奖惩的时效性远比奖惩的力度更重要，远期激励可以增大员工的离职成本</li>
<li>3，现金激励与期权激励相结合</li>
<li>4，单场奖和连胜奖相结合</li>
</ul>
<h4 id="军规28-不要搞大跃进，大跃进的必然结果就是大倒退！"><a href="#军规28-不要搞大跃进，大跃进的必然结果就是大倒退！" class="headerlink" title="军规28 不要搞大跃进，大跃进的必然结果就是大倒退！"></a>军规28 不要搞大跃进，大跃进的必然结果就是大倒退！</h4><ul>
<li>成功没有捷径</li>
<li>做企业是跑长跑，要快速启动，迅速行动，但过程之中要一步一步来</li>
<li>创业者要有过程感，不要急于求成</li>
<li>俞永福的企业发展“三关”论</li>
<li>产品关，关注于产品本身，而不是技术深度或者营销策略！</li>
<li>市场关，要学会自己尝试，独自开创出一条适合自己的道路来</li>
<li>管理关，创业初期犯错成本不高，但随着业务发展，代价必然直线上升。因此企业必须建立相关的规范管理制度</li>
<li>企业发展速度要按经济规律来</li>
<li>革命晚成功半年又如何？任何时候做事的关键都是控制，让一切在你的控制之内比速度力度都重要，革命可以晚成功但不能翻车</li>
<li>出来混总是要还的。企业的发展速度并非越快越好</li>
</ul>
<h4 id="军规29-先试点再推广"><a href="#军规29-先试点再推广" class="headerlink" title="军规29 先试点再推广"></a>军规29 先试点再推广</h4><ul>
<li>推广前先试点</li>
<li>先试点，一般情况下试点要找一个有代表性的，但又不是主要市场的地方展开，核心是验证想法是否可行，拿出有说服力的数据来！不要认为自己是产品的用户！</li>
<li>榜样的力量是无穷的</li>
<li>营销的核心是找到推广方法</li>
<li>企业经营重在两件事：营销和创新</li>
<li>营销的核心是找到可复制的推广方法，特点：1，能够产生规模销量；2，简单且可复制；3，投入产出比合适</li>
<li>如何试点</li>
<li>一般而言试点目的：1，验证方法是否可行；2，抓数据，量化方案；3，写菜谱，形成手册，让所有的人可以复制</li>
<li>推广之前必须打样，方法：1，亲自抓；2，可复制；3，要抠细节；4，打样的过程要细；5，要写手册</li>
</ul>
<h4 id="军规30-坚持是必须的，维持是没有意义的"><a href="#军规30-坚持是必须的，维持是没有意义的" class="headerlink" title="军规30 坚持是必须的，维持是没有意义的"></a>军规30 坚持是必须的，维持是没有意义的</h4><ul>
<li>转型不是失败，为了维持的维持才是最大的失败</li>
<li>几乎所有的成功都历经磨难</li>
<li>几乎所有伟大的公司都经历过转型</li>
<li>维持没有意义</li>
<li>分清坚持还是维持，要学会跳出画面看画，必须让自己脱离公司的日常事务</li>
<li>抬头看路比低头拉车更重要</li>
</ul>
<h4 id="军规31-成功后不折腾"><a href="#军规31-成功后不折腾" class="headerlink" title="军规31 成功后不折腾"></a>军规31 成功后不折腾</h4><ul>
<li>成功后不要头脑发热</li>
<li>多元化要慎重，首先隔行如隔山，其次多元化会导致资源分散，管理能力不足</li>
<li>加速度要节制，重要的是可持续增长</li>
<li>不要被转件忽悠</li>
<li>纸上谈兵的正规化对企业有害无利，要善于揣摩、借鉴别人的管理经验，但绝不能生搬硬套</li>
<li>靠专家建议定战略基本上没戏!战略是一门实践科学，记住不在其位不谋其政，不担其责</li>
<li>要敢于坚守自己的成功之道。谦虚是好事，但不能怀疑自己，尤其不要邯郸学步。管理要改良而不是革命</li>
</ul>
<h4 id="军规32-借助资本的力量创业"><a href="#军规32-借助资本的力量创业" class="headerlink" title="军规32 借助资本的力量创业"></a>军规32 借助资本的力量创业</h4><ul>
<li>现在是资本时代</li>
<li>资本的介入已经改变了企业的成长周期</li>
<li>只有用好资本才能成功</li>
<li>不融资就会输在起跑线上</li>
<li>借助资本的力量加快发张速度</li>
<li>和最强的资本结合</li>
<li>学会和资本打交道是创始人的必修课</li>
</ul>
<h4 id="军规33-融资要敢于吃亏"><a href="#军规33-融资要敢于吃亏" class="headerlink" title="军规33 融资要敢于吃亏"></a>军规33 融资要敢于吃亏</h4><ul>
<li>别相信那些融资神话，企业融不到资是常态</li>
<li>想清楚缺钱干什么再去融资</li>
<li>竭尽全力之后再去融资。自己的钱都不敢花，别人凭什么给你钱？做好你的事，钱会来找你的</li>
<li>尽可能多的验证你的想法</li>
<li>融资要找对人，一般而言只有合伙人在基金中才能发挥作用，只有决策委员会才能最终决策</li>
<li>融资的窍门是吃亏，融资的三个窍门：1，融资价格要低点儿；2，融资规模要小点儿；3，融资时间要早点儿</li>
</ul>
<h4 id="军规34-风险投资只是你的一段情"><a href="#军规34-风险投资只是你的一段情" class="headerlink" title="军规34 风险投资只是你的一段情"></a>军规34 风险投资只是你的一段情</h4><ul>
<li>风险投资进入企业的唯一目的是获利退出</li>
<li>不要指望投资人能帮你钱以外的事情</li>
<li>克服融资时的“弱势”心理</li>
<li>不要被“战略投资”控制</li>
<li>不要被team sheet忽悠，team sheet几投资条款清单</li>
<li>不要“卖”了公司</li>
</ul>
<h4 id="军规35-任何时候都不要让投资人替你决策"><a href="#军规35-任何时候都不要让投资人替你决策" class="headerlink" title="军规35 任何时候都不要让投资人替你决策"></a>军规35 任何时候都不要让投资人替你决策</h4><ul>
<li>投资人和公司不在一条船上</li>
<li>投资人和公司的利益即统一有对立</li>
<li>投资人不是陪伴企业终生的人</li>
<li>投资人代表的尴尬地位</li>
<li>融资条款很关键</li>
<li>所谓的行业惯例条款都是可以改的 </li>
<li>记住你才是企业的主人</li>
<li>任何时候都不要放弃你对公司的责任</li>
<li>不要对赌</li>
</ul>
<h4 id="军规36-不要为了上市而上市"><a href="#军规36-不要为了上市而上市" class="headerlink" title="军规36 不要为了上市而上市"></a>军规36 不要为了上市而上市</h4><ul>
<li>上市不是目的</li>
<li>上市时企业的成人礼</li>
<li>上市能够极大的促进企业的规范发展</li>
<li>上市不是判断企业是否成功的标准</li>
<li>下决心上市才能成功</li>
<li>只有横下一条心上市才可能成功</li>
<li>漫长的国内上市路</li>
<li>上市之后，考试才刚刚开始</li>
<li>包装上市不可取 </li>
</ul>
<h3 id="附录：名将是怎样炼成的"><a href="#附录：名将是怎样炼成的" class="headerlink" title="附录：名将是怎样炼成的"></a>附录：名将是怎样炼成的</h3><p>&emsp;&emsp;名将学校开学了，第一个年级要学习的是军事理论。所有想成为名将的人，必须要学习一些经典的理论知识，包括孙子兵法、吴子兵法等等，只有在积累了大量的理论知识后，你才能跨入下一个年级，但这个年纪有一个很特殊的规定，因为有些同学家里穷，买不起书本，所以他们只能在实战中去学习这些理论。他们之中的优秀代表就是李云龙同学。<br><br>&emsp;&emsp;穷人家的孩子早当家，实在没有说错的，这些在实战中学习理论的同学将可以跳过第二个程序，直接进入第三个程序。<br><br>&emsp;&emsp;我们还是和大多数同学一起，来看看第二个年级要学习些什么，第二个年级学习的内容是实战。这是极为重要的，那些理论中学习的优秀者如果不能过这一关，他们就将被授予一个光荣的称号–纸上谈兵，这个称号的第一个获得者是赵括同学，授予者是二年级的年级主任赵奢。<br><br>&emsp;&emsp;我们来解释一下为什么实战如此重要，这是因为虽然军事理论都是高年级的学长们经验总结，但由于他们写这些东西的时候，情况和现状是不完全一样的，在实战中，如果照搬是要吃大亏的。赵括同学就是没有学好，才不能毕业的。<br><br>&emsp;&emsp;作为一个学员，想成为名将，一般都是从小兵干起，当然除了**外，比如赵括同学，由于年级主任赵奢是他父亲，所以他一开始就是大将，这是不妥当的。<br><br>&emsp;&emsp;因为只有战场才能让一个人成为真正的名将，他必须亲手持刀去追击敌人，见识战场的惨烈，明白人被刀砍是要死的，了解你不杀我，我就杀你这条战场上永不过时的真理，知道所谓打仗就是以性命相搏，他们才会明白什么是战场，什么是实战。<br><br>&emsp;&emsp;大多数学员会在这一关被淘汰，他们会改行，一生当一个军事票友，这对他们来说并不见得是一件坏事。<br><br>&emsp;&emsp;而留存下来的那些学员，在残酷的实战中逐渐了解了战争的规律，开始真正走上名将之路。<br><br>&emsp;&emsp;好了，我们带领剩下的学员来到三年级，三年级要学习的是冷酷。<br><br>&emsp;&emsp;成为一个名将，就必须和仁慈、温和之类的名词说再见，他必须心如铁石，冷酷无情，当然历史上也有很多以仁出名的儒将，但请大家注意，他们的仁是对士兵和老百姓而言的，对敌人他们比谁都冷酷。<br><br>&emsp;&emsp;所谓仁不带兵，义不行贾，冷酷不是残忍，不是杀戮无辜的老百姓，而是坚忍，比如你的一个很好的朋友触犯了军纪，但你为了执行军纪，一定要杀了他，只有这样，你才能控制军队，即使他是你最要好的朋友，甚至是你的亲人，你也要这样做。<br><br>&emsp;&emsp;这才是真正的冷酷！<br><br>&emsp;&emsp;学员们将在战场上学会冷酷，他们可能都是善良的年轻人，平时从不与人争吵，但当他们走上战场，亲眼看到自己的同乡和战友被敌人杀死，或者身负重伤在地上痛苦的呻吟，他们会被愤怒和痛苦所鼓动，毫不留情的杀死一切与自己敌对的人，给地上的伤兵补上一刀，然后一个人在尸体旁边喃喃自语，就在这地狱一般的环境中，他们变了。<br><br>&emsp;&emsp;从杀鸡都怕见血到敌人的脑浆和鲜血溅到身上浑然不知，从温文尔雅到冷酷无情，他们在残酷的环境中毕业了，不合格者将被淘汰，而那些心如坚石的人将进入四年级的学习，他们离成为名将越来越近。<br><br>&emsp;&emsp;四年级要学习的是理智，这也是极为重要的一个环节，我们作为普通人，生活中会被许多事情左右自己的情绪，比如买彩票中个二等奖几百块，你也会高兴半天，要是炒股票赚了大钱，就更不用说了。那么如果你玩的游戏是以人命为赌注呢？你会有何反应。<br><br>&emsp;&emsp;当你在极度紧张的环境中与敌人僵持了很长时间，突然敌人退却了，你能遏制住心中的激动，先判断形势再去追击吗？当你抵挡不住敌人的进攻，全军即将崩溃时，你能及时冷静下来，发现敌人的弱点吗？<br><br>&emsp;&emsp;是的，这太难了，我们都是凡人，都有感情，容易激动，而我们的学员们就必须保持冷静和理智，在任何时候都不被感情左右，就如同赛车一样，赛车是一项激情四射的运动，然而车手却必须保持绝对的冷静。<br><br>&emsp;&emsp;这就是四年级学员要做到的，能过这一关的人，已经很少了，剩下的精英们，我们继续前进！<br><br>&emsp;&emsp;五年级是最重要的一个年级，在这个年级里，学员们要学习的是判断。<br><br>&emsp;&emsp;这是名将的重要特征，不需要理由，不需要依据，你能依靠的就是你自己的判断。你要明白的是，你所掌握的是无数士兵的生命，而所有的人都等着你拿注意。<br><br>&emsp;&emsp;小兵只管打仗，遇到问题，他会问伍长，伍长会问百户，百户会问千户，千户问指挥，你就是指挥，你还能去问谁？！<br><br>&emsp;&emsp;在士兵的眼中，你就是上帝，就是主宰世界的神！他们能否活下来就看你的了！<br><br>&emsp;&emsp;兵法之所以奇妙，关键在于一个变字，所谓善出奇者，无穷如天地，不竭如江海！战场是一个瞬息万变的世界，决断只在一线之间，进攻还是防守，前进还是退却，都要你拿注意，在你身边也许有一大群参谋，但他们往往并不站在真理一边，决断的还是你。如果参谋比你高明，为什么要你当主帅？！<br><br>&emsp;&emsp;如果你能从那变化莫测的世界中，发现其中的奥妙，并就此做出正确的决断，那么恭喜你，你已经具备了名将最主要的素质。但是还有一关是你必须通过的，只有过了这一关，你才是真正的名将。<br><br>&emsp;&emsp;现在我们来到最后一个年级，这个年级我们要学习的是坚强。<br><br>&emsp;&emsp;从某种意义上说，这是非常重要的一个学习内容，所谓胜败兵家常事，不过安慰自己而已，打了败仗，死几万人，你能承受这样的心理压力吗，你怎么去面对那些士兵的家人，怎么有脸去见将指挥权交给你的上级？那是几万人命，不是几万只鸡！<br><br>&emsp;&emsp;然而你的选择只能是坚强，即使你屡战屡败，但必须屡败屡战！我们可以想象，当你数次败在同一个人手下时，你会畏惧这个人，所谓的恐某症就是这么来的，即使你有着杰出的军事才能，不能战胜自己的软弱，还是不能成为名将的。<br><br>&emsp;&emsp;而那些最优秀的人能够从失败中爬起来，去挑战那个多次战胜自己的人，这才是坚强！<br><br>&emsp;&emsp;当你具备了以上所有条件后，你就成为了真正的名将，但还有一点，是你必须具备的，那就是运气。<br><br>&emsp;&emsp;说起来似乎有点滑稽，这也是很重要的一个因素，没准就在你万事俱备，准备大展身手时，一支冷箭射来，就此死掉，那才是比窦娥还冤，你的一切抱负和能力都无法展现了。战史上只会这样记载，某年某月某日，某某人在战场上被不知名小兵射死，其人具体情况不详。<br><br>&emsp;&emsp;所以名将之路是一条艰苦的道路，非大智大勇，大吉大利之人不能为。<br><br>&emsp;&emsp;故兵无常势，水无常形。能因敌变化而取胜者，谓之神。<br><br>&emsp;&emsp;在这变化无穷的战场上，要想成为真正的军神，你必须在一次次的残杀中幸存下来，看着周围的人死去，忍受无尽的痛苦，在战争中学习战争，努力获取那不为人知的奥秘和规律，经历无数次失败，有勇气从无数士兵的尸体上站立起来，去打败对手。<br><br>&emsp;&emsp;这才是真正的名将之路，一条痛苦、孤独、血腥的道路，在这条路上，能信任和依靠的人只有你自己。但只要你走到终点，光荣和胜利就会在那里等待着你。</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/02/01/创业36条军规/" data-id="ckd90jomq006yxc51b7bvowkm" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/page/8/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/10/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>