<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">焦正奎的博客</a></h1>
      <p>不要怕！不要悔！慢慢来！</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="焦正奎的博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-单例的利与弊" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/01/18/单例的利与弊/">单例的利与弊</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/01/18/单例的利与弊/" class="article-date">
  <time datetime="2016-01-18T10:14:18.000Z" itemprop="datePublished">2016-01-18</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul>
<li>概念：一个单例类，在整个程序中只有一个实例，并且提供一个类方法供全局调用，在编译时初始化这个类，然后一直保存在内存中，到程序（APP）退出时由系统自动释放这部分内存。</li>
<li>存储位置：全局区</li>
<li>系统的单例：UIApplication、NSNotificationCenter、NSFileManager、NSUserDefaults</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li><p>通用版单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (ZKSingleManager *)sharedInstance &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static ZKSingleManager *instance = nil;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">if (instance == nil) &#123;</span><br><span class="line">instance = [[ZKSingleManager alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>严格版单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@interface ZKSingleManager : NSObject</span><br><span class="line">+ (ZKSingleManager *)sharedInstance;</span><br><span class="line"></span><br><span class="line">// NS_UNAVAILABLE 表示禁止此方法调用</span><br><span class="line">- (instancetype)init NS_UNAVAILABLE;</span><br><span class="line">// 效果同上，但可以带上文字说明</span><br><span class="line">+ (instancetype)new __attribute__((unavailable(&quot;单例只能通过sharedInstance初始化&quot;)));</span><br><span class="line">- (id)copy  __attribute__((unavailable(&quot;单例禁止深拷贝&quot;)));</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;ZKSingleManager.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation ZKSingleManager</span><br><span class="line"></span><br><span class="line">+ (ZKSingleManager *)sharedInstance &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">static ZKSingleManager *instance = nil;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">if (instance == nil) &#123;</span><br><span class="line">instance = [[ZKSingleManager alloc] initPrivate];</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initPrivate &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h4><ul>
<li>优点：1、在整个程序中只会实例化一次，所以在程序如果出了问题，可以快速的定位问题所在；2、由于在整个程序中只存在一个对象，节省了系统内存资源，提高了程序的运行效率；</li>
<li>缺点:1、不能被继承，不能有子类；2、不易被重写或扩展（可以使用分类）；3、同时，由于单例对象只要程序在运行中就会一直占用系统内存，该对象在闲置时并不能销毁，在闲置时也消耗了系统内存资源；</li>
</ul>
<h4 id="当你使用单例的时候-你需要问自己以下四个问题"><a href="#当你使用单例的时候-你需要问自己以下四个问题" class="headerlink" title="当你使用单例的时候 你需要问自己以下四个问题"></a>当你使用单例的时候 你需要问自己以下四个问题</h4><ol>
<li>这个类表达的含义真的只能有一个实例么？（如UIApplication）还是只是为了好调用而已？; </li>
<li>这个单例持有的内存一直存在；</li>
<li>是否能用类方法代替？；  </li>
<li>这个单例对象是否能成为另一个单例对象的属性？如果是，应该作为另一个单例的属性</li>
</ol>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://objccn.io/issue-13-2/" target="_blank" rel="noopener">避免滥用单例</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/01/18/单例的利与弊/" data-id="ckd90jomq006vxc51fc1mv5l8" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-视图更新的几个方法" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2016/01/01/视图更新的几个方法/">视图更新的几个方法</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2016/01/01/视图更新的几个方法/" class="article-date">
  <time datetime="2016-01-01T10:14:18.000Z" itemprop="datePublished">2016-01-01</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-layoutSubviews"><a href="#1-layoutSubviews" class="headerlink" title="1 layoutSubviews"></a>1 layoutSubviews</h3><h4 id="1-1-官方介绍"><a href="#1-1-官方介绍" class="headerlink" title="1.1 官方介绍"></a>1.1 官方介绍</h4><p>The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.</p>
<p>Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.</p>
<p>You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.</p>
<h4 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2 分析"></a>1.2 分析</h4><ul>
<li>只能重写layoutSubviews，不能主动调用！只能系统调用</li>
<li>想要调layoutSubviews方法，需要调setNeedsLayout或layoutIfNeeded</li>
<li>此方法作用是更加精细的控制子视图frame</li>
</ul>
<h4 id="1-3系统调用layoutSubviews时机"><a href="#1-3系统调用layoutSubviews时机" class="headerlink" title="1.3系统调用layoutSubviews时机"></a>1.3系统调用layoutSubviews时机</h4><p>简单的说更新布局总会重新触发layoutSubviews方法，但注意：init初始化不会触发layoutSubviews</p>
<ul>
<li>调用 addSubview 方法时会执行该方法。</li>
<li>设置并改变子视图的frame属性时会触发该方法。</li>
<li>滑动UIScrollView及继承与UIScrollView的控件时会触发该方法。</li>
<li>旋转屏幕时，会触发父视图的layoutSubviews方法。</li>
<li>设置并改变视图的frame属性时会触发父视图的layoutSubviews方法。</li>
</ul>
<h3 id="2-layoutIfNeeded"><a href="#2-layoutIfNeeded" class="headerlink" title="2 layoutIfNeeded"></a>2 layoutIfNeeded</h3><h4 id="2-1-官方介绍"><a href="#2-1-官方介绍" class="headerlink" title="2.1 官方介绍"></a>2.1 官方介绍</h4><p>Use this method to force the view to update its layout immediately. When using Auto Layout, the layout engine updates the position of views as needed to satisfy changes in constraints. Using the view that receives the message as the root view, this method lays out the view subtree starting at the root. If no layout updates are pending, this method exits without modifying the layout or calling any layout-related callbacks.</p>
<h4 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2 分析"></a>2.2 分析</h4><ul>
<li>如果需要刷新的haul，立即强制刷新接受者和它的子视图！</li>
<li>也就是说layoutIfNeeded之后有可能不刷新不调用layoutSubviews，例如view的frame等状态没有变化</li>
</ul>
<h4 id="2-3-参考"><a href="#2-3-参考" class="headerlink" title="2.3 参考"></a>2.3 参考</h4><ul>
<li><a href="https://stackoverflow.com/questions/1182945/how-is-layoutifneeded-used" target="_blank" rel="noopener">How is layoutIfNeeded used?</a></li>
</ul>
<h3 id="3-setNeedsLayout"><a href="#3-setNeedsLayout" class="headerlink" title="3 setNeedsLayout"></a>3 setNeedsLayout</h3><h4 id="3-1-官方介绍"><a href="#3-1-官方介绍" class="headerlink" title="3.1 官方介绍"></a>3.1 官方介绍</h4><p>Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.</p>
<h4 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2 分析"></a>3.2 分析</h4><ul>
<li>当需要重新布局时，在主线程调用setNeedsLayout，将设置一个标志位并立即返回</li>
<li>调用setNeedsLayout并不会立即更新视图，而是下次runloop更新视图</li>
<li>可以将多个视图更新合并在一起，提高性能</li>
<li>layoutSubviews一定会被调用</li>
</ul>
<h3 id="4-setNeedsDisplay"><a href="#4-setNeedsDisplay" class="headerlink" title="4 setNeedsDisplay"></a>4 setNeedsDisplay</h3><h4 id="4-1-官方介绍"><a href="#4-1-官方介绍" class="headerlink" title="4.1 官方介绍"></a>4.1 官方介绍</h4><p>You can use this method or the setNeedsDisplayInRect: to notify the system that your view’s contents need to be redrawn. This method makes a note of the request and returns immediately. The view is not actually redrawn until the next drawing cycle, at which point all invalidated views are updated.</p>
<p>Note:If your view is backed by a CAEAGLLayer object, this method has no effect. It is intended for use only with views that use native drawing technologies (such as UIKit and Core Graphics) to render their content.</p>
<p>If your view is backed by a CAEAGLLayer object, this method has no effect. It is intended for use only with views that use native drawing technologies (such as UIKit and Core Graphics) to render their content.<br>You should use this method to request that a view be redrawn only when the content or appearance of the view change. If you simply change the geometry of the view, the view is typically not redrawn. Instead, its existing content is adjusted based on the value in the view’s contentMode property. Redisplaying the existing content improves performance by avoiding the need to redraw content that has not changed.</p>
<h4 id="4-2-分析"><a href="#4-2-分析" class="headerlink" title="4.2 分析"></a>4.2 分析</h4><ul>
<li>当需要重绘调用setNeedsDisplay，将设置一个标志位并立即返回</li>
<li>调用setNeedsDisplay并不会立即更新视图，而是下次runloop更新视图</li>
<li>setNeedsDisplay一定会调用drawRect:方法</li>
<li>如果视图由caeagllayer对象支持，则此方法无效</li>
<li>如果只更改视图的几何图形，需要通过ContentMode的值进行调整的</li>
</ul>
<h4 id="4-3-参考"><a href="#4-3-参考" class="headerlink" title="4.3 参考"></a>4.3 参考</h4><ul>
<li><a href="https://stackoverflow.com/questions/14506968/setneedslayout-and-setneedsdisplay?r=SearchResults" target="_blank" rel="noopener">setNeedsLayout and setNeedsDisplay</a></li>
</ul>
<h3 id="5-other-question"><a href="#5-other-question" class="headerlink" title="5 other question"></a>5 other question</h3><ul>
<li><p>更改约束怎么实现动画？参考：<a href="https://stackoverflow.com/questions/12622424/how-do-i-animate-constraint-changes?r=SearchResults" target="_blank" rel="noopener">How do I animate constraint changes?</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[UIView animateWithDuration:5</span><br><span class="line">animations:^&#123;</span><br><span class="line">self._addBannerDistanceFromBottomConstraint.constant = -32;</span><br><span class="line">[self.view layoutIfNeeded]; // Called on parent view</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://stackoverflow.com/questions/20609206/setneedslayout-vs-setneedsupdateconstraints-and-layoutifneeded-vs-updateconstra?r=SearchResults" target="_blank" rel="noopener">setNeedsLayout vs. setNeedsUpdateConstraints and layoutIfNeeded vs updateConstraintsIfNeeded</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setNeedsUpdateConstraints makes sure a future call to updateConstraintsIfNeeded calls updateConstraints.</span><br><span class="line"></span><br><span class="line">setNeedsLayout makes sure a future call to layoutIfNeeded calls layoutSubviews.</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2016/01/01/视图更新的几个方法/" data-id="ckd90joo900atxc51yo81xgsh" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/">UI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-再读编写高质量iOS的52个方法" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/12/29/再读编写高质量iOS的52个方法/">再读编写高质量iOS的52个方法</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/12/29/再读编写高质量iOS的52个方法/" class="article-date">
  <time datetime="2015-12-29T10:14:18.000Z" itemprop="datePublished">2015-12-29</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ol>
<li>OC 的起源</li>
</ol>
<ol start="2">
<li>在头文件中尽量少引入其他头文件</li>
</ol>
<ul>
<li>使用@class 将引入头文件的时机尽量延后，同时用于两个文件相互引用的问题。</li>
<li>用#import 不用#include</li>
<li>必要的时候用一个 .h 文件来整理用到的引用</li>
</ul>
<ol start="3">
<li>可以用语法糖</li>
</ol>
<ul>
<li>要注意nil的情况，语法糖创建的都是不可变对象</li>
</ul>
<ol start="4">
<li>多用类型常量，少用#define预处理指令</li>
</ol>
<ul>
<li>少用#define 用类似 static const CGFloat time = 0.3 ，如需要则在 .h 中使用extern CGFloat const time 声明为外部可用的</li>
<li>常量在 .m 文件内用k开头，不过现在好像所有的都是k开头</li>
<li>变量一定要同时用static和const来声明，const表示不能修改，static则表示该变量仅在定义此变量的编- - 译单元中可见，不加static在编译器会自动加external 外部符号，若此时在另外声明同名变量，则报错</li>
</ul>
<ol start="5">
<li>用枚举表示状态选项状态码-fobjc-arc</li>
</ol>
<ul>
<li>尽量不用enum 用NS_ENUM ，</li>
<li>凡是以按位或操作的组合枚举都应使用NS_OPTIONS定义，枚举量对应的值可以用 1&lt;&lt;0 方便各选项通过“按位或”操作来组合。不需要互相组合则用NS_ENUM</li>
<li>使用switch来区分枚举的时候，最好不要加上default语句，这样当新加一种枚举类型时，编译器会报错</li>
</ul>
<ol start="6">
<li>理解属性这一概念</li>
</ol>
<ul>
<li>@dynamic 阻止编译器自动合成getter和setter方法，但如果自己也不实现，编译器是不会报错的</li>
<li>nonatomic   readwrite   readonly   assign   strong   weak  copy  unsafe_unretained  getter  setter</li>
<li>iOS中使用同步锁开销很大，开发Mac OS X程序时使用同步锁却没事</li>
</ul>
<ol start="7">
<li>在对象内部尽量直接访问实例变量</li>
</ol>
<ul>
<li>直接用下划线访问属性，不会触发KVO，不经过getter和setter方法</li>
<li>在getter和setter方法中不要出现self</li>
<li>在初始化及dealloc方法中，总是应该直接通过实例变量来读写数据,在init和dealloc方法中避免时候用self.property</li>
</ul>
<ol start="8">
<li>理解对象等同性这一概念</li>
</ol>
<ul>
<li>== 判断内存是否相等， isEqual 判断对象是都相等</li>
<li>相同对象必须有相同的哈希码，但两个哈希码相同的对象却未必相同</li>
</ul>
<ol start="9">
<li>以类簇隐藏实现细节</li>
</ol>
<ul>
<li>实现子类时，一定要注意父类指明覆盖的方法</li>
</ul>
<ol start="10">
<li>在既有类中使用关联对象存放自定义数据</li>
</ol>
<ul>
<li>objc_setAssociateObject    objc_getAssociatedObject  objc_removeAssociatedObjects</li>
<li>慎用，很难发现也很难排查</li>
</ul>
<ol start="11">
<li>理解objc_msgSend的作用</li>
</ol>
<ol start="12">
<li>理解消息转发机制</li>
</ol>
<ul>
<li>resolveInstanceMethod:  resolveClassMethod:</li>
<li>forwardingTargetForSelector</li>
<li>forwardInvocation</li>
</ul>
<ol start="13">
<li><p>用方法调配技术（method swizzling）调试黑盒方法</p>
</li>
<li><p>理解类对象的用意</p>
</li>
</ol>
<ul>
<li>id本身就是指针，所以不用 *</li>
<li>isMemberOfClass  isKindOfClass</li>
</ul>
<ol start="15">
<li>用前缀避免命名空间冲突</li>
</ol>
<ul>
<li>apple宣称其保留使用所有“两字母前缀”的权利，所以自己选用的前缀应该是三个字母及以上的</li>
<li>项目中所有的方法、函数都最好加前缀</li>
</ul>
<ol start="16">
<li>提供全能初始化方法</li>
</ol>
<ul>
<li>必须要实现的，放到init里让对象实例化的时候就实现。（全能初始化）</li>
<li>子类要包含父类全能初始化方法干的事。</li>
<li>可以抛出异常来提醒，但不建议，OC中只有发生严重错误时，才应该抛出异常。、</li>
</ul>
<ol start="17">
<li>实现description 方法</li>
</ol>
<ul>
<li>重写description 方法能自定义打印内容，其实可以Hook一下让所有的类以及其属性值都打印出来，不过暂时没必要。</li>
<li>debugDescription 是开发者在调试器中以控制台命令打印对象时才调用。</li>
</ul>
<ol start="18">
<li>尽量使用不可变对象</li>
</ol>
<ul>
<li>尽量少的暴露属性，即便暴露属性也要尽量设置为只读的。</li>
<li>暴露的readonly属性最好设置内存管理，并在内部重新声明为readwrite，避免正在写的时候外面有人在读，必要的时候可以用dispatch_sync 将存取操作设置为同步操作。</li>
<li>不要暴露可变的collection属性，应该提供相关方法修改内部可变的collection，而在公开属性中getter方法中对内部可变的copy操作。</li>
</ul>
<ol start="19">
<li>使用清晰而协调的命名方式</li>
</ol>
<ul>
<li>如果方法的返回值是新创建的，那么方法名的首个词应是返回值类型。</li>
<li>应该把表示参数类型的名词放在参数前面。</li>
<li>如果方法要在当前对象上执行凑走，那么久应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。</li>
<li>不要使用str这种简称，应该用string这样的全称。</li>
<li>BOOL属性应加is前缀。如果某方法返回非属性的BOOL值，那么应该根据其功能，选用has或is当前缀。</li>
<li>将get这个前缀留给那些借由“输出参数”来保存返回值的方法。</li>
</ul>
<ol start="20">
<li>为私有方法名加前缀</li>
</ol>
<ul>
<li>不要用下划线作为前缀定义私有方法，因为这是预留给苹果公司用的。</li>
<li>可以将使用的类名前缀用作私有方法前缀来避免冲突。</li>
</ul>
<ol start="21">
<li>理解Objective-C错误类型</li>
</ol>
<ul>
<li>如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放，即便不用ARC，也很难写出在抛出异常时不会导致内存泄漏的代码</li>
<li>OC采用的做法：只在极其罕见（致命）的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。</li>
<li>如果父类强制子类实现某方法，可以在父类对应方法里抛出异常。</li>
<li>出现不非致命错误是OC一般让方法返回nil，或者使用NSError。</li>
<li>NSError一般通过(NSError<strong>)error 这种输出参数来返回。实际上编译器会将NSError</strong>转换成NSError<em> _ _ autoreleasing</em> ,也就是说指针所指的对象会这方法执行完毕后自动释放。</li>
</ul>
<ol start="22">
<li>理解NSCopying协议</li>
</ol>
<ul>
<li>自己的类支持拷贝操作，就需要实现NSCopying协议。copyWithZone方法中zone参数是因为以前是按zone（区）来划分的，但现在都是使用default zone，因此可以不用管zone参数。</li>
<li>非属性的内部使用实例，可以通过 -&gt; 语法</li>
<li>mutableCopy   copy  区别</li>
</ul>
<ol start="23">
<li>通过委托与数据源协议进行对象间通信</li>
</ol>
<ul>
<li>delegate 属性要定义成weak，而不是strong的。</li>
<li>@optional</li>
</ul>
<ol start="24">
<li>将类的实现代码分散到便于管理的数个分类之中</li>
</ol>
<ul>
<li>将应该视为“私有”的方法归入名为private的分类中以隐藏实现细节。</li>
</ul>
<ol start="25">
<li>总是为第三方类的分类名称加前缀</li>
</ol>
<ul>
<li>如果相同属性或方法，分类会覆盖原来的，而且很可能覆盖很多次。。。解决的办法就是加前缀。</li>
</ul>
<ol start="26">
<li>勿在分类中声明属性</li>
</ol>
<ul>
<li>把封装数据所用到的全部属性都定义在主接口里</li>
</ul>
<ol start="27">
<li>使用“class-continuation分类”隐藏实现细节</li>
</ol>
<ul>
<li>必须定义在其接续的那个类的实现文件里，没有名字；并且是唯一能声明实例变量的分类  @interface Person() {  // something  }</li>
<li>非公开的属性最好写在class-continuation</li>
</ul>
<ol start="28">
<li>通过协议提供匿名对象</li>
</ol>
<ul>
<li>@property (nonatomic , weak) id <somedelegate> delegate;  id <somedelegate>就是匿名对象</somedelegate></somedelegate></li>
<li>协议可在某种程度上提供匿名类型，具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法</li>
<li>使用匿名对象类隐藏类型名称（或类名）</li>
<li>如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以用匿名对象来表示。</li>
</ul>
<ol start="29">
<li>理解引用计数</li>
</ol>
<ul>
<li>retainCount方法不太准，不建议使用。</li>
<li>保留环，一则般需要设置weak处理，block的循环引用则用_ _weak     _ _strong    _ _block来处理</li>
</ul>
<ol start="30">
<li><p>以  ARC简化引用计数</p>
</li>
<li><p>在dealloc方法中只释放引用并解除监听</p>
</li>
</ol>
<ul>
<li>不应该自己调用dealloc，虽然非ARC用调 [super dealloc]，但ARC不用。应该做的就是释放引用，取消订阅或KVO</li>
<li>错误，异常，对于一些特殊操作很重要，提醒释放内存。</li>
<li>系统并不保证每个创建出来的对象的dealloc都会执行。</li>
<li>编写dealloc方法时，不要在里面随便调用其他方法。</li>
<li>dealloc里也不要调用属性的存取方法</li>
</ul>
<ol start="32">
<li>编写“异常安全代码”时留意内存管理问题</li>
</ol>
<ul>
<li>@try {} @catch {} @finally {}  捕获异常时，一定要注意将try块内所创立的对象清理干净。</li>
<li>默认情况下,ARC不生成安全处理异常所需的清理代码，开启编译器标志 –fobjc-arc-exceptions 后，可以生成清理代码，但开启后将导致程序变大，而且会降低运行效率。</li>
</ul>
<ol start="33">
<li>以若引用避免保留环</li>
</ol>
<ul>
<li>避免保留环的最佳方式就是弱引用。</li>
<li>weak 、assign 和 unsafe_unretained</li>
</ul>
<ol start="34">
<li>以自动释放池块降低内存峰值</li>
</ol>
<ul>
<li>通常只有一个地方需要创建自动释放池 @autoreleasepoll { // dosomething }，那就是在main函数里面</li>
<li>自动释放池可以嵌套，可以控制应用程序峰值</li>
<li>自动释放池的释放要等线程下一次runloop时才会清空</li>
</ul>
<ol start="35">
<li><p>用僵尸对象调试内存管理</p>
</li>
<li><p>不用使用retainCount</p>
</li>
</ol>
<ul>
<li>ARC已经废弃此方法，即便非ARC此方法获取的值也不准。</li>
</ul>
<ol start="37">
<li>理解“块”这一概念</li>
</ol>
<ul>
<li>int (^addBlock)(int a , int b) = ^(int a, int b){ return a+ b; };</li>
<li>Block捕获的变量在块内是不可变的，需要改的用_ _block修饰</li>
<li>_ _weak  _ _strong </li>
<li>定义Block的内存是分配在栈区，离开相应的范围之后，编译器有可能把分配给块的内存覆盖掉，因此需要用copy，拷贝到堆区当做一个一对象处理，拥有引用计数</li>
<li>全局块不会捕捉任何状态，运行时也无须状态来参与，声明在全局内存区，因此拷贝是个空操作，故全局块绝不可能为紫铜所收回，这种块实际上相当于单例。</li>
</ul>
<ol start="38">
<li>为常用的块类型创建typedef</li>
</ol>
<ul>
<li>块的类型有参数和返回值组成。</li>
</ul>
<ol start="39">
<li>用handler块降低代码分散程度</li>
</ol>
<ul>
<li>系统发现某个应用程序的主线程已经阻塞了一段时间后，就会令其停止。</li>
<li>建议使用同一个块来处理成功与失败的情况。</li>
<li>应该由调用API的人来决定handler应该运行在哪个线程上。</li>
</ul>
<ol start="40">
<li>用块引用其所属对象时不要出现保留环</li>
</ol>
<ul>
<li>一定要找个适当的时间解除保留环，而不能把责任推给API的调用者。</li>
</ul>
<ol start="41">
<li>多用派发队列，少用同步锁</li>
</ol>
<ul>
<li>@synchronized(self) 同步锁，会降低代码效率，因为共用同一个锁的那些同步块，都必须按顺序执行。</li>
<li>NSLock</li>
<li>安全高效代替同步块和锁对象的是 串行同步队列</li>
<li>执行异步派发时，需要拷贝块</li>
<li>dispatch_barrier_async  dispatch_barrier_sync</li>
</ul>
<ol start="42">
<li>多用GCD，少用performSelector系列方法</li>
</ol>
<ul>
<li>用performSelector 调用一个方法，编译器并不知道将要调用的方法，也就不了解其方法签名以及返回值情况，所以没办法运用ARC的内存管理规则来判定返回值是不是应该释放，鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作，然而这么做可能导致内存泄漏。</li>
<li>一般返回只能是void或对象类型，而performSelector返回的是id类型，那么就需要执行一些转换操作，很容易出错！若返回类型为C的结构体，则不可使用performSelector方法。</li>
<li>没机会为被调用的方法指定参数，被调用的selec的输入可能指向位置的垃圾内存</li>
<li>如果跨线程执行，最好不用performSelector，而用GCD</li>
</ul>
<ol start="43">
<li>掌握GCD及操作队列的使用时机</li>
</ol>
<ul>
<li>GCD是纯C的API，而操作队列则是Ojbective-C的对象。</li>
<li>NSOperation 运行之前，可以取消某个操作（但已经启动的无法取消）；可指定操作间依赖关系；通过KVO观察属性；指定操作的优先级（GCD可以控制队列的优先级，不是块的）</li>
</ul>
<ol start="44">
<li>通过Dispatch Group机制，根据系统资源状况来执行任务</li>
</ol>
<ul>
<li>dispatch_group_t  dispatch_group_async  dispatch_group_enter  dispatch_group_leave  dispatch_group_wait  dispatch_group_notify</li>
</ul>
<ol start="45">
<li>使用dispatch_once来执行只需运行一次的线程安全代码</li>
</ol>
<ul>
<li>标记应该声明static或global作用域中，而且每次标记应该相同</li>
</ul>
<ol start="46">
<li>不要使用dispatch_get_current_queue</li>
</ol>
<ul>
<li>iOS6 之后已经弃用dispatch_get_current_queue，极其容易造成死锁</li>
<li>典型错误用法：用dispatch_get_current_queue检测当前队列是不是某个特定队列，试图避免执行同步派发时可能遭遇的死锁问题。</li>
<li>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。</li>
</ul>
<ol start="47">
<li><p>熟悉系统框架</p>
</li>
<li><p>多用块枚举，少用for循环、</p>
</li>
</ol>
<ul>
<li>块枚举法，本身就能通过NSEnumerationOptions 配置GCD来并发执行遍历操作。</li>
<li>若提前知道待遍历对象类型，则应修改块签名，指出对象的具体类型。</li>
</ul>
<ol start="49">
<li>对自定义其内存管理语义的collection使用无缝桥接</li>
</ol>
<ul>
<li>_ <em>bridge 本身的意思是：ARC仍然具备这个OC对象的所有权，而</em> _bridge_retained意味着ARC将交出对象的所有权</li>
</ul>
<ol start="50">
<li>构建缓存时选用NSCache而非NSDictionary</li>
</ol>
<ul>
<li>当系统资源将要耗尽时，NSCache可以自动删减缓存。</li>
<li>NSCache并不会“拷贝”键，而是会“保留”它。</li>
<li>NSCache是线程安全的，不加锁多个线程也可以同时访问。</li>
</ul>
<ol start="51">
<li>精简initialize与load的实现代码</li>
</ol>
<ul>
<li>当包含类或分类的程序载入系统时会调用load方法，而且只会调一次。如果类和分类都实现了load方法，则先调类的，再调分类的。</li>
<li>load方法中使用其他类是不安全的，因为比先执行超类的load方法，而根据某个给定的程序库却无法判断出其中各个类的载入顺序。</li>
<li>load方法并不像普通方法那样，如果某个类本身没实现load方法，那么不管其各级超类是否实现此方法，系统都不会调用</li>
<li>load方法必须实现的精简，因为整个应用程序在执行load方法时都会阻塞。</li>
<li><ul>
<li>(void) initialize   与 – (void) init 不一样</li>
</ul>
</li>
<li><ul>
<li>(void) initialize 对于每个类来说，该方法会在程序首次用该类之前调用，且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。</li>
</ul>
</li>
<li><ul>
<li>(void) initialize方法时惰性调用的，用不到的类不会运行，但load方法是程序会一直阻塞到所有类的load都执行完。</li>
</ul>
</li>
<li><ul>
<li>(void) initialize 与其他方法一样，如果某个类未实现它，而超类实现了，则运行超类的实现代码。</li>
</ul>
</li>
<li><ul>
<li>(void) initialize 方法要尽量精简，只应该用来设置内部数据，不应该调用其他方法，即便是本类自己的方法最好也别调用；若某个全局状态无法再编译期间初始化，则可放到initialize里来做。</li>
</ul>
</li>
</ul>
<ol start="52">
<li>别忘了NSTimer会保留其目标对象</li>
</ol>
<ul>
<li>设置成重复执行模式计时器，很容易引入保留环</li>
<li>self.timer  设置self为target  就产生了保留环。</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/12/29/再读编写高质量iOS的52个方法/" data-id="ckd90joml006ixc51kbn41hop" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-毛玻璃效果代码" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/12/19/毛玻璃效果代码/">毛玻璃效果代码</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/12/19/毛玻璃效果代码/" class="article-date">
  <time datetime="2015-12-19T03:02:37.000Z" itemprop="datePublished">2015-12-19</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ul>
<li><p>方法1，使用CIFilter滤镜</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//生成一张毛玻璃图片 </span><br><span class="line">- (UIImage*)blur:(UIImage*)theImage  &#123; </span><br><span class="line">CIContext *context = [CIContext contextWithOptions:nil]; </span><br><span class="line">CIImage *inputImage = [CIImage imageWithCGImage:theImage.CGImage]; </span><br><span class="line"></span><br><span class="line">CIFilter *filter = [CIFilter filterWithName:@&quot;CIGaussianBlur&quot;]; </span><br><span class="line">[filter setValue:inputImage forKey:kCIInputImageKey]; </span><br><span class="line">[filter setValue:[NSNumber numberWithFloat:15.0f] forKey:@&quot;inputRadius&quot;]; </span><br><span class="line">CIImage *result = [filter valueForKey:kCIOutputImageKey]; </span><br><span class="line"></span><br><span class="line">CGImageRef cgImage = [context createCGImage:result fromRect:[inputImage extent]]; </span><br><span class="line"></span><br><span class="line">UIImage *returnImage = [UIImage imageWithCGImage:cgImage]; </span><br><span class="line">CGImageRelease(cgImage); </span><br><span class="line">return returnImage; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法2，使用iOS8系统效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *imageView =[[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 200, 100)];</span><br><span class="line">imageView.image = [UIImage imageNamed:@&quot;logo&quot;];</span><br><span class="line">[self.view addSubview:imageView];</span><br><span class="line">/*</span><br><span class="line">UIBlurEffectStyleExtraLight,  //高亮</span><br><span class="line">UIBlurEffectStyleLight,       //亮</span><br><span class="line">UIBlurEffectStyleDark         //暗</span><br><span class="line">*/</span><br><span class="line">UIBlurEffect *blurEffect =[UIBlurEffect effectWithStyle:UIBlurEffectStyleDark];</span><br><span class="line">UIVisualEffectView *effectView =[[UIVisualEffectView alloc]initWithEffect:blurEffect];</span><br><span class="line">effectView.frame = CGRectMake(0,0, imageView.frame.size.width, imageView.frame.size.height);</span><br><span class="line">[self.view addSubview:effectView];</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/12/19/毛玻璃效果代码/" data-id="ckd90jonv009txc513j3rr3ja" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-学习技巧" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/11/30/学习技巧/">学习技巧</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/11/30/学习技巧/" class="article-date">
  <time datetime="2015-11-30T10:14:18.000Z" itemprop="datePublished">2015-11-30</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/技巧/">技巧</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;我，半个码农！还没入行Java，马上又换行到iOS，重新自学新语言：Object-C！因是公司内部转岗，基本上所有的东西都要自学，东一榔头，西一棒子的学，也不可能专门拿出两三个月专门去培训（还是因为穷，不工作连房租饭费都没有！更不要说1万多的天文培训费，真心没钱！贷款培训？我傻吗！有工作不干，借钱吃饭贷款培训！！！），历经种种阵痛，现在也算是可以写tableview的iOS，现总结一下以往的学习经验</p>
<p>&emsp;&emsp;<strong>公司和学校真的不一样</strong>！我承认我是学渣，渣的不能再渣！大学（也很渣…）4年，上午的课几乎就没去过(嗯，我要说都怪晚上11点半才断电，手机电脑还能撑好几个小时你们可以理解吧)！下午的课，看心情……整天不是在看小说就是在玩游戏（三国志系列和P社四萌是我的最爱，但真心不推荐玩，比网游更费时间）！啰里啰嗦的说了这么多，其实我想说的：学校里的东西真的很简单，没人强迫你拿出产出，考试过了就可以了。我虽然是渣中之渣，但混个60分还是很简单的：考前两三天看看书背一背就可以了（额…高数，用了两周）！当然也挂过科，唯一一次挂科贡献给了一门选修课！但等到工作的时候，再背书就不管用了，再集中突击，该不会的还不会！而现实是我必须要尽快上手(公司内部转岗，给我一两周学习已经是天大的恩赐了)！压力不一样，心态和效率也就不一样！</p>
<p>&emsp;&emsp;<strong>学习新语言必先学语法</strong>！很多人告诉我，语法看看就行了，先去做项目，多做几遍什么语法都会了！等等，这些语法都是什么鬼？这么多层嵌套都是咋回事？嗯，一开始我就是这么被坑的，我真的花了一两天时间熟悉一下语法就去看项目了！一看它认识我，我不认识它！啃了一天也没弄明白数据是怎么流动的，又强忍着性子，从新学习语法！再重申一遍：学习新语言必先学语法！不要求百分之百都记下来，但特殊语法一定要记下来！例如，基本类型、枚举、结构体等一带而过就可以，这些东西99%都一样，没必要花费时间去仔细研究，大不了采坑！但像block，MRC、引用计数啥的要敲些代码仔细研究一下使用方法才好！</p>
<p>&emsp;&emsp;<strong>尽快学习IDE的使用技巧</strong>！xcode是我见过的，最简单、最可靠、功能最齐全的IDE,说实话一开始配置SSH（Spring、Struts、Hibernate）时，我着实的折腾了一两天，还是在同学的帮助下弄完的！但XCode只能用一个字来形容：爽！学习一门新语言要尽快适应IDE，学习IDE使用技巧和调试技巧！这是稳赚不赔的买卖，提升的何止是效率！我印象最深的教训：第一次使用xib时，我足足花了一下午的时间去学习xib的属性是怎么和h文件的属性连接在一起的！因我们项目整体是手动计算frame的，几乎没用到xib，而我是快速自学的，代码都是参照现有项目来的，没见过xib！网上的文章将xib的都是什么属性怎么用，我最关心的怎么连接这点事根本就没人写,最后还是找了个视频才知道….还真就是太简单了才没人写</p>
<p>&emsp;&emsp;<strong>关于教学视频，我是不喜欢的</strong>！现在网上资源十分丰富，很多人都是通过教学视频来入门各种语言的，但我个人不以为然！原因如下：1，大多数的教学视频质量真的不咋地！2，质量稍微好点的都要去培训班，而我没时间去！3，大多数视频时间太长，能用5分钟解决的，非要用一小时去哔哔！当然，每个人都有自己的看法，我只不过没有养成认真听讲的习惯……</p>
<p>&emsp;&emsp;<strong>关于看书,最好一目十行，找到不懂得或感兴趣的再仔细研究</strong>！现在的书籍同质化太严重了，翻来覆去就那点东西，网上大堆大堆的iOS入门书籍，大多是废话连篇，没啥干货，连我这种还没入门的小菜鸟都忽悠不了！但有些经典书还是非常好的，编写高质量iOS和OSX的52个方法和OC高级编程iOS与OSX多线程和内存管理就非常不错</p>
<p>&emsp;&emsp;<strong>请教问题是个大学问</strong>！我总结了一下我认为比较合理的方法：1、百度不到再去问人！不要浪费别人的时间，何况别人的时间更值钱！2、在别人有时间的时候见缝插针的提问，能问到更好，问不到也别纠缠！重要是别让人烦！3、态度要诚恳，语气要温和！你有问题没解决你很着急，但这管他什么事？把他惹毛了就不告诉你，你岂不是更尴尬更难受！4、实在处理不了，要学会放弃！毕竟是菜鸟，与其问也问不到写也不会写还死扛着，还不如认怂交给老大做，老大做完你再慢慢学吗</p>
<p>&emsp;&emsp;<strong>最最重要的是会百度，肯踩坑</strong>！</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/11/30/学习技巧/" data-id="ckd90jon60087xc510jqvide8" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-NSUserDefault" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/11/08/NSUserDefault/">NSUserDefault</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/11/08/NSUserDefault/" class="article-date">
  <time datetime="2015-11-08T10:14:18.000Z" itemprop="datePublished">2015-11-08</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;今天打算水一水最基础的NSUserDefault，因为太常用了都没啥可写的！但后来发现可以APP间共享数据！嗯，正好最近也不知道水什么，就水它了！</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>轻量级数据持久化工具类</li>
<li>存储方式key-value，key要实现NSCoding协议，注意使用对应方法value才可以是值类型</li>
<li>文件格式：plist，保存位置：/Library/preferences/ Bound ID.plist</li>
<li>NSUserDefault中5个域的检索顺序：NSArgumentDomain-&gt;Application-&gt;NSGlobalDomain-&gt;Languages-&gt;NSRegistrationDomain</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>简单，一个单例走天下，跟NSDictionary用法差不多</li>
<li>提供了大量的快捷方法，例arrayForKey: setBool: forKey:</li>
<li>线程安全,不管存的啥，取出来的都是<strong>不可变类型</strong></li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li><p>非实时写入硬盘，而是先写入内存，系统再定时写入硬盘。想要实时写入硬盘调用synchronize方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 非实时写入，最可能问题是程序突然中断，虽然调用了setObject forkey，但再次启动时读取的仍是上个数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>不适合写入大量数据</p>
</li>
<li>频繁的读写会导致性能问题</li>
<li>单例写法很独特 [NSUserDefaults standardUserDefaults]</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基础技巧"><a href="#基础技巧" class="headerlink" title="基础技巧"></a>基础技巧</h4><ul>
<li><p>存取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设值set方法和取值forKey方法都一样，唯一区别就是参数类型</span><br><span class="line">// 注意所有object都必须实现NSCoding协议</span><br><span class="line">NSUserDefaults *userDefault =  [NSUserDefaults standardUserDefaults];</span><br><span class="line">NSMutableArray *muArr = [[NSMutableArray alloc] initWithObjects:@1,@2, nil];</span><br><span class="line">[userDefault setObject:muArr forKey:@&quot;key&quot;];</span><br><span class="line">[userDefault synchronize];</span><br><span class="line">NSArray *arr = [userDefault objectForKey:@&quot;key&quot;];// 取出来是不可变类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSUserDefaults *userDefault =  [NSUserDefaults standardUserDefaults];</span><br><span class="line">[userDefault setObject:nil forKey:@&quot;key&quot;];// 不建议</span><br><span class="line">[userDefault removeObjectForKey:@&quot;key&quot;];// 建议</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">NSDictionary *defaultSet = @&#123;@&quot;name&quot;:@&quot;JZK&quot;, @&quot;sex&quot;:@&quot;man&quot;&#125;;</span><br><span class="line">// 注册默认值，主要用于通用配制的初次载入！取值的时候节省了if判断和测试</span><br><span class="line">[[NSUserDefaults standardUserDefaults] registerDefaults:defaultSet];</span><br><span class="line">// Override point for customization after application launch.</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h4><ul>
<li><p>APP间数据共享</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 开启App Groups，共享的App都需要加入同一个Group，@&quot;com.yourcompany.appsShare&quot;</span><br><span class="line">// appA中</span><br><span class="line">NSUserDefaults *shareDefaultA = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];</span><br><span class="line">[shareDefaultA setObject:@&quot;appA&quot; forKey:@&quot;shareKey&quot;];</span><br><span class="line">// appB中</span><br><span class="line">NSUserDefaults *shareDefaultB = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];</span><br><span class="line">NSString *value = [shareDefaultB objectForKey:@&quot;shareKey&quot;];</span><br><span class="line"></span><br><span class="line">// 域名管理，几乎用不到</span><br><span class="line">// 将指定的域名插入到接收方的搜索列表中</span><br><span class="line">// - (void)addSuiteNamed:(NSString*)suiteName;</span><br><span class="line">// 从接收器的搜索列表中移除指定的域名</span><br><span class="line">// - (void)removeSuiteNamed:(NSString*)suiteName;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前域名下所有的key value</span><br><span class="line">NSUserDefaults *userDefault = [[NSUserDefaults standardUserDefaults];</span><br><span class="line">// NSUserDefaults *userDefault = [[NSUserDefaults alloc]initWithSuiteName:@&quot;com.yourcompany.appsShare&quot;];</span><br><span class="line">NSDictionary* dic = [userDefault dictionaryRepresentation];</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/11/08/NSUserDefault/" data-id="ckd90jol2002sxc51yx7251wz" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-网络图片怎么适配" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/10/19/网络图片怎么适配/">网络图片怎么适配</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/10/19/网络图片怎么适配/" class="article-date">
  <time datetime="2015-10-19T10:14:18.000Z" itemprop="datePublished">2015-10-19</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;这两天UI给提了个bug，说网络下载的图片变小了？查了半天才才发现UI后端上传的图片是2x的，而客户端是按3x来处理的！这就比较坑了……所以就产生了这篇水文！</p>
<p>&emsp;&emsp; 我们采用的是如下（1.1）方案，但约定毕竟不靠谱呀！出现问题又是客户端背锅！</p>
<ul>
<li>1.1 跟后端约定只能穿3x图片，客户端下载图片之后直接绘制即可<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int scale = 3;</span><br><span class="line">UIImage *image = [UIImage imageWithCGImage:img.CGImage withScale:scale];</span><br><span class="line">CGFloat imageHeight = image.size.height / scale;</span><br><span class="line">CGFloat imageWidth = image.size.width / scale;</span><br><span class="line">imageView.frame = CGRectMake(0, 0, imageHeight, imageWidth);</span><br><span class="line">imageView.image = image;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp; 约定不靠谱，那就让服务端都传过来吧！</p>
<ul>
<li>1.2 增强型约定格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">image:&#123;</span><br><span class="line">imgUrl:ttps://xxx.png,</span><br><span class="line">scale:3,</span><br><span class="line">width:100,</span><br><span class="line">height:100</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line">UIImage *image = [UIImage imageWithCGImage:img.CGImage withScale:scale];</span><br><span class="line">imageView.frame = CGRectMake(0, 0, width, height);</span><br><span class="line">imageView.image = image;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;1.2的方案确实更好一点，但服务端的童鞋说这么多接口都这么改，怕要累死了……</p>
<p>&emsp;&emsp;那么怎么办？来看看SD怎么玩的吧</p>
<ul>
<li>1.3 SD怎么玩的？原来是通过url是否包含2x和3x来处理的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if ([[UIScreen mainScreen] respondsToSelector:@selector(scale)]) &#123;</span><br><span class="line">CGFloat scale = 1;</span><br><span class="line">if (key.length &gt;= 8) &#123;</span><br><span class="line">NSRange range = [key rangeOfString:@&quot;@2x.&quot;];</span><br><span class="line">if (range.location != NSNotFound) &#123;</span><br><span class="line">scale = 2.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">range = [key rangeOfString:@&quot;@3x.&quot;];</span><br><span class="line">if (range.location != NSNotFound) &#123;</span><br><span class="line">scale = 3.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (scale != image.scale) &#123;</span><br><span class="line">UIImage *scaledImage = [[UIImage alloc] initWithCGImage:image.CGImage scale:scale orientation:image.imageOrientation];</span><br><span class="line">scaledImage.sd_imageFormat = image.sd_imageFormat;</span><br><span class="line">image = scaledImage;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return image;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;等等if (scale != image.scale)，那是不是直接用image.scale也可以呢？</p>
<ul>
<li>1.4 不行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体代码不写了，可以让后端给你传2x和3x图片分别测试，也可以自己设代理映射本地图片，结果都是一样的！无论2x还是3x，下载后的image，image.scale都是1！但通过imageNamed方式加载本地图片，image.scale却是正确的！！</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&emsp;&emsp;综上所述，想要完美适配图片，只能通过约定的方式：要么约定只能穿3x图片，要么约定上传图片时带着2x或3x信息</p>
<p>&emsp;&emsp;至于jpg格式，jpg要什么适配！！</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/10/19/网络图片怎么适配/" data-id="ckd90joo700anxc5115691kxy" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-核心动画" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/10/08/核心动画/">核心动画</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/10/08/核心动画/" class="article-date">
  <time datetime="2015-10-08T10:14:18.000Z" itemprop="datePublished">2015-10-08</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="CAlayer简介"><a href="#CAlayer简介" class="headerlink" title="CAlayer简介"></a>CAlayer简介</h3><h4 id="UIView与CALayer"><a href="#UIView与CALayer" class="headerlink" title="UIView与CALayer"></a>UIView与CALayer</h4><ul>
<li>关系</li>
<li>CALayer 是 Core Animation Layer</li>
<li>UIView默认有个CALayer，是负责真正的绘图部分</li>
<li>UIView可以理解为是CALayer的管理器，对CALayer进行封装，所以他们大部分属性都是类似的</li>
<li>区别</li>
<li>CALayer继承自NSObject不响应事件，UIView继承自UIResponder能够响应事件</li>
<li>CAlayer是QuatzCore框架内容，UIView是UIKit框架内容</li>
<li>CALayer直接支持3D展示，UIView需要借助transform</li>
<li>CALayer大部分属性修改都能形成隐式动画，UIView没有</li>
</ul>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>是否支持隐式动画</th>
</tr>
</thead>
<tbody>
<tr>
<td>anchorPoint</td>
<td>锚点，取值0到1，比例值！默认(0.5,0.5)，永远和position重合</td>
<td>是</td>
</tr>
<tr>
<td>backgroundColor</td>
<td>图层背景颜色</td>
<td>是</td>
</tr>
<tr>
<td>borderColor</td>
<td>边框颜色</td>
<td>是</td>
</tr>
<tr>
<td>borderWidth</td>
<td>边框宽度</td>
<td>是</td>
</tr>
<tr>
<td>bounds</td>
<td>图层大小</td>
<td>是</td>
</tr>
<tr>
<td>contents</td>
<td>图层显示内容，例如可以将图片作为图层内容显示</td>
<td>是</td>
</tr>
<tr>
<td>contentsRect</td>
<td>图层显示内容的大小和位置</td>
<td>是</td>
</tr>
<tr>
<td>cornerRadius</td>
<td>圆角半径</td>
<td>是</td>
</tr>
<tr>
<td>doubleSided</td>
<td>图层背面是否显示，默认为YES</td>
<td>否</td>
</tr>
<tr>
<td>frame</td>
<td>图层大小和位置，不支持隐式动画</td>
<td>否</td>
</tr>
<tr>
<td>hidden</td>
<td>是否隐藏</td>
<td>是</td>
</tr>
<tr>
<td>mask</td>
<td>图层蒙版</td>
<td>是</td>
</tr>
<tr>
<td>maskToBounds</td>
<td>子图层是否剪切图层边界，默认为NO</td>
<td>是</td>
</tr>
<tr>
<td>opacity</td>
<td>透明度 ，类似于UIView的alpha</td>
<td>是</td>
</tr>
<tr>
<td>position</td>
<td>图层中心点位置，类似于UIView的center</td>
<td>是</td>
</tr>
<tr>
<td>shadowColor</td>
<td>阴影颜色</td>
<td>是</td>
</tr>
<tr>
<td>shadowOffset</td>
<td>阴影偏移量</td>
<td>是</td>
</tr>
<tr>
<td>shadowOpacity</td>
<td>阴影透明度，注意默认为0，如果设置阴影必须设置此属性</td>
<td>是</td>
</tr>
<tr>
<td>shadowPath</td>
<td>阴影的形状</td>
<td>是</td>
</tr>
<tr>
<td>shadowRadius</td>
<td>阴影模糊半径</td>
<td>是</td>
</tr>
<tr>
<td>sublayers</td>
<td>子图层</td>
<td>是</td>
</tr>
<tr>
<td>sublayerTransform</td>
<td>子图层形变</td>
<td>是</td>
</tr>
<tr>
<td>transform</td>
<td>图层形变</td>
<td>是</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：一般CALayer中很少使用frame，通常使用bounds和position代替</li>
<li>注意：UIView的transform是CGAffineTransform用于2D变化，CALayer的的transform是CATransform3D用于3D变化，可互转; CGAffineTransform和CATransform3D的共同点是带有rotation用于旋转、带有scale用于缩放、带有translation用于平移</li>
</ul>
<h3 id="Core-Animation"><a href="#Core-Animation" class="headerlink" title="Core Animation"></a>Core Animation</h3><h4 id="CAAnimation"><a href="#CAAnimation" class="headerlink" title="CAAnimation"></a>CAAnimation</h4><ul>
<li>核心动画的根类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 时间函数</span><br><span class="line">/*</span><br><span class="line">kCAMediaTimingFunctionLinear        // 匀速</span><br><span class="line">kCAMediaTimingFunctionEaseIn        // 慢进</span><br><span class="line">kCAMediaTimingFunctionEaseOut       // 慢出</span><br><span class="line">kCAMediaTimingFunctionEaseInEaseOut // 慢进慢出</span><br><span class="line">kCAMediaTimingFunctionDefault       // 默认值（慢进慢出）</span><br><span class="line">*/</span><br><span class="line">@property(nullable, strong) CAMediaTimingFunction *timingFunction;</span><br><span class="line"></span><br><span class="line">// 注意是strong，设置代理后必须在适当时机手动释放delegate</span><br><span class="line">@property(nullable, strong) id &lt;CAAnimationDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">// 动画执行完毕后是否从图层上移除，默认为YES（视图会恢复到动画前的状态），可设置为NO（图层保持动画执行后的状态，前提是fillMode设置为kCAFillModeForwards）</span><br><span class="line">@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAMediaTiming-协议"><a href="#CAMediaTiming-协议" class="headerlink" title="CAMediaTiming 协议"></a>CAMediaTiming 协议</h4><ul>
<li>CAMediaTiming是一个很好的使用协议实现多继承的样例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 开始时间，默认0即当前时间，延迟2秒可用 beginTime=CACurrentMediaTime() + 2;</span><br><span class="line">@property CFTimeInterval beginTime;</span><br><span class="line"></span><br><span class="line">// 动画持续时长，默认0</span><br><span class="line">@property CFTimeInterval duration;</span><br><span class="line"></span><br><span class="line">// 动画速度，默认1，设为0表示暂停动画</span><br><span class="line">// 动画的实际时间 = duration / speed</span><br><span class="line">@property float speed;</span><br><span class="line"></span><br><span class="line">// 动画已经进行了多长时间，默认0</span><br><span class="line">@property CFTimeInterval timeOffset;</span><br><span class="line"></span><br><span class="line">// 重复次数，默认0</span><br><span class="line">@property float repeatCount;</span><br><span class="line"></span><br><span class="line">// 重复时间，默认0</span><br><span class="line">@property CFTimeInterval repeatDuration;</span><br><span class="line"></span><br><span class="line">// 是否反转，即所有动画倒着来一遍，默认NO</span><br><span class="line">@property BOOL autoreverses;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">首先设置animation.removeOnCompletion = NO</span><br><span class="line">kCAFillModeForwards  // 动画结束后保持最后一帧的状态</span><br><span class="line">kCAFillModeBackwards // 动画开始前报纸第一帧的状态</span><br><span class="line">kCAFillModeBoth      // 都有</span><br><span class="line">kCAFillModeRemoved   // 相当于动画对CALayer没影响，执行完就移除</span><br><span class="line">*/</span><br><span class="line">@property(copy) CAMediaTimingFillMode fillMode;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAAnimationDelegate"><a href="#CAAnimationDelegate" class="headerlink" title="CAAnimationDelegate"></a>CAAnimationDelegate</h4><ul>
<li>注意此delegate是用strong修饰的，使用完必须手动置nil<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 动画开始时回调</span><br><span class="line">- (void)animationDidStart:(CAAnimation *)anim;</span><br><span class="line"></span><br><span class="line">// 动画结束或中断时回调，finished为YES表示动画结束</span><br><span class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAPropertyAnimation"><a href="#CAPropertyAnimation" class="headerlink" title="CAPropertyAnimation"></a>CAPropertyAnimation</h4><ul>
<li>属性动画的基类（通过属性进行动画设置，注意是可动画属性），不能直接使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 一般基础动画和关键帧动画都都会通过去下便利初始化初始化</span><br><span class="line">+ (instancetype)animationWithKeyPath:(nullable NSString *)path;</span><br><span class="line"></span><br><span class="line">// 其实即使CALayer的属性（支持隐式动画的）参照上面</span><br><span class="line">// 注意是NSString，KVC方式来赋值的，所以特别注意拼写问题，大小写等</span><br><span class="line">// 使用transform时 ，应该具体到属性，例@&quot;transform.scale&quot;、@&quot;transform.rotation.z&quot;</span><br><span class="line">@property(nullable, copy) NSString *keyPath;</span><br><span class="line"></span><br><span class="line">// 插值计算函数，不用管，用系统的就好！</span><br><span class="line">@property(nullable, strong) CAValueFunction *valueFunction;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CABasicAnimation"><a href="#CABasicAnimation" class="headerlink" title="CABasicAnimation"></a>CABasicAnimation</h4><ul>
<li>基础动画，通过属性修改进行动画参数控制，最常见用法是设置fromValue和toValue</li>
<li><p>注意：fromValue、toValue和byValue都是strong修饰的id类型，具体类型需要根据keyPath的类型处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">fromValue和toValue不为nil，keyPath属性值在fromValue与toValue之间渐变</span><br><span class="line">fromValue和byValue不为nil，keyPath属性值在fromValue与(fromValue+byValue)之间渐变</span><br><span class="line">byValue和toValue不为nil，keyPath属性值在(toValue-byValue)与toValue之间渐变</span><br><span class="line">fromValue不为nil，keyPath属性值在fromValue与图层对应当前值之间渐变</span><br><span class="line">toValue不为nil，keyPath属性值在图层对应当前值与toValue之间渐变</span><br><span class="line">byValue不为nil，keyPath属性值在图层对应当前值与(图层对应当前值+toValue)之间渐变</span><br><span class="line">*/</span><br><span class="line">@property(nullable, strong) id fromValue;</span><br><span class="line">@property(nullable, strong) id toValue;</span><br><span class="line">@property(nullable, strong) id byValue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然fromValue、toValue和byValue也可使用CATransform3D对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CATransform3D transformFrom = CATransform3DMakeScale(1.0, 1.0, 1.0);</span><br><span class="line">CASpringAnimation *springAnimation = [CASpringAnimation animationWithKeyPath:@&quot;transform&quot;];</span><br><span class="line">springAnimation.fromValue = [NSValue valueWithCATransform3D:transformFrom];</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CABasicAnimation* animation;</span><br><span class="line">animation = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</span><br><span class="line">animation.toValue = [NSNumber numberWithFloat: M_PI * 30 ];</span><br><span class="line">animation.duration = 2.0;</span><br><span class="line">// 可设时间函数</span><br><span class="line">//    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">animation.cumulative = YES;</span><br><span class="line">animation.repeatCount = 0;</span><br><span class="line">animation.removedOnCompletion = NO;</span><br><span class="line">animation.fillMode = kCAFillModeForwards;</span><br><span class="line"></span><br><span class="line">[view.layer addAnimation:rotationAnimation forKey:@&quot;rotationAnimation&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CAKeyframeAnimation"><a href="#CAKeyframeAnimation" class="headerlink" title="CAKeyframeAnimation"></a>CAKeyframeAnimation</h4><ul>
<li><p>关键帧动画，同样是通过属性进行动画参数控制，但是同基础动画不同的是它可以有多个状态控制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 关键帧（就是标志位）数组，类型由keyPath确定</span><br><span class="line">@property(nullable, copy) NSArray *values;</span><br><span class="line"></span><br><span class="line">// 将时间点和关键帧（标志位）一一对应，数值为总时长的百分比，默认均分</span><br><span class="line">@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;</span><br><span class="line"></span><br><span class="line">// 每个关键帧之间的动画缓冲效果，timingFunctions.count = keyTimes.count-1</span><br><span class="line">@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;</span><br><span class="line"></span><br><span class="line">// 指定动画路径，设置此属性将忽略values等</span><br><span class="line">@property(nullable) CGPathRef path;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">double duration = 16 / 30.0;</span><br><span class="line">NSArray *keyTimes = @[@0, @((7/30.0)), @((13/30.0)), @((16/30.0))];</span><br><span class="line">CAKeyframeAnimation *sizeAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</span><br><span class="line">sizeAni.values = @[@1.0, @1.2, @0.90, @1.0];</span><br><span class="line">sizeAni.keyTimes = keyTimes;</span><br><span class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">group.animations = @[sizeAni];</span><br><span class="line">group.duration = duration;</span><br><span class="line">[view.layer addAnimation:group forKey:nil];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="CAAnimationGroup"><a href="#CAAnimationGroup" class="headerlink" title="CAAnimationGroup"></a>CAAnimationGroup</h3><ul>
<li>动画组，动画组是一种组合模式设计，可以通过动画组来进行所有动画行为的统一控制，组中所有动画效果可以并发执行。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NSArray *keyTimes = @[@0, @((7/43.0)), @((17/43.0)), @((29/43.0)), @(1)];</span><br><span class="line">CAKeyframeAnimation *sizeAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</span><br><span class="line">sizeAni.values = @[@0, @1.1, @1, @1, @1];</span><br><span class="line">sizeAni.duration = duration;</span><br><span class="line">sizeAni.keyTimes = keyTimes;</span><br><span class="line">sizeAni.repeatCount = CGFLOAT_MAX;</span><br><span class="line"></span><br><span class="line">CAKeyframeAnimation *opacityAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];</span><br><span class="line">opacityAni.values = @[@0, @1, @1, @1, @1];</span><br><span class="line">opacityAni.keyTimes = keyTimes;</span><br><span class="line"></span><br><span class="line">CAKeyframeAnimation *positionAni = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</span><br><span class="line">CGPoint centerPoint = adView.center;</span><br><span class="line">CGRect frameRect = adView.frame;</span><br><span class="line">CGPoint startPoint = CGPointMake(centerPoint.x, (frameRect.origin.y + frameRect.size.height));</span><br><span class="line">CGPoint endPoint = CGPointMake(centerPoint.x, centerPoint.y);</span><br><span class="line">NSArray *values = [NSArray arrayWithObjects:[NSValue valueWithCGPoint:startPoint], [NSValue valueWithCGPoint:endPoint],[NSValue valueWithCGPoint:endPoint], [NSValue valueWithCGPoint:endPoint], [NSValue valueWithCGPoint:endPoint], nil];</span><br><span class="line">positionAni.values = values;</span><br><span class="line">positionAni.keyTimes = keyTimes;</span><br><span class="line"></span><br><span class="line">CAAnimationGroup *group = [CAAnimationGroup animation];</span><br><span class="line">group.animations = @[sizeAni, positionAni];</span><br><span class="line">group.duration = duration;</span><br><span class="line">group.removedOnCompletion = NO;</span><br><span class="line">[adView.layer addAnimation:group forKey:@&quot;addArrowViewGroupAnimation&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h4><ul>
<li>事务的作用：保证一个或多个layer的一个或多个属性变化同时进行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[CATransaction begin];</span><br><span class="line">&#123;</span><br><span class="line">// some animaiton</span><br><span class="line">&#125;</span><br><span class="line">[CATransaction commit];</span><br><span class="line"></span><br><span class="line">[CATransaction setCompletionBlock:^&#123;</span><br><span class="line">// do something</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><p>&emsp;&emsp;不写了，除了弹簧动画需要自己测试下参数外，其它的都很简单！另外需要注意的是animate的completionblock不会引起循环引用，可放心使用！</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cocoachina.com/articles/10005" target="_blank" rel="noopener">http://www.cocoachina.com/articles/10005</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/10/08/核心动画/" data-id="ckd90jons009kxc512693k1zn" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/">UI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-UIScrollView瀑布流" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/09/26/UIScrollView瀑布流/">UIScrollView瀑布流</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/09/26/UIScrollView瀑布流/" class="article-date">
  <time datetime="2015-09-26T10:14:18.000Z" itemprop="datePublished">2015-09-26</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ul>
<li>原理：先计算出所有cell的位置，然后根据offset判断屏幕内的进行加载</li>
<li><p>JZKWaterFallView.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@class JZKWaterFallView;</span><br><span class="line">@protocol JZKWaterFallViewDelegate &lt;NSObject&gt;</span><br><span class="line">// 多少列</span><br><span class="line">- (NSInteger)numberOfCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">// 一共多少个cell</span><br><span class="line">- (NSInteger)numberOfCellsInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">// 定制cell类型</span><br><span class="line">- (UIView *)waterFallView:(JZKWaterFallView *)waterFallView cellForRowAtIndex:(NSInteger )index;</span><br><span class="line">// cell高度,可以用NSIndexPath，但我懒得整了</span><br><span class="line">- (CGFloat)waterFallView:(JZKWaterFallView *)tableView heightForRowAtIndex:(NSInteger )index;</span><br><span class="line">// 点击事件自己写吧，懒得判断UIView具体类型了</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">// 列间距</span><br><span class="line">- (CGFloat )offsetXBetweenCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">// 行间距</span><br><span class="line">- (CGFloat )offsetYBetweenLinesInWaterFallView:(JZKWaterFallView *)waterFallView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JZKWaterFallView : UIView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) id&lt;JZKWaterFallViewDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (UIView *)dequeueReusableCell;</span><br><span class="line">- (void)reloadData;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>JZKWaterFallView.m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;JZKWaterFallView.h&quot;</span><br><span class="line"></span><br><span class="line">#define kItemViewTag 6848</span><br><span class="line"></span><br><span class="line">@interface JZKWaterFallView ()&lt;UIScrollViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIScrollView *scrollView;</span><br><span class="line">@property (nonatomic, strong) UIView *contentView;</span><br><span class="line">// 各个cell的位置</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *cellFrames;</span><br><span class="line">// cell 缓冲池</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *cellCachePool;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation JZKWaterFallView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">self = [super initWithFrame:frame];</span><br><span class="line">if (self) &#123;</span><br><span class="line">[self setUpWithFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setUpWithFrame:(CGRect)frame &#123;</span><br><span class="line">CGFloat width = frame.size.width;</span><br><span class="line">CGFloat height = frame.size.height;</span><br><span class="line">_scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 0, width, height)];</span><br><span class="line">_scrollView.delegate = self;</span><br><span class="line">[self addSubview:_scrollView];</span><br><span class="line">_cellCachePool = [[NSMutableArray alloc] init];</span><br><span class="line">_cellFrames = [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)reloadData &#123;</span><br><span class="line">[self clear];</span><br><span class="line">if ([self numberOfCulumns] &gt; 0 &amp;&amp; [self numberOfCells] &gt; 0) &#123;</span><br><span class="line">[self reloadScrollView];</span><br><span class="line">CGFloat offsetY = _scrollView.contentOffset.y;</span><br><span class="line">[self refreshItemViewWithOffsetY:offsetY];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)clear &#123;</span><br><span class="line">[_contentView removeFromSuperview];</span><br><span class="line">_contentView = nil;</span><br><span class="line">[_cellFrames removeAllObjects];</span><br><span class="line">[_cellCachePool removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)reloadScrollView &#123;</span><br><span class="line">CGFloat scrollViewWidth = _scrollView.frame.size.width;</span><br><span class="line">_contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, scrollViewWidth, 200)];</span><br><span class="line">[_scrollView addSubview:_contentView];</span><br><span class="line"></span><br><span class="line">NSInteger culumnsCount = [self numberOfCulumns];</span><br><span class="line">NSInteger cellCount = [self numberOfCells];</span><br><span class="line">CGFloat offsetX = [self offsetXBetweenCulumns];</span><br><span class="line">CGFloat offsetY = [self offsetYBetweenLines];</span><br><span class="line">CGFloat cellWidth = (scrollViewWidth - (culumnsCount * offsetX))/ culumnsCount;</span><br><span class="line">CGFloat maxHeight = [self cellHeightAtIndex:0] + offsetY;</span><br><span class="line">NSMutableArray *culumnsHeight = [[NSMutableArray alloc] init];</span><br><span class="line">NSInteger targetCulumn = 0;</span><br><span class="line">for (int index = 0; index &lt; cellCount; index++) &#123;</span><br><span class="line">CGFloat cellHeight = [self cellHeightAtIndex:index];</span><br><span class="line">CGFloat originX = 0;</span><br><span class="line">CGFloat originY = 0;</span><br><span class="line">// 第一排c特殊处理</span><br><span class="line">if (index &lt; culumnsCount) &#123;</span><br><span class="line">originY = 0;</span><br><span class="line">originX = index*(cellWidth + offsetX);</span><br><span class="line">[culumnsHeight addObject:@(cellHeight + offsetY)];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">// 找到所有列中最矮的</span><br><span class="line">CGFloat minHeight = MAXFLOAT;</span><br><span class="line">for (int j = 0 ; j &lt; culumnsHeight.count; j++) &#123;</span><br><span class="line">CGFloat height = [[culumnsHeight objectAtIndex:j] floatValue];</span><br><span class="line">if (minHeight &gt; height) &#123;</span><br><span class="line">minHeight = height;</span><br><span class="line">targetCulumn = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">originY = minHeight;</span><br><span class="line">originX = targetCulumn * (cellWidth + offsetX);</span><br><span class="line">// 替换</span><br><span class="line">[culumnsHeight replaceObjectAtIndex:targetCulumn withObject:@(originY+cellHeight + offsetY)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CGRect frame = CGRectMake(originX, originY, cellWidth, cellHeight);</span><br><span class="line">NSValue *value = [NSValue valueWithCGRect:frame];</span><br><span class="line">[_cellFrames addObject:value];</span><br><span class="line"></span><br><span class="line">if (maxHeight &lt; originY + cellHeight +offsetY) &#123;</span><br><span class="line">maxHeight = originY + cellHeight +offsetY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_contentView.frame = CGRectMake(0, 0, scrollViewWidth, maxHeight);</span><br><span class="line">_scrollView.contentSize = CGSizeMake(scrollViewWidth, maxHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)refreshItemViewWithOffsetY:(CGFloat )offsetY &#123;</span><br><span class="line">for (int index = 0; index &lt; [self numberOfCells]; index++) &#123;</span><br><span class="line">NSValue *value = [_cellFrames objectAtIndex:index];</span><br><span class="line">CGRect frame = [value CGRectValue];</span><br><span class="line">// 判断是否在屏幕内</span><br><span class="line">NSInteger tag = kItemViewTag + index;</span><br><span class="line">if (frame.origin.y + frame.size.height &gt; offsetY &amp;&amp; frame.origin.y + frame.size.height &lt; offsetY + _scrollView.frame.size.height) &#123;</span><br><span class="line">if (![_contentView viewWithTag:tag]) &#123;</span><br><span class="line">UIView *view = [self cellViewForIndex:index];</span><br><span class="line">view.frame = frame;</span><br><span class="line">[_contentView addSubview:view];</span><br><span class="line">[view setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">if ([_contentView viewWithTag:tag]) &#123;</span><br><span class="line">UIView *view = [_contentView viewWithTag:tag];</span><br><span class="line">[_cellCachePool addObject:view];</span><br><span class="line">[view removeFromSuperview];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)dequeueReusableCell &#123;</span><br><span class="line">if (_cellCachePool.count &gt; 0) &#123;</span><br><span class="line">UIView *view = [_cellCachePool firstObject];</span><br><span class="line">[_cellCachePool removeObjectAtIndex:0];</span><br><span class="line">return view;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return nil;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark scrollDelegate</span><br><span class="line"></span><br><span class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;</span><br><span class="line">CGFloat offsetY = scrollView.contentOffset.y;</span><br><span class="line">[self refreshItemViewWithOffsetY:offsetY];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark getter</span><br><span class="line">- (NSInteger )numberOfCulumns &#123;</span><br><span class="line">return [self.delegate numberOfCulumnsInWaterFallView:self];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger )numberOfCells &#123;</span><br><span class="line">return [self.delegate numberOfCellsInWaterFallView:self];</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat )offsetXBetweenCulumns &#123;</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(offsetXBetweenCulumnsInWaterFallView:)]) &#123;</span><br><span class="line">return [self.delegate offsetXBetweenCulumnsInWaterFallView:self];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat )offsetYBetweenLines &#123;</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(offsetYBetweenLinesInWaterFallView:)]) &#123;</span><br><span class="line">return [self.delegate offsetYBetweenLinesInWaterFallView:self];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return 5;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat )cellHeightAtIndex:(NSInteger)index &#123;</span><br><span class="line">return [self.delegate waterFallView:self heightForRowAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)cellViewForIndex:(NSInteger )index &#123;</span><br><span class="line">return [self.delegate waterFallView:self cellForRowAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&lt;JZKWaterFallViewDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSMutableArray *heights;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">JZKWaterFallView *waterFallView = [[JZKWaterFallView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, 300)];</span><br><span class="line">waterFallView.delegate = self;</span><br><span class="line">[self.view addSubview:waterFallView];</span><br><span class="line">_heights = [[NSMutableArray alloc] init];</span><br><span class="line">for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">CGFloat height = (arc4random() % 9)*11;</span><br><span class="line">[_heights addObject:@(height)];</span><br><span class="line">&#125;</span><br><span class="line">[waterFallView reloadData];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfCellsInWaterFallView:(JZKWaterFallView *)waterFallView &#123;</span><br><span class="line">return _heights.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfCulumnsInWaterFallView:(JZKWaterFallView *)waterFallView &#123;</span><br><span class="line">return 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIView *)waterFallView:(JZKWaterFallView *)waterFallView cellForRowAtIndex:(NSInteger)index &#123;</span><br><span class="line">UILabel *label = (UILabel *)[waterFallView dequeueReusableCell];</span><br><span class="line">if (label == nil) &#123;</span><br><span class="line">label = [[UILabel alloc] init];</span><br><span class="line">&#125;</span><br><span class="line">label.text = [NSString stringWithFormat:@&quot;第%li个&quot;,(long)index];</span><br><span class="line">if (index % 2 == 0) &#123;</span><br><span class="line">label.backgroundColor = [UIColor blueColor];</span><br><span class="line">&#125;else &#123;</span><br><span class="line">label.backgroundColor = [UIColor yellowColor];</span><br><span class="line">&#125;</span><br><span class="line">return label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)waterFallView:(JZKWaterFallView *)tableView heightForRowAtIndex:(NSInteger)index &#123;</span><br><span class="line">return [[_heights objectAtIndex:index] floatValue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/09/26/UIScrollView瀑布流/" data-id="ckd90jolg003txc514ce3xdw8" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UI/">UI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-OC怎么实现多参数" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2015/09/17/OC怎么实现多参数/">OC怎么实现多参数</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2015/09/17/OC怎么实现多参数/" class="article-date">
  <time datetime="2015-09-17T10:14:18.000Z" itemprop="datePublished">2015-09-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;今天被一个问题难到了，OC怎么实现多参数？</p>
<p>&emsp;&emsp;其实我们经常用的NSArray里就有多参数的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)arrayWithObjects:(ObjectType)firstObj, ... NS_REQUIRES_NIL_TERMINATION;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;那么我们怎么自己定义多参数函数呢？几经周折找到了<a href="https://developer.apple.com/library/archive/qa/qa1405/_index.html" target="_blank" rel="noopener">官方源码</a>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line"></span><br><span class="line">@interface NSMutableArray (variadicMethodExample)</span><br><span class="line"></span><br><span class="line">- (void) appendObjects:(id) firstObject, ...; // This method takes a nil-terminated list of objects.</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSMutableArray (variadicMethodExample)</span><br><span class="line"></span><br><span class="line">- (void) appendObjects:(id) firstObject, ...</span><br><span class="line">&#123;</span><br><span class="line">id eachObject;</span><br><span class="line">va_list argumentList;</span><br><span class="line">if (firstObject) // The first argument isn&apos;t part of the varargs list,</span><br><span class="line">&#123;                                   // so we&apos;ll handle it separately.</span><br><span class="line">[self addObject: firstObject];</span><br><span class="line">va_start(argumentList, firstObject); // Start scanning for arguments after firstObject.</span><br><span class="line">while (eachObject = va_arg(argumentList, id)) // As many times as we can get an argument of type &quot;id&quot;</span><br><span class="line">[self addObject: eachObject]; // that isn&apos;t nil, add it to self&apos;s contents.</span><br><span class="line">va_end(argumentList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;要不要加NS_REQUIRES_NIL_TERMINATION ？ 我认为要加，这个宏表示最后需要一个nil，就是为了多参数准备的</p>
<p>&emsp;&emsp;stackoverflow上有个问题，也可以参考一下（其实就是省略函数名）：<a href="https://stackoverflow.com/questions/722651/how-do-i-pass-multiple-parameters-in-objective-c?r=SearchResults" target="_blank" rel="noopener">https://stackoverflow.com/questions/722651/how-do-i-pass-multiple-parameters-in-objective-c?r=SearchResults</a></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2015/09/17/OC怎么实现多参数/" data-id="ckd90jol3002vxc51rwjdn37l" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/page/9/">Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>