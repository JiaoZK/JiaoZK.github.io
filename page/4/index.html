<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">焦正奎的博客</a></h1>
      <p>不要怕！不要悔！慢慢来！</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="焦正奎的博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-LLVM入门" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/08/20/LLVM入门/">LLVM入门</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/08/20/LLVM入门/" class="article-date">
  <time datetime="2017-08-20T10:14:18.000Z" itemprop="datePublished">2017-08-20</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>&emsp;&emsp;LLVM是一个好用、好玩，而且超前的系统语言（比如C和C++语言）编译器。LLVM的<a href="http://llvm.org" target="_blank" rel="noopener">官网</a> 和 <a href="https://www.bookstack.cn/read/clang-llvm/README.md" target="_blank" rel="noopener">中文版</a>，此外初学入门可参考<a href="https://blog.csdn.net/snsn1984/column/info/llvm" target="_blank" rel="noopener">LLVM零基础学习</a>的学习思路</p>
<p>&emsp;&emsp;LLVM强大的原因：1. LLVM的“中间表示”（IR）是一项大创新。2. 模块化</p>
<p>&emsp;&emsp;Everything is a lib. Everything is a value.</p>
<p>&emsp;&emsp;LLVM的组成部分：<br><img src="http://www.aosabook.org/images/llvm/SimpleCompiler.png" alt="image"></p>
<ul>
<li>前端，获取你的源代码然后将它转变为某种中间表示。Clang其实就是前端</li>
<li>流程（Pass），将程序在中间表示之间互相变换。一般情况下，流程也用来优化代码：流程输出的（中间表示）程序和它输入的（中间表示）程序相比在功能上完全相同，只是在性能上得到改进。</li>
<li>后端，可以生成实际运行的机器码。</li>
</ul>
<p>&emsp;&emsp;LLVM 的优点主要得益于它的三层式架构 – 第一层支持多种语言作为输入(例如 C, ObjectiveC, C++ 和 Haskell)，第二层是一个共享式的优化器(对 LLVM IR 做优化处理)，第三层是许多不同的目标平台(例如 Intel, ARM 和 PowerPC)。在这三层式的架构中，如果你想要添加一门语言到 LLVM 中，那么可以把重要精力集中到第一层上，如果想要增加另外一个目标平台，那么你没必要过多的考虑输入语言。在书 The Architecture of Open Source Applications 中 LLVM 的创建者 (Chris Lattner) 写了一章很棒的内容：关于：<a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="noopener">LLVM 架构</a></p>
<p><img src="http://www.aosabook.org/images/llvm/RetargetableCompiler.png" alt="image"></p>
<h4 id="1-1-重要文档"><a href="#1-1-重要文档" class="headerlink" title="1.1 重要文档"></a>1.1 重要文档</h4><ul>
<li><a href="http://llvm.org/doxygen/" target="_blank" rel="noopener">自动生成的Doxygen文档页</a>非常重要。</li>
<li><a href="http://llvm.org/docs/index.html" target="_blank" rel="noopener">LLVM的文档</a>的<a href="https://blog.csdn.net/snsn1984/article/details/8165529" target="_blank" rel="noopener">分类简介</a>，其中<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">语言参考手册</a>也非常有用</li>
<li><a href="http://llvm.org/docs/ProgrammersManual.html" target="_blank" rel="noopener">开发者手册</a>描述了一些LLVM特有的数据结构的工具，<a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="noopener">编写LLVM流程</a></li>
<li>不过在在线浏览LLVM代码时，这个<a href="https://github.com/llvm-mirror/llvm" target="_blank" rel="noopener">GitHub镜像</a>有时会更方便。</li>
<li>推荐的入门书：《Getting Started with LLVM Core Libraries》</li>
</ul>
<h4 id="1-2-LLVM的IR"><a href="#1-2-LLVM的IR" class="headerlink" title="1.2 LLVM的IR"></a>1.2 LLVM的IR</h4><p>&emsp;&emsp;<a href="http://llvm.org/docs/LangRef.html" target="_blank" rel="noopener">LLVM IR的介绍</a>，LLVM的IR是中间文件，是通用的，便于前后端扩展。LLVM的IR主要有三种格式：一种是在内存中的编译中间语言；一种是硬盘上存储的二进制中间语言（以.bc结尾），最后一种是可读的中间格式（以.ll结尾）。这三种中间格式是完全相等的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello.c文件</span><br><span class="line"></span><br><span class="line">//得到二进制的.bc文件</span><br><span class="line">clang -emit-llvm -c hello.c -o hello.bc </span><br><span class="line"></span><br><span class="line">// 得到对应的hello.ll文件</span><br><span class="line">llvm-dis hello.bc</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;<strong>TODO: LLVM IR的语法简介</strong></p>
<h4 id="1-3-LLVM-的Pass"><a href="#1-3-LLVM-的Pass" class="headerlink" title="1.3 LLVM 的Pass"></a>1.3 LLVM 的Pass</h4><p>&emsp;&emsp;在LLVM中优化以pass形式实现,每一个pass代表一种优化,可以把每个Pass看成一个小模块，可单独使用也可组合使用。所有的Pass都是继承自Pass类的, 基本上分为两类, 一类是分析analysis pass (存放在lib/Analysis下), 负责收集信息共其它pass使用, 辅助调试或使程序可视化; 另一类是变换transform pass (存放在lib/Transforms下), 改变程序的dataflow / controlflow. LLVM中实现了几十种优化pass, 其中许多pass运行不止一次</p>
<p>&emsp;&emsp;在文档 <a href="http://llvm.org/docs/Passes.html" target="_blank" rel="noopener">http://llvm.org/docs/Passes.html</a> 中，列出了所有的PASS的命令行参数以及这个PASS主要是做什么用的，<a href="http://llvm.org/docs/doxygen/html/classllvm_1_1Pass.html" target="_blank" rel="noopener">思维导图版</a></p>
<h4 id="1-4-LLVM的源码结构"><a href="#1-4-LLVM的源码结构" class="headerlink" title="1.4 LLVM的源码结构"></a>1.4 LLVM的源码结构</h4><p>&emsp;&emsp;参考：<a href="https://blog.csdn.net/snsn1984/article/details/8170575" target="_blank" rel="noopener">https://blog.csdn.net/snsn1984/article/details/8170575</a></p>
<ul>
<li>llvm/examples 这个目录主要是一些简单例子，演示如何使用LLVM IR 和 JIT。还有建立一个简单的编译器的例子的代码。</li>
<li>llvm/include  这个目录主要包含LLVM library的公共头文件。</li>
<li>llvm/lib      这个目录包含了大部分的LLVM的源码。在LLVM中大部分的源码都是以库的形式存在的，这样不同的工具之前就很容易共用代码。</li>
<li>llvm/projects 这个目录包含着一些依赖LLVM的工程，这些工程严格来说又不算LLVM一部分。</li>
<li>llvm/runtimes 这个目录包含了一些库，这些库会编译成LLVM的bitcode，然后当clang linking 程序的时候使用。</li>
<li>llvm/test     这个目录是LLVM的测试套件，包含了很多测试用例，这些测试用例是测试LLVM的所有基本功能的。</li>
<li>llvm/tools    这个目录理是各个工具的源码，这些工具都是建立在刚才上面的那些库的基础之上的。也是主要的用户接口</li>
<li>llvm/utils    这个目录包含了一些和LLVM源码一起工作的应用。有些应用在LLVM的编译过程中是不可或缺的。</li>
</ul>
<h3 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令</h3><h4 id="3-1-基本命令"><a href="#3-1-基本命令" class="headerlink" title="3.1 基本命令"></a>3.1 基本命令</h4><ul>
<li>llvm-as 解释 LLVM assembler 汇编器</li>
<li>llvm-dis 解释 LLVM disassembler 反汇编器</li>
<li>opt 解释 LLVM optimizer 优化器</li>
<li>llc 解释 LLVM static compiler 静态编译器</li>
<li>lli 解释 directly execute programs from LLVM bitcode 直接执行LLVM 字节码</li>
<li>llvm-link 解释 LLVM bitcode linker 字节码连接器</li>
<li>llvm-ar 解释 LLVM archiver 归档器</li>
<li>llvm-nm -list LLVM bitcode and object file’s symbol table 列出LLVM字节码和目标文件中的符号表</li>
<li>llvm-config 解释 Print LLVM compilation options 打印LLVM编译选项</li>
<li>llvm-diff 解释 LLVM structual ‘diff’ LLVM结构上的diff</li>
<li>llvm-cov 解释 emit coverage information 省略覆盖信息</li>
<li>llvm-stress 解释 generate random .ll files 生成随机的.ll文件</li>
<li>llvm-symbolizer 解释 convert addresses into source code locations 把地址值转换成源代码位置</li>
</ul>
<h4 id="3-2-调试工具"><a href="#3-2-调试工具" class="headerlink" title="3.2 调试工具"></a>3.2 调试工具</h4><ul>
<li>bugpoint 解释 automatic test case reduction tool 自动测试用例下降工具</li>
<li>llvm-extract 解释 extract a function from an LLVM module 从LLVM模块中抽取一个函数</li>
<li>llvm-bcanalyzer 解释 LLVM bitcode analyzer LLVM字节码分析器</li>
</ul>
<h4 id="3-3-开发者工具"><a href="#3-3-开发者工具" class="headerlink" title="3.3 开发者工具"></a>3.3 开发者工具</h4><ul>
<li>FileCheck 解释 Flexible pattern matching file verifier 弹性模式匹配的文件验证器</li>
<li>tblgen 解释 Target Description To C++ Code Generator 目标描述到C++代码生成器</li>
<li>lit 解释 LLVM Integrated Tester LLVM集成的测试器</li>
<li>llvm-build 解释 LLVM Project Build Utility LLVM项目生成工具</li>
<li>llvm-readobj 解释 LLVM Object Reader LLVM目标文件阅读器</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://llvm.org" target="_blank" rel="noopener">官网</a> 和 <a href="https://www.bookstack.cn/read/clang-llvm/README.md" target="_blank" rel="noopener">中文版</a></li>
<li><a href="https://objccn.io/issue-6-2/" target="_blank" rel="noopener">objc中国：编译器</a></li>
<li><a href="https://blog.csdn.net/snsn1984/column/info/llvm" target="_blank" rel="noopener">LLVM零基础学习</a></li>
<li><a href="https://blog.csdn.net/snsn1984/column/info/llvm-study/3" target="_blank" rel="noopener">LLVM每日谈</a></li>
<li><a href="http://llvmweekly.org" target="_blank" rel="noopener">LLVM Weekly</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQwNDYyMg==&amp;mid=2247486617&amp;idx=2&amp;sn=646f0600f2713eab67a25adacbdbbe5c&amp;source=41#wechat_redirect" target="_blank" rel="noopener">为什么人人都该懂点LLVM</a></li>
<li><a href="https://lowlevelbits.org/getting-started-with-llvm/clang-on-os-x/" target="_blank" rel="noopener">GETTING STARTED WITH LLVM/CLANG ON OS X</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/08/20/LLVM入门/" data-id="ckd90jokn001oxc51tuskgtwd" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-防抓包策略" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/08/13/防抓包策略/">防抓包策略</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/08/13/防抓包策略/" class="article-date">
  <time datetime="2017-08-13T10:14:18.000Z" itemprop="datePublished">2017-08-13</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="charles抓包原理简介"><a href="#charles抓包原理简介" class="headerlink" title="charles抓包原理简介"></a>charles抓包原理简介</h3><p>&emsp;&emsp;简单的理解是charles是中间商赚差价！没有中间商的时候，client是和server进行三次握手，握手成功，确认了眼神就可以通信了！有charles代理时，变成了client和charles三次握手，charles拿着client的随机数，自己选个算法那给client一个假证书！client为啥认这个假证书？因为开始代理前会让用户下载并信任一个根证书，charles颁发的其他证书,默认都会被系统所信任；所以clent就和charles愉快的聊了起来；charles这个中间商又怎么和server聊上的呢？也是三次握手，charlse拿着client给的认证信息和伪造的随机数信息，跟服务器说：我就是client，跟我聊吧！服务器看到证件齐全就把数据给charlse了，charlse再通过算法和随机数就能获取到服务器的真实数据</p>
<h3 id="几种方案"><a href="#几种方案" class="headerlink" title="几种方案"></a>几种方案</h3><h4 id="1-检测是否设置代理"><a href="#1-检测是否设置代理" class="headerlink" title="1. 检测是否设置代理"></a>1. 检测是否设置代理</h4><ul>
<li><p>原理是一般抓包是通过设置手机代理的方式进行的。因此可以通过CFNetwork获取系统代理信息，如果有代理就不发请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 可参照 ASI源码ASIHTTPRequest的 configureProxies方法</span><br><span class="line">+ (BOOL)configureProxiesWithUrl:(NSURL *)url &#123;</span><br><span class="line">NSArray *proxies = nil;</span><br><span class="line">#if TARGET_OS_IPHONE</span><br><span class="line">NSDictionary *proxySettings = [NSMakeCollectable(CFNetworkCopySystemProxySettings()) autorelease];</span><br><span class="line">#else</span><br><span class="line">NSDictionary *proxySettings = [NSMakeCollectable(SCDynamicStoreCopyProxies(NULL)) autorelease];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">proxies = [NSMakeCollectable(CFNetworkCopyProxiesForURL((CFURLRef)url, (CFDictionaryRef)proxySettings)) autorelease];</span><br><span class="line"></span><br><span class="line">if (!proxies) &#123;</span><br><span class="line">// @&quot;Unable to obtain information on proxy servers needed for request&quot;</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ([proxies count] &gt; 0) &#123;</span><br><span class="line">NSDictionary *settings = [proxies objectAtIndex:0];</span><br><span class="line">if ([settings objectForKey:(NSString *)kCFProxyAutoConfigurationURLKey]) &#123;</span><br><span class="line">// PAC 暂不考虑</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">if ([[settings objectForKey:(NSString *)kCFProxyTypeKey] isEqualToString:(NSString *)kCFProxyTypeNone]) &#123;</span><br><span class="line">//没有设置代理</span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
</li>
<li>简单，核心代码就两行</li>
<li>可靠，虽然ASI已经被废弃很长时间了，但据我所知依然有部分APP（xxx金融）无法彻底摆脱对ASI的依赖，所以代码稳定性还是有保证的。</li>
<li>检测频率低，由于设置手机代理，必然离开当前APP，即当APP在前台时检测一次，网络变化时检测一次即可满足大部分需求（ASI是通过设置request的标志位类降低请求频率的）</li>
<li>缺点</li>
<li>只能检测手机是否设置代理，如果路由器也设置代理则检测不到</li>
<li>用户使用VPN和PAC自动代理，也将被认为设置代理，无法请求网络</li>
<li>检测到代理就不发送请求的处理方式，过于强势；但我没想出来更好的方案</li>
<li>有人评论相关博客说没设置代理也会提示设置了代理，<a href="https://www.jianshu.com/p/4682aecf162d?open_source=weibo_search" target="_blank" rel="noopener">链接</a>，但此博客未校验PAC文件情况（ASI检测了PAC），所以这里是个潜在风险点</li>
</ul>
<h4 id="2-https-公钥认证"><a href="#2-https-公钥认证" class="headerlink" title="2. https + 公钥认证"></a>2. https + 公钥认证</h4><ul>
<li><p>内置公钥证书，不仅校验域名,也将证书中的公钥及其他信息也进行校验</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+(AFSecurityPolicy*)customSecurityPolicy &#123;</span><br><span class="line">// 导入证书</span><br><span class="line">NSString *cerPath = [[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;cer&quot;];//证书的路径</span><br><span class="line">NSData *certData = [NSData dataWithContentsOfFile:cerPath];</span><br><span class="line">/*</span><br><span class="line">AFSSLPinningModeCertificate //证书所有字段都一样才通过认证，</span><br><span class="line">AFSSLPinningModePublicKey   //只认证公钥那一段</span><br><span class="line">AFSSLPinningModeCertificate //更安全。但是单向认证不能防止“中间人攻击”</span><br><span class="line">*/</span><br><span class="line">AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span><br><span class="line">// 如果是需要验证自建证书，需要设置为YES</span><br><span class="line">securityPolicy.allowInvalidCertificates = YES;</span><br><span class="line"></span><br><span class="line">//validatesDomainName 是否需要验证域名，默认为YES；</span><br><span class="line">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span><br><span class="line"></span><br><span class="line">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span><br><span class="line">//如置为NO，建议自己添加对应域名的校验逻辑。</span><br><span class="line">securityPolicy.validatesDomainName = YES;</span><br><span class="line">NSSet&lt;NSData*&gt; * set = [[NSSet alloc]initWithObjects:certData  , nil];</span><br><span class="line">securityPolicy.pinnedCertificates = set;</span><br><span class="line"></span><br><span class="line">return securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
</li>
<li>安全级别最高</li>
<li>相对简单，AFN都已经封装好了</li>
<li>频率低</li>
<li>缺点</li>
<li>运维和安全团队给不给公钥证书？</li>
<li>证书过期怎么办？预留接口？</li>
<li>多域名怎么处理？</li>
</ul>
<h4 id="3-CONNECT-请求方式-（无效）"><a href="#3-CONNECT-请求方式-（无效）" class="headerlink" title="3. CONNECT 请求方式 （无效）"></a>3. CONNECT 请求方式 （无效）</h4><ul>
<li>原理：把服务器作为跳板，先验证用户名和密码等信息，再让服务器代替用户去访问其它网页，之后把数据返回给用户</li>
<li>破解方法：charlse -&gt; Proxy Settings -&gt; Proxies HTTP Proxy中勾选Enable transparent HTTP proxying 来查看CONNECT请求</li>
</ul>
<h4 id="4-connectionProxyDictionary-无效"><a href="#4-connectionProxyDictionary-无效" class="headerlink" title="4. connectionProxyDictionary (无效)"></a>4. connectionProxyDictionary (无效)</h4><ul>
<li>使用NSURLSessionConfiguration的connectionProxyDictionary<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无效</span><br><span class="line">NSURLSessionConfiguration *conf = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">conf.connectionProxyDictionary = @&#123;&#125;;</span><br><span class="line">// 网上还有提出hook方案来设置connectionProxyDictionary，但也无效</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://stackoverflow.com/questions/1598109/iphone-programmatically-read-proxy-settings?r=SearchResults" target="_blank" rel="noopener">iphone programmatically read proxy settings</a></li>
<li><a href="https://segmentfault.com/q/1010000010544277" target="_blank" rel="noopener">iOS上如何防止他人抓包获取信息</a></li>
<li><a href="https://www.jianshu.com/p/4682aecf162d?open_source=weibo_search" target="_blank" rel="noopener">iOS 如何防止https抓包(中间人攻击),及charles抓包原理</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/08/13/防抓包策略/" data-id="ckd90jooh00bbxc51egi3bspp" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-APP运行理论" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/08/11/APP运行理论/">APP运行理论</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/08/11/APP运行理论/" class="article-date">
  <time datetime="2017-08-11T10:14:18.000Z" itemprop="datePublished">2017-08-11</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>转载自：<a href="https://zhidao.baidu.com/question/1370352051634002499.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1370352051634002499.html</a></p>
<p>main() 执行前发生的事<br><br>Mach-O 格式<br><br>虚拟内存基础<br><br>Mach-O 二进制的加载<br><br>理论速成<br><br>Mach-O 术语<br><br>Mach-O 是针对不同运行时可执行文件的文件类型。<br><br>文件类型：<br><br>Executable： 应用的主要二进制<br><br>Dylib： 动态链接库（又称 DSO 或 DLL）<br><br>Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。<br><br>Image： executable，dylib 或 bundle<br><br>Framework： 包含 Dylib 以及资源文件和头文件的文件夹<br><br>Mach-O 镜像文件<br><br>Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。<br><br>segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。<br><br>section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。<br><br>几乎所有 Mach-O 都包含这三个段（segment）： <strong>TEXT , </strong>DATA 和 <strong>LINKEDIT ：<br>
</strong>TEXT 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。<br><br><strong>DATA 包含全局变量，静态变量等。可读写（rw-）。<br>
</strong>LINKEDIT 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。<br><br>Mach-O Universal 文件<br><br>FAT 二进制 文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。<br><br>按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。<br><br>虚拟内存<br><br>虚拟内存就是一层间接寻址（indirection）。软件工程中有句格言就是任何问题都能通过添加一个间接层来解决。虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。<br><br>对于文件可以不用一次性读入整个文件，可以使用分页映射（ mmap() ）的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。<br><br>也就是说 Mach-O 文件中的 <strong>TEXT 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。 </strong>DATA 段是可读写的。这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean/dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。<br><br>Mach-O 镜像 加载<br><br>所以在多个进程加载 Mach-O 镜像时 <strong>TEXT 和 </strong>LINKEDIT 因为只读，都是可以共享内存的。而 <strong>DATA 因为可读写，就会产生 dirty page。当 dyld 执行结束后， </strong>LINKEDIT 就没用了，对应的内存页会被回收。<br><br>安全<br><br>ASLR（Address Space Layout Randomization）：地址空间布局随机化，镜像会在随机的地址上加载。这其实是一二十年前的旧技术了。<br><br>代码签名：可能我们认为 Xcode 会把整个文件都做加密 hash 并用做数字签名。其实为了在运行时验证 Mach-O 文件的签名，并不是每次重复读入整个文件，而是把每页内容都生成一个单独的加密散列值，并存储在 <strong>LINKEDIT 中。这使得文件每页的内容都能及时被校验确并保不被篡改。<br><br>从 exec() 到 main()<br><br>exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围 至少 是 4KB；对于 64 位进程则 至少 是 4GB。NULL 指针引用和指针截断误差都是会被它捕获。<br><br>dyld 加载 dylib 文件<br><br>Unix 的前二十年很安逸，因为那时还没有发明动态链接库。有了动态链接库后，一个用于加载链接库的帮助程序被创建。在苹果的平台里是 dyld ，其他 Unix 系统也有ld.so 。 当内核完成映射进程的工作后会将名字为 dyld 的Mach-O 文件映射到进程中的随机地址，它将 PC 寄存器设为 dyld 的地址并运行。 dyld 在应用进程中运行的工作是加载应用依赖的所有动态链接库，准备好运行所需的一切，它拥有的权限跟应用一样。<br><br>下面的步骤构成了 dyld 的时间线：<br><br>Load dylibs -&gt; Rebase -&gt; Bind -&gt; ObjC -&gt; Initializers<br><br>加载 Dylib<br><br>从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap() 。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。<br><br>Fix-ups<br><br>在加载所有的动态链接库之后，它们只是处在相互独立的状态，需要将它们绑定起来，这就是 Fix-ups。代码签名使得我们不能修改指令，那样就不能让一个 dylib 的调用另一个 dylib。这时需要加很多间接层。<br><br>现代 code-gen 被叫做动态 PIC（Position Independent Code），意味着代码可以被加载到间接的地址上。当调用发生时，code-gen 实际上会在 </strong>DATA 段中创建一个指向被调用者的指针，然后加载指针并跳转过去。<br><br>所以 dyld 做的事情就是修正（fix-up）指针和数据。Fix-up 有两种类型，rebasing 和 binding。<br><br>Rebasing 和 Binding<br><br>Rebasing：在镜像内部调整指针的指向<br><br>Binding：将指针指向镜像外部的内容<br><br>可以通过命令行查看 rebase 和 bind 等信息：<br><br>xcrun dyldinfo -rebase -bind -lazy_bind myapp.app/myapp<br></p>
<p>通过这个命令可以查看所有的 Fix-up。rebase，bind，weak_bind，lazy_bind 都存储在 <strong>LINKEDIT 段中，并可通过 LC_DYLD_INFO_ONLY 查看各种信息的偏移量和大小。<br><br>建议用 MachOView 查看更加方便直观。<br><br>从 dyld 源码层面简要介绍下 Rebasing 和 Binding 的流程。<br><br>ImageLoader 是一个用于加载可执行文件的基类，它负责链接镜像，但不关心具体文件格式，因为这些都交给子类去实现。每个可执行文件都会对应一个 ImageLoader实例。 ImageLoaderMachO 是用于加载 Mach-O 格式文件的 ImageLoader 子类，而ImageLoaderMachOClassic 和 ImageLoaderMachOCompressed 都继承于 ImageLoaderMachO ，分别用于加载那些 </strong>LINKEDIT 段为传统格式和压缩格式的 Mach-O 文件。<br><br>因为 dylib 之间有依赖关系，所以 ImageLoader 中的好多操作都是沿着依赖链递归操作的，Rebasing 和 Binding 也不例外，分别对应着 recursiveBind() 和 recursiveBind() 这两个方法。因为是递归，所以会自底向上地分别调用 doRebase() 和 doBind() 方法，这样被依赖的 dylib 总是先于依赖它的 dylib 执行 Rebasing 和 Binding。传入 doRebase() 和 doBind() 的参数包含一个 LinkContext 上下文，存储了可执行文件的一堆状态和相关的函数。<br><br>在 Rebasing 和 Binding 前会判断是否已经 Prebinding。如果已经进行过预绑定（Prebinding），那就不需要 Rebasing 和 Binding 这些 Fix-up 流程了，因为已经在预先绑定的地址加载好了。<br><br>ImageLoaderMachO 实例 不使用预绑 定会有四个原因：<br><br>Mach-O Header 中 MH_PREBOUND 标志位为 0<br><br>镜像加载地址有偏移（这个后面会讲到）<br><br>依赖的库有变化<br><br>镜像使用 flat-namespace，预绑定的一部分会被忽略<br><br>LinkContext 的环境变量禁止了预绑定<br><br>ImageLoaderMachO 中 doRebase() 做的事情大致如下：<br><br>如果使用预绑定， fgImagesWithUsedPrebinding 计数加一，并 return ;否则进入第二步<br><br>如果 MH_PREBOUND 标志位为 1 （也就是可以预绑定但没使用），且镜像在共享内存中，重置上下文中所有的 lazy pointer。（如果镜像在共享内存中，稍后会在 Binding 过程中绑定，所以无需重置）<br><br>如果镜像加载地址偏移量为0，则无需 Rebasing，直接 return ；否则进入第四步<br><br>调用 rebase() 方法，这才是真正做 Rebasing 工作的方法。如果开启 TEXT_RELOC_SUPPORT 宏，会允许 rebase() 方法对 <strong>TEXT 段做写操作来对其进行 Fix-up。所以其实 </strong>TEXT 只读属性并不是绝对的。<br><br>ImageLoaderMachOClassic 和 ImageLoaderMachOCompressed 分别实现了自己的doRebase() 方法。实现逻辑大同小异，同样会判断是否使用预绑定，并在真正的 Binding 工作时判断 TEXT_RELOC_SUPPORT 宏来决定是否对 <strong>TEXT 段做写操作。最后都会调用 setupLazyPointerHandler 在镜像中设置 dyld 的 entry point，放在最后调用是为了让主可执行文件设置好 </strong>dyld 或 <strong>program_vars 。<br><br>Rebasing<br><br>在过去，会把 dylib 加载到指定地址，所有指针和数据对于代码来说都是对的， dyld 就无需做任何 fix-up 了。如今用了 ASLR 后悔将 dylib 加载到新的随机地址(actual_address)，这个随机的地址跟代码和数据指向的旧地址(preferred_address)会有偏差，dyld 需要修正这个偏差(slide)，做法就是将 dylib 内部的指针地址都加上这个偏移量，偏移量的计算方法如下：<br><br>Slide = actual_address - preferred_address<br><br>然后就是重复不断地对 </strong>DATA 段中需要 rebase 的指针加上这个偏移量。这就又涉及到 page fault 和 COW。这可能会产生 I/O 瓶颈，但因为 rebase 的顺序是按地址排列的，所以从内核的角度来看这是个有次序的任务，它会预先读入数据，减少 I/O 消耗。<br><br>Binding<br><br>Binding 是处理那些指向 dylib 外部的指针，它们实际上被符号（symbol）名称绑定，也就是个字符串。之前提到 <strong>LINKEDIT 段中也存储了需要 bind 的指针，以及指针需要指向的符号。 dyld 需要找到 symbol 对应的实现，这需要很多计算，去符号表里查找。找到后会将内容存储到 </strong>DATA 段中的那个指针中。Binding 看起来计算量比 Rebasing 更大，但其实需要的 I/O 操作很少，因为之前 Rebasing 已经替 Binding 做过了。<br><br>ObjC Runtime<br><br>Objective-C 中有很多数据结构都是靠 Rebasing 和 Binding 来修正（fix-up）的，比如 Class 中指向超类的指针和指向方法的指针。<br><br>ObjC 是个动态语言，可以用类的名字来实例化一个类的对象。这意味着 ObjC Runtime 需要维护一张映射类名与类的全局表。当加载一个 dylib 时，其定义的所有的类都需要被注册到这个全局表中。<br><br>C++ 中有个问题叫做易碎的基类（fragile base class）。ObjC 就没有这个问题，因为会在加载时通过 fix-up 动态类中改变实例变量的偏移量。<br><br>在 ObjC 中可以通过定义类别（Category）的方式改变一个类的方法。有时你想要添加方法的类在另一个 dylib 中，而不在你的镜像中（也就是对系统或别人的类动刀），这时也需要做些 fix-up。<br><br>ObjC 中的 selector 必须是唯一的。<br><br>Initializers<br><br>C++ 会为静态创建的对象生成初始化器。而在 ObjC 中有个叫 +load 的方法，然而它被废弃了，现在建议使用 +initialize 。对比详见： <a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" target="_blank" rel="noopener">http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do</a><br><br>现在有了主执行文件，一堆 dylib，其依赖关系构成了一张巨大的有向图，那么执行初始化器的顺序是什么？自顶向上！按照依赖关系，先加载叶子节点，然后逐步向上加载中间节点，直至最后加载根节点。这种加载顺序确保了安全性，加载某个 dylib 前，其所依赖的其余 dylib 文件肯定已经被预先加载。<br><br>最后 dyld 会调用 main() 函数。 main() 会调用 UIApplicationMain() 。<br><br>改善启动时间<br><br>从点击 App 图标到加载 App 闪屏之间会有个动画，我们希望 App 启动速度比这个动画更快。虽然不同设备上 App 启动速度不一样，但启动时间最好控制在 400ms。需要注意的是启动时间一旦超过 20s，系统会认为发生了死循环并杀掉 App 进程。当然启动时间最好以 App 所支持的最低配置设备为准。直到 applicationWillFinishLaunching 被调动，App 才启动结束。<br><br>测量启动时间<br><br>Warm launch: App 和数据已经在内存中<br><br>Cold launch: App 不在内核缓冲存储器中<br><br>冷启动（Cold launch）耗时才是我们需要测量的重要数据，为了准确测量冷启动耗时，测量前需要重启设备。在 main() 方法执行前测量是很难的，好在 dyld 提供了内建的测量方法：在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 1 。控制台输出的内容如下：<br><br>Total pre-main time:228.41 milliseconds (100.0%)<br><br>dylib loading time:82.35 milliseconds (36.0%)<br><br>rebase/binding time:6.12 milliseconds (2.6%)<br><br>ObjC setup time:7.82 milliseconds (3.4%)<br><br>initializer time:132.02 milliseconds (57.8%)<br><br>slowest intializers :libSystem.B.dylib:122.07 milliseconds (53.4%)<br><br>CoreFoundation:5.59 milliseconds (2.4%)<br><br>优化启动时间<br><br>可以针对 App 启动前的每个步骤进行相应的优化工作。<br><br>加载 Dylib<br><br>之前提到过加载系统的 dylib 很快，因为有优化。但加载内嵌（embedded）的 dylib 文件很占时间，所以尽可能把多个内嵌 dylib 合并成一个来加载，或者使用 static archive。使用 dlopen() 来在运行时懒加载是不建议的，这么做可能会带来一些问题，并且总的开销更大。<br><br>Rebase/Binding<br><br>之前提过 Rebaing 消耗了大量时间在 I/O 上，而在之后的 Binding 就不怎么需要 I/O 了，而是将时间耗费在计算上。所以这两个步骤的耗时是混在一起的。<br><br>之前说过可以从查看 <strong>DATA 段中需要修正（fix-up）的指针，所以减少指针数量才会减少这部分工作的耗时。对于 ObjC 来说就是减少 Class , selector 和category 这些元数据的数量。从编码原则和设计模式之类的理论都会鼓励大家多写精致短小的类和方法，并将每部分方法独立出一个类别，其实这会增加启动时间。对于 C++ 来说需要减少虚方法，因为虚方法会创建 vtable，这也会在 </strong>DATA 段中创建结构。虽然 C++ 虚方法对启动耗时的增加要比 ObjC 元数据要少，但依然不可忽视。最后推荐使用 Swift 结构体，它需要 fix-up 的内容较少。<br><br>ObjC Setup<br><br>针对这步所能事情很少，几乎都靠 Rebasing 和 Binding 步骤中减少所需 fix-up 内容。因为前面的工作也会使得这步耗时减少。<br><br>Initializer<br><br>显式初始化<br><br>使用 +initialize 来替代 +load<br><br>不要使用 <strong>atribute</strong>((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。比如使用 dispatch_once() , pthread_once() 或 std::once() 。也就是在第一次使用时才初始化，推迟了一部分工作耗时。<br><br>隐式初始化<br><br>对于带有 复杂（non-trivial）构造器 的 C++ 静态变量：<br><br>在调用的地方使用初始化器。<br><br>只用简单值类型赋值（POD:Plain Old Data），这样静态链接器会预先计算__DATA 中的数据，无需再进行 fix-up 工作。<br><br>使用编译器 warning 标志 -Wglobal-constructors 来发现隐式初始化代码。<br><br>使用 Swift 重写代码，因为 Swift 已经预先处理好了，强力推荐。<br><br>不要在初始化方法中调用 dlopen() ，对性能有影响。因为 dyld 在 App 开始前运行，由于此时是单线程运行所以系统会取消加锁，但 dlopen() 开启了多线程，系统不得不加锁，这就严重影响了性能，还可能会造成死锁以及产生未知的后果。所以也不要在初始化器中创建线程。<br></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/08/11/APP运行理论/" data-id="ckd90jok00007xc51sgfsk63c" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他/">其他</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-卡顿优化" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/07/30/卡顿优化/">卡顿优化</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/07/30/卡顿优化/" class="article-date">
  <time datetime="2017-07-30T10:14:18.000Z" itemprop="datePublished">2017-07-30</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;iOS卡顿优化其实已经烂大街了，网上全都是各种各样的文章！所有操作无非就两件事：降低主线程工作和降低CPU工作。常用策略：</p>
<ul>
<li>少创建、更改对象</li>
<li>少用图层混合、透明、阴影、裁切</li>
<li>少用图片拉伸</li>
<li>能让小弟（子线程）干的让小弟干</li>
<li>缓存、缓存和缓存，让下一次更快速</li>
<li>提前、提前和提前，让这一次更快速</li>
</ul>
<p>&emsp;&emsp;等等等等…</p>
<p>&emsp;&emsp;但实际开发中确实：WC这个clearColor需保留，NM那个阴影不能改，神马鬼缓存更新不及时、shit提前计算有偏差…到最后就变成了：管它合适不合适，用<a href="https://www.cnblogs.com/lxlx1798/p/6933604.html" target="_blank" rel="noopener">Time Profiler</a>查出来的耗时高就改改!其它…真的不是不想改，而是不敢改、不能改甚至不愿意改</p>
<h3 id="1-优化记录"><a href="#1-优化记录" class="headerlink" title="1 优化记录"></a>1 优化记录</h3><p>&emsp;&emsp;好了，吐槽吐完了！该来的总会来，该改的也总的改，逃是逃不过去的！先水水为期2期的卡顿优化我们都干了啥</p>
<h4 id="1-推动Crab平台升级"><a href="#1-推动Crab平台升级" class="headerlink" title="1 推动Crab平台升级"></a>1 推动Crab平台升级</h4><p>&emsp;&emsp;如果我告诉你我们一半以上的卡顿都是监控卡顿的三方库造成的，你会不会很惊讶？我们也很惊讶！怪不得手百要自研APM(刚开始真的推不动以至于我们也想造轮子，但领导不同意)！因为CrabSDK集成了<a href="https://github.com/plausiblelabs/plcrashreporter" target="_blank" rel="noopener">plcrashreporter</a>直接在卡顿时进行符号化，结果就是本来是卡顿，经过plcrashreporter变成了卡死！！！当然推动SDK更新也没啥好办法，只能每天”打卡“式催进度…</p>
<p>&emsp;&emsp;其实还有BPush的SDK也很卡（想不明白一个pushSDK为啥要卡主线程）也是推动升级来解决的…</p>
<p>&emsp;&emsp;催进度过程中倒学了点经验，最最主要”别把这事当个事，也别把这事不当事！“</p>
<ol>
<li>放平心态：谁都知道能动手码代码就别废话，但这次你需要废话！所以一定要放平心态：就当是做销售练习吧</li>
<li>要有礼貌：都说理工男情商低，程序员就更不用说了！但催进度时，你不是程序员，你有求于人，所以一定要有礼貌！什么谢谢、好的、能不能、稍微啥的该上就得上！就当你社会课没上完，进行再教育呢</li>
<li>要有耐心：程序员都追求效率，恨不得能让机器干的都让机器干！这次，不好意思，你对面那个是”大爷“不是机器，你除了供着就只能等着！着急也没用</li>
</ol>
<h4 id="2-等比缩放"><a href="#2-等比缩放" class="headerlink" title="2 等比缩放"></a>2 等比缩放</h4><p>&emsp;&emsp;这个就是一个超级大坑，之前UI就推行了一套所谓的等比缩放方案，举个例子：在iphone5上展示要等比例缩放iphone6上！如果所有的都等比例缩放也许还比较好处理一点，但UI又要求左右两边间距必须是40px，只有中间内容缩放、1像素横线边框线不缩放等等，到最后的实现方案布局约束都是一个计算函数和一个找补函数。这样就带来了一堆问题</p>
<ol>
<li>频繁函数计算，特别是浮点数实时计算！</li>
<li>大量的”找补“方法，神奇数字！</li>
<li>层级复杂，为了正确显示效果，不得不增加无用图层</li>
<li>频繁刷新，layoutIfNeed满大街都是</li>
<li>复用率低，很多cell刷新是都会将subview都刷一下，防止”对不齐“</li>
<li>开发效率低</li>
</ol>
<p>&emsp;&emsp;结合以上问题，试验了几种方法</p>
<h4 id="2-1-异步渲染内容到图片"><a href="#2-1-异步渲染内容到图片" class="headerlink" title="2.1 异步渲染内容到图片"></a>2.1 异步渲染内容到图片</h4><p>&emsp;&emsp;参考：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a>注意Dome中可能会出现几十个线程卡顿问题，那是因为global最多也就64个线程，超了就卡了</p>
<ul>
<li>好处：1、充分利用GPU和CPU； 2、减少view层级</li>
<li>坏处：1、代码较多； 2、预先计算，增加VM层；</li>
<li>结论：被弃！修改起来成本较高，后续新增可考虑</li>
</ul>
<h4 id="2-2-类似微信读配置文件"><a href="#2-2-类似微信读配置文件" class="headerlink" title="2.2 类似微信读配置文件"></a>2.2 类似微信读配置文件</h4><ul>
<li>好处：1、灵活，以后可以做调整字体需求；2、避免复杂实时计算</li>
<li>坏处：1、配置文件和view的映射关系复杂；2、复杂约束难以表达；3、调试麻烦</li>
<li>结论：被弃！因为开发调试实在是太麻烦了，重构一个简单的小页面都累死个人</li>
</ul>
<h4 id="2-3-折中方案"><a href="#2-3-折中方案" class="headerlink" title="2.3 折中方案"></a>2.3 折中方案</h4><ol>
<li>绝大多数model因打点需求都包含id字段，可重写isEqual来判断model是否改变来减少刷新次数</li>
<li>将cell刷新方法拆分refreshContent和refreshFrame两个，将cell分类，对更新数据源只调整显示不调整frame的cell高度进行缓存并只调动refreshContent</li>
<li>将大部分的layoutIfNeed替换成setNeedsLayout</li>
<li>小部分cell采用异步渲染到图片的方案：例如公告轮播、导航条</li>
</ol>
<h4 id="3-局部刷新"><a href="#3-局部刷新" class="headerlink" title="3 局部刷新"></a>3 局部刷新</h4><p>&emsp;&emsp;简单的说就几条</p>
<ol>
<li>tablview等只刷新标记需要刷新的cell。我们采用的方式是通过新旧数据源isEqual来判断哪些cell需要刷新，另外允许cell改变自身数据源时回调tableview刷新自己</li>
<li>基金排行等类似页面巧用childViewController来延迟加载延迟刷新</li>
<li>hidden VS 懒加载，我个人认为不涉及到约束改变使用懒加载，涉及到约束更改用hidden！例如登录和未登录的头部信息，完全互斥，以前代码是都加载通过hidden来处理，现在改成了懒加载！毕竟一般人不会来回登录着玩，登录了十几天也不一定退一次</li>
</ol>
<h4 id="4-按需加载被废弃"><a href="#4-按需加载被废弃" class="headerlink" title="4 按需加载被废弃"></a>4 按需加载<del>被废弃</del></h4><p>&emsp;&emsp;废弃原因：PM和领导觉得一共也没多少数据还显示默认图不能接受！而且没有上拉加载更多，这个功能比较鸡肋…</p>
<p>&emsp;&emsp;一样可参考：<a href="https://github.com/johnil/VVeboTableViewDemo" target="_blank" rel="noopener">VVeboTableViewDemo</a>，核心原理就是检测滑动状态，只加载用户可见范围的cell</p>
<ol>
<li>可见cell的定义，需根据手机屏幕大小进行自定义，但这会增加代码复杂度</li>
<li>快速滑动可能出现白屏，建议用”默认图“代替</li>
<li>像首页这种多接口内容拼接而成并且支持服务端排序的页面不合适</li>
</ol>
<h4 id="5-资源同步改异步"><a href="#5-资源同步改异步" class="headerlink" title="5 资源同步改异步"></a>5 资源同步改异步</h4><ol>
<li>竟然在mian使用dataWithContentsOfURL方法同步下载头像！着实吓了我一跳，犹豫半天问了好几圈才敢改代码</li>
<li>使用imageNamed方法批量加载小图片（48个），imageNamed方法一般情况下还是很好用的，但像这种批量加载小图片还是建议异步使用imageWithContentsOfFile方法然后NSArray内存缓存的方式实现</li>
</ol>
<h4 id="6-少用-synchronized，少在主线程深拷贝"><a href="#6-少用-synchronized，少在主线程深拷贝" class="headerlink" title="6 少用@synchronized，少在主线程深拷贝"></a>6 少用@synchronized，少在主线程深拷贝</h4><p>&emsp;&emsp;在使用Time Profiler检查耗时时，无意中发现项目里大量用了@synchronized锁，甚至很多锁都是不必要的，例如明显上下文都在主线程里也要加上@synchronized锁来确保安全。这个问题我在例会上提出来之后，也没人能解释为什么，估计就是历史遗留问题了！当然处理起来比较麻烦，因为不知道为什么，降级措施也不好处理，最终我也只去掉了3个锁的使用</p>
<p>&emsp;&emsp;几乎伴随着锁的就是在主线程中进行深拷贝，而且是整个页面数据的深拷贝！也许是为了安全，但确实有些烂用了，没必要addObject之类的操作都要深拷贝一份再操作</p>
<h4 id="7-减少图层混合"><a href="#7-减少图层混合" class="headerlink" title="7 减少图层混合"></a>7 减少图层混合</h4><p>&emsp;&emsp;推荐策略</p>
<ul>
<li>设opaque为YES、</li>
<li>设backgroundColor和父视图颜色一致且不透明、</li>
<li>不设 &lt;1 的alpha值</li>
<li>确保UIImage没有alpha通道</li>
</ul>
<p>&emsp;&emsp;怎么检测图层混合</p>
<ol>
<li>模拟器debug中color blended layers红色区域表示图层发生了混合</li>
<li>真机上Instrument-选中Core Animation-勾选Color Blended Layers</li>
</ol>
<p>&emsp;&emsp;注意事项：这个确实是体力活，更是个细心活，一定要注意上下文环境</p>
<h4 id="8-图片的使用"><a href="#8-图片的使用" class="headerlink" title="8 图片的使用"></a>8 图片的使用</h4><p>&emsp;&emsp;最麻烦的其实是找UI要图…提前准备好挨批的准备</p>
<ol>
<li>图片缩放问题，对于高频图片采用重绘方式避免重复拉伸。对低频拉伸图片争取让UI给合适大小的图</li>
<li>阴影和圆角都尽可能找图片代替</li>
<li>尽量使用png</li>
<li>尽量使用SD下载网络图片，因为SD已经在子线程解码图片</li>
</ol>
<h3 id="2-监控"><a href="#2-监控" class="headerlink" title="2 监控"></a>2 监控</h3><p>&emsp;&emsp;其实一开始不想写这个的！卡顿监控方案已经烂大街了，而且这种重复造轮子的算不得KPI（虽然crab这个破轮子卡的都快不能跑了）！但是PM说没感觉有什么太大效果，这个就不能忍了！</p>
<h4 id="1-runloop"><a href="#1-runloop" class="headerlink" title="1 runloop"></a>1 runloop</h4><p>&emsp;&emsp;这个算上市面上最通用的方案了，参考：<a href="http://www.tanhao.me/code/151113.html/" target="_blank" rel="noopener">iOS实时卡顿监控</a>，里面写的非常详细！核心思路：主线程绝大部分计算或者绘制任务都是以Runloop为单位发生。NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources和kCFRunLoopBeforeWaiting之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)</span><br><span class="line">&#123;</span><br><span class="line">MyClass *object = (__bridge MyClass*)info;</span><br><span class="line"></span><br><span class="line">// 记录状态值</span><br><span class="line">object-&gt;activity = activity;</span><br><span class="line"></span><br><span class="line">// 发送信号</span><br><span class="line">dispatch_semaphore_t semaphore = moniotr-&gt;semaphore;</span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;</span><br><span class="line">- (void)registerObserver</span><br><span class="line">&#123;</span><br><span class="line">CFRunLoopObserverContext context = &#123;0,(__bridge void*)self,NULL,NULL&#125;;</span><br><span class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreate(kCFAllocatorDefault,</span><br><span class="line">kCFRunLoopAllActivities,</span><br><span class="line">YES,</span><br><span class="line">0,</span><br><span class="line">&amp;runLoopObserverCallBack,</span><br><span class="line">&amp;context);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopCommonModes);</span><br><span class="line"></span><br><span class="line">// 创建信号</span><br><span class="line">semaphore = dispatch_semaphore_create(0);</span><br><span class="line"></span><br><span class="line">// 在子线程监控时长</span><br><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">while (YES)</span><br><span class="line">&#123;</span><br><span class="line">// 假定连续5次超时50ms认为卡顿(当然也包含了单次超时250ms)</span><br><span class="line">long st = dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 50*NSEC_PER_MSEC));</span><br><span class="line">if (st != 0)</span><br><span class="line">&#123;</span><br><span class="line">if (activity==kCFRunLoopBeforeSources || activity==kCFRunLoopAfterWaiting)</span><br><span class="line">&#123;</span><br><span class="line">if (++timeoutCount &lt; 5)</span><br><span class="line">continue;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;好像有点儿卡哦&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">timeoutCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;需要注意的</p>
<ol>
<li>dome里使用PLCrashReporter进行符号化会很卡</li>
<li>卡顿只dump主线程调用栈就可以了</li>
<li>调用栈也许有”延迟“</li>
</ol>
<h4 id="2-子线程"><a href="#2-子线程" class="headerlink" title="2 子线程"></a>2 子线程</h4><p>&emsp;&emsp;这个思路及很有意思，简单的说就是不断的用子线程去主线程去撞：我打你一拳，你踢我一脚。过段时间你没踢我，你有问题！可参考：<a href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&amp;mid=2650264136&amp;idx=1&amp;sn=052c1db8131d4bed8458b98e1ec0d5b0&amp;chksm=f406837dc3710a6b49e76ce3639f671373b553e8a91b544e82bb8747e9adc7985fea1093a394#rd" target="_blank" rel="noopener">iOS应用UI线程卡顿监控</a> , PS: 获取调用栈我觉得直接用<a href="https://github.com/plausiblelabs/plcrashreporter" target="_blank" rel="noopener">plcrashreporter</a>就好，plcrashreporter的核心原理：新期一个线程A，挂起除A外的所有线程，dump调用栈！另外对符号化感兴趣的，请阅读<a href="https://blog.csdn.net/abc649395594/article/details/52350426" target="_blank" rel="noopener">获取任意线程调用栈的那些事</a> 和 <a href="https://www.jianshu.com/p/29051908c74b" target="_blank" rel="noopener">iOS Crash 捕获及堆栈符号化思路剖析</a></p>
<p>&emsp;&emsp;一个swift版的三方库可做参考：<a href="https://github.com/zixun/ANREye" target="_blank" rel="noopener">ANREye</a></p>
<h4 id="3-组合拳"><a href="#3-组合拳" class="headerlink" title="3 组合拳"></a>3 组合拳</h4><p>&emsp;&esmp;参考<a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ%3D%3D&amp;idx=1&amp;mid=207890859&amp;scene=23&amp;sn=e98dd604cdb854e7a5808d2072c29162&amp;srcid=0921FzoCw9j1W7n4uFYKuarC#rd" target="_blank" rel="noopener">微信iOS卡顿监控系统</a>，微信这个思路很全面，runloop、CPU、FPS都监控，[代码]<a href="https://aozhimin.github.io/iOS-Monitor-Platform/)如下：" target="_blank" rel="noopener">https://aozhimin.github.io/iOS-Monitor-Platform/)如下：</a></p>
<h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark CPU</span><br><span class="line">// cpu利用率</span><br><span class="line">+ (CGFloat)cpuUsage &#123;</span><br><span class="line">kern_return_t kr;</span><br><span class="line">task_info_data_t tinfo;</span><br><span class="line">mach_msg_type_number_t task_info_count;</span><br><span class="line"></span><br><span class="line">task_info_count = TASK_INFO_MAX;</span><br><span class="line">kr = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thread_array_t         thread_list;</span><br><span class="line">mach_msg_type_number_t thread_count;</span><br><span class="line"></span><br><span class="line">thread_info_data_t     thinfo;</span><br><span class="line">mach_msg_type_number_t thread_info_count;</span><br><span class="line"></span><br><span class="line">thread_basic_info_t basic_info_th;</span><br><span class="line"></span><br><span class="line">// get threads in the task</span><br><span class="line">kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long total_time     = 0;</span><br><span class="line">long total_userTime = 0;</span><br><span class="line">CGFloat total_cpu   = 0;</span><br><span class="line">int j;</span><br><span class="line"></span><br><span class="line">// for each thread</span><br><span class="line">for (j = 0; j &lt; (int)thread_count; j++) &#123;</span><br><span class="line">thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">kr = thread_info(thread_list[j], THREAD_BASIC_INFO,</span><br><span class="line">(thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">if (kr != KERN_SUCCESS) &#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line"></span><br><span class="line">if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">total_time     = total_time + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">total_userTime = total_userTime + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">total_cpu      = total_cpu + basic_info_th-&gt;cpu_usage / (float)TH_USAGE_SCALE * 100.0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));</span><br><span class="line">assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">return total_cpu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CPU核数</span><br><span class="line">+ (NSUInteger)cpuNumber &#123;</span><br><span class="line">return [NSProcessInfo processInfo].processorCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//// CPU类型</span><br><span class="line">//+ (NSString *)cpuType &#123;</span><br><span class="line">//    host_basic_info_data_t hostInfo;</span><br><span class="line">//    mach_msg_type_number_t infoCount;</span><br><span class="line">//    infoCount = HOST_BASIC_INFO_COUNT;</span><br><span class="line">//    host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&amp;hostInfo, &amp;infoCount);</span><br><span class="line">//    switch (hostInfo.cpu_type) &#123;</span><br><span class="line">//        case CPU_TYPE_ARM64:</span><br><span class="line">//            return @&quot;ARM64&quot;;</span><br><span class="line">//            break;</span><br><span class="line">//            </span><br><span class="line">//        default:</span><br><span class="line">//            return @&quot;unknown&quot;;</span><br><span class="line">//            break;</span><br><span class="line">//    &#125;</span><br><span class="line">//&#125;</span><br></pre></td></tr></table></figure>
<h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 内存相关</span><br><span class="line">// 当前进程内存</span><br><span class="line">+ (long long)appUsedMemory &#123;</span><br><span class="line">struct mach_task_basic_info info;</span><br><span class="line">mach_msg_type_number_t count = MACH_TASK_BASIC_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">int r = task_info(mach_task_self(), MACH_TASK_BASIC_INFO, (task_info_t)&amp; info, &amp; count);</span><br><span class="line">if (r == KERN_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">return info.resident_size/MBSize;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 物理内存</span><br><span class="line">+ (long long)physicalMemory &#123;</span><br><span class="line">return [NSProcessInfo processInfo].physicalMemory/MBSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 当前设备已用内存</span><br><span class="line">+ (long long)deviceUsedMemory&#123;</span><br><span class="line">size_t length = 0;</span><br><span class="line">int mib[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int pagesize = 0;</span><br><span class="line">mib[0] = CTL_HW;</span><br><span class="line">mib[1] = HW_PAGESIZE;</span><br><span class="line">length = sizeof(pagesize);</span><br><span class="line">if (sysctl(mib, 2, &amp;pagesize, &amp;length, NULL, 0) &lt; 0)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_msg_type_number_t count = HOST_VM_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">vm_statistics64_data_t vmstat;</span><br><span class="line"></span><br><span class="line">if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int wireMem = vmstat.wire_count * pagesize;</span><br><span class="line">int activeMem = vmstat.active_count * pagesize;</span><br><span class="line">return (wireMem + activeMem)/MBSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 当前设备可用内存</span><br><span class="line">+ (long long)deviceFreeMemory &#123;</span><br><span class="line">size_t length = 0;</span><br><span class="line">int mib[6] = &#123;0&#125;;</span><br><span class="line"></span><br><span class="line">int pagesize = 0;</span><br><span class="line">mib[0] = CTL_HW;</span><br><span class="line">mib[1] = HW_PAGESIZE;</span><br><span class="line">length = sizeof(pagesize);</span><br><span class="line">if (sysctl(mib, 2, &amp;pagesize, &amp;length, NULL, 0) &lt; 0) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_msg_type_number_t count = HOST_VM_INFO_COUNT;</span><br><span class="line"></span><br><span class="line">vm_statistics64_data_t vmstat;</span><br><span class="line"></span><br><span class="line">if (host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmstat, &amp;count) != KERN_SUCCESS)&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int freeMem = vmstat.free_count * pagesize;</span><br><span class="line">int inactiveMem = vmstat.inactive_count * pagesize;</span><br><span class="line"></span><br><span class="line">return (freeMem + inactiveMem)/MBSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">- (id)init &#123;</span><br><span class="line">self = [super init];</span><br><span class="line">if( self )&#123;</span><br><span class="line">[self setup];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark FPS</span><br><span class="line"></span><br><span class="line">- (void)setup &#123;</span><br><span class="line">_updateInterval = 0.5f;</span><br><span class="line">_historyCount = 0;</span><br><span class="line">_historySum = 0;</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver: self</span><br><span class="line">selector: @selector(applicationWillResignActiveNotification)</span><br><span class="line">name: UIApplicationWillResignActiveNotification</span><br><span class="line">object: nil];</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver: self</span><br><span class="line">selector: @selector(applicationDidBecomeActiveNotification)</span><br><span class="line">name: UIApplicationDidBecomeActiveNotification</span><br><span class="line">object: nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)startDisplayLink &#123;</span><br><span class="line">_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(displayLinkProc)];</span><br><span class="line">[_displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)stopDisplayLink &#123;</span><br><span class="line">[_displayLink setPaused:YES];</span><br><span class="line">[_displayLink removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];</span><br><span class="line">[_displayLink invalidate];</span><br><span class="line">_displayLink = nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActiveNotification &#123;</span><br><span class="line">[self.displayLink setPaused:NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationWillResignActiveNotification &#123;</span><br><span class="line">[self.displayLink setPaused:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不准有延迟</span><br><span class="line">- (void)displayLinkProc &#123;</span><br><span class="line">_historyCount += _displayLink.frameInterval;</span><br><span class="line"></span><br><span class="line">CFTimeInterval interval = _displayLink.timestamp - _lastTime;</span><br><span class="line">if( interval &gt;= _updateInterval ) &#123;</span><br><span class="line">_lastTime = _displayLink.timestamp;</span><br><span class="line">// 回调上层刷新展示</span><br><span class="line">NSUInteger fps = (NSUInteger)(_historyCount / interval);</span><br><span class="line">if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(frezingCheker:currentFPS:)]) &#123;</span><br><span class="line">[self.delegate frezingCheker:self currentFPS:fps];</span><br><span class="line">&#125;</span><br><span class="line">_fps = fps;</span><br><span class="line">_historyCount = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">[self stopDisplayLink];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></li>
<li><a href="https://aozhimin.github.io/iOS-Monitor-Platform/" target="_blank" rel="noopener">https://aozhimin.github.io/iOS-Monitor-Platform/</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/07/30/卡顿优化/" data-id="ckd90jomr0071xc51eybipx5e" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能/">性能</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-观呼吸" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/07/27/观呼吸/">观呼吸</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/07/27/观呼吸/" class="article-date">
  <time datetime="2017-07-27T10:14:18.000Z" itemprop="datePublished">2017-07-27</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ul>
<li>前面三分之一都在讲禅修是什么！不是什么!总结三句话：1，管你屁事、管我屁事、有这屁事； 2， 既来之，则安之</li>
<li>一旦坐下，就不要任意改变姿势！盘腿是为了不抖腿！坐定之后，闭上眼睛，我们的心就好像一杯浑浊的水，装着浊水的杯子静置时间越久，泥沙就越能沉淀下来</li>
<li>没有对象，心就不可能集中。将心集中在呼吸之上，深呼吸三次，三次深呼吸之后，恢复正常的呼吸，让你的呼吸自由的进出，再轻松的将你的注意力集中在鼻孔边缘。单纯注意呼吸进出的感觉：在吸完气即将把期呼出之前，有一个短暂的停顿，注意它，并且注意呼气的开始。在呼完气即将吸气进来之前，又有另一个短暂的停顿，同样也注意这个短暂的停顿。别瞎想，别说话，别瞎听，只专注于呼吸。</li>
<li>当心跑开时，马上以正念拉回来，增长定力的措施：数息，呼气数数，吸气数数；</li>
<li>最重要的原则是：坐的时候背要挺直，脊椎要像一叠铜板一样，一个顶一个，让脊柱直立起来，但不应造成肌肉紧张，头则要与脊柱保持一条直线，身体的其余部位则松软的垂挂在脊柱上。这些都必须在放松的状态下进行，不要僵硬。</li>
<li>选择软硬适度的坐垫，选择舒服的衣服，选择舒适的坐姿(单盘，双盘或不盘)，双手重叠放于膝上，目标就是希望身体完全不动，但不能睡着</li>
<li>三次深呼吸之后是自然的呼吸，应该去感受呼吸，而不是控制呼吸，除非你在数息</li>
<li>别思考也别睡着，别着急也别放任</li>
<li>在禅修中，我们靠的是精进，而非蛮力。我们唯一能做到努力就是温和而耐心地保持注意力</li>
<li>必须熊排除自怨自艾与自责着手</li>
</ul>
<p>怎样处理禅修中的问题？<br>问题一：身体的疼痛<br>消除疼痛、治疗，或把疼痛作为禅修对象、检查坐垫、调整坐姿、松开衣物。</p>
<p>问题二：腿失去知觉<br>双腿发麻是由神经压迫而引起，你不会因为坐姿而伤害到腿部组织的。当腿失去知觉，你只要观察这个现象即可。禅修一段时间之后，麻痹感会逐渐消失。</p>
<p>问题三：奇特的感觉<br>当你达到放松时，神经系统只是开始更有效率地让感官信号通过。大量先前受阻的感官信号如今可以畅行无阻，因而引发各种独特的感受。它没有任何特别的意义，就只是感受而已，因此只要使用平常的技巧即可。看着它生起，再看着它消失，不要被牵扯进去。</p>
<p>问题四：昏沉<br>不要对睡眠让步。如果你很想睡就深吸气，憋得愈久愈好，然后再慢慢吐出来。接着再深吸一口气，然后尽量憋住，再慢慢吐出来。反复这么做，直到你的身体温暖起来，睡意全消为止。接着，再回到呼吸上。</p>
<p>问题五：无法专注<br>在禅修前解决手边的纷争。如果解决不了，坚持禅修，不去理会问题，放下自我中心。</p>
<p>问题六：无聊<br>1、重新建立真实的正念；<br>正念看每一刻就像是这世上的第一次与唯一的一次。因此，再看一次。<br>2、观察你的心态。<br>注意看你无聊的状态。什么是无聊？无聊在哪里？它感觉像什么？它的成分是什么？它有任何生理上的感受吗？它对你的思维过程有什么作用？重新检视无聊，就像你以前从来不曾经历过那种状态一样。</p>
<p>问题七：恐惧<br>你可能在潜意识里设定了一个“检查即将发生的事”的程序。因此，当一个令人害怕的幻想出现时，定力就会锁定它，而幻想就以你专注的能量为食，并且成长。不要对抗恐惧，置身事外，让它自来自去。它只是幻想。</p>
<p>问题八：太勉强<br>不要急于看到结果，不要有太强烈的期待。只要以稳定而平衡的努力进行禅修即可。享受禅修，不要让它变成一个苦差或负担。</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/07/27/观呼吸/" data-id="ckd90joob00awxc519ixeakvd" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-消除项目警告" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/07/22/消除项目警告/">消除项目警告</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/07/22/消除项目警告/" class="article-date">
  <time datetime="2017-07-22T10:14:18.000Z" itemprop="datePublished">2017-07-22</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-修复方法"><a href="#1-修复方法" class="headerlink" title="1 修复方法"></a>1 修复方法</h3><h4 id="1-1-Unused-Entity-Issues"><a href="#1-1-Unused-Entity-Issues" class="headerlink" title="1.1 Unused Entity Issues"></a>1.1 Unused Entity Issues</h4><ul>
<li>定了了但没使用的变量，解决方案：判断上下文，如果真没用到就注掉，最好别删掉</li>
</ul>
<h4 id="1-2-User-Defined-Issue"><a href="#1-2-User-Defined-Issue" class="headerlink" title="1.2 User-Defined Issue"></a>1.2 User-Defined Issue</h4><ul>
<li>自定义警告，看看是不是TODO？是不是可以用NSAssert代替？</li>
</ul>
<h4 id="1-3-Lexical-or-Preprocessor-Issue"><a href="#1-3-Lexical-or-Preprocessor-Issue" class="headerlink" title="1.3 Lexical or Preprocessor Issue"></a>1.3 Lexical or Preprocessor Issue</h4><ul>
<li>以前xcode传入weak对象会有警告，RAC就在里面做了屏蔽，现在xcode已经没有警告了！</li>
</ul>
<h4 id="1-4-Format-String-Issue"><a href="#1-4-Format-String-Issue" class="headerlink" title="1.4 Format String Issue"></a>1.4 Format String Issue</h4><ul>
<li>格式化字符串的警告！处理办法，点击警告，使用xcod推荐的格式</li>
</ul>
<h4 id="1-5-Apple-Mach-O-Linker-Id-Warning"><a href="#1-5-Apple-Mach-O-Linker-Id-Warning" class="headerlink" title="1.5 Apple Mach-O Linker (Id) Warning"></a>1.5 Apple Mach-O Linker (Id) Warning</h4><ul>
<li>文件夹路径或Framework路径报错</li>
<li>1，Click on your project (targets)；2， Click on Build Settings</li>
<li>if your error includes the -L flag, then delete the values in Library Search Paths</li>
<li>if your error includes the -F flag, then delete the values in Framework Search Paths</li>
<li>参考：<br><a href="https://stackoverflow.com/questions/9458739/ld-warning-directory-not-found-for-option?noredirect=1&amp;lq=1" target="_blank" rel="noopener">https://stackoverflow.com/questions/9458739/ld-warning-directory-not-found-for-option?noredirect=1&amp;lq=1</a></li>
</ul>
<h4 id="1-6-Deprecations"><a href="#1-6-Deprecations" class="headerlink" title="1.6 Deprecations"></a>1.6 Deprecations</h4><ul>
<li>已经废弃的方法</li>
<li>处理办法：使用推荐方法替换</li>
</ul>
<h4 id="1-7-semantic-issue"><a href="#1-7-semantic-issue" class="headerlink" title="1.7 semantic issue"></a>1.7 semantic issue</h4><ul>
<li>语法问题</li>
<li>根据警告添加、修改或注释相关方法</li>
</ul>
<h4 id="1-8-Unsupported-Configuration"><a href="#1-8-Unsupported-Configuration" class="headerlink" title="1.8 Unsupported Configuration"></a>1.8 Unsupported Configuration</h4><ul>
<li><a href="https://stackoverflow.com/questions/26547399/xcode-storyboard-warning-constraint-referencing-items-turned-off-in-current-con" target="_blank" rel="noopener">https://stackoverflow.com/questions/26547399/xcode-storyboard-warning-constraint-referencing-items-turned-off-in-current-con</a></li>
<li><a href="https://blog.csdn.net/phantom2000x/article/details/56008709" target="_blank" rel="noopener">https://blog.csdn.net/phantom2000x/article/details/56008709</a></li>
<li><a href="https://stackoverflow.com/questions/13531035/xcode-scene-is-unreachable-due-to-lack-of-entry-points-but-cant-find-it" target="_blank" rel="noopener">https://stackoverflow.com/questions/13531035/xcode-scene-is-unreachable-due-to-lack-of-entry-points-but-cant-find-it</a></li>
</ul>
<h4 id="1-9-SB的push方法"><a href="#1-9-SB的push方法" class="headerlink" title="1.9 SB的push方法"></a>1.9 SB的push方法</h4><ul>
<li><a href="https://stackoverflow.com/questions/26417175/xcode-6-push-segues-are-deprecated-in-ios-8-0-and-later" target="_blank" rel="noopener">https://stackoverflow.com/questions/26417175/xcode-6-push-segues-are-deprecated-in-ios-8-0-and-later</a></li>
</ul>
<h4 id="1-10-Validate-Project-Settings"><a href="#1-10-Validate-Project-Settings" class="headerlink" title="1.10 Validate Project Settings"></a>1.10 Validate Project Settings</h4><ul>
<li>配置文件更新到ios8</li>
<li><a href="https://blog.csdn.net/isharestudio/article/details/20462737" target="_blank" rel="noopener">https://blog.csdn.net/isharestudio/article/details/20462737</a></li>
<li><a href="https://stackoverflow.com/questions/9612226/any-way-to-make-validate-project-settings-warning-go-away-in-xcode-4-3-4-3-1" target="_blank" rel="noopener">https://stackoverflow.com/questions/9612226/any-way-to-make-validate-project-settings-warning-go-away-in-xcode-4-3-4-3-1</a></li>
</ul>
<h3 id="2-屏蔽方法"><a href="#2-屏蔽方法" class="headerlink" title="2 屏蔽方法"></a>2 屏蔽方法</h3><h4 id="2-1-屏蔽某个警告"><a href="#2-1-屏蔽某个警告" class="headerlink" title="2.1 屏蔽某个警告"></a>2.1 屏蔽某个警告</h4><ul>
<li><p>相关命令获取方式：<br>run -&gt; 找到对应警告 -&gt; 右击 -&gt; reveal in log -&gt; 找到一些带框的标识 [-Wunused-variable]   [-Wenum-conversion]    [-Wbool-conversion]，[]之中的就是关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clang diagnostic 是#pragma 第一个常用命令：</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;关键字&quot;</span><br><span class="line">// 你自己的代码</span><br><span class="line">#pragma clang diagnostic pop</span><br></pre></td></tr></table></figure>
</li>
<li><p>参考：<a href="https://blog.csdn.net/zww1984774346/article/details/53409033" target="_blank" rel="noopener">https://blog.csdn.net/zww1984774346/article/details/53409033</a></p>
</li>
</ul>
<h4 id="2-2-屏蔽某个文件的所有警告（慎用）"><a href="#2-2-屏蔽某个文件的所有警告（慎用）" class="headerlink" title="2.2 屏蔽某个文件的所有警告（慎用）"></a>2.2 屏蔽某个文件的所有警告（慎用）</h4><ul>
<li>target -&gt; Build Phases -&gt; 搜到你要的文件 -&gt; compiler Flages -&gt; -w</li>
</ul>
<h4 id="2-3-屏蔽cocoapod的警告"><a href="#2-3-屏蔽cocoapod的警告" class="headerlink" title="2.3 屏蔽cocoapod的警告"></a>2.3 屏蔽cocoapod的警告</h4><ul>
<li>在Profile文件中添加如下代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 1. 先用 inhibit_all_warnings!标志位</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line">// 2. 涉及雄兼容可用如下方法</span><br><span class="line">post_install do |installer|</span><br><span class="line">installer.pods_project.targets.each do |target|</span><br><span class="line">target.build_configurations.each do |config|</span><br><span class="line">if config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;].to_f &lt; 8.0</span><br><span class="line">config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;] = &apos;8.0&apos;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-把所有警告当做错误"><a href="#3-把所有警告当做错误" class="headerlink" title="3 把所有警告当做错误"></a>3 把所有警告当做错误</h3><ul>
<li>Build Setting -&gt; 搜treat -&gt; 把Treat Warning as Error的值为YES</li>
</ul>
<h3 id="4-监控？"><a href="#4-监控？" class="headerlink" title="4 监控？"></a>4 监控？</h3><p>&emsp;&emsp;说实话，我想来想去也没想到除了Treat Warning as Error有什么好的监控方案</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/07/22/消除项目警告/" data-id="ckd90joo100a5xc51ofoe8e93" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-子线程绘制UI检查工具" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/07/07/子线程绘制UI检查工具/">子线程绘制UI检查工具</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/07/07/子线程绘制UI检查工具/" class="article-date">
  <time datetime="2017-07-07T10:14:18.000Z" itemprop="datePublished">2017-07-07</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>&emsp;&emsp;今天UI走查，对样式进行了大量修改，但改完后一个view的背景色等总是慢半拍！一开始没注意到这个问题，直到UI童鞋给我提了BUG…</p>
<h4 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h4><ol>
<li>是不是网络延迟的事？改为写死颜色值！结论：复现</li>
<li>是不是动画造成的？删除相关动画，保留基础代码！结论：复现</li>
<li>打点后查看日志，发现 Main Thread Checker: UI API called on a background thread ，子线程渲染UI！改为主线程刷新，解决问题！</li>
</ol>
<h4 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h4><ol>
<li>我习惯于网络请求成功后回调前切换到主线程回调，这样上层UI不需要关心线程问题，拿来数据进行渲染就可以了！毕竟UI请求时也没切换到子线程去请求</li>
<li>同事习惯于网络请求成功后先回调给UI，如果UI需要渲染在自己切换主线程……我就是这么掉坑里的</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>自己写了个简单的子线程UI绘制检查方案，如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIView (MainThread)</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(setNeedsLayout) swizzledSelector:@selector(mainThread_setNeedsLayout)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(setNeedsDisplay) swizzledSelector:@selector(mainThread_setNeedsDisplay)];</span><br><span class="line">[[self class] hookWithOriginalSelector:@selector(setNeedsDisplayInRect:) swizzledSelector:@selector(mainThread_setNeedsDisplayInRect:)];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mainThread_setNeedsLayout &#123;</span><br><span class="line">[self UIMainThreadCheck];</span><br><span class="line">[self mainThread_setNeedsLayout];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)mainThread_setNeedsDisplay &#123;</span><br><span class="line">[self UIMainThreadCheck];</span><br><span class="line">[self mainThread_setNeedsDisplay];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)mainThread_setNeedsDisplayInRect:(CGRect)rect &#123;</span><br><span class="line">[self UIMainThreadCheck];</span><br><span class="line">[self mainThread_setNeedsDisplayInRect:rect];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)UIMainThreadCheck &#123;</span><br><span class="line">NSString *desc = [NSString stringWithFormat:@&quot;%@ 类没在主线程执行请检查相关代码实现&quot;, self.class];</span><br><span class="line">NSAssert([NSThread isMainThread], desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">+ (void)hookWithOriginalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector &#123;</span><br><span class="line">Class class = [self class];</span><br><span class="line">Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">BOOL didAddMethod = class_addMethod(class,</span><br><span class="line">originalSelector,</span><br><span class="line">method_getImplementation(swizzledMethod),</span><br><span class="line">method_getTypeEncoding(swizzledMethod));</span><br><span class="line">if (didAddMethod) &#123;</span><br><span class="line">class_replaceMethod(class,</span><br><span class="line">swizzledSelector,</span><br><span class="line">method_getImplementation(originalMethod),</span><br><span class="line">method_getTypeEncoding(originalMethod));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/07/07/子线程绘制UI检查工具/" data-id="ckd90jon50084xc51514gwh73" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-代码规范" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/06/30/代码规范/">代码规范</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/06/30/代码规范/" class="article-date">
  <time datetime="2017-06-30T10:14:18.000Z" itemprop="datePublished">2017-06-30</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>转载自<a href="https://github.com/samlaudev/Objective-C-Coding-Style#error-handling" target="_blank" rel="noopener">https://github.com/samlaudev/Objective-C-Coding-Style#error-handling</a></p>
<p>其它参考：<a href="https://www.jianshu.com/p/8b76814b3663" target="_blank" rel="noopener">Objective-C编码规范(译)</a>、<a href="https://github.com/google/styleguide" target="_blank" rel="noopener">Google代码规范</a>以及<a href="https://github.com/zh-google-styleguide/zh-google-styleguide" target="_blank" rel="noopener">中文版</a>、</p>
<p>补充更新：<a href="https://juejin.im/post/5a0921c05188252ae93a7014" target="_blank" rel="noopener">如何提高代码的可读性?</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzA5NzMwODI0MA==&amp;mid=2647761689&amp;idx=1&amp;sn=b35c6a64d39d716003502a7925cf3a7f" target="_blank" rel="noopener">何为代码质量？——用脑子写代码</a>、WordPress的<a href="https://github.com/wordpress-mobile/objective-c-style-guide" target="_blank" rel="noopener">OC规范</a>和<a href="https://github.com/wordpress-mobile/swift-style-guide" target="_blank" rel="noopener">Swift规范</a></p>
<p>&emsp;&emsp;看到一份不错的代码规范，摘录下来！PS：感觉比百度的好</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#language">语言</a></li>
<li><a href="#code-organization">代码组织</a></li>
<li><a href="#spacing">空格</a></li>
<li><a href="#comments">注释</a></li>
<li><a href="#naming">命名</a></li>
<li><a href="#underscores">下划线</a></li>
<li><a href="#methods">方法</a></li>
<li><a href="#variables">变量</a></li>
<li><a href="#property-attributes">属性特性</a></li>
<li><a href="#dot-notation-syntax">点符号语法</a></li>
<li><a href="#literals">字面值</a></li>
<li><a href="#constants">常量</a></li>
<li><a href="#enumerated-types">枚举类型</a></li>
<li><a href="#case-statements">Case语句</a></li>
<li><a href="#private-properties">私有属性</a></li>
<li><a href="#booleans">布尔值</a></li>
<li><a href="#conditionals">条件语句</a></li>
<li><a href="#ternary-operator">三元操作符</a></li>
<li><a href="#init-methods">Init方法</a></li>
<li><a href="#class-constructor-methods">类构造方法</a></li>
<li><a href="#cgrect-functions">CGRect函数</a></li>
<li><a href="#golden-path">黄金路径</a></li>
<li><a href="#error-handling">错误处理</a></li>
<li><a href="#singletons">单例模式</a></li>
<li><a href="#line-breaks">换行符</a></li>
<li><a href="#xcode-project">Xcode工程</a></li>
</ul>
<p><b id="language"></b></p>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>应该使用US英语.</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColour = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure>
<p><b id="code-organization"></b></p>
<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>在函数分组和protocol/delegate实现中使用<code>#pragma mark -</code>来分类方法，要遵循以下一般结构：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Lifecycle</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Custom Accessors</span></span><br><span class="line">- (<span class="keyword">void</span>)setCustomProperty:(<span class="keyword">id</span>)value &#123;&#125;</span><br><span class="line">- (<span class="keyword">id</span>)customProperty &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - IBActions/Event Response</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)submitData:(<span class="keyword">id</span>)sender &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)someButtonDidPressed:(<span class="built_in">UIButton</span>*)button</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Protocol conformance</span></span><br><span class="line"><span class="meta">#pragma mark - UITextFieldDelegate</span></span><br><span class="line"><span class="meta">#pragma mark - UITableViewDataSource</span></span><br><span class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Public</span></span><br><span class="line">- (<span class="keyword">void</span>)publicMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private</span></span><br><span class="line">- (<span class="keyword">void</span>)privateMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSObject</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><b id="spacing"></b></p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>缩进使用<strong>4</strong>个空格，确保在Xcode偏好设置来设置。(raywenderlich.com使用<strong>2</strong>个空格)</li>
<li>方法大括号和其他大括号(<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等.)总是在同一行语句打开但在新行中关闭。</li>
</ul>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line"><span class="comment">//Do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//Do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。</li>
<li>优先使用auto-synthesis。但如果有必要，<code>@synthesize</code> 和 <code>@dynamic</code>应该在实现中每个都声明新的一行。</li>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请<strong>不要</strong>这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。</li>
</ul>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">animations:^&#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line">completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line"><span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><b id="comments"></b></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当需要注释时，注释应该用来解释这段特殊代码<strong>为什么</strong>要这样做。任何被使用的注释都必须保持最新或被删除。</p>
<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。<em>例外：这不应用在生成文档的注释</em></p>
<p><b id="naming"></b></p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>Apple命名规则尽可能坚持，特别是与这些相关的<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html" target="_blank" rel="noopener">memory management rules</a> (<a href="http://stackoverflow.com/a/2865194/340508" target="_blank" rel="noopener">NARC</a>)。</p>
<p>长的，描述性的方法和变量命名是好的。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *settingsButton;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *setBut;</span><br></pre></td></tr></table></figure>
<p>三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。</p>
<p>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>
<p>属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@ synthesize语句，除非你有一个好的理由。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> varnm;</span><br></pre></td></tr></table></figure>
<p><b id="underscores"></b></p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>当使用属性时，实例变量应该使用<code>self.</code>来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有<code>self.</code>。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<p><b id="methods"></b></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像<code>initWithWidth:height</code>以下这个例子：</p>
<p><strong>应该:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setExampleText:(<span class="built_in">NSString</span> *)text image:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector to:(<span class="keyword">id</span>)anObject forAllCells:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line">- (<span class="keyword">id</span>)viewWithTag:(<span class="built_in">NSInteger</span>)tag;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width height:(<span class="built_in">CGFloat</span>)height;</span><br></pre></td></tr></table></figure></p>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setT:(<span class="built_in">NSString</span> *)text i:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector :(<span class="keyword">id</span>)anObject :(<span class="built_in">BOOL</span>)flag;</span><br><span class="line">- (<span class="keyword">id</span>)taggedView:(<span class="built_in">NSInteger</span>)tag;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width andHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<p><b id="variables"></b></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p>
<p>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>，除了一些特殊情况下常量。</p>
<p><a href="#private-properties">私有变量</a> 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(<code>init</code>, <code>initWithCoder:</code>, 等…)，<code>dealloc</code> 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6" target="_blank" rel="noopener">这里</a></p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTTutorial</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTTutorial</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"><span class="built_in">NSString</span> *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b id="property-attributes"></b></p>
<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><p>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p>NSString应该使用<code>copy</code> 而不是 <code>strong</code>的属性特性。</p>
<p>为什么？即使你声明一个<code>NSString</code>的属性，有人可能传入一个<code>NSMutableString</code>的实例，然后在你没有注意的情况下修改它。 </p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>
<p><b id="dot-notation-syntax"></b></p>
<h2 id="点符号语法"><a href="#点符号语法" class="headerlink" title="点符号语法"></a>点符号语法</h2><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html" target="_blank" rel="noopener">这里</a></p>
<p>点语法应该<strong>总是</strong>被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
<p><strong>应该:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span>.array count];</span><br><span class="line">view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication].delegate;</span><br></pre></td></tr></table></figure></p>
<p><strong>不应该:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span>.array.count;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</span><br></pre></td></tr></table></figure></p>
<p><b id="literals"></b></p>
<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code>的字面值应该在创建这些类的不可变实例时被使用。请特别注意<code>nil</code>值不能传入<code>NSArray</code>和<code>NSDictionary</code>字面值，因为这样会导致crash。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@"iPhone"</span>: <span class="string">@"Kate"</span>, <span class="string">@"iPad"</span>: <span class="string">@"Kamal"</span>, <span class="string">@"Mobile Web"</span>: <span class="string">@"Bill"</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span>, <span class="string">@"Mobile Web"</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>
<p><b id="constants"></b></p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define CompanyName @<span class="meta-string">"RayWenderlich.com"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define thumbnailHeight 2</span></span><br></pre></td></tr></table></figure>
<p><b id="enumerated-types"></b></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>当使用<code>enum</code>时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p>
<p><strong>例如:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">RWTLeftMenuTopItemMain,</span><br><span class="line">RWTLeftMenuTopItemShows,</span><br><span class="line">RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>你也可以显式地赋值(展示旧的k-style常量定义)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTGlobalConstants) &#123;</span><br><span class="line">RWTPinSizeMin = <span class="number">1</span>,</span><br><span class="line">RWTPinSizeMax = <span class="number">5</span>,</span><br><span class="line">RWTPinCountMin = <span class="number">100</span>,</span><br><span class="line">RWTPinCountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>旧的k-style常量定义应该<strong>避免</strong>除非编写Core Foundation C的代码。</p>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> GlobalConstants &#123;</span><br><span class="line">kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><b id="case-statements"></b></p>
<h2 id="Case语句"><a href="#Case语句" class="headerlink" title="Case语句"></a>Case语句</h2><p>大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Multi-line example using braces</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// ** fall-through! **</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">// code executed for values 1 and 2</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: </span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当在switch使用枚举类型时，’default’是不需要的。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line"><span class="keyword">case</span> RWTLeftMenuTopItemMain:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RWTLeftMenuTopItemShows:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> RWTLeftMenuTopItemSchedule:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b id="private-properties"></b></p>
<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如<code>RWTPrivate</code>或<code>private</code>)应该从不使用除非是扩展其他类。匿名分类应该通过使用<headerfile>+Private.h文件的命名规则暴露给测试。</headerfile></p>
<p><strong>例如:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTDetailViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) GADBannerView *googleAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ADBannerView *iAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWebView</span> *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><b id="booleans"></b></p>
<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Objective-C使用<code>YES</code>和<code>NO</code>。因为<code>true</code>和<code>false</code>应该只在CoreFoundation，C或C++代码使用。既然<code>nil</code>解析成<code>NO</code>，所以没有必要在条件语句比较。不要拿某样东西直接与<code>YES</code>比较，因为<code>YES</code>被定义为1和一个<code>BOOL</code>能被设置为8位。</p>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (![anotherObject boolValue]) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject == <span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ([anotherObject boolValue] == <span class="literal">NO</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">YES</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">true</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>
<p>如果<code>BOOL</code>属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure>
<p>文字和例子从这里引用<a href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE" target="_blank" rel="noopener">Cocoa Naming Guidelines</a></p>
<p><b id="conditionals"></b></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，<a href="http://programmers.stackexchange.com/a/16530" target="_blank" rel="noopener">even more dangerous defect</a>可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line"><span class="keyword">return</span> success;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error) <span class="keyword">return</span> success;</span><br></pre></td></tr></table></figure>
<p><b id="ternary-operator"></b></p>
<h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>当需要提高代码的清晰性和简洁性时，三元操作符<code>?:</code>才会使用。单个条件求值常常需要它。多个条件求值时，如果使用<code>if</code>语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line">result = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> isHorizontal = <span class="literal">YES</span>;</span><br><span class="line">result = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = a &gt; b ? x = c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure>
<p><b id="init-methods"></b></p>
<h2 id="Init方法"><a href="#Init方法" class="headerlink" title="Init方法"></a>Init方法</h2><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用<code>instancetype</code>而不是<code>id</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看关于instancetype的文章<a href="#class-constructor-methods">Class Constructor Methods</a></p>
<p><b id="class-constructor-methods"></b></p>
<h2 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法"></a>类构造方法</h2><p>当类构造方法被使用时，它应该返回类型是<code>instancetype</code>而不是<code>id</code>。这样确保编译器正确地推断结果类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Airplane</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)airplaneWithType:(RWTAirplaneType)type;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>关于更多instancetype信息，请查看<a href="http://nshipster.com/instancetype/" target="_blank" rel="noopener">NSHipster.com</a></p>
<p><b id="cgrect-functions"></b></p>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><p>当访问<code>CGRect</code>里的<code>x</code>, <code>y</code>, <code>width</code>, 或 <code>height</code>时，应该使用<a href="http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html" target="_blank" rel="noopener"><code>CGGeometry</code>函数</a>而不是直接通过结构体来访问。引用Apple的<code>CGGeometry</code>:</p>
<blockquote>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
</blockquote>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = frame.origin.x;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame.origin.y;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame.size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame.size.height;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; .origin = <span class="built_in">CGPointZero</span>, .size = frame.size &#125;;</span><br></pre></td></tr></table></figure>
<p><b id="golden-path"></b></p>
<h2 id="黄金路径"><a href="#黄金路径" class="headerlink" title="黄金路径"></a>黄金路径</h2><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line"><span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line"><span class="keyword">if</span> ([someOther boolValue]) &#123;</span><br><span class="line"><span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><b id="error-handling"></b></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p><strong>应该:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> trySomethingWithError:&amp;error]) &#123;</span><br><span class="line"><span class="comment">// Handle Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>不应该:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">[<span class="keyword">self</span> trySomethingWithError:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">// Handle Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<p><b id="singletons"></b></p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例对象应该使用线程安全模式来创建共享实例。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会防止<a href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html" target="_blank" rel="noopener">possible and sometimes prolific crashes</a>.</p>
<p><b id="line-breaks"></b></p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] initWithProductIdentifiers:productIdentifiers];</span><br></pre></td></tr></table></figure>
<p>一行很长的代码应该分成两行代码，下一行用两个空格隔开。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] </span><br><span class="line">initWithProductIdentifiers:productIdentifiers];</span><br></pre></td></tr></table></figure>
<p><b id="xcode-project"></b></p>
<h2 id="Xcode工程"><a href="#Xcode工程" class="headerlink" title="Xcode工程"></a>Xcode工程</h2><p>物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据<strong>类型</strong>来分组，而且还可以根据<strong>功能</strong>来分组，这样代码更加清晰。</p>
<p>尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下<a href="http://boredzo.org/blog/archives/2009-11-07/warnings" target="_blank" rel="noopener">additional warnings</a>。如果你需要忽略特殊的警告，使用 <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas" target="_blank" rel="noopener">Clang’s pragma feature</a>。</p>
<h1 id="其他Objective-C编码规范"><a href="#其他Objective-C编码规范" class="headerlink" title="其他Objective-C编码规范"></a>其他Objective-C编码规范</h1><p>如果我们的编码规范不符合你的口味，可以查看其他的编码规范：</p>
<ul>
<li><a href="https://github.com/RobotsAndPencils/objective-c-style-guide" target="_blank" rel="noopener">Robots &amp; Pencils</a></li>
<li><a href="https://github.com/NYTimes/objective-c-style-guide" target="_blank" rel="noopener">New York Times</a></li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml" target="_blank" rel="noopener">Google</a></li>
<li><a href="https://github.com/github/objective-c-conventions" target="_blank" rel="noopener">GitHub</a></li>
<li><a href="https://trac.adium.im/wiki/CodingStyle" target="_blank" rel="noopener">Adium</a></li>
<li><a href="https://gist.github.com/soffes/812796" target="_blank" rel="noopener">Sam Soffes</a></li>
<li><a href="http://cocoadevcentral.com/articles/000082.php" target="_blank" rel="noopener">CocoaDevCentral</a></li>
<li><a href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html" target="_blank" rel="noopener">Luke Redpath</a></li>
<li><a href="http://www.cimgf.com/zds-code-style-guide/" target="_blank" rel="noopener">Marcus Zarra</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/06/30/代码规范/" data-id="ckd90jomg0063xc5197o7kha8" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/其他/">其他</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-NSException介绍" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/06/17/NSException介绍/">NSException介绍</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/06/17/NSException介绍/" class="article-date">
  <time datetime="2017-06-17T10:14:18.000Z" itemprop="datePublished">2017-06-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><ul>
<li>name :  唯一标识符</li>
<li>reason: 异常原因，最重要的属性！找问题就靠它了</li>
<li>userInfo：当异常被抛出时，返回原因等的一个字典<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;</span><br><span class="line">// 如果这里面的代码执行后会导致程序崩溃，就会跳到@catch这个方法中</span><br><span class="line">// @throw someException</span><br><span class="line">&#125; @catch(NSException *exception) &#123;</span><br><span class="line">// 处理异常</span><br><span class="line">&#125;@finally&#123;</span><br><span class="line">// 这里的代码是一定执行的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2 常见异常"></a>2 常见异常</h3><h4 id="2-1-NSGenericException"><a href="#2-1-NSGenericException" class="headerlink" title="2.1 NSGenericException"></a>2.1 NSGenericException</h4><ul>
<li>通用异常？我也翻译不准还要看reason，不能一概而论，不过个人理解就跟枚举的第一个default一样</li>
<li>我只见一次NSGenericException，对数组进行删除操作时见到的<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *muArr = @[@1, @2, @3].mutableCopy;</span><br><span class="line">for (id elem in muArr) &#123;</span><br><span class="line">[muArr removeObject:elem];</span><br><span class="line">&#125;</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSGenericException&apos;, reason: &apos;*** Collection &lt;__NSArrayM: 0x600002052310&gt; was mutated while being enumerated.&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-NSRangeException越界"><a href="#2-2-NSRangeException越界" class="headerlink" title="2.2 NSRangeException越界"></a>2.2 NSRangeException越界</h4><ul>
<li>一般是数组越界，字符创越界两种！Debug下打开全局断点基本都是定位到，release下分析崩溃行上下文基本也能处理<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 空数组</span><br><span class="line">NSMutableArray *photos  = [NSMutableArray array];</span><br><span class="line">NSLog(@&quot;--- %@&quot;,photos[0]);</span><br><span class="line"></span><br><span class="line">// Crash</span><br><span class="line">// Terminating app due to uncaught exception &apos;NSRangeException&apos;, reason: &apos;*** -[__NSArrayM objectAtIndexedSubscript:]: index 0 beyond bounds for empty array&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-3-NSInvalidArgumentException-非法入参"><a href="#2-3-NSInvalidArgumentException-非法入参" class="headerlink" title="2.3 NSInvalidArgumentException 非法入参"></a>2.3 NSInvalidArgumentException 非法入参</h4><ul>
<li>开发阶段可用NSAssert代替，但使用NSInvalidArgumentException可以保证在release阶段也不会出现入参问题的crash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSMutableArray *muArr = [[NSMutableArray alloc] init];</span><br><span class="line">NSString *str = nil;</span><br><span class="line">[muArr addObject:str];</span><br><span class="line">// erminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil&apos;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-4-NSInternalInconsistencyException"><a href="#2-4-NSInternalInconsistencyException" class="headerlink" title="2.4 NSInternalInconsistencyException"></a>2.4 NSInternalInconsistencyException</h4><ul>
<li>内部矛盾异常，主要在断言失败时自动调用！</li>
<li>出现这个异常，一般都是类型问题，xib连线问题，约束问题等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSAssert(NO, @&quot;this will call NSInternalInconsistencyException&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-5-NSMallocException-内存不足"><a href="#2-5-NSMallocException-内存不足" class="headerlink" title="2.5 NSMallocException 内存不足"></a>2.5 NSMallocException 内存不足</h4><ul>
<li>内存不足的问题，无法分配足够的内存空间,比如需要分配的内存大小是一个不正常的值，比较巨大或者设备的内存空间不足以及耗尽</li>
</ul>
<h3 id="3-小技巧"><a href="#3-小技巧" class="headerlink" title="3 小技巧"></a>3 小技巧</h3><h4 id="3-1-throw的妙用"><a href="#3-1-throw的妙用" class="headerlink" title="3.1 @throw的妙用"></a>3.1 @throw的妙用</h4><ul>
<li><p>限制某方式使用，特别是废弃的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 强制使用initWithPath作为初始化，也可以直接用NSAssert(NO, @&quot;原因&quot;);</span><br><span class="line">@throw [NSException exceptionWithName:NSGenericException</span><br><span class="line">reason:@&quot;`-init` unavailable. Use `-initWithReachability:` instead&quot;</span><br><span class="line">userInfo:nil];</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制子类实现某个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 如果所有子类都必须实现某个方法，怎么做才好？</span><br><span class="line">// 第一种方法声明协议，父类遵守，子类实现；但协议只能产生警告，不够强硬！而且一旦父类实现了该方法，子类实现不实现根本就无所谓！</span><br><span class="line">// 第二种方法，父类实现该方法并添加@throw强制实现子类去自己重载</span><br><span class="line">- (void)changeActivityState:(BOOL)active &#123;</span><br><span class="line">@throw [NSException exceptionWithName:NSInternalInconsistencyException</span><br><span class="line">reason:[NSString stringWithFormat:@&quot;You must override %@ in %@&quot;, NSStringFromSelector(_cmd), self.class]</span><br><span class="line">userInfo:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-2-自己捕获异常"><a href="#3-2-自己捕获异常" class="headerlink" title="3.2 自己捕获异常"></a>3.2 自己捕获异常</h4><ul>
<li>注意，很多三方SDK也用到了自定义异常处理，咱们捕获了要转发出去<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static NSUncaughtExceptionHandler *_previousHandler;</span><br><span class="line">// 在程序开始运行就监控异常</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">// 保存第三方处理异常的 handler</span><br><span class="line">_previousHandler = NSGetUncaughtExceptionHandler();</span><br><span class="line">// 将下面C函数的函数地址当做参数</span><br><span class="line">NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line">// 设置一个C函数，用来接收崩溃信息</span><br><span class="line">void UncaughtExceptionHandler(NSException *exception)&#123;</span><br><span class="line">// 崩溃栈</span><br><span class="line">NSArray *symbols = [exception callStackSymbols];</span><br><span class="line">NSString *reason = [exception reason];</span><br><span class="line">NSString *name = [exception name];</span><br><span class="line">// 本地记录并上传</span><br><span class="line"></span><br><span class="line">// 转发为三方</span><br><span class="line">_previousHandler(exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012-BAJGFBFB</a></li>
</ul>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><ul>
<li>NSException 异常，非正常，想不到的是异常</li>
<li>NSError 错误，流程的一部分，有正确就有错误</li>
<li>NSAssert 断言，保证正确（或错误），就是程序员确定这个是正确的（或错误的），常用测试和参数校验</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/06/17/NSException介绍/" data-id="ckd90jol1002oxc510bgp8zqp" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-有意思的-try-Catch" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/06/10/有意思的-try-Catch/">有意思的@try@Catch</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/06/10/有意思的-try-Catch/" class="article-date">
  <time datetime="2017-06-10T10:14:18.000Z" itemprop="datePublished">2017-06-10</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;今天和同事聊天，聊到了tryCatch的使用，他说trycatch用起来很简单！我问他有风险吗！他说，trycatch有啥风险，随便用！回头想想iOS的@try@catch，额…不提也…哎，其实也是可以水一篇的哈！</p>
<p>&emsp;&emsp;简单的来说，Apple虽然同时提供了错误处理（NSError）和异常处理（exception）两种机制，但是Apple更加提倡开发者使用NSError来处理程序运行中可恢复的错误。而异常被推荐用来处理不可恢复的错误。</p>
<p>&emsp;&emsp;参考：<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Exceptions.html#//apple_ref/doc/uid/10000012i" target="_blank" rel="noopener">官网</a></p>
<blockquote>
<p>Important: You should reserve the use of exceptions for programming or unexpected runtime errors such as out-of-bounds collection access, attempts to mutate immutable objects, sending an invalid message, and losing the connection to the window server. You usually take care of these sorts of errors with exceptions when an application is being created rather than at runtime.<br>If you have an existing body of code (such as third-party library) that uses exceptions to handle error conditions, you may use the code as-is in your Cocoa application. But you should ensure that any expected runtime exceptions do not escape from these subsystems and end up in the caller’s code. For example, a parsing library might use exceptions internally to indicate problems and enable a quick exit from a parsing state that could be deeply recursive; however, you should take care to catch such exceptions at the top level of the library and translate them into an appropriate return code or state.</p>
</blockquote>
<p>&emsp;&emsp;此外tryCatch比较耗性能，不能用于流程控制 <a href="https://stackoverflow.com/questions/3678438/try-catch-exception-handling-practice-for-iphone-objective-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/3678438/try-catch-exception-handling-practice-for-iphone-objective-c</a> ；容易造成内存泄漏 <a href="https://stackoverflow.com/questions/27140891/why-does-try-catch-in-objective-c-cause-memory-leak" target="_blank" rel="noopener">https://stackoverflow.com/questions/27140891/why-does-try-catch-in-objective-c-cause-memory-leak</a> ；更重要的是tryCatch干的活，基本上NSError和断点都能干 <a href="https://stackoverflow.com/questions/13774611/try-catch-equivalent-in-objective-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/13774611/try-catch-equivalent-in-objective-c</a></p>
<hr>
<p>&emsp;&emsp;当然这篇水文关注的不是tryCatch少用的原因！</p>
<p>&emsp;&emsp;其实我本来打算研究一下tryCatch为什么耗性能的！但真没研究出来，不过到发现一个好玩的东西，本着水一篇算一篇，水一会算一会的精神，我还是水了出来！</p>
<p>&emsp;&emsp;测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation Person</span><br><span class="line">- (void)test &#123;</span><br><span class="line">@try &#123;</span><br><span class="line">NSLog(@&quot;try&quot;);</span><br><span class="line">&#125; @catch (NSException *exception) &#123;</span><br><span class="line">NSLog(@&quot;catch&quot;);</span><br><span class="line">&#125; @finally &#123;</span><br><span class="line">NSLog(@&quot;finally&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译后得到如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// @implementation Person</span><br><span class="line"></span><br><span class="line">static void _I_Person_test(Person * self, SEL _cmd) &#123;</span><br><span class="line">&#123;</span><br><span class="line">id volatile _rethrow = 0;</span><br><span class="line">try &#123;</span><br><span class="line">// 这里对应@try @catch</span><br><span class="line">try &#123;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_0);</span><br><span class="line">&#125; catch (_objc_exc_NSException *_exception) &#123;</span><br><span class="line">/*</span><br><span class="line">从代码上看只捕获_objc_exc_NSException</span><br><span class="line"></span><br><span class="line">typedef struct objc_object NSException;</span><br><span class="line">typedef struct &#123;&#125; _objc_exc_NSException;</span><br><span class="line">*/</span><br><span class="line">NSException *exception = (NSException*)_exception;</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (id e) &#123;</span><br><span class="line">// 理论上讲 非 _objc_exc_NSException才能走到这里</span><br><span class="line">_rethrow = e;</span><br><span class="line">&#125;</span><br><span class="line">&#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125;</span><br><span class="line">~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125;</span><br><span class="line">id rethrow;</span><br><span class="line">&#125; _fin_force_rethow(_rethrow);</span><br><span class="line">NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_gb__20zxxjd0p318c5gng983b6r0000gp_T_person_bc91d3_mi_2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// @end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;大家可直观的观察到包含两个trycatch，说实话哈！我是第一次见到try里面嵌套trycatch，很久以前学习JAVA时见过catch或finally里面还有trycatch，主要是因为JAVA处理异常时还可能发生别的异常，所以再加一个trycatch来捕获子异常。延伸一下，try配合多个catch 和 trycatch嵌套最主要的区别就是一个try多个catch只能捕获一次异常；而trycatch嵌套可以捕获多个异常。当然你要硬说<a href="https://stackoverflow.com/questions/136035/catch-multiple-exceptions-at-once" target="_blank" rel="noopener">一个try也可以捕获多个异常</a>，我也不反对，毕竟这种方式不太常用！</p>
<p>&emsp;&emsp;可以参考<a href="https://www.cnblogs.com/zhangchengye/p/5674240.html" target="_blank" rel="noopener">try catch里面try catch嵌套</a>加深对trycatch嵌套的理解！个人猜测，之所以try嵌套还是为了尽可能的捕获异常（我依然认为这么写的意义不大），但即便如此@try@catch无法捕获UncaughtException，而oc中大部分crash如：内存溢出、野指针等都是无法捕获的，而能捕获的只是像数组越界之类的，所以@try@catch真的比较鸡肋。</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/06/10/有意思的-try-Catch/" data-id="ckd90jonp009bxc51in37ivw8" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/page/3/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>