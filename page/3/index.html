<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">焦正奎的博客</a></h1>
      <p>不要怕！不要悔！慢慢来！</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="焦正奎的博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-AFN都干了什么" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/10/08/AFN都干了什么/">AFN都干了什么？</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/10/08/AFN都干了什么/" class="article-date">
  <time datetime="2017-10-07T16:31:35.000Z" itemprop="datePublished">2017-10-08</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ol>
<li>TargetConditionals.h 内置很多条件判断的宏 <a href="https://www.jianshu.com/p/dc0404c09060" target="_blank" rel="noopener">https://www.jianshu.com/p/dc0404c09060</a></li>
<li><p>修复ios8的bug，同步方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static void url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    if (NSFoundationVersionNumber &lt; NSFoundationVersionNumber_With_Fixed_5871104061079552_bug) &#123;</span><br><span class="line">        // Fix of bug</span><br><span class="line">        // Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span><br><span class="line">        // Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span><br><span class="line">        dispatch_sync(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://blog.csdn.net/Qsir/article/details/86496346" target="_blank" rel="noopener"><strong>typeof</strong>() 、 __typeof（） 、 typeof（）的区别</a></p>
</li>
<li><p>字典绑定task和回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(NSURLSessionTask *)task</span><br><span class="line">&#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line">    NSParameterAssert(delegate);</span><br><span class="line"></span><br><span class="line">// 这是NSLock</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">    [self addNotificationObserverForTask:task];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</span><br><span class="line">    NSParameterAssert(task);</span><br><span class="line"></span><br><span class="line">    [self.lock lock];</span><br><span class="line">    [self removeNotificationObserverForTask:task];</span><br><span class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>hook问题？沿着继承链找到第一个并hook! 惊艳点！！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    /**</span><br><span class="line">     WARNING: Trouble Ahead</span><br><span class="line">     https://github.com/AFNetworking/AFNetworking/pull/2702</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</span><br><span class="line">        /**</span><br><span class="line">         iOS 7 and iOS 8 differ in NSURLSessionTask implementation, which makes the next bit of code a bit tricky.</span><br><span class="line">         Many Unit Tests have been built to validate as much of this behavior has possible.</span><br><span class="line">         Here is what we know:</span><br><span class="line">            - NSURLSessionTasks are implemented with class clusters, meaning the class you request from the API isn&apos;t actually the type of class you will get back.</span><br><span class="line">            - Simply referencing `[NSURLSessionTask class]` will not work. You need to ask an `NSURLSession` to actually create an object, and grab the class from there.</span><br><span class="line">            - On iOS 7, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `__NSCFURLSessionTask`.</span><br><span class="line">            - On iOS 8, `localDataTask` is a `__NSCFLocalDataTask`, which inherits from `__NSCFLocalSessionTask`, which inherits from `NSURLSessionTask`.</span><br><span class="line">            - On iOS 7, `__NSCFLocalSessionTask` and `__NSCFURLSessionTask` are the only two classes that have their own implementations of `resume` and `suspend`, and `__NSCFLocalSessionTask` DOES NOT CALL SUPER. This means both classes need to be swizzled.</span><br><span class="line">            - On iOS 8, `NSURLSessionTask` is the only class that implements `resume` and `suspend`. This means this is the only class that needs to be swizzled.</span><br><span class="line">            - Because `NSURLSessionTask` is not involved in the class hierarchy for every version of iOS, its easier to add the swizzled methods to a dummy class and manage them there.</span><br><span class="line">        </span><br><span class="line">         Some Assumptions:</span><br><span class="line">            - No implementations of `resume` or `suspend` call super. If this were to change in a future version of iOS, we&apos;d need to handle it.</span><br><span class="line">            - No background task classes override `resume` or `suspend`</span><br><span class="line">         </span><br><span class="line">         The current solution:</span><br><span class="line">            1) Grab an instance of `__NSCFLocalDataTask` by asking an instance of `NSURLSession` for a data task.</span><br><span class="line">            2) Grab a pointer to the original implementation of `af_resume`</span><br><span class="line">            3) Check to see if the current class has an implementation of resume. If so, continue to step 4.</span><br><span class="line">            4) Grab the super class of the current class.</span><br><span class="line">            5) Grab a pointer for the current class to the current implementation of `resume`.</span><br><span class="line">            6) Grab a pointer for the super class to the current implementation of `resume`.</span><br><span class="line">            7) If the current class implementation of `resume` is not equal to the super class implementation of `resume` AND the current implementation of `resume` is not equal to the original implementation of `af_resume`, THEN swizzle the methods</span><br><span class="line">            8) Set the current class to the super class, and repeat steps 3-8</span><br><span class="line">         */</span><br><span class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</span><br><span class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</span><br><span class="line">#pragma GCC diagnostic push</span><br><span class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</span><br><span class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask class];</span><br><span class="line">        </span><br><span class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</span><br><span class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并发数1，串行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.operationQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    self.operationQueue.maxConcurrentOperationCount = 1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFNetworking里的GET,POST,HEAD,PUT,PATCH,DELETE请求均经过dispatch_queue_t，由外部传入，可以是并行也可以是串行，如果没有传入则使用dispatch_get_main_queue</p>
</li>
<li><p>AF做了一些workround苹果bug的事情：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）iOS8之前苹果的bug，在concurrent queue创建NSURLSessionTask，会导致不正确的completionHandlers的调用，AFNetworking做了安全保护，在iOS8之前都在 serial queue中创建NSURLSessionTask</span><br><span class="line">2）iOS7苹果的bug，NSURLSession创建UploadTask的时候，有时会返回nil，AF会尝试重试三次创建，来workround这个bug</span><br><span class="line">3）初始化NSURLSession的时候，对于NSURLSessionConfiguration的处理不一样，iOS9以下是将config做为引用，而在9及其以上是copy了一份</span><br></pre></td></tr></table></figure>
</li>
<li><p>AFNetworking内部是使用一个completion dispatch group 和一个processing concurrent dispatch queue，来管理成功或者失败block的回掉的</p>
</li>
<li><p>AFNetworking的maxconcurrentcount是1，所以没有做并发量的控制，就是一个单线程队列管理，但是AFImageDownloader里做了并发数的限制，最大下载数是4</p>
</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/10/08/AFN都干了什么/" data-id="ckd90jojt0001xc51zy63oy0n" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-SDWebImage都干了什么" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/10/04/SDWebImage都干了什么/">SDWebImage都干了什么？</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/10/04/SDWebImage都干了什么/" class="article-date">
  <time datetime="2017-10-03T16:31:35.000Z" itemprop="datePublished">2017-10-04</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>High Level Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="image"></p>
<p>Overall Class Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageClassDiagram.png" alt="image"></p>
<p>Top Level API Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageTopLevelClassDiagram.png" alt="image"></p>
<p>Main Sequence Diagram<br><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageSequenceDiagram.png" alt="image"></p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><ol>
<li><p>为啥不用NSThread</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">    if (dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; else &#123;\</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>SD里大量用到了 @synchronized(self)，另外正在下载中取消了怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_cancelImageLoadOperationWithKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (key) &#123;</span><br><span class="line">        // Cancel in progress downloader from queue</span><br><span class="line">        SDOperationsDictionary *operationDictionary = [self sd_operationDictionary];</span><br><span class="line">        // 这个协议好，将抽象和实现分离！其实这就是最好的分层解耦</span><br><span class="line">        id&lt;SDWebImageOperation&gt; operation;</span><br><span class="line">        </span><br><span class="line">        @synchronized (self) &#123;</span><br><span class="line">            operation = [operationDictionary objectForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        if (operation) &#123;</span><br><span class="line">            if ([operation conformsToProtocol:@protocol(SDWebImageOperation)]) &#123;</span><br><span class="line">                // 是不是抽象的非常好，下载、解码、还是存储根本就不用关心</span><br><span class="line">                [operation cancel];</span><br><span class="line">            &#125;</span><br><span class="line">            @synchronized (self) &#123;</span><br><span class="line">                [operationDictionary removeObjectForKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>学艺不精：怎么设置view的center</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.center = CGPointMake(CGRectGetMidX(self.bounds), CGRectGetMidY(self.bounds));</span><br></pre></td></tr></table></figure>
</li>
<li><p>和2毕竟相似，最基础的解耦思想：协议+抽象。 注意协议的定义以及requair的使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (void)sd_startImageIndicator &#123;</span><br><span class="line">    id&lt;SDWebImageIndicator&gt; imageIndicator = self.sd_imageIndicator;</span><br><span class="line">    if (!imageIndicator) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch_main_async_safe(^&#123;</span><br><span class="line">        // SDWebImageActivityIndicator、SDWebImageProgressIndicator等等</span><br><span class="line">        [imageIndicator startAnimatingIndicator];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 再看协议是怎么定义的</span><br><span class="line">/**</span><br><span class="line"> A protocol to custom the indicator during the image loading.</span><br><span class="line"> All of these methods are called from main queue.</span><br><span class="line"> */</span><br><span class="line">@protocol SDWebImageIndicator &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@required</span><br><span class="line">/**</span><br><span class="line"> The view associate to the indicator.</span><br><span class="line"></span><br><span class="line"> @return The indicator view</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, readonly, nonnull) UIView *indicatorView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Start the animating for indicator.</span><br><span class="line"> */</span><br><span class="line">- (void)startAnimatingIndicator;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> Stop the animating for indicator.</span><br><span class="line"> */</span><br><span class="line">- (void)stopAnimatingIndicator;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">/**</span><br><span class="line"> Update the loading progress (0-1.0) for indicator. Optional</span><br><span class="line"> </span><br><span class="line"> @param progress The progress, value between 0 and 1.0</span><br><span class="line"> */</span><br><span class="line">- (void)updateIndicatorProgress:(double)progress;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>@property 的属性class，表示给类增加一个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, class, nullable) id&lt;SDImageCache&gt; defaultImageCache;</span><br><span class="line"></span><br><span class="line">// .m文件</span><br><span class="line">static id&lt;SDImageCache&gt; _defaultImageCache;</span><br><span class="line"></span><br><span class="line">+ (id&lt;SDImageCache&gt;)defaultImageCache &#123;</span><br><span class="line">    return _defaultImageCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (void)setDefaultImageCache:(id&lt;SDImageCache&gt;)defaultImageCache &#123;</span><br><span class="line">    if (defaultImageCache &amp;&amp; ![defaultImageCache conformsToProtocol:@protocol(SDImageCache)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    _defaultImageCache = defaultImageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>io队列是串行队列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承 NSCache的正确方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface SDMemoryCache &lt;KeyType, ObjectType&gt; : NSCache &lt;KeyType, ObjectType&gt; &lt;SDMemoryCache&gt;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong, nonnull, readonly) SDImageCacheConfig *config;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
</li>
<li><p>像不像手动实现MVVM？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void * SDMemoryCacheContext = &amp;SDMemoryCacheContext;</span><br><span class="line"></span><br><span class="line">- (void)commonInit &#123;</span><br><span class="line">    SDImageCacheConfig *config = self.config;</span><br><span class="line">    self.totalCostLimit = config.maxMemoryCost;</span><br><span class="line">    self.countLimit = config.maxMemoryCount;</span><br><span class="line">    </span><br><span class="line">    [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCost)) options:0 context:SDMemoryCacheContext];</span><br><span class="line">    [config addObserver:self forKeyPath:NSStringFromSelector(@selector(maxMemoryCount)) options:0 context:SDMemoryCacheContext];</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    if (context == SDMemoryCacheContext) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(maxMemoryCost))]) &#123;</span><br><span class="line">            self.totalCostLimit = self.config.maxMemoryCost;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(maxMemoryCount))]) &#123;</span><br><span class="line">            self.countLimit = self.config.maxMemoryCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strong weak Cache</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, nonnull) NSMapTable&lt;KeyType, ObjectType&gt; *weakCache; // strong-weak cache</span><br><span class="line"></span><br><span class="line">self.weakCache = [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory valueOptions:NSPointerFunctionsWeakMemory capacity:0];</span><br><span class="line"></span><br><span class="line">// NSMapTable线程不安全，用锁</span><br><span class="line">#ifndef SD_LOCK</span><br><span class="line">#define SD_LOCK(lock) dispatch_semaphore_wait(lock, DISPATCH_TIME_FOREVER);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef SD_UNLOCK</span><br><span class="line">#define SD_UNLOCK(lock) dispatch_semaphore_signal(lock);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件按MD5存的，注意文件名是有长度限制的，超长就不加扩展名了！注意检查的时候也要检查扩展名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#define SD_MAX_FILE_EXTENSION_LENGTH (NAME_MAX - CC_MD5_DIGEST_LENGTH * 2 - 1)</span><br><span class="line"></span><br><span class="line">static inline NSString * _Nonnull SDDiskCacheFileNameForKey(NSString * _Nullable key) &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    // File system has file name length limit, we need to check if ext is too long, we don&apos;t add it to the filename</span><br><span class="line">    if (ext.length &gt; SD_MAX_FILE_EXTENSION_LENGTH) &#123;</span><br><span class="line">        ext = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)containsDataForKey:(NSString *)key &#123;</span><br><span class="line">    NSParameterAssert(key);</span><br><span class="line">    NSString *filePath = [self cachePathForKey:key];</span><br><span class="line">    BOOL exists = [self.fileManager fileExistsAtPath:filePath];</span><br><span class="line">    </span><br><span class="line">    // fallback because of https://github.com/rs/SDWebImage/pull/976 that added the extension to the disk file name</span><br><span class="line">    // checking the key with and without the extension</span><br><span class="line">    if (!exists) &#123;</span><br><span class="line">        exists = [self.fileManager fileExistsAtPath:filePath.stringByDeletingPathExtension];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return exists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>wirteToUrl,苹果推荐使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// get cache Path for image key</span><br><span class="line">NSString *cachePathForKey = [self cachePathForKey:key];</span><br><span class="line">// transform to NSUrl</span><br><span class="line">NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line"></span><br><span class="line">[data writeToURL:fileURL options:self.config.diskCacheWritingOptions error:nil];</span><br><span class="line"></span><br><span class="line">// disable iCloud backup</span><br><span class="line">if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">    // ignore iCloud backup resource value error</span><br><span class="line">    [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optionsProcessor是strong</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> The options processor is used, to have a global control for all the image request options and context option for current manager.</span><br><span class="line"> @note If you use `transformer`, `cacheKeyFilter` or `cacheSerializer` property of manager, the input context option already apply those properties before passed. This options processor is a better replacement for those property in common usage.</span><br><span class="line"> For example, you can control the global options, based on the URL or original context option like the below code.</span><br><span class="line"> </span><br><span class="line"> @code</span><br><span class="line"> SDWebImageManager.sharedManager.optionsProcessor = [SDWebImageOptionsProcessor optionsProcessorWithBlock:^SDWebImageOptionsResult * _Nullable(NSURL * _Nullable url, SDWebImageOptions options, SDWebImageContext * _Nullable context) &#123;</span><br><span class="line">     // Only do animation on `SDAnimatedImageView`</span><br><span class="line">     if (!context[SDWebImageContextAnimatedImageClass]) &#123;</span><br><span class="line">        options |= SDWebImageDecodeFirstFrameOnly;</span><br><span class="line">     &#125;</span><br><span class="line">     // Do not force decode for png url</span><br><span class="line">     if ([url.lastPathComponent isEqualToString:@&quot;png&quot;]) &#123;</span><br><span class="line">        options |= SDWebImageAvoidDecodeImage;</span><br><span class="line">     &#125;</span><br><span class="line">     // Always use screen scale factor</span><br><span class="line">     SDWebImageMutableContext *mutableContext = [NSDictionary dictionaryWithDictionary:context];</span><br><span class="line">     mutableContext[SDWebImageContextImageScaleFactor] = @(UIScreen.mainScreen.scale);</span><br><span class="line">     context = [mutableContext copy];</span><br><span class="line"> </span><br><span class="line">     return [[SDWebImageOptionsResult alloc] initWithOptions:options context:context];</span><br><span class="line"> &#125;];</span><br><span class="line"> @endcode</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, strong, nullable) id&lt;SDWebImageOptionsProcessor&gt; optionsProcessor;</span><br></pre></td></tr></table></figure>
</li>
<li><p>SD是怎么限制字典配制项的？比钱包强了不止一个档次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef NSString * SDWebImageContextOption NS_EXTENSIBLE_STRING_ENUM;</span><br><span class="line">typedef NSDictionary&lt;SDWebImageContextOption, id&gt; SDWebImageContext;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A String to be used as the operation key for view category to store the image load operation. This is used for view instance which supports different image loading process. If nil, will use the class name as operation key. (NSString *)</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT SDWebImageContextOption _Nonnull const SDWebImageContextSetImageOperationKey;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> A SDWebImageManager instance to control the image download and cache process using in UIImageView+WebCache category and likes. If not provided, use the shared manager (SDWebImageManager *)</span><br><span class="line"> */</span><br><span class="line">FOUNDATION_EXPORT SDWebImageContextOption _Nonnull const SDWebImageContextCustomManager;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@weakify(operation); 和 @strongify(operation); <a href="https://blog.csdn.net/ryansuan/article/details/51941702" target="_blank" rel="noopener">https://blog.csdn.net/ryansuan/article/details/51941702</a>  和  <a href="https://www.cnblogs.com/fengmin/p/5870554.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengmin/p/5870554.html</a></p>
</li>
</ol>
<ol start="15">
<li><p>大量IO操作应该放到@autoreleasepool里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载状态和锁，分细一点还是有好处的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;NSURL *&gt; *failedURLs;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t failedURLsLock; // a lock to keep the access to `failedURLs` thread-safe</span><br><span class="line">@property (strong, nonatomic, nonnull) NSMutableSet&lt;SDWebImageCombinedOperation *&gt; *runningOperations;</span><br><span class="line">@property (strong, nonatomic, nonnull) dispatch_semaphore_t runningOperationsLock; // a lock to keep the access to `runningOperations` thread-safe</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载通过栈排序还是堆排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (self.config.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">        // Emulate LIFO execution order by systematically, each previous adding operation can dependency the new operation</span><br><span class="line">        // This can gurantee the new operation to be execulated firstly, even if when some operations finished, meanwhile you appending new operations</span><br><span class="line">        // Just make last added operation dependents new operation can not solve this problem. See test case #test15DownloaderLIFOExecutionOrder</span><br><span class="line">        for (NSOperation *pendingOperation in self.downloadQueue.operations) &#123;</span><br><span class="line">            [pendingOperation addDependency:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载会不会死锁？哪里用到锁？加到队列后自动调用start开始下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">SD_LOCK(self.operationsLock);</span><br><span class="line">    id downloadOperationCancelToken;</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *operation = [self.URLOperations objectForKey:url];</span><br><span class="line">    // There is a case that the operation may be marked as finished or cancelled, but not been removed from `self.URLOperations`.</span><br><span class="line">    if (!operation || operation.isFinished || operation.isCancelled) &#123;</span><br><span class="line">        operation = [self createDownloaderOperationWithUrl:url options:options context:context];</span><br><span class="line">        if (!operation) &#123;</span><br><span class="line">            SD_UNLOCK(self.operationsLock);</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadOperation userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Downloader operation is nil&quot;&#125;];</span><br><span class="line">                completedBlock(nil, nil, error, YES);</span><br><span class="line">            &#125;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        @weakify(self);</span><br><span class="line">        operation.completionBlock = ^&#123;</span><br><span class="line">            @strongify(self);</span><br><span class="line">            if (!self) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            SD_LOCK(self.operationsLock);</span><br><span class="line">            [self.URLOperations removeObjectForKey:url];</span><br><span class="line">            SD_UNLOCK(self.operationsLock);</span><br><span class="line">        &#125;;</span><br><span class="line">        self.URLOperations[url] = operation;</span><br><span class="line">        // Add operation to operation queue only after all configuration done according to Apple&apos;s doc.</span><br><span class="line">        // `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span><br><span class="line">        [self.downloadQueue addOperation:operation];</span><br><span class="line">        downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // When we reuse the download operation to attach more callbacks, there may be thread safe issue because the getter of callbacks may in another queue (decoding queue or delegate queue)</span><br><span class="line">        // So we lock the operation here, and in `SDWebImageDownloaderOperation`, we use `@synchonzied (self)`, to ensure the thread safe between these two classes.</span><br><span class="line">        @synchronized (operation) &#123;</span><br><span class="line">            downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        &#125;</span><br><span class="line">        if (!operation.isExecuting) &#123;</span><br><span class="line">            if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">            &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                operation.queuePriority = NSOperationQueuePriorityNormal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SD_UNLOCK(self.operationsLock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎么在自己的类里开始后台下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">BOOL hasApplication = UIApplicationClass &amp;&amp; [UIApplicationClass respondsToSelector:@selector(sharedApplication)];</span><br><span class="line">if (hasApplication &amp;&amp; [self shouldContinueWhenAppEntersBackground]) &#123;</span><br><span class="line">    __weak typeof(self) wself = self;</span><br><span class="line">    UIApplication * app = [UIApplicationClass performSelector:@selector(sharedApplication)];</span><br><span class="line">    self.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        [wself cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不设NSURLSession的delegateQueue竟然默认串行队列回调! 注意这里回调会通过操作转给内部的task从而实现解码缓存啥的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">        NSURLSession *session = self.unownedSession;</span><br><span class="line">        if (!session) &#123;</span><br><span class="line">            NSURLSessionConfiguration *sessionConfig = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">            sessionConfig.timeoutIntervalForRequest = 15;</span><br><span class="line">            </span><br><span class="line">            /**</span><br><span class="line">             *  Create the session for this task</span><br><span class="line">             *  We send nil as delegate queue so that the session creates a serial operation queue for performing all delegate</span><br><span class="line">             *  method calls and completion handler calls.</span><br><span class="line">             */</span><br><span class="line">            session = [NSURLSession sessionWithConfiguration:sessionConfig</span><br><span class="line">                                                    delegate:self</span><br><span class="line">                                               delegateQueue:nil];</span><br><span class="line">            self.ownedSession = session;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">#pragma mark NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    // Identify the operation that runs this task and pass it the delegate method</span><br><span class="line">    NSOperation&lt;SDWebImageDownloaderOperation&gt; *dataOperation = [self operationWithTask:dataTask];</span><br><span class="line">    if ([dataOperation respondsToSelector:@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)]) &#123;</span><br><span class="line">        [dataOperation URLSession:session dataTask:dataTask didReceiveResponse:response completionHandler:completionHandler];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionHandler) &#123;</span><br><span class="line">            completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当网络请求成功或失败需要调用 done表示此操作已完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// make sure to call `[self done]` to mark operation as finished</span><br><span class="line">if (error) &#123;</span><br><span class="line">    // custom error instead of URLSession error</span><br><span class="line">    if (self.responseError) &#123;</span><br><span class="line">        error = self.responseError;</span><br><span class="line">    &#125;</span><br><span class="line">    [self callCompletionBlocksWithError:error];</span><br><span class="line">    [self done];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断两个Data是否相等，用什么？既不用 == ，也不用isEqualTo，而是isEqualToData</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.cachedData isEqualToData:imageData]</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件的总长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session</span><br><span class="line">          dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSURLSessionResponseDisposition disposition = NSURLSessionResponseAllow;</span><br><span class="line">    NSInteger expected = (NSInteger)response.expectedContentLength;</span><br><span class="line">    expected = expected &gt; 0 ? expected : 0;</span><br><span class="line">    self.expectedSize = expected;</span><br><span class="line">    self.response = response;</span><br><span class="line">    NSInteger statusCode = [response respondsToSelector:@selector(statusCode)] ? ((NSHTTPURLResponse *)response).statusCode : 200;</span><br><span class="line">    BOOL valid = statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400;</span><br><span class="line">    if (!valid) &#123;</span><br><span class="line">        self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorInvalidDownloadStatusCode userInfo:@&#123;SDWebImageErrorDownloadStatusCodeKey : @(statusCode)&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    //&apos;304 Not Modified&apos; is an exceptional one</span><br><span class="line">    //URLSession current behavior will return 200 status code when the server respond 304 and URLCache hit. But this is not a standard behavior and we just add a check</span><br><span class="line">    if (statusCode == 304 &amp;&amp; !self.cachedData) &#123;</span><br><span class="line">        valid = NO;</span><br><span class="line">        self.responseError = [NSError errorWithDomain:SDWebImageErrorDomain code:SDWebImageErrorCacheNotModified userInfo:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (valid) &#123;</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(0, expected, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // Status code invalid and marked as cancelled. Do not call `[self.dataTask cancel]` which may mass up URLSession life cycle</span><br><span class="line">        disposition = NSURLSessionResponseCancel;</span><br><span class="line">    &#125;</span><br><span class="line">    __block typeof(self) strongSelf = self;</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:strongSelf];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已经下载的长度，注意解码问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    if (!self.imageData) &#123;</span><br><span class="line">        self.imageData = [[NSMutableData alloc] initWithCapacity:self.expectedSize];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.imageData appendData:data];</span><br><span class="line">    </span><br><span class="line">    self.receivedSize = self.imageData.length;</span><br><span class="line">    if (self.expectedSize == 0) &#123;</span><br><span class="line">        // Unknown expectedSize, immediately call progressBlock and return</span><br><span class="line">        for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">            progressBlock(self.receivedSize, self.expectedSize, self.request.URL);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Get the finish status</span><br><span class="line">    BOOL finished = (self.receivedSize &gt;= self.expectedSize);</span><br><span class="line">    // Get the current progress</span><br><span class="line">    double currentProgress = (double)self.receivedSize / (double)self.expectedSize;</span><br><span class="line">    double previousProgress = self.previousProgress;</span><br><span class="line">    double progressInterval = currentProgress - previousProgress;</span><br><span class="line">    // Check if we need callback progress</span><br><span class="line">    if (!finished &amp;&amp; (progressInterval &lt; self.minimumProgressInterval)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    self.previousProgress = currentProgress;</span><br><span class="line"></span><br><span class="line">    if (self.options &amp; SDWebImageDownloaderProgressiveLoad) &#123;</span><br><span class="line">        // Get the image data</span><br><span class="line">        NSData *imageData = [self.imageData copy];</span><br><span class="line">        </span><br><span class="line">        // progressive decode the image in coder queue</span><br><span class="line">        dispatch_async(self.coderQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                UIImage *image = SDImageLoaderDecodeProgressiveImageData(imageData, self.request.URL, finished, self, [[self class] imageOptionsFromDownloaderOptions:self.options], self.context);</span><br><span class="line">                if (image) &#123;</span><br><span class="line">                    // We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</span><br><span class="line">                    </span><br><span class="line">                    [self callCompletionBlocksWithImage:image imageData:nil error:nil finished:NO];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (SDWebImageDownloaderProgressBlock progressBlock in [self callbacksForKey:kProgressCallbackKey]) &#123;</span><br><span class="line">        progressBlock(self.receivedSize, self.expectedSize, self.request.URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>token的多继承</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface SDWebImageDownloadToken : NSObject &lt;SDWebImageOperation&gt;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/10/04/SDWebImage都干了什么/" data-id="ckd90jol90039xc51ptmgx4p3" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Aspects都干了什么" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/10/01/Aspects都干了什么/">Aspects都干了什么？</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/10/01/Aspects都干了什么/" class="article-date">
  <time datetime="2017-09-30T16:31:35.000Z" itemprop="datePublished">2017-10-01</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ol>
<li>使用的OSSpinLockLock锁，不安全了! 详情</li>
<li>@”retain”, @”release”, @”autorelease”, @”forwardInvocation:”为黑名单不能hook</li>
<li>AspectPositionBefore is the only valid position when hooking dealloc.</li>
<li>Unable to find selector，即不能hook未识别方法</li>
<li>检查子类是否hook，子类hook相应方法super不再hook</li>
<li>由于使用的block，需要做blockSignature 和 selecterSignature校验</li>
<li><a href="https://developer.apple.com/documentation/foundation/nsmethodsignature" target="_blank" rel="noopener">NSMethodSignature官网</a>其中Type Encodings需要了解一下</li>
<li>类似KVO，生成一个subClass_Aspects_的子类</li>
<li>IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)<strong>ASPECTS_ARE_BEING_CALLED</strong>, “v@:@”);// If there is no method, replace will act like class_addMethod.</li>
<li><p>替换class，想不到吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line"></span><br><span class="line">static void aspect_hookedGetClass(Class class, Class statedClass) &#123;</span><br><span class="line">    NSCParameterAssert(class);</span><br><span class="line">    NSCParameterAssert(statedClass);</span><br><span class="line">    Method method = class_getInstanceMethod(class, @selector(class));</span><br><span class="line">    IMP newIMP = imp_implementationWithBlock(^(id self) &#123;</span><br><span class="line">        return statedClass;</span><br><span class="line">    &#125;);</span><br><span class="line">    class_replaceMethod(class, @selector(class), newIMP, method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把的subClass_Aspects_相关方法指向_objc_msgForward，// We use forwardInvocation to hook in.</p>
</li>
<li>如果没hook成功，则调用原来的((void( <em>)(id, SEL, NSInvocation </em>))objc_msgSend)(self, originalForwardInvocationSEL, invocation);</li>
<li>用before、after和instand三个数组来处理替换前替换后地或不调用原IMP</li>
<li></li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/10/01/Aspects都干了什么/" data-id="ckd90jok4000cxc51itdcjv6h" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Mach-O文件" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/09/29/Mach-O文件/">Mach-O文件</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/09/29/Mach-O文件/" class="article-date">
  <time datetime="2017-09-29T15:31:18.000Z" itemprop="datePublished">2017-09-29</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;大家都知道iOS编译到最后是Mach-O文件，其实就是iOS或OS X的可执行文件！</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>&emsp;&emsp;最后给大家安利两个工具：1、<a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView:mach-o文件解析器</a>可直接查看mach-o文件；2、OSX系统自带的otool可以分析Mach-O可执行文件</p>
<p><img src="https://upload-images.jianshu.io/upload_images/852671-9fde036a1ce9d902.jpg?imageMogr2/auto-orient/" alt="image"></p>
<h4 id="1-Header"><a href="#1-Header" class="headerlink" title="1 Header"></a>1 Header</h4><p>&emsp;&emsp;下载<a href="https://opensource.apple.com/tarballs/xnu/" target="_blank" rel="noopener">源码</a> -&gt; EXTERNAL_HEADERS -&gt; mach-o文件夹 -&gt; loader.h 查看相关源码，32位和64位区别不大，这里只贴了64位的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line">* 64-bit architectures.</span><br><span class="line">*/</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">uint32_t    magic;        /* mach magic number identifier */</span><br><span class="line">cpu_type_t    cputype;    /* cpu specifier */</span><br><span class="line">cpu_subtype_t    cpusubtype;    /* machine specifier */</span><br><span class="line">uint32_t    filetype;    /* type of file */</span><br><span class="line">uint32_t    ncmds;        /* number of load commands */</span><br><span class="line">uint32_t    sizeofcmds;    /* the size of all the load commands */</span><br><span class="line">uint32_t    flags;        /* flags */</span><br><span class="line">uint32_t    reserved;    /* reserved */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span><br><span class="line">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span><br><span class="line">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;简单解释</p>
<ul>
<li>magic 用于判断程序的平台版本</li>
<li>cputype 和 cpusubtype 用于判断cpu型号和cpu子型号</li>
<li><p>filetype 文件类型,决定了文件布局方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Constants for the filetype field of the mach_header</span><br><span class="line">*/</span><br><span class="line">#define    MH_OBJECT    0x1        /* relocatable object file */</span><br><span class="line">#define    MH_EXECUTE    0x2        /* demand paged executable file */</span><br><span class="line">#define    MH_FVMLIB    0x3        /* fixed VM shared library file */</span><br><span class="line"></span><br><span class="line">等...</span><br></pre></td></tr></table></figure>
</li>
<li><p>ncmds代表Load Command的个数</p>
</li>
<li>sizeofcmds代表ncmds段Load Command的总字节数</li>
<li><p>flags表示dyld加载标志位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Constants for the flags field of the mach_header */</span><br><span class="line">#define    MH_NOUNDEFS    0x1        /* the object file has no undefined</span><br><span class="line">references */</span><br><span class="line">#define    MH_INCRLINK    0x2        /* the object file is the output of an</span><br><span class="line"></span><br><span class="line">等...</span><br></pre></td></tr></table></figure>
</li>
<li><p>reserved是x64的保留位</p>
</li>
</ul>
<h3 id="2-Load-Command"><a href="#2-Load-Command" class="headerlink" title="2 Load Command"></a>2 Load Command</h3><p>&emsp;&emsp;先看源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct load_command &#123;</span><br><span class="line">uint32_t cmd;</span><br><span class="line">uint32_t cmdsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;每一个command前两个字段必须是CMD和CMDSIZE，且每一个都是一个特殊的结构体，所以除了cmd之外还需要cmdsize<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Constants for the cmd field of all load commands, the type */</span><br><span class="line">#define    LC_SEGMENT    0x1    /* segment of this file to be mapped */</span><br><span class="line">#define    LC_SYMTAB    0x2    /* link-edit stab symbol table info */</span><br><span class="line"></span><br><span class="line">等...</span><br></pre></td></tr></table></figure></p>
<h3 id="3-segment-command"><a href="#3-segment-command" class="headerlink" title="3 segment_command"></a>3 segment_command</h3><p>&emsp;&emsp;直接使用LC_xxx搜索就能搜到相应的cmd数据结构，直接搜索LC_SEGMENT ，查看segment的结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* The 64-bit segment load command indicates that a part of this file is to be</span><br><span class="line">* mapped into a 64-bit task&apos;s address space.  If the 64-bit segment has</span><br><span class="line">* sections then section_64 structures directly follow the 64-bit segment</span><br><span class="line">* command and their size is reflected in cmdsize.</span><br><span class="line">*/</span><br><span class="line">struct segment_command_64 &#123; /* for 64-bit architectures */</span><br><span class="line">uint32_t    cmd;        /* LC_SEGMENT_64 */</span><br><span class="line">uint32_t    cmdsize;    /* includes sizeof section_64 structs */</span><br><span class="line">char        segname[16];    /* segment name */</span><br><span class="line">uint64_t    vmaddr;        /* memory address of this segment */</span><br><span class="line">uint64_t    vmsize;        /* memory size of this segment */</span><br><span class="line">uint64_t    fileoff;    /* file offset of this segment */</span><br><span class="line">uint64_t    filesize;    /* amount to map from the file */</span><br><span class="line">vm_prot_t    maxprot;    /* maximum VM protection */</span><br><span class="line">vm_prot_t    initprot;    /* initial VM protection */</span><br><span class="line">uint32_t    nsects;        /* number of sections in segment */</span><br><span class="line">uint32_t    flags;        /* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意问题（大小写敏感）</p>
<ul>
<li>__TEXT segment 包含了被执行的代码。它被以只读和可执行的方式映射。进程被允许执行这些代码，但是不能修改。这些代码也不能对自己做出修改，因此这些被映射的页从来不会被改变。</li>
<li>__DATA segment 以可读写和不可执行的方式映射。它包含了将会被更改的数据。</li>
</ul>
<h3 id="4-section"><a href="#4-section" class="headerlink" title="4 section"></a>4 section</h3><p>&emsp;&emsp;源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct section_64 &#123; /* for 64-bit architectures */</span><br><span class="line">char        sectname[16];    /* name of this section */</span><br><span class="line">char        segname[16];    /* segment this section goes in */</span><br><span class="line">uint64_t    addr;        /* memory address of this section */</span><br><span class="line">uint64_t    size;        /* size in bytes of this section */</span><br><span class="line">uint32_t    offset;        /* file offset of this section */</span><br><span class="line">uint32_t    align;        /* section alignment (power of 2) */</span><br><span class="line">uint32_t    reloff;        /* file offset of relocation entries */</span><br><span class="line">uint32_t    nreloc;        /* number of relocation entries */</span><br><span class="line">uint32_t    flags;        /* flags (section type and attributes)*/</span><br><span class="line">uint32_t    reserved1;    /* reserved (for offset or index) */</span><br><span class="line">uint32_t    reserved2;    /* reserved (for count or sizeof) */</span><br><span class="line">uint32_t    reserved3;    /* reserved */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;常见的Section，<a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/Assembler/" target="_blank" rel="noopener">更多</a></p>
<table>
<thead>
<tr>
<th>Section</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TEXT.</strong>text</td>
<td>主程序代码</td>
</tr>
<tr>
<td><strong>TEXT.</strong>cstring</td>
<td>C 语言字符串</td>
</tr>
<tr>
<td><strong>TEXT.</strong>const</td>
<td>const 关键字修饰的常量</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs</td>
<td>用于 Stub 的占位代码，很多地方称之为桩代码。</td>
</tr>
<tr>
<td><strong>TEXT.</strong>stubs_helper</td>
<td>当 Stub 无法找到真正的符号地址后的最终指向</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_methname</td>
<td>Objective-C 方法名称</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_methtype</td>
<td>Objective-C 方法类型</td>
</tr>
<tr>
<td><strong>TEXT.</strong>objc_classname</td>
<td>Objective-C 类名称</td>
</tr>
<tr>
<td><strong>DATA.</strong>data</td>
<td>初始化过的可变数据</td>
</tr>
<tr>
<td><strong>DATA.</strong>la_symbol_ptr</td>
<td>lazy binding 的指针表，表中的指针一开始都指向 __stub_helper</td>
</tr>
<tr>
<td>__DATA.nl_symbol_ptr</td>
<td>非 lazy binding 的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</td>
</tr>
<tr>
<td><strong>DATA.</strong>const</td>
<td>没有初始化过的常量</td>
</tr>
<tr>
<td><strong>DATA.</strong>cfstring</td>
<td>程序中使用的 Core Foundation 字符串（CFStringRefs）</td>
</tr>
<tr>
<td><strong>DATA.</strong>bss</td>
<td>BSS，存放为初始化的全局变量，即常说的静态内存分配</td>
</tr>
<tr>
<td><strong>DATA.</strong>common</td>
<td>没有初始化过的符号声明</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_classlist</td>
<td>Objective-C 类列表</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_protolist</td>
<td>Objective-C 原型</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_imginfo</td>
<td>Objective-C 镜像信息</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_selfrefs</td>
<td>Objective-C self 引用</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_protorefs</td>
<td>Objective-C 原型引用</td>
</tr>
<tr>
<td><strong>DATA.</strong>objc_superrefs</td>
<td>Objective-C 超类引用</td>
</tr>
</tbody>
</table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://objccn.io/issue-6-3/" target="_blank" rel="noopener">objc中国 Mach-O 可执行文件</a></li>
<li><a href="https://www.jianshu.com/p/54d842db3f69" target="_blank" rel="noopener">趣探 Mach-O：文件格式分析</a></li>
<li><a href="https://www.jianshu.com/p/8498cec10a41" target="_blank" rel="noopener">趣探 Mach-O：加载过程</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/09/29/Mach-O文件/" data-id="ckd90joks0020xc51xnc52xsz" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-MJRefresh或SVPullToRefresh都干了什么" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/09/28/MJRefresh或SVPullToRefresh都干了什么/">MJRefresh或SVPullToRefresh 都干了什么？</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/09/28/MJRefresh或SVPullToRefresh都干了什么/" class="article-date">
  <time datetime="2017-09-27T16:31:35.000Z" itemprop="datePublished">2017-09-28</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="MJRefresh"><a href="#MJRefresh" class="headerlink" title="MJRefresh"></a>MJRefresh</h3><p>MJRefresh的prepare和placeSubView巧妙的利用self特征，即self表示的是当前的实例对象，重写父类方法，再调用的时候就会调用到对应子类的实际placeSubview方法，即重载；第二个有意思的地方是 属性的setter实例化view就直接加上了；第三监听contentoffset的偏移量来设置state</p>
<ol>
<li><p>基类，注意scrollView的声明方式 weak以及readonly的写法;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** 刷新控件的基类 */</span><br><span class="line">@interface MJRefreshComponent : UIView</span><br><span class="line">&#123;</span><br><span class="line">    /** 记录scrollView刚开始的inset */</span><br><span class="line">    UIEdgeInsets _scrollViewOriginalInset;</span><br><span class="line">    /** 父控件 */</span><br><span class="line">    __weak UIScrollView *_scrollView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 交给子类去访问</span><br><span class="line">/** 记录scrollView刚开始的inset */</span><br><span class="line">@property (assign, nonatomic, readonly) UIEdgeInsets scrollViewOriginalInset;</span><br><span class="line">/** 父控件 */</span><br><span class="line">@property (weak, nonatomic, readonly) UIScrollView *scrollView;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子view初始化在哪里？注意强制子类调用父类方法；因为如果使用init初始化下拉刷新这是的frame是cgrectzero，没法布局；还有一个因素下面讲</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** 初始化 */</span><br><span class="line">- (void)prepare NS_REQUIRES_SUPER;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">        // 准备工作</span><br><span class="line">        [self prepare];</span><br><span class="line">        </span><br><span class="line">        // 默认是普通状态</span><br><span class="line">        self.state = MJRefreshStateIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prepare</span><br><span class="line">&#123;</span><br><span class="line">    // 基本属性</span><br><span class="line">    self.autoresizingMask = UIViewAutoresizingFlexibleWidth;</span><br><span class="line">    self.backgroundColor = [UIColor clearColor];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子view的布局在哪里？注意强制子类调用父类方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** 摆放子控件frame */</span><br><span class="line">- (void)placeSubviews NS_REQUIRES_SUPER;</span><br><span class="line"></span><br><span class="line">- (void)layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [self placeSubviews];</span><br><span class="line">    </span><br><span class="line">    [super layoutSubviews];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)placeSubviews&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子view的加载方式:weak、懒加载、另外懒加载时就直接addsubview了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@property (weak, nonatomic) UIActivityIndicatorView *loadingView;</span><br><span class="line"></span><br><span class="line">#pragma mark - 懒加载子控件</span><br><span class="line">- (UIActivityIndicatorView *)loadingView</span><br><span class="line">&#123;</span><br><span class="line">    if (!_loadingView) &#123;</span><br><span class="line">        UIActivityIndicatorView *loadingView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:self.activityIndicatorViewStyle];</span><br><span class="line">        loadingView.hidesWhenStopped = YES;</span><br><span class="line">        [self addSubview:_loadingView = loadingView];</span><br><span class="line">    &#125;</span><br><span class="line">    return _loadingView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>巧妙地关联对象; 这样就不需要专门的addSubView时机了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMj_header:(MJRefreshHeader *)mj_header</span><br><span class="line">&#123;</span><br><span class="line">    if (mj_header != self.mj_header) &#123;</span><br><span class="line">        // 删除旧的，添加新的</span><br><span class="line">        [self.mj_header removeFromSuperview];</span><br><span class="line">        // 插到tablview的最顶层</span><br><span class="line">        [self insertSubview:mj_header atIndex:0];</span><br><span class="line">        </span><br><span class="line">        // 存储新的</span><br><span class="line">        objc_setAssociatedObject(self, &amp;MJRefreshHeaderKey,</span><br><span class="line">                                 mj_header, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MJRefreshHeader *)mj_header</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;MJRefreshHeaderKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置tableView.mj_header 出发 [self insertSubview:mj_header atIndex:0]; 然后就触发了willMoveToSuperview</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</span><br><span class="line">&#123;</span><br><span class="line">    [super willMoveToSuperview:newSuperview];</span><br><span class="line">    </span><br><span class="line">    // 如果不是UIScrollView，不做任何事情</span><br><span class="line">    if (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[UIScrollView class]]) return;</span><br><span class="line">    </span><br><span class="line">    // 旧的父控件移除监听</span><br><span class="line">    [self removeObservers];</span><br><span class="line">    </span><br><span class="line">    if (newSuperview) &#123; // 新的父控件</span><br><span class="line">        // 设置宽度</span><br><span class="line">        self.mj_w = newSuperview.mj_w;</span><br><span class="line">        // 设置位置</span><br><span class="line">        self.mj_x = -_scrollView.mj_insetL;</span><br><span class="line">        </span><br><span class="line">        // 记录UIScrollView</span><br><span class="line">        _scrollView = (UIScrollView *)newSuperview;</span><br><span class="line">        // 设置永远支持垂直弹簧效果</span><br><span class="line">        _scrollView.alwaysBounceVertical = YES;</span><br><span class="line">        // 记录UIScrollView最开始的contentInset</span><br><span class="line">        _scrollViewOriginalInset = _scrollView.mj_inset;</span><br><span class="line">        </span><br><span class="line">        // 添加监听</span><br><span class="line">        [self addObservers];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听ContentOffset，ContentSize和手势，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObservers</span><br><span class="line">&#123;</span><br><span class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</span><br><span class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil];</span><br><span class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil];</span><br><span class="line">    self.pan = self.scrollView.panGestureRecognizer;</span><br><span class="line">    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>state状态改变则需要刷新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    _state = state;</span><br><span class="line">    </span><br><span class="line">    // 加入主队列的目的是等setState:方法调用完毕、设置完文字后再去布局子控件</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue([self setNeedsLayout];)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意VC切换问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)beginRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">        self.alpha = 1.0;</span><br><span class="line">    &#125;];</span><br><span class="line">    self.pullingPercent = 1.0;</span><br><span class="line">    // 只要正在刷新，就完全显示</span><br><span class="line">    if (self.window) &#123;</span><br><span class="line">        self.state = MJRefreshStateRefreshing;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 预防正在刷新中时，调用本方法使得header inset回置失败</span><br><span class="line">        if (self.state != MJRefreshStateRefreshing) &#123;</span><br><span class="line">            self.state = MJRefreshStateWillRefresh;</span><br><span class="line">            // 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span><br><span class="line">            [self setNeedsDisplay];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>展示之前</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect</span><br><span class="line">&#123;</span><br><span class="line">    [super drawRect:rect];</span><br><span class="line">    </span><br><span class="line">    if (self.state == MJRefreshStateWillRefresh) &#123;</span><br><span class="line">        // 预防view还没显示出来就调用了beginRefreshing</span><br><span class="line">        self.state = MJRefreshStateRefreshing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>endRefreshing, state状态驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark 结束刷新状态</span><br><span class="line">- (void)endRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshDispatchAsyncOnMainQueue(self.state = MJRefreshStateIdle;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="SVPullToRefresh"><a href="#SVPullToRefresh" class="headerlink" title="SVPullToRefresh"></a>SVPullToRefresh</h3><ol>
<li><p>手动调用KVO</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPullToRefreshView:(SVPullToRefreshView *)pullToRefreshView &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;SVPullToRefreshView&quot;];</span><br><span class="line">    objc_setAssociatedObject(self, &amp;UIScrollViewPullToRefreshView,</span><br><span class="line">                             pullToRefreshView,</span><br><span class="line">                             OBJC_ASSOCIATION_ASSIGN);</span><br><span class="line">    [self didChangeValueForKey:@&quot;SVPullToRefreshView&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SVPullToRefreshView *)pullToRefreshView &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;UIScrollViewPullToRefreshView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一如既往的弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) UIScrollView *scrollView;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一定要计算inset，实际上上面MJ也保存了inset，思路是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view.originalTopInset = self.contentInset.top;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多监听了一个frame</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[self addObserver:self.pullToRefreshView forKeyPath:@&quot;contentOffset&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">[self addObserver:self.pullToRefreshView forKeyPath:@&quot;contentSize&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">[self addObserver:self.pullToRefreshView forKeyPath:@&quot;frame&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br></pre></td></tr></table></figure>
</li>
<li><p>监听contentOffset然后手动调scrollViewDidScroll，总感觉怪怪的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123;</span><br><span class="line">    if([keyPath isEqualToString:@&quot;contentOffset&quot;])</span><br><span class="line">        [self scrollViewDidScroll:[[change valueForKey:NSKeyValueChangeNewKey] CGPointValue]];</span><br><span class="line">    else if([keyPath isEqualToString:@&quot;contentSize&quot;]) &#123;</span><br><span class="line">        [self layoutSubviews];</span><br><span class="line">        </span><br><span class="line">        CGFloat yOrigin;</span><br><span class="line">        switch (self.position) &#123;</span><br><span class="line">            case SVPullToRefreshPositionTop:</span><br><span class="line">                yOrigin = -SVPullToRefreshViewHeight;</span><br><span class="line">                break;</span><br><span class="line">            case SVPullToRefreshPositionBottom:</span><br><span class="line">                yOrigin = MAX(self.scrollView.contentSize.height, self.scrollView.bounds.size.height);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        self.frame = CGRectMake(0, yOrigin, self.bounds.size.width, SVPullToRefreshViewHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    else if([keyPath isEqualToString:@&quot;frame&quot;])</span><br><span class="line">        [self layoutSubviews];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)scrollViewDidScroll:(CGPoint)contentOffset &#123;</span><br><span class="line">    if(self.state != SVPullToRefreshStateLoading) &#123;</span><br><span class="line">        CGFloat scrollOffsetThreshold = 0;</span><br><span class="line">        switch (self.position) &#123;</span><br><span class="line">            case SVPullToRefreshPositionTop:</span><br><span class="line">                scrollOffsetThreshold = self.frame.origin.y - self.originalTopInset;</span><br><span class="line">                break;</span><br><span class="line">            case SVPullToRefreshPositionBottom:</span><br><span class="line">                scrollOffsetThreshold = MAX(self.scrollView.contentSize.height - self.scrollView.bounds.size.height, 0.0f) + self.bounds.size.height + self.originalBottomInset;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(!self.scrollView.isDragging &amp;&amp; self.state == SVPullToRefreshStateTriggered)</span><br><span class="line">            self.state = SVPullToRefreshStateLoading;</span><br><span class="line">        else if(contentOffset.y &lt; scrollOffsetThreshold &amp;&amp; self.scrollView.isDragging &amp;&amp; self.state == SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionTop)</span><br><span class="line">            self.state = SVPullToRefreshStateTriggered;</span><br><span class="line">        else if(contentOffset.y &gt;= scrollOffsetThreshold &amp;&amp; self.state != SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionTop)</span><br><span class="line">            self.state = SVPullToRefreshStateStopped;</span><br><span class="line">        else if(contentOffset.y &gt; scrollOffsetThreshold &amp;&amp; self.scrollView.isDragging &amp;&amp; self.state == SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionBottom)</span><br><span class="line">            self.state = SVPullToRefreshStateTriggered;</span><br><span class="line">        else if(contentOffset.y &lt;= scrollOffsetThreshold &amp;&amp; self.state != SVPullToRefreshStateStopped &amp;&amp; self.position == SVPullToRefreshPositionBottom)</span><br><span class="line">            self.state = SVPullToRefreshStateStopped;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        CGFloat offset;</span><br><span class="line">        UIEdgeInsets contentInset;</span><br><span class="line">        switch (self.position) &#123;</span><br><span class="line">            case SVPullToRefreshPositionTop:</span><br><span class="line">                offset = MAX(self.scrollView.contentOffset.y * -1, 0.0f);</span><br><span class="line">                offset = MIN(offset, self.originalTopInset + self.bounds.size.height);</span><br><span class="line">                contentInset = self.scrollView.contentInset;</span><br><span class="line">                self.scrollView.contentInset = UIEdgeInsetsMake(offset, contentInset.left, contentInset.bottom, contentInset.right);</span><br><span class="line">                break;</span><br><span class="line">            case SVPullToRefreshPositionBottom:</span><br><span class="line">                if (self.scrollView.contentSize.height &gt;= self.scrollView.bounds.size.height) &#123;</span><br><span class="line">                    offset = MAX(self.scrollView.contentSize.height - self.scrollView.bounds.size.height + self.bounds.size.height, 0.0f);</span><br><span class="line">                    offset = MIN(offset, self.originalBottomInset + self.bounds.size.height);</span><br><span class="line">                    contentInset = self.scrollView.contentInset;</span><br><span class="line">                    self.scrollView.contentInset = UIEdgeInsetsMake(contentInset.top, contentInset.left, offset, contentInset.right);</span><br><span class="line">                &#125; else if (self.wasTriggeredByUser) &#123;</span><br><span class="line">                    offset = MIN(self.bounds.size.height, self.originalBottomInset + self.bounds.size.height);</span><br><span class="line">                    contentInset = self.scrollView.contentInset;</span><br><span class="line">                    self.scrollView.contentInset = UIEdgeInsetsMake(-offset, contentInset.left, contentInset.bottom, contentInset.right);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>subView的加载倒是出奇的一致！唯一区别是MJ用weak修饰，其实我也觉得应该用weak</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, readwrite) UILabel *titleLabel;</span><br><span class="line"></span><br><span class="line">- (UILabel *)titleLabel &#123;</span><br><span class="line">    if(!_titleLabel) &#123;</span><br><span class="line">        _titleLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 210, 20)];</span><br><span class="line">        _titleLabel.text = NSLocalizedString(@&quot;Pull to refresh...&quot;,);</span><br><span class="line">        _titleLabel.font = [UIFont boldSystemFontOfSize:14];</span><br><span class="line">        _titleLabel.backgroundColor = [UIColor clearColor];</span><br><span class="line">        _titleLabel.textColor = textColor;</span><br><span class="line">        [self addSubview:_titleLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    return _titleLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>都是通过state状态驱动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (void)setState:(SVPullToRefreshState)newState &#123;</span><br><span class="line">    </span><br><span class="line">    if(_state == newState)</span><br><span class="line">        return;</span><br><span class="line">    </span><br><span class="line">    SVPullToRefreshState previousState = _state;</span><br><span class="line">    _state = newState;</span><br><span class="line">    </span><br><span class="line">    [self setNeedsLayout];</span><br><span class="line">    [self layoutIfNeeded];</span><br><span class="line">    </span><br><span class="line">    switch (newState) &#123;</span><br><span class="line">        case SVPullToRefreshStateAll:</span><br><span class="line">        case SVPullToRefreshStateStopped:</span><br><span class="line">            [self resetScrollViewContentInset];</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case SVPullToRefreshStateTriggered:</span><br><span class="line">            break;</span><br><span class="line">            </span><br><span class="line">        case SVPullToRefreshStateLoading:</span><br><span class="line">            [self setScrollViewContentInsetForLoading];</span><br><span class="line">            </span><br><span class="line">            if(previousState == SVPullToRefreshStateTriggered &amp;&amp; pullToRefreshActionHandler)</span><br><span class="line">                pullToRefreshActionHandler();</span><br><span class="line">            </span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/09/28/MJRefresh或SVPullToRefresh都干了什么/" data-id="ckd90jokq001wxc51iex4gwj2" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-dyld笔记" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/09/23/dyld笔记/">dyld笔记</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/09/23/dyld笔记/" class="article-date">
  <time datetime="2017-09-23T10:14:18.000Z" itemprop="datePublished">2017-09-23</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;前一段时间整理了下iOS的编译过程，对整体流程有了个大概印象！但在<a href="https://www.jianshu.com/p/d5cf01424e92" target="_blank" rel="noopener">点击 Run 之后发生了什么？</a>里提到了APP启动中dyld的作用，对此了解不是很多，只是知道dyld是用来加载的，正好看到大神的相关文章，这次就水一水dyld笔记吧</p>
<p>&emsp;&emsp;先下载<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">dyld源码</a></p>
<h3 id="1-dyld-start"><a href="#1-dyld-start" class="headerlink" title="1 __dyld_start"></a>1 __dyld_start</h3><p>&emsp;&emsp;load方法打个断点，调用栈第一个就是我们要观察的__dyld_start的方法。汇编看不懂(虽然LLVM -dis可以反汇编，但IR文件更不好理解，而且没必要)，但有注释呀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"># call dyldbootstrap::start(app_mh, argc, argv, slide, dyld_mh, &amp;startGlue)</span><br><span class="line">...</span><br><span class="line"># clean up stack and jump to &quot;start&quot; in main executable</span><br><span class="line">...</span><br><span class="line"># LC_MAIN case, set up stack for call to main()</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;扩展：执行__dyld_start之前执行了什么？参考:<a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/" target="_blank" rel="noopener">_dyld_start之前</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">▼ execve       // 用户点击了app, 用户态会发送一个系统调用 execve 到内核</span><br><span class="line">▼ __mac_execve  // 创建线程</span><br><span class="line">▼ exec_activate_image // 在 encapsulated_binary 这一步会根据image的类型选择imgact的方法</span><br><span class="line">▼ exec_mach_imgact</span><br><span class="line">▼ load_machfile</span><br><span class="line">▶︎ parse_machfile  //解析主二进制macho</span><br><span class="line">▼ load_dylinker // 解析完 macho后，根据macho中的 LC_LOAD_DYLINKER 这个LoadCommand来启动这个二进制的加载器，即 /usr/bin/dyld</span><br><span class="line">▼ parse_machfile // 解析 dyld 这个mach-o文件，这个过程中会解析出entry_point</span><br><span class="line">▼ activate_exec_state</span><br><span class="line">▶︎ thread_setentrypoint // 设置entry_point。</span><br></pre></td></tr></table></figure></p>
<h3 id="2-dyldbootstrap-start-方法"><a href="#2-dyldbootstrap-start-方法" class="headerlink" title="2 dyldbootstrap::start 方法"></a>2 dyldbootstrap::start 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">//  This is code to bootstrap dyld.  This work in normally done for a program by dyld and crt. // 就是启动dyld的</span><br><span class="line">//  In dyld we have to do this manually.</span><br><span class="line">//</span><br><span class="line">uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader,uintptr_t* startGlue) &#123;</span><br><span class="line"></span><br><span class="line">// 中间主要是重绑定判断、参数转化等</span><br><span class="line"></span><br><span class="line">// 最后调用</span><br><span class="line">return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-dyld-main"><a href="#3-dyld-main" class="headerlink" title="3 dyld::_main"></a>3 dyld::_main</h3><p>&emsp;&emsp;有将近500行代码,说实话没太看懂，还是直接贴大神的总结吧！另外写一点我感兴趣的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 设置运行环境，环境变量</span><br><span class="line">2. 加载共享缓存</span><br><span class="line">3. 实例化Image</span><br><span class="line">4. 动态库的版本化重载</span><br><span class="line">5. 加载插入的动态库</span><br><span class="line">6. link主程序</span><br><span class="line">7. link插入的动态库</span><br><span class="line">8. weakBind</span><br><span class="line">9. initialize</span><br><span class="line">10.main</span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-加载dyld-image-和-main-image，"><a href="#3-1-加载dyld-image-和-main-image，" class="headerlink" title="3.1 加载dyld image 和 main image，"></a>3.1 加载dyld image 和 main image，</h4><p>&emsp;&emsp;不看代码我一直以为dyldbootstrap::start阶段就已经加载dyld image<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Trace dyld&apos;s load</span><br><span class="line">notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, &quot;dyld_file&quot;));</span><br><span class="line">#if !TARGET_IPHONE_SIMULATOR</span><br><span class="line">// Trace the main executable&apos;s load</span><br><span class="line">notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &quot;executable_file&quot;));</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<h4 id="3-2-奇怪的注释"><a href="#3-2-奇怪的注释" class="headerlink" title="3.2 奇怪的注释"></a>3.2 奇怪的注释</h4><p>&emsp;&emsp; 突然间出现 // could not use closure info, launch old way  注释，也没找到return或else处理，这个注释是啥意思？怎么launch old way？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// load shared cache</span><br><span class="line">checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">// 接下来校验closure是否需要支持，以及一些措施</span><br><span class="line"></span><br><span class="line">// 问题在这，</span><br><span class="line">// could not use closure info, launch old way</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-instantiateFromLoadedImage"><a href="#3-3-instantiateFromLoadedImage" class="headerlink" title="3.3 instantiateFromLoadedImage"></a>3.3 instantiateFromLoadedImage</h4><p>&emsp;&emsp; isCompatibleMachO 是检查mach-o的subtype是否是当前cpu可以支持； <em> instantiateMainExecutable 就是实例化可执行文件， 这个期间会解析LoadCommand， 这个之后会发送 dyld_image_state_mapped 通知； </em> addImage 添加到 allImages中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static ImageLoader* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</span><br><span class="line">&#123;</span><br><span class="line">// try mach-o loader</span><br><span class="line">if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span><br><span class="line">ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">addImage(image);</span><br><span class="line">return image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">throw &quot;main executable not a known format&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-4-load-libraries"><a href="#3-4-load-libraries" class="headerlink" title="3.4 load libraries"></a>3.4 load libraries</h4><p>&emsp;&emsp; inserted 环境 libraries, then main, then others.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// load any inserted libraries</span><br><span class="line">if    ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</span><br><span class="line">for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </span><br><span class="line">loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br><span class="line">// record count of inserted libraries so that a flat search will look at </span><br><span class="line">// inserted libraries, then main, then others.</span><br><span class="line">sInsertedDylibCount = sAllImages.size()-1;</span><br><span class="line"></span><br><span class="line">// link main executable</span><br><span class="line">gLinkContext.linkingMainExecutable = true;</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">if ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">// previous link() on main executable has already adjusted its internal pointers for ASLR</span><br><span class="line">// work around that by rebasing by inverse amount</span><br><span class="line">sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">gLinkContext.bindFlat = true;</span><br><span class="line">gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// link any inserted libraries</span><br><span class="line">// do this after linking main executable so that any dylibs pulled in by inserted </span><br><span class="line">// dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span><br><span class="line">if ( sInsertedDylibCount &gt; 0 ) &#123;</span><br><span class="line">for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+1];</span><br><span class="line">link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">image-&gt;setNeverUnloadRecursive();</span><br><span class="line">&#125;</span><br><span class="line">// only INSERTED libraries can interpose</span><br><span class="line">// register interposing info after all inserted libraries are bound so chaining works</span><br><span class="line">for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">ImageLoader* image = sAllImages[i+1];</span><br><span class="line">image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-weakBind"><a href="#3-5-weakBind" class="headerlink" title="3.5 weakBind"></a>3.5 weakBind</h4><p>&emsp;&emsp; 强符号：函数和已经初始化的全局变量;弱符号：未初始化的全局变量！弱符号对于库来说十分有用，我们在开发库时，可以将某些符号定义为弱符号，这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，增加了很大的灵活性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sMainExecutable-&gt;weakBind(gLinkContext);</span><br></pre></td></tr></table></figure></p>
<h4 id="总结：dyld-作用顺序的概括"><a href="#总结：dyld-作用顺序的概括" class="headerlink" title="总结：dyld 作用顺序的概括"></a>总结：dyld 作用顺序的概括</h4><ul>
<li>从 kernel 留下的原始调用栈引导和启动自己</li>
<li>将程序依赖的动态链接库递归加载进内存，当然这里有缓存机制</li>
<li>non-lazy 符号立即 link 到可执行文件，lazy 的存表里</li>
<li>Runs static initializers for the executable</li>
<li>找到可执行文件的 main 函数，准备参数并调用</li>
<li>程序执行中负责绑定 lazy 符号、提供 runtime dynamic loading services、提供调试器接口</li>
<li>程序main函数 return 后执行 static terminator</li>
<li>某些场景下 main 函数结束后调 libSystem 的 _exit 函数</li>
</ul>
<h3 id="其它：-objc的启动"><a href="#其它：-objc的启动" class="headerlink" title="其它： objc的启动"></a>其它： objc的启动</h3><p>&emsp;&emsp; _objc_init源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">static bool initialized = false;</span><br><span class="line">if (initialized) return;</span><br><span class="line">initialized = true;</span><br><span class="line"></span><br><span class="line">// 各种初始化</span><br><span class="line">environ_init();</span><br><span class="line">tls_init();</span><br><span class="line">static_init();</span><br><span class="line">lock_init();</span><br><span class="line">// 看了一下exception_init是空实现！！就是说objc的异常是完全采用c++那一套的。</span><br><span class="line">exception_init();</span><br><span class="line">// 注册dyld事件的监听</span><br><span class="line">_dyld_objc_notify_register(&amp;map_2_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>dyld 开始将程序二进制文件初始化</li>
<li>交由 ImageLoader 读取 image，其中包含了我们的类、方法等各种符号</li>
<li>再由libsystem 中的一个initialize方法 libsystem_initializer中初始化了 libdispatch</li>
<li>然后libdispatch调用了_os_object_int, 最终调用了 _objc_init，并绑定runtime回调</li>
<li>由于 runtime 向 dyld 绑定了回调，当 image 加载到内存后，dyld 会通知 runtime 进行处理</li>
<li>runtime 接手后调用 map_images 做解析和处理，接下来 load_images 中调用 call_load_methods 方法，遍历所有加载进来的 Class，按继承层级依次调用 Class 的 +load 方法和其 Category 的 +load 方法</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">iOS 程序 main 函数之前发生了什么</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/06/20/dyldyu-objc/" target="_blank" rel="noopener">dyld与ObjC</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/06/30/dyld2/" target="_blank" rel="noopener">Dyld系列之一：_dyld_start之前</a></li>
<li><a href="https://blog.cnbluebox.com/blog/2017/10/12/dyld2/" target="_blank" rel="noopener">Dyld之二: 动态链接过程</a></li>
<li><a href="https://segmentfault.com/a/1190000007769327" target="_blank" rel="noopener">dyld 加载 Mach-O</a></li>
<li><a href="https://blog.csdn.net/gaoyuqiang30/article/details/52536168" target="_blank" rel="noopener">iOS中的dyld缓存是什么？</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/09/23/dyld笔记/" data-id="ckd90jolv004kxc519oy4wy8p" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-iOS编译过程" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/09/16/iOS编译过程/">iOS编译过程</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/09/16/iOS编译过程/" class="article-date">
  <time datetime="2017-09-16T10:14:18.000Z" itemprop="datePublished">2017-09-16</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-编译简介"><a href="#1-编译简介" class="headerlink" title="1 编译简介"></a>1 编译简介</h3><h4 id="1-1-编译"><a href="#1-1-编译" class="headerlink" title="1.1 编译"></a>1.1 编译</h4><p>&emsp;&emsp;把高级语言翻译成机器语言或汇编语言，叫编译！</p>
<p>&emsp;&emsp;语言翻译的两种基本形态: 编译器与解释器</p>
<ul>
<li>编译器采用先翻译后执行. 例如C语言 .c -&gt; .o -&gt; 再运行！特点：工作效率高,可移植性差，时间换空间</li>
<li>解释器采用边翻译边执行. 例如shell 边写边执行！特点：工作效率低,可移植性好，空间换时间</li>
</ul>
<p>&emsp;&emsp;一般编译器有以下工作步骤：</p>
<ol>
<li>词法分析（lexical analysis）：此阶段的任务是从左到右一个字符一个字符地读入源程序，使用词法分析器（扫描器）对构成源程序的字符流进行扫描然后根据语言的词法规则识别单词（Token），至少分以下几类：关键字(保留字)、标识符、字面量、特殊符号</li>
</ol>
<ul>
<li>1.1 识别记号并交给语法分析器(根据模式识别记号)</li>
<li>1.2 滤掉源程序中的无用成分,如注释、空格和回车等</li>
<li>1.3 处理与具体平台有关的输入(如文件结束符的不同表示等)</li>
</ul>
<ol start="2">
<li>语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser）</li>
<li>语义分析（Syntax analysis）：根据语义规则对语法树中的语法单元进行静态语义检查,如类型检查和转换等,目的是保证语法和语义都正确，因为一个语法上正确的句子，它所代表的意义并不一定正确.</li>
<li>中间码生成（可选）：生成一种既接近目标语言,又与具体机器无关的表示,便于代码优化与代码生成.好处是前后分离，便于扩展</li>
<li>中间代码优化(可选)：优化后功能相同，但在占用的空间上和程序执行的时间上都更省、更有效</li>
<li>目标代码生成：一般分为三种形式目标代码，A 汇编；B 可重定位二进制；C 内存形式</li>
<li>目标代码</li>
</ol>
<p>&emsp;&emsp;编译过程 1 至 6 阶段，都会管理符号表，便于各个阶段的查找\填写等工作；另外各个阶段都会有出错处理</p>
<p>&emsp;&emsp;编译器和解释器的区别往往是在第4步(中间代码)之后开始的.编译型语言的可执行程序产生的是直接执行机器指令，而解释型语言的每一句源代码都要经过解释器解释为可以执行的机器指令</p>
<p>&emsp;&emsp;最后，编译器完成编译后，由链接器（Linker）将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。</p>
<h4 id="1-2-链接"><a href="#1-2-链接" class="headerlink" title="1.2 链接"></a>1.2 链接</h4><p>&emsp;&emsp;静态链接：在编译链接期间发挥作用，把目标文件和静态库一起链接形成可执行文件</p>
<p>&emsp;&emsp;链接器需要对源代码进行的处理：</p>
<ol>
<li>对各个目标文件中没有定义的变量，在其他目标文件中寻找到相关的定义。</li>
<li>把不同目标文件中生成的同类型的段进行合并。</li>
<li>对不同目标文件中的变量进行地址重定位。</li>
</ol>
<h4 id="1-3-装载"><a href="#1-3-装载" class="headerlink" title="1.3 装载"></a>1.3 装载</h4><p>&emsp;&emsp;动态链接库需要编译器做的最基本的事情：</p>
<ol>
<li>链接库在将目标文件链接成可执行文件的时候如果发现某一个变量或者函数在目标文件中找不到，会按预定义的动态库寻找路径寻找动态库中定义的变量或者函数。</li>
<li>如果链接库在某一个动态链接库中找到了该变量或者函数定义，链接库首先会把这个动态链接库写到可执行文件的依赖库中，然后生成这个当前变量或者函数的代理 symbol.</li>
<li>在_GLOBAL_OFFSET_TABLE_代码中生成真正的动态跳转指令，并且在库函数（比如strncpy,printf）代理symbol中跳转到_GLOBAL_OFFSET_TABLE_中相应的偏移位置。</li>
</ol>
<h3 id="2-iOS编译"><a href="#2-iOS编译" class="headerlink" title="2 iOS编译"></a>2 iOS编译</h3><p>&emsp;&emsp;iOS的编译工具是LLVM, Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，可用如下命令查看编译源文件有几个阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器</span><br></pre></td></tr></table></figure></p>
<h4 id="2-1-预编译"><a href="#2-1-预编译" class="headerlink" title="2.1 预编译"></a>2.1 预编译</h4><p>&emsp;&emsp;主要用来处理那些源文件中以#开头的预编译命令，比如宏、#include等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-词法分析"><a href="#2-2-词法分析" class="headerlink" title="2.2 词法分析"></a>2.2 词法分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</span><br></pre></td></tr></table></figure>
<h4 id="2-3-语法分析"><a href="#2-3-语法分析" class="headerlink" title="2.3 语法分析"></a>2.3 语法分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</span><br></pre></td></tr></table></figure>
<h4 id="2-4-语义分析"><a href="#2-4-语义分析" class="headerlink" title="2.4 语义分析"></a>2.4 语义分析</h4><h4 id="2-5-生成中间代码-LLVM-IR"><a href="#2-5-生成中间代码-LLVM-IR" class="headerlink" title="2.5 生成中间代码 LLVM IR"></a>2.5 生成中间代码 LLVM IR</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>
<h4 id="2-6-中间代码优化-可选"><a href="#2-6-中间代码优化-可选" class="headerlink" title="2.6 中间代码优化(可选)"></a>2.6 中间代码优化(可选)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s</span><br><span class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</span><br></pre></td></tr></table></figure>
<h4 id="2-7-目标代码生成-汇编代码"><a href="#2-7-目标代码生成-汇编代码" class="headerlink" title="2.7 目标代码生成 汇编代码"></a>2.7 目标代码生成 汇编代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -S -fobjc-arc main.m -o main.s</span><br></pre></td></tr></table></figure>
<h4 id="2-8-目标代码"><a href="#2-8-目标代码" class="headerlink" title="2.8 目标代码"></a>2.8 目标代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -fmodules -c main.m -o main.o</span><br></pre></td></tr></table></figure>
<h4 id="2-9-汇编器"><a href="#2-9-汇编器" class="headerlink" title="2.9 汇编器"></a>2.9 汇编器</h4><p>&emsp;&emsp;汇编器把汇编代码转换为机器代码，但<a href="https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM" target="_blank" rel="noopener">大神</a>说iOS没用汇编器</p>
<h4 id="2-9-链接"><a href="#2-9-链接" class="headerlink" title="2.9 链接"></a>2.9 链接</h4><p>&emsp;&emsp;连接器把编译产生的.o文件合并成一个mach-o文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果</span><br></pre></td></tr></table></figure></p>
<h4 id="2-10-签名"><a href="#2-10-签名" class="headerlink" title="2.10 签名"></a>2.10 签名</h4><p>&emsp;&emsp;程序一旦签名，就没有办法更改其中的任何东西，包括资源文件，可执行文件等，iOS系统会检查这个签名</p>
<h4 id="总结完整步骤："><a href="#总结完整步骤：" class="headerlink" title="总结完整步骤："></a>总结完整步骤：</h4><ol>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework 例如Foundation.framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ol>
<p>&emsp;&emsp;最后安利一本书<a href="https://item.jd.com/10067200.html" target="_blank" rel="noopener">程序员的自我修养：链接、装载与库</a></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://objccn.io/issue-6-2/" target="_blank" rel="noopener">objc中国：编译器</a></li>
<li><a href="https://github.com/LeoMobileDeveloper/Blogs/blob/master/iOS/iOS编译过程的原理和应用.md" target="_blank" rel="noopener">iOS编译过程的原理和应用</a></li>
<li><a href="https://mp.weixin.qq.com/s/D5IqhiDfe2gGb1Hkm2uS2w?" target="_blank" rel="noopener">编译原理之词法分析简介</a></li>
<li><a href="https://tech.meituan.com/2015/01/22/linker.html" target="_blank" rel="noopener">高级语言的编译：链接及装载过程介绍</a></li>
<li><a href="https://www.jianshu.com/p/d5cf01424e92" target="_blank" rel="noopener">点击 Run 之后发生了什么？</a></li>
<li><a href="https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM" target="_blank" rel="noopener">深入剖析 iOS 编译 Clang LLVM</a></li>
</ul>
<h4 id="更新一篇比较好的文章"><a href="#更新一篇比较好的文章" class="headerlink" title="更新一篇比较好的文章"></a>更新一篇比较好的文章</h4><ul>
<li><a href="https://blog.csdn.net/Hello_Hwc/article/details/85226147" target="_blank" rel="noopener">深入浅出iOS编译</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/09/16/iOS编译过程/" data-id="ckd90jolz004qxc510up220uf" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编译/">编译</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-实现类似NSURLSessionDownloadDelegate的协议" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/09/01/实现类似NSURLSessionDownloadDelegate的协议/">实现类似NSURLSessionDownloadDelegate的协议</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/09/01/实现类似NSURLSessionDownloadDelegate的协议/" class="article-date">
  <time datetime="2017-08-31T16:31:35.000Z" itemprop="datePublished">2017-09-01</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><p>&emsp;&emsp;今天排查 NSURLSession 的https证书时发现一个好玩的东西，玩了iOS这么多年竟然没注意这个小知识点！废话不多说，先看一般初始化的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</span><br><span class="line"></span><br><span class="line">@property (readonly, retain) NSOperationQueue *delegateQueue;</span><br><span class="line">@property (nullable, readonly, retain) id &lt;NSURLSessionDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;嗯，初始化一个 NSURLSession，并设置代理 NSURLSessionDelegate</p>
<p>&emsp;&emsp;当然玩过NSURLSession都知道，用到下载要实现 NSURLSessionDownloadDelegate 协议，继承关系如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSURLSessionDelegate &lt;NSObject&gt;</span><br><span class="line">// 巴拉巴拉</span><br><span class="line"></span><br><span class="line">@protocol NSURLSessionTaskDelegate &lt;NSURLSessionDelegate&gt;</span><br><span class="line">// 巴拉巴拉</span><br><span class="line"></span><br><span class="line">@protocol NSURLSessionDownloadDelegate &lt;NSURLSessionTaskDelegate&gt;</span><br><span class="line">// 巴拉巴拉</span><br></pre></td></tr></table></figure></p>
<h4 id="试验"><a href="#试验" class="headerlink" title="试验"></a>试验</h4><p>&emsp;&emsp;那么问题来了，初始化设置代理时明明设置的是NSURLSessionDelegate，为什么NSURLSessionDownloadDelegate的代理方法也能响应呢？这还不简单，父类指针指向子类实例，自然能够调用子类的方法！嗯，我一开始也是这么想的，但问题又来了，一般我们这么写的时候需要强制类型转化！当然这也不难使用 conformsToProtocol 检测一下，强制转化就行！好吧，试一下！测试代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@protocol JZKTest1Protocol &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">- (void)test1Method;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@protocol JZKTest2Protocol &lt;JZKTest1Protocol&gt;</span><br><span class="line"></span><br><span class="line">- (void)test2Method;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface JZKCornerShadowView : UIView</span><br><span class="line"></span><br><span class="line">@property (nonatomic, weak) id&lt;JZKTest1Protocol&gt; delegate;</span><br><span class="line"></span><br><span class="line">- (void)logSomething1; // call test1Method</span><br><span class="line">- (void)logSomething2; // call test2Method</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来是 logSomething2 方法，最开始我是这么写的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)logSomething2 &#123;</span><br><span class="line">    if ([_delegate conformsToProtocol:@protocol(JZKTest2Protocol)]) &#123;</span><br><span class="line">        id&lt;JZKTest2Protocol&gt; tempDelegate = _delegate;</span><br><span class="line">        if ([tempDelegate respondsToSelector:@selector(test2Method)]) &#123;</span><br><span class="line">            [tempDelegate test2Method];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;但这么写会提示警告：Initializing ‘<strong>strong id<jzktest2protocol>‘ with an expression of incompatible type ‘id<jzktest1protocol>  _Nullable </jzktest1protocol></jzktest2protocol></strong>weak’ 。好吧！改吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)logSomething2 &#123;</span><br><span class="line">    if ([_delegate conformsToProtocol:@protocol(JZKTest2Protocol)]) &#123;</span><br><span class="line">        id&lt;JZKTest2Protocol&gt; _Nullable __weak tempDelegate = (id&lt;JZKTest2Protocol&gt;)_delegate;</span><br><span class="line">        if ([tempDelegate respondsToSelector:@selector(test2Method)]) &#123;</span><br><span class="line">            [tempDelegate test2Method];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;等等 _Nullable __weak 这倒没什么！但后面 (id<jzktest2protocol>) 看起来实在是太别扭了！好丑！而且这两个Protocol都是ViewController实现的！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@interface ViewController ()&lt;JZKTest1Protocol,JZKTest2Protocol&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">@implementation ViewController</span><br><span class="line">- (void)test1Method &#123;</span><br><span class="line">    NSLog(@&quot;test1Method&quot;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)test2Method &#123;</span><br><span class="line">    NSLog(@&quot;test2Method&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    JZKCornerShadowView *shadow = [[JZKCornerShadowView alloc] init];</span><br><span class="line">    shadow.delegate = self;</span><br><span class="line">    [shadow logSomething1];</span><br><span class="line">    [shadow logSomething2];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></jzktest2protocol></p>
<p>&esmp;&emsp;即_delegate其实是指向同一个对象！那就省事了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)logSomething2 &#123;</span><br><span class="line">    if ([_delegate respondsToSelector:@selector(test2Method)]) &#123;</span><br><span class="line">        [_delegate performSelector:@selector(test2Method)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;经过测试，即便用两个VC去分别实现JZKTest1Protocol和JZKTest2Protocol协议，这么写也行！当然performSelector有诸多的不便！很不爽…，想来想去只有消息转发了，试试走起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (id)performSelector:(SEL)aSelector withArguments:(NSArray *)arguments &#123;</span><br><span class="line">    </span><br><span class="line">    if (aSelector == nil) return nil;</span><br><span class="line">    NSMethodSignature *signature = [[self class] instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span><br><span class="line">    invocation.target = self;</span><br><span class="line">    invocation.selector = aSelector;</span><br><span class="line">    </span><br><span class="line">    // invocation 有2个隐藏参数，所以 argument 从2开始</span><br><span class="line">    if ([arguments isKindOfClass:[NSArray class]]) &#123;</span><br><span class="line">        NSInteger count = MIN(arguments.count, signature.numberOfArguments - 2);</span><br><span class="line">        for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            const char *type = [signature getArgumentTypeAtIndex:2 + i];</span><br><span class="line">            </span><br><span class="line">            // 需要做参数类型判断然后解析成对应类型，这里默认所有参数均为OC对象</span><br><span class="line">            if (strcmp(type, &quot;@&quot;) == 0) &#123;</span><br><span class="line">                id argument = arguments[i];</span><br><span class="line">                [invocation setArgument:&amp;argument atIndex:2 + i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [invocation invoke];</span><br><span class="line">    </span><br><span class="line">    id returnVal;</span><br><span class="line">    if (strcmp(signature.methodReturnType, &quot;@&quot;) == 0) &#123;</span><br><span class="line">        [invocation getReturnValue:&amp;returnVal];</span><br><span class="line">    &#125;</span><br><span class="line">    // 需要做返回类型判断。比如返回值为常量需要包装成对象，这里仅以最简单的`@`为例</span><br><span class="line">    return returnVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><h5 id="PS1-class-conformsToProtocol-与-conformsToProtocol-的区别"><a href="#PS1-class-conformsToProtocol-与-conformsToProtocol-的区别" class="headerlink" title="PS1 :class_conformsToProtocol 与 conformsToProtocol 的区别"></a>PS1 :class_conformsToProtocol 与 conformsToProtocol 的区别</h5><ul>
<li>class_conformsToProtocol 不检测父类中实现的Protocol,而 [NSObject conformsToProtocol:]检测所有继承类中实现的Protocol</li>
<li>[NSObject conformsToProtocol:] 仅限于NSObject ,而class_conformsToProtocol 适用于所有Class</li>
<li>苹果建议用 [NSObject conformsToProtocol:]</li>
</ul>
<h5 id="PS2-weak和-strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！"><a href="#PS2-weak和-strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！" class="headerlink" title="PS2 : weak和 strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！"></a>PS2 : <strong>weak和 </strong>strong一般都是用于修饰self，其实是通用的！只不过声明ivar时默认是strong而已！</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@implementation JZKCornerShadowView &#123;</span><br><span class="line">    UILabel * __weak _titleLabel;</span><br><span class="line">    // __weak UILabel *_titleLabel; 不建议这么写</span><br><span class="line">    UILabel * __strong _subTitleLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="PS3：performSelector的问题"><a href="#PS3：performSelector的问题" class="headerlink" title="PS3：performSelector的问题"></a>PS3：performSelector的问题</h5><ul>
<li>运行时才校验，编译时不做校验！更适合那些runtime添加的方法</li>
<li>运行时才校验，因此参数返回值类型不确定，且参数个数有限！</li>
<li>实现多参数就是用NSDictionary，<strong>不要迷信网上所谓的消息转发方案</strong>。1、很多系统方法都在用performSelector；2、能用消息转发Apple没必要写三个几乎一样的performSelector方法了；3、hook试验时发现EXC_BAD_ACCESS问题，且没找到哦奥原因</li>
<li>performSelector… 为同步方法。但performSelector…afterDelay…等带afterDelay的为异步方法，即便afterDelay为0！特别注意afterDelay很容易造成内存泄漏，解决办法afterDelay调用的方法未执行时取消调用</li>
<li>onThread 和 InBackground 可指定线程运行某段代码，实现多线程</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/09/01/实现类似NSURLSessionDownloadDelegate的协议/" data-id="ckd90jon9008hxc51ghjat43z" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-22条商规" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/08/31/22条商规/">22条商规</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/08/31/22条商规/" class="article-date">
  <time datetime="2017-08-31T10:14:18.000Z" itemprop="datePublished">2017-08-31</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul>
<li>定位和聚焦定位非常重要，反其道而行之也许就是机会。</li>
<li>定位不是一成不变的，应把握分化趋势，适时重定位。</li>
<li>每个人只能为每个品类留下两个品牌空间，即就能记住俩品牌！例如空调，就记住了格力和美的</li>
<li>定位4步法：</li>
<li>第一步，分析整个外部环境，确定我们的竞争对手是谁，竞争对手的价值是什么</li>
<li>第二步，避开竞争对手在顾客心智中的强势，或是利用其强势中蕴含的弱点，确立品牌的优势位置：定位</li>
<li>第三步，为这一定位寻求一个可靠的证明：信任状</li>
<li>第四步，将这一定位整合进企业内部运营的方方面面，特别是传播上要有足够的资源，以将这定位植入顾客心智</li>
<li>夺取心智资源。每个人精力时间都优先，第一时间想到什么品牌，就很可能用什么品牌</li>
<li>定位激发品牌生产力。</li>
<li>定位提升运营绩效。更聚焦有效的，剔除无效的</li>
<li>定位客观存在，要么在正确、精准的定位上，要么在错误、模糊的定位上</li>
<li>所有组织和个人都需要定位</li>
<li>美国企业哲学就是聚焦、狭窄而深入，中国企业哲学是宽泛而浅显</li>
<li>企业很难仅仅通过满足客户需求的方式在营销中获得成功。更应该聚焦</li>
</ul>
<h3 id="商规"><a href="#商规" class="headerlink" title="商规"></a>商规</h3><h4 id="领先定律"><a href="#领先定律" class="headerlink" title="领先定律"></a>领先定律</h4><ul>
<li>成为第一胜过做的最好，第一能占领客户心智，最好却无法界定。</li>
<li>创造一个你能成为第一的新领域。</li>
<li>时机很重要，天时地利人和。</li>
<li>首创品牌通常能保持自己的领先地位，甚至成为品类的代名词</li>
</ul>
<h4 id="品类定律"><a href="#品类定律" class="headerlink" title="品类定律"></a>品类定律</h4><ul>
<li>如果你不能第一个进入某品类，那么就创造一个品类使自己成为第一。</li>
<li>首先要问并不是“与竞争对手相比，这个产品有哪些优势”，而是“这个产品能在哪个品类成为第一”。</li>
<li>几乎每个人都会对新品类产生兴趣，很少有人会对更好的产品产生兴趣</li>
</ul>
<h4 id="心智定律"><a href="#心智定律" class="headerlink" title="心智定律"></a>心智定律</h4><ul>
<li>市场营销是一场争夺认知而不是产品的战争，在进入市场之前应该率先进入心智。</li>
<li>在市场营销中最为徒劳的就是试图改变人们的认知。</li>
<li>应采用迅猛而非渐进的方式给别人留下一个深刻印象，不要想着逐渐影响别人以博得好感！</li>
</ul>
<h4 id="认知定律"><a href="#认知定律" class="headerlink" title="认知定律"></a>认知定律</h4><ul>
<li>市场营销领域并不存在客观现实性，也不存在事实，更不存在最好的产品。</li>
<li>存在的只是顾客心智中的认知，其他都是幻觉！</li>
<li>大多数人都认为自己的认知能力比别人强，认为自己总是正确的。</li>
<li>人们总是相信自己愿意相信的东西。</li>
<li>另外一点就是从众效应，认同的人越多，认同的人越多</li>
</ul>
<h4 id="聚焦定律"><a href="#聚焦定律" class="headerlink" title="聚焦定律"></a>聚焦定律</h4><ul>
<li>市场营销的要点就是聚焦，收缩经营范围将使你更强大，追逐所有目标将使你一事无成。</li>
<li>最有效的代名词应该是简洁、能体现优势的词语。</li>
<li>光环效应，专注于某一优势，用户会带来更多优势。</li>
<li>你不能讲其他公司的代名词据为己有，避免正面战斗选择迂回战术。</li>
<li>你不能讲焦点集中在质量或是诸如如此类不存在对立面的概念上。</li>
<li>有了自己的代名词要进行专利注册，但允许别人使用。要全力保护自己概念在市场上地位。</li>
</ul>
<h4 id="专有定律"><a href="#专有定律" class="headerlink" title="专有定律"></a>专有定律</h4><ul>
<li>当你的竞争对手已经在潜在顾客心智中拥有一个代名词或定位时，你若再想拥有同一个代名词将是徒劳无益的。</li>
<li>花更多的钱去抢别人的代名词不但抢不到，而且会提升对手的影响力。</li>
<li>用户想要什么，和我们在广告中强调什么没关系，强调的应该是自己的代名词。</li>
</ul>
<h4 id="阶梯定律"><a href="#阶梯定律" class="headerlink" title="阶梯定律"></a>阶梯定律</h4><ul>
<li>产品都非生来平等，潜在顾客在做购买决定时总会对各品牌进行排序，对于每一个品类，顾客的心智中都会形成一个选购顺序阶梯，每个品牌占有一层阶梯。你的营销战略应该根据你的品牌占据了心智阶梯的位置来决定。</li>
<li>通常人们只接受与自己认知相一致的新信息，其他的都会被置之不理。</li>
<li>有时候在大品类的阶梯上屈居第三要胜过在小品类的阶梯上独占鳌头</li>
<li>在营销中，心智决定市场；品牌的心智地位决定市场地位；心智份额决定市场份额</li>
</ul>
<h4 id="二元定律"><a href="#二元定律" class="headerlink" title="二元定律"></a>二元定律</h4><ul>
<li>从总体和长远角度来看，你会发现市场往往演化成两大品牌竞争的局面。</li>
<li>当你处于第三的位置，你无法通过直接攻击两个强大的领先者来获得更大发展，而他们却可能从中渔利。</li>
<li>明确自己的定位，采用符合自己定位的手段</li>
<li>顾客相信市场营销是一场产品的较量，因为他们相信领先品牌总是更好一些，他们开始购买领先品牌</li>
</ul>
<h4 id="对立定律"><a href="#对立定律" class="headerlink" title="对立定律"></a>对立定律</h4><ul>
<li>若想成为市场第二，那么你的战略应由第一决定。知己知彼，任何第二都有机会干掉第一</li>
<li>必须发现领导者强大的本质，然后以与其相对立的定位出现在潜在顾客面前！不要试图变得更好，但要试图变得不同</li>
<li>模仿领先者是徒劳的</li>
<li>不要一味地打击你的竞争对手。要求你不断宣传竞争对手的弱点（必须以事实为根据），是你的潜在顾客很快就能意识到这个问题，接着迅速调转矛头</li>
</ul>
<h4 id="分化定律"><a href="#分化定律" class="headerlink" title="分化定律"></a>分化定律</h4><ul>
<li>每个品类总是始于某一个单一的品类，但在一段时间之后，这个品类开始分化成几个小品类</li>
<li>是领先者保持其对市场已有统治的方法之一，是给新产品起新名字</li>
</ul>
<h4 id="长效定律"><a href="#长效定律" class="headerlink" title="长效定律"></a>长效定律</h4><ul>
<li>短期内，促销能够增加公司的销售额；但从长期来看，促销只会减少公司销售额。因为它教会顾客不要在”正常“价格是买东西</li>
</ul>
<h4 id="延伸定律"><a href="#延伸定律" class="headerlink" title="延伸定律"></a>延伸定律</h4><ul>
<li>产品越多，市场越大，阵线越长，赚的钱反而越少</li>
<li>我宁愿在某一方面强，也不愿在所有方面都弱</li>
<li>误区：虽然长期来看品牌延伸是一个失败的战略，但就短期而言，它却可以让你成功</li>
</ul>
<h4 id="牺牲定律"><a href="#牺牲定律" class="headerlink" title="牺牲定律"></a>牺牲定律</h4><ul>
<li>你如果想取得成功，就应该牺牲一些东西。有三样东西是你需要牺牲的：产品线、目标市场和不断的变化</li>
<li>市场营销是一场心智之战，它是认知的竞争，而不是产品或服务的竞争</li>
<li>集中产品焦点，深化产品内容</li>
<li>更大的网可以捕捉更多的顾客，但事实恰恰相反</li>
<li>你所明确的市场营销目标并不就是实际上购买你的产品的那些人。尽管百事可乐的营销目标是青少年，但市场却包括所有人</li>
<li>如果你视图追随市场的每一个潮流与风头，你将注定要被淘汰出局。保持稳固地位的最好方法是从一开始就不要改变你的战略</li>
</ul>
<h4 id="特性定律"><a href="#特性定律" class="headerlink" title="特性定律"></a>特性定律</h4><ul>
<li>必须有自己独特的认识或特性，并以此为中心展开营销</li>
<li>必须努力拥有最为重要的特性</li>
<li>你无法估量具有新特征的产品开拓市场的潜力，因此绝不要嘲笑它</li>
</ul>
<h4 id="坦诚定律"><a href="#坦诚定律" class="headerlink" title="坦诚定律"></a>坦诚定律</h4><ul>
<li>慎用，很容易玩砸了！</li>
<li>是自己的产品深入人心最有效的方法是首先承认自己的不足（广泛被人们认为的缺点），当人们开始关注你时，在转向正面的宣传</li>
<li>承认自己的弱点是违背公司和个人本性的</li>
<li>最重要的是坦诚可以解除顾客的戒备心理</li>
<li>如果你的名字不好，那么你将面临两个选择：换一个名字或调侃它，但不要轻视它</li>
</ul>
<h4 id="唯一定律"><a href="#唯一定律" class="headerlink" title="唯一定律"></a>唯一定律</h4><ul>
<li>在大多数情况下，你的竞争者只有一个容易被攻破的薄弱环节，正是这个环境应该成为你全力攻击的焦点</li>
<li>在市场营销中，更努力的工作并不一定是成功的秘诀</li>
<li>在市场营销中能够凑效的战略与在军事上的战略相同：出其不意</li>
<li>营销人员必须亲临市场竞争第一线，知道什么能做什么不能做</li>
</ul>
<h4 id="莫测定律"><a href="#莫测定律" class="headerlink" title="莫测定律"></a>莫测定律</h4><ul>
<li>未来不可准确预测，只能着眼于未来趋势</li>
<li>意想不到的事总会发生，但我们必须努力</li>
<li>预见未来和对未来下注是两码事</li>
</ul>
<h4 id="成功定律"><a href="#成功定律" class="headerlink" title="成功定律"></a>成功定律</h4><ul>
<li>成功往往会导致 盲目 贸然 延伸产品线！容易骄傲和自大</li>
<li>民众关于现实情况的真实看法才是最主要的！</li>
</ul>
<h4 id="失败定律"><a href="#失败定律" class="headerlink" title="失败定律"></a>失败定律</h4><ul>
<li>尽早发现错误并及时采取措施以停止损失。补救、 放弃</li>
<li>试验不可怕，失败不可怕，可怕的是没复盘同一个地方失败两次</li>
</ul>
<h4 id="炒作定律"><a href="#炒作定律" class="headerlink" title="炒作定律"></a>炒作定律</h4><ul>
<li>炒作就是炒作。事情进展顺利，不需要宣传炒作，当它需要炒作时，一般意味着它遇到了麻烦。</li>
<li>炒作的本质并不是这个新产品正在走向成功，而是宣告现有的产品要过时</li>
<li>真正的革命会在午夜悄无声息的到来</li>
</ul>
<h4 id="趋势定律"><a href="#趋势定律" class="headerlink" title="趋势定律"></a>趋势定律</h4><ul>
<li>如果你面对一个正在迅速崛起的行业，具有时尚的一切特征，那么你最好能够淡化时尚。通过淡化时尚，你就能使之流行的时间延长，从而使它更像一种趋势</li>
</ul>
<h4 id="资源定律"><a href="#资源定律" class="headerlink" title="资源定律"></a>资源定律</h4><ul>
<li>一分钱难倒英雄汉！</li>
<li>平时，一毛钱不赚就是赔</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/08/31/22条商规/" data-id="ckd90jojw0003xc51a2qnx34v" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Clang笔记" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2017/08/31/Clang笔记/">Clang笔记</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2017/08/31/Clang笔记/" class="article-date">
  <time datetime="2017-08-31T10:14:18.000Z" itemprop="datePublished">2017-08-31</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;前一段时间学了下LLVM的知识，LLVM非常强大，确实很好玩！但学起来确实挺多挺枯燥的，也没发现有什么用处（其实就是啃不动英文文档了），过了刚开始的冲劲也就停滞不前了，平时开发还是Clang用的稍微多一点，今天就水水clang吧</p>
<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>&emsp;&emsp;Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。<a href="http://clang.llvm.org/get_started.html" target="_blank" rel="noopener">官方入门</a>,详细内容参考：<a href="http://clang.llvm.org" target="_blank" rel="noopener">官网</a> </p>
<p>&emsp;&emsp;Clang是基于库的，在Clang的官方文档<a href="http://clang.llvm.org/docs/InternalsManual.html" target="_blank" rel="noopener">“Clang” CFE Internals Manual</a>中，对Clang内部的介绍也是依据库来进行分类的。</p>
<h4 id="1-1-AST"><a href="#1-1-AST" class="headerlink" title="1.1 AST"></a>1.1 AST</h4><p>&emsp;&emsp;一般编译器有以下工作步骤：</p>
<ul>
<li>词法分析（Lexical analysis）：此阶段的任务是从左到右一个字符一个字符地读入源程序，对构成源程序的字符流进行扫描然后根据构词规则识别 单词（Token），完成这个任务的组件是 词法分析器（Lexical analyzer，简称Lexer），也叫 扫描器（Scanner）；</li>
<li>语法分析（Syntactic analysis，也叫 Parsing）： 此阶段的主要任务是由 词法分析器 生成的单词构建 抽象语法树（Abstract Syntax Tree ，AST），完成此任务的组件是 语法分析器（Parser）；</li>
<li>目标码生成： 此阶段编译器会遍历上一步生成的抽象语法树，然后为每个节点生成 机器 / 字节码。</li>
<li>编译器完成编译后，由链接器（Linker）将生成的目标文件链接成可执行文件，这一步并不是必须的，一些依赖于虚拟机运行的语言（如 Java，Erlang）就不需要链接。</li>
</ul>
<p>&emsp;&emsp;关于Clang AST，有一个<a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">官方文档</a> 。基于AST可以进行程序转换，现在Clang下面已经有一些额外的工具：比如clang-modernize实现的就是对C+ +程序中可以使用C ++ 11的地方进行转换，转换成在这些地方使用C++11特性的程序，等于直接在程序上进行的修改，是一个source-to-source的转换工具。</p>
<h4 id="1-2-libclang"><a href="#1-2-libclang" class="headerlink" title="1.2 libclang"></a>1.2 libclang</h4><p>&emsp;&emsp;现在的Clang，不仅仅是一个编译器前端，同时也可以作为一个库使用。作为一个库使用的时候，可以用它去分析C/C++/ObjectC语言代码，可以分析源码得到AST，也可以获取已经分析好的AST，也可以遍历AST，还可以获取AST中基本元素的物理源码位置。这就是libclang。</p>
<p>&emsp;&emsp;其它库介绍：</p>
<ul>
<li>LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。</li>
<li>The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。</li>
<li>The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。</li>
<li>Precompiled Headers - Clang 支持预编译 headers 的两个实现。</li>
<li>The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。</li>
<li>The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。</li>
<li>The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。</li>
<li>The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。</li>
</ul>
<h4 id="1-3-Clang-driver"><a href="#1-3-Clang-driver" class="headerlink" title="1.3 Clang driver"></a>1.3 Clang driver</h4><p>&emsp;&emsp;Clang driver是一个驱动，一个包含编译全部阶段的驱动，不同于前端Clang，也不同于编译器Clang。命令行使用的“clang”其实并不是前端Clang，而是指的是Clang driver；在命令行使用的“Clang cc1”也指的不是前端Clang，而指的是Clang编译器，这其中不仅包含了前端Clang，还包含了LLVM Core部分等。Clang driver不仅仅调用了前端Clang，同时还调用了LLVM Core</p>
<h3 id="Clang命令（大小写敏感）"><a href="#Clang命令（大小写敏感）" class="headerlink" title="Clang命令（大小写敏感）"></a>Clang命令（大小写敏感）</h3><h4 id="命令解释"><a href="#命令解释" class="headerlink" title="命令解释"></a>命令解释</h4><p>&emsp;&emsp;最重要的命令是什么？我个人认为，无论什么脚本语言，最重要的命令永远是<strong>帮助</strong>：clang –help。Clang命令高达700+，这里仅介绍常用的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">USAGE: clang [options] &lt;inputs&gt;</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">-###                    Print (but do not run) the commands to run for this compilation 查看操作内部命令，一般用于分析流程</span><br><span class="line">--analyze               Run the static analyzer 运行静态代码检查器</span><br><span class="line">-B &lt;dir&gt;                Add &lt;dir&gt; to search path for binaries and object files used implicitly 将&lt;dir&gt;添加到搜索路径</span><br><span class="line">-CC                     Include comments from within macros in preprocessed output 在预处理的输出中包含宏在内的注释，非常重要</span><br><span class="line">--config &lt;value&gt;        Specifies configuration file  配置文件</span><br><span class="line">-C                      Include comments in preprocessed output 在预处理的输出中包含注释，非常重要</span><br><span class="line">-c                      Only run preprocess, compile, and assemble steps 仅运行预处理、编译和组装步骤</span><br><span class="line">-emit-ast               Emit Clang AST files for source inputs</span><br><span class="line">-E                      Only run the preprocessor 只运行预处理</span><br><span class="line">-fblocks                Enable the &apos;blocks&apos; language feature</span><br><span class="line">-fcolor-diagnostics     Use colors in diagnostics 诊断中可以使用颜色</span><br><span class="line">-fcxx-exceptions        Enable C++ exceptions  启用C++类型异常</span><br><span class="line">-fexceptions            Enable support for exception handling 启用异常</span><br><span class="line">-fmodules               Enable the &apos;modules&apos; language feature 启用“模块”语言功能</span><br><span class="line">-fplugin=&lt;dsopath&gt;      Load the named plugin (dynamic shared object) 启用插件</span><br><span class="line">-ObjC++                 Treat source input files as Objective-C++ inputs 把源文件当做OC++</span><br><span class="line">-ObjC                   Treat source input files as Objective-C inputs 把源文件当做OC</span><br><span class="line">-g                      Generate source-level debug information 生成完整的调试信息。</span><br><span class="line">-o &lt;file&gt;               Write output to &lt;file&gt; 输出文件</span><br><span class="line">-print-file-name=&lt;file&gt; Print the full library path of &lt;file&gt; 输出文件所在路径</span><br><span class="line">-print-ivar-layout      Enable Objective-C Ivar layout bitmap print trace 启用OC的ivar布局</span><br><span class="line">-pthread                Support POSIX threads in generated code 在生成的代码中支持POSIX线程</span><br><span class="line">-rewrite-objc           Rewrite Objective-C source to C++ 将OC重写成C++</span><br><span class="line">-S                      Only run preprocess and compilation steps 仅运行预处理和编译步骤</span><br><span class="line">--target=&lt;value&gt;        Generate code for the given target 为给定目标生成代码</span><br><span class="line">-w                      Suppress all warnings 禁用警告</span><br><span class="line">-Xclang &lt;arg&gt;           Pass &lt;arg&gt; to the clang compiler 向clang编译器传递参数</span><br></pre></td></tr></table></figure></p>
<h4 id="常用组合命令"><a href="#常用组合命令" class="headerlink" title="常用组合命令"></a>常用组合命令</h4><ul>
<li><p>查看编译的几个阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -ccc-print-phases main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看预编译过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -E main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看操作内部命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -### main.m -o main</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写成C++，<a href="https://blog.csdn.net/majiakun1/article/details/52842010" target="_blank" rel="noopener">报错</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc main.m</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clang -fobjc-arc -framework Foundation HelloWord.m -o HelloWord</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">-x 编译语言比如objective-c</span><br><span class="line">-arch 编译的架构，比如arm7</span><br><span class="line">-f 以-f开头的。</span><br><span class="line">-W 以-W开头的，可以通过这些定制编译警告</span><br><span class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</span><br><span class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</span><br><span class="line">-I 把编译信息写入指定的辅助文件</span><br><span class="line">-F 需要的Framework</span><br><span class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</span><br><span class="line">-o 编译结果</span><br><span class="line">*/</span><br><span class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://clang.llvm.org" target="_blank" rel="noopener">官网</a> </li>
<li><a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="noopener">更多clang工具</a></li>
<li><a href="https://blog.csdn.net/snsn1984/column/info/hacking-clang" target="_blank" rel="noopener">深入研究Clang</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2017/08/31/Clang笔记/" data-id="ckd90jokc000pxc51teop7xvl" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>