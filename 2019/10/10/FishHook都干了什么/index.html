<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="原创,原理,">










<meta name="description" content="准备知识APP启动的时候是会去链接很多动态库，如UIKit，UIFoundation等。函数的调用是通过跳转指令跳到函数对应的内存地址，而动态库是在程序启动时才去链接的，因此动态库中函数的地址在一开始是不知道的，所以这些函数的地址存放在DATA,la_symbol_prt表中，也就是所谓的PIC(位置无关代码)。在函数第一次调用的时候例如NSLog()函数，这个表中的地址不是直接指向NSLog的正">
<meta name="keywords" content="原创,原理">
<meta property="og:type" content="article">
<meta property="og:title" content="FishHook都干了什么？">
<meta property="og:url" content="http://jiaozhengkui.top/2019/10/10/FishHook都干了什么/index.html">
<meta property="og:site_name" content="jiao﹢奎">
<meta property="og:description" content="准备知识APP启动的时候是会去链接很多动态库，如UIKit，UIFoundation等。函数的调用是通过跳转指令跳到函数对应的内存地址，而动态库是在程序启动时才去链接的，因此动态库中函数的地址在一开始是不知道的，所以这些函数的地址存放在DATA,la_symbol_prt表中，也就是所谓的PIC(位置无关代码)。在函数第一次调用的时候例如NSLog()函数，这个表中的地址不是直接指向NSLog的正">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://camo.githubusercontent.com/18243516844d12b1bd158ce3687635d6e48d2e2e/687474703a2f2f692e696d6775722e636f6d2f4856587148437a2e706e67">
<meta property="og:updated_time" content="2019-11-10T12:52:23.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FishHook都干了什么？">
<meta name="twitter:description" content="准备知识APP启动的时候是会去链接很多动态库，如UIKit，UIFoundation等。函数的调用是通过跳转指令跳到函数对应的内存地址，而动态库是在程序启动时才去链接的，因此动态库中函数的地址在一开始是不知道的，所以这些函数的地址存放在DATA,la_symbol_prt表中，也就是所谓的PIC(位置无关代码)。在函数第一次调用的时候例如NSLog()函数，这个表中的地址不是直接指向NSLog的正">
<meta name="twitter:image" content="https://camo.githubusercontent.com/18243516844d12b1bd158ce3687635d6e48d2e2e/687474703a2f2f692e696d6775722e636f6d2f4856587148437a2e706e67">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jiaozhengkui.top/2019/10/10/FishHook都干了什么/">





  <title>FishHook都干了什么？ | jiao﹢奎</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jiao﹢奎</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jiaozhengkui.top/2019/10/10/FishHook都干了什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="焦正奎">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/author.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jiao﹢奎">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">FishHook都干了什么？</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-10T00:31:35+08:00">
                2019-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h4><p>APP启动的时候是会去链接很多动态库，如UIKit，UIFoundation等。函数的调用是通过跳转指令跳到函数对应的内存地址，而动态库是在程序启动时才去链接的，因此动态库中函数的地址在一开始是不知道的，所以这些函数的地址存放在<strong>DATA,</strong>la_symbol_prt表中，也就是所谓的PIC(位置无关代码)。在函数第一次调用的时候例如NSLog()函数，这个表中的地址不是直接指向NSLog的正确地址，而是指向了dyld_stub_binder函数地址，它的作用就是去计算出NSLog的真正地址，然后将<strong>DATA,</strong>la_symbol_prt中NSLog对应的地址改为它的实际地址，这样第二次调用的时候就是直接调用到NSLog。另外除了<strong>la_symbol_prt表之外，还有与之对应的indirect Symbols、Symbol Table以及String Table。它们之间的关系是，**首先通过符号在</strong>la_symbol_prt的index，加上在Load Command中对__la_symbol_prt的描述信息reversed1，找到indirect Symbols中 index+reversed1 位置的数据index2，然后在找到Symbol Table中index2位置的数据拿到偏移地址offset，最后在String Table中找offset处的数据，该数据就是函数名”_NSLog”。**</p>
<p>fishhook是怎么hook懒加载和非懒加载的</p>
<h4 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h4><p><a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">https://github.com/facebook/fishhook</a></p>
<p>dyld binds lazy and non-lazy symbols by updating pointers in particular sections of the __DATA segment of a Mach-O binary. fishhook re-binds these symbols by determining the locations to update for each of the symbol names passed to rebind_symbols and then writing out the corresponding replacements.</p>
<p>For a given image, the <strong>DATA segment may contain two sections that are relevant for dynamic symbol bindings: </strong>nl_symbol_ptr and <strong>la_symbol_ptr. </strong>nl_symbol_ptr is an array of pointers to non-lazily bound data (these are bound at the time a library is loaded) and <strong>la_symbol_ptr is an array of pointers to imported functions that is generally filled by a routine called dyld_stub_binder during the first call to that symbol (it’s also possible to tell dyld to bind these at launch). In order to find the name of the symbol that corresponds to a particular location in one of these sections, we have to jump through several layers of indirection. For the two relevant sections, the section headers (struct sections from &lt;mach-o/loader.h&gt;) provide an offset (in the reserved1 field) into what is known as the indirect symbol table. The indirect symbol table, which is located in the </strong>LINKEDIT segment of the binary, is just an array of indexes into the symbol table (also in <strong>LINKEDIT) whose order is identical to that of the pointers in the non-lazy and lazy symbol sections. So, given struct section nl_symbol_ptr, the corresponding index in the symbol table of the first address in that section is indirect_symbol_table[nl_symbol_ptr-&gt;reserved1]. The symbol table itself is an array of struct nlists (see &lt;mach-o/nlist.h&gt;), and each nlist contains an index into the string table in </strong>LINKEDIT which where the actual symbol names are stored. So, for each pointer <strong>nl_symbol_ptr and </strong>la_symbol_ptr, we are able to find the corresponding symbol and then the corresponding string to compare against the requested symbol names, and if there is a match, we replace the pointer in the section with the replacement.</p>
<p>The process of looking up the name of a given entry in the lazy or non-lazy pointer tables looks like this: Visual explanation</p>
<p><img src="https://camo.githubusercontent.com/18243516844d12b1bd158ce3687635d6e48d2e2e/687474703a2f2f692e696d6775722e636f6d2f4856587148437a2e706e67" alt="image"></p>
<h4 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h4><ul>
<li><p>h 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * A structure representing a particular intended rebinding from a symbol</span><br><span class="line"> * name to its replacement</span><br><span class="line"> */</span><br><span class="line">struct rebinding &#123;</span><br><span class="line">  const char *name; // 函数名</span><br><span class="line">  void *replacement; // hook之后用于替换的函数</span><br><span class="line">  void **replaced; // 用于保存原来的函数地址，这里传递一个函数指针变量的地址进去</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * For each rebinding in rebindings, rebinds references to external, indirect</span><br><span class="line"> * symbols with the specified name to instead point at replacement for each</span><br><span class="line"> * image in the calling process as well as for all future images that are loaded</span><br><span class="line"> * by the process. If rebind_functions is called more than once, the symbols to</span><br><span class="line"> * rebind are added to the existing list of rebindings, and if a given symbol</span><br><span class="line"> * is rebound more than once, the later rebinding will take precedence.</span><br><span class="line"> */</span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Rebinds as above, but only in the specified image. The header should point</span><br><span class="line"> * to the mach-o header, the slide should be the slide offset. Others as above.</span><br><span class="line"> */</span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line">int rebind_symbols_image(void *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         struct rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel);</span><br></pre></td></tr></table></figure>
</li>
<li><p>c 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;fishhook.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;mach/mach.h&gt;</span><br><span class="line">#include &lt;mach/vm_map.h&gt;</span><br><span class="line">#include &lt;mach/vm_region.h&gt;</span><br><span class="line">#include &lt;mach-o/dyld.h&gt;</span><br><span class="line">#include &lt;mach-o/loader.h&gt;</span><br><span class="line">#include &lt;mach-o/nlist.h&gt;</span><br><span class="line"></span><br><span class="line">#ifdef __LP64__</span><br><span class="line">typedef struct mach_header_64 mach_header_t;</span><br><span class="line">typedef struct segment_command_64 segment_command_t;</span><br><span class="line">typedef struct section_64 section_t;</span><br><span class="line">typedef struct nlist_64 nlist_t;</span><br><span class="line">#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span><br><span class="line">#else</span><br><span class="line">typedef struct mach_header mach_header_t;</span><br><span class="line">typedef struct segment_command segment_command_t;</span><br><span class="line">typedef struct section section_t;</span><br><span class="line">typedef struct nlist nlist_t;</span><br><span class="line">#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifndef SEG_DATA_CONST</span><br><span class="line">#define SEG_DATA_CONST  &quot;__DATA_CONST&quot;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">struct rebindings_entry &#123;</span><br><span class="line">  struct rebinding *rebindings;</span><br><span class="line">  size_t rebindings_nel;</span><br><span class="line">  struct rebindings_entry *next;// 下一个指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 链表表头</span><br><span class="line">static struct rebindings_entry *_rebindings_head;</span><br><span class="line"></span><br><span class="line">int rebind_symbols(struct rebinding rebindings[], size_t rebindings_nel) &#123;</span><br><span class="line">  int retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  if (retval &lt; 0) &#123;</span><br><span class="line">    return retval;</span><br><span class="line">  &#125;</span><br><span class="line">  // If this was the first call, register callback for image additions (which is also invoked for</span><br><span class="line">  // existing images, otherwise, just run on existing images</span><br><span class="line">  if (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    // 这里只是注册了一个func，并没有调用所以不用考虑参数</span><br><span class="line">      /*</span><br><span class="line">      * The following functions allow you to install callbacks which will be called</span><br><span class="line">      * by dyld whenever an image is loaded or unloaded.  During a call to _dyld_register_func_for_add_image()</span><br><span class="line">      * the callback func is called for every existing image.  Later, it is called as each new image</span><br><span class="line">      * is loaded and bound (but initializers not yet run).  The callback registered with</span><br><span class="line">      * _dyld_register_func_for_remove_image() is called after any terminators in an image are run</span><br><span class="line">      * and before the image is un-memory-mapped.</span><br><span class="line">      */</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      // 这里才是真正的调用</span><br><span class="line">    uint32_t c = _dyld_image_count();</span><br><span class="line">    for (uint32_t i = 0; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int prepend_rebindings(struct rebindings_entry **rebindings_head,</span><br><span class="line">                              struct rebinding rebindings[],</span><br><span class="line">                              size_t nel) &#123;</span><br><span class="line">  // 开辟新内存，C语言的标准写法</span><br><span class="line">  struct rebindings_entry *new_entry = (struct rebindings_entry *) malloc(sizeof(struct rebindings_entry));</span><br><span class="line">  // C语言开辟内存之后，必须校验是否开辟成功</span><br><span class="line">  if (!new_entry) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">    // C中数组的指针就是数组里第一个元素的指针</span><br><span class="line">  new_entry-&gt;rebindings = (struct rebinding *) malloc(sizeof(struct rebinding) * nel);</span><br><span class="line">  if (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    // malloc 内存不够需手动调整大小，内存释放需free，且free之后最好设为null</span><br><span class="line">    free(new_entry);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">    // 拷贝</span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    第一次时 _rebindings_head 为null，即new_entry-&gt;next为null</span><br><span class="line">    然后将_rebindings_head 指向 当前的new_entry</span><br><span class="line">    第二次再来会新开辟内存生成new_entry2，注意由于_rebindings_head是static变量</span><br><span class="line">    _rebindings_head保留的是上次的new_entry，此时new_entry2-&gt;next即指向new_entry</span><br><span class="line">    */</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 函数指针 void (*funcp)(); 函数的指针</span><br><span class="line">// 指针函数 int * GetDate(int wk,int dy); 返回值是指针</span><br><span class="line">static void _rebind_symbols_for_image(const struct mach_header *header,</span><br><span class="line">                                      intptr_t slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void rebind_symbols_for_image(struct rebindings_entry *rebindings,</span><br><span class="line">                                     const struct mach_header *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">    // 地址符号信息</span><br><span class="line">  Dl_info info;</span><br><span class="line">    // dladdr 获取某个地址的符号信息</span><br><span class="line">  if (dladdr(header, &amp;info) == 0) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">    // 因64位和32位的结构稍有不同，需要自定义</span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  segment_command_t *linkedit_segment = NULL;</span><br><span class="line">  struct symtab_command* symtab_cmd = NULL; // 符号表</span><br><span class="line">  struct dysymtab_command* dysymtab_cmd = NULL; // 间接符号表</span><br><span class="line"></span><br><span class="line">    // 指向load Command的起始地址(uintptr_t)header。header是指针，</span><br><span class="line">    // header内存里存储的就是mach_header结构体的内存位置, 固强转long即可</span><br><span class="line">  uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">    // 遍历load command中所有的segment_command</span><br><span class="line">  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    </span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">        /*</span><br><span class="line">         int strcmp(const char *str1, const char *str2)</span><br><span class="line">         如果返回值 &lt; 0，则表示 str1 小于 str2。</span><br><span class="line">         如果返回值 &gt; 0，则表示 str2 小于 str1。</span><br><span class="line">         如果返回值 = 0，则表示 str1 等于 str2。</span><br><span class="line">         */</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Find base symbol/string table addresses</span><br><span class="line">    //slide是ASLR的随机偏移，linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff是mach-o在文件中的基地址，两者相加就是ASLR后的mach-o加载进内存的基地址</span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">    // Format of a symbol table entry of a Mach-O file</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">    // String Table的起始地址</span><br><span class="line">  char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  // Get indirect symbol table (array of uint32_t indices into symbol table)</span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  // 虽然上面所有的segment_command已经遍历完了，但header并没变，所以是第二次遍历load command</span><br><span class="line">  cur = (uintptr_t)header + sizeof(mach_header_t);</span><br><span class="line">  for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">// #define    LC_SEGMENT    0x1    /* segment of this file to be mapped */</span><br><span class="line">    if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">    // 遍历__DATA段的sections</span><br><span class="line">      for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">          // cur指向segment_command的起始地址需要偏移过去找到seciton的位置</span><br><span class="line">          // 不过 + j这个操作还是j惊艳到我了，毕竟是指针而不是section_t数组</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + sizeof(segment_command_t)) + j;</span><br><span class="line">          // 绑定懒加载 __la_symbol_ptr</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">          // 绑定非懒加载 __nl_symbol_ptr</span><br><span class="line">        if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static vm_prot_t get_protection(void *sectionStart) &#123;</span><br><span class="line">  mach_port_t task = mach_task_self();</span><br><span class="line">  vm_size_t size = 0;</span><br><span class="line">  vm_address_t address = (vm_address_t)sectionStart;</span><br><span class="line">  memory_object_name_t object;</span><br><span class="line">#if __LP64__</span><br><span class="line">  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT_64;</span><br><span class="line">  vm_region_basic_info_data_64_t info;</span><br><span class="line">  kern_return_t info_ret = vm_region_64(</span><br><span class="line">      task, &amp;address, &amp;size, VM_REGION_BASIC_INFO_64, (vm_region_info_64_t)&amp;info, &amp;count, &amp;object);</span><br><span class="line">#else</span><br><span class="line">  mach_msg_type_number_t count = VM_REGION_BASIC_INFO_COUNT;</span><br><span class="line">  vm_region_basic_info_data_t info;</span><br><span class="line">  kern_return_t info_ret = vm_region(task, &amp;address, &amp;size, VM_REGION_BASIC_INFO, (vm_region_info_t)&amp;info, &amp;count, &amp;object);</span><br><span class="line">#endif</span><br><span class="line">  if (info_ret == KERN_SUCCESS) &#123;</span><br><span class="line">    return info.protection;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return VM_PROT_READ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void perform_rebinding_with_section(struct rebindings_entry *rebindings,</span><br><span class="line">                                           section_t *section, // 节点</span><br><span class="line">                                           intptr_t slide, // ASLR的偏移量</span><br><span class="line">                                           nlist_t *symtab,</span><br><span class="line">                                           char *strtab,</span><br><span class="line">                                           uint32_t *indirect_symtab) &#123;</span><br><span class="line">    </span><br><span class="line">  const bool isDataConst = strcmp(section-&gt;segname, &quot;__DATA_CONST&quot;) == 0;</span><br><span class="line">    // indirect Symbols中包含了各个section中符号在Symbol Table的index，</span><br><span class="line">    // 这里是直接定位到对应__DATA,__la_symbol_ptr所在的index数组</span><br><span class="line">  uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">    // void** ？？？void * 为 “无类型指针”，即可以指向任何类型</span><br><span class="line">  void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr);</span><br><span class="line">    </span><br><span class="line">    /* read permission */</span><br><span class="line">  vm_prot_t oldProtection = VM_PROT_READ;</span><br><span class="line">    </span><br><span class="line">    // 常量</span><br><span class="line">  if (isDataConst) &#123;</span><br><span class="line">    oldProtection = get_protection(rebindings);</span><br><span class="line">      // mprotect()函数可以用来修改一段指定内存区域的保护属性。</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, PROT_READ | PROT_WRITE);</span><br><span class="line">  &#125;</span><br><span class="line">  for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123;</span><br><span class="line">      </span><br><span class="line">    uint32_t symtab_index = indirect_symbol_indices[i];</span><br><span class="line">      </span><br><span class="line">      /*</span><br><span class="line">      * An indirect symbol table entry is simply a 32bit index into the symbol table</span><br><span class="line">      * to the symbol that the pointer or stub is refering to.  Unless it is for a</span><br><span class="line">      * non-lazy symbol pointer section for a defined symbol which strip(1) as</span><br><span class="line">      * removed.  In which case it has the value INDIRECT_SYMBOL_LOCAL.  If the</span><br><span class="line">      * symbol was also absolute INDIRECT_SYMBOL_ABS is or&apos;ed with that.</span><br><span class="line">      */</span><br><span class="line">    if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">      // index into the string table, String Table中的偏移量</span><br><span class="line">    uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">      // 起始地址 + 偏移量 = 符号名</span><br><span class="line">    char *symbol_name = strtab + strtab_offset;</span><br><span class="line">      // symbol_name[0]一般是 _ 下划线, symbol_name[1] 是函数名</span><br><span class="line">    bool symbol_name_longer_than_1 = symbol_name[0] &amp;&amp; symbol_name[1];</span><br><span class="line">      </span><br><span class="line">    struct rebindings_entry *cur = rebindings;</span><br><span class="line">    while (cur) &#123;</span><br><span class="line">        // 遍历需要绑定的函数</span><br><span class="line">      for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">       //编译的时候会将符号转成带下划线的，比如printf会转成_printf,所以从下划线后面的字符开始比较</span><br><span class="line">        if (symbol_name_longer_than_1 &amp;&amp;</span><br><span class="line">            strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123;</span><br><span class="line">          if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">              // 保存原来的函数地址</span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">            // 替换成新的函数实现</span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">            // 退出遍历，即针对同一符号多次调用fishhook重绑定，只有会对最后一次调用的生效</span><br><span class="line">          goto symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">  if (isDataConst) &#123;</span><br><span class="line">    int protection = 0;</span><br><span class="line">    if (oldProtection &amp; VM_PROT_READ) &#123;</span><br><span class="line">      protection |= PROT_READ;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldProtection &amp; VM_PROT_WRITE) &#123;</span><br><span class="line">      protection |= PROT_WRITE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldProtection &amp; VM_PROT_EXECUTE) &#123;</span><br><span class="line">      protection |= PROT_EXEC;</span><br><span class="line">    &#125;</span><br><span class="line">    mprotect(indirect_symbol_bindings, section-&gt;size, protection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int rebind_symbols_image(void *header,</span><br><span class="line">                         intptr_t slide,</span><br><span class="line">                         struct rebinding rebindings[],</span><br><span class="line">                         size_t rebindings_nel) &#123;</span><br><span class="line">    struct rebindings_entry *rebindings_head = NULL;</span><br><span class="line">    int retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, (const struct mach_header *) header, slide);</span><br><span class="line">    if (rebindings_head) &#123;</span><br><span class="line">      free(rebindings_head-&gt;rebindings);</span><br><span class="line">    &#125;</span><br><span class="line">    free(rebindings_head);</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    焦正奎
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://jiaozhengkui.top/2019/10/10/FishHook都干了什么/" title="FishHook都干了什么？">http://jiaozhengkui.top/2019/10/10/FishHook都干了什么/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/原创/" rel="tag"><i class="fa fa-tag"></i> 原创</a>
          
            <a href="/tags/原理/" rel="tag"><i class="fa fa-tag"></i> 原理</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/08/AFN都干了什么/" rel="next" title="AFN都干了什么？">
                <i class="fa fa-chevron-left"></i> AFN都干了什么？
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/12/Masonry都干了什么/" rel="prev" title="Masonry都干了什么？">
                Masonry都干了什么？ <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/author.jpg" alt="焦正奎">
            
              <p class="site-author-name" itemprop="name">焦正奎</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">133</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#准备知识"><span class="nav-number">1.</span> <span class="nav-text">准备知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#官方解释"><span class="nav-number">2.</span> <span class="nav-text">官方解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码解读"><span class="nav-number">3.</span> <span class="nav-text">代码解读</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">焦正奎</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
