<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
    <meta name="keywords" content="jiaozhengkui">
  
  
    <meta name="description" content="焦正奎的博客">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    
    焦正奎的博客</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="jumbotron">
  <div class="video">
    
      <div class="video-frame">
        <img src="/images/ocean/overlay-hero.png" alt="Decorative image frame">
      </div>
    
    <div class="video-media">
      <video playsinline autoplay loop muted data-autoplay poster="/images/ocean/ocean.png" x5-video-player-type="h5">
        <source src="/images/ocean/ocean.mp4" type="video/mp4">
        <source src="/images/ocean/ocean.ogv" type="video/ogg">
        <source src="/images/ocean/ocean.webm" type="video/webm">
        <p>Your user agent does not support the HTML5 Video element.</p>
      </video>
      <div class="video-overlay"></div>
    </div>
    <div class="video-inner text-center text-white">
      <h1><a href="/">焦正奎的博客</a></h1>
      <p>不要怕！不要悔！慢慢来！</p>
      <div><img src="/images/hexo-inverted.svg" class="brand" alt="焦正奎的博客"></div>
    </div>
    <div class="video-learn-more">
      <a class="anchor" href="#landingpage"><i class="fe fe-mouse"></i></a>
    </div>
  </div>
</section>

<div id="landingpage">
  <section class="outer">
    <article class="articles">
      
      <h1 class="page-type-title"></h1>
      
        
          <article id="post-swiftUI练习" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/06/15/swiftUI练习/">swiftUI练习</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2019/06/15/swiftUI练习/" class="article-date">
  <time datetime="2019-06-15T10:14:18.000Z" itemprop="datePublished">2019-06-15</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;要说这次WWDC最惊艳的是什么？绝对是swiftUI！好长时间没水点东西了（没时间也没精力整理），但这个swiftUI我确实想凑个热闹！毕竟太好玩了！官方教程：<a href="https://developer.apple.com/tutorials/swiftui/" target="_blank" rel="noopener">https://developer.apple.com/tutorials/swiftui/</a>  建议大家跟着官方教程学一遍！其实不用英语很好，直接看代码也能看懂个大概的! </p>
<p>&emsp;&emsp;由于是照超官方教程，没啥技术含量！项目不发了，也没必要！鼓励大家自己按教程敲一敲看一看！这里就贴点我觉得好玩的代码</p>
<ol>
<li><p>some 关键字是Swift 5.1 的新特性，个人理解就是一种确定类型，具体什么类型调用者自己去看函数。参考：<a href="https://stackoverflow.com/questions/56433665/what-is-the-some-keyword-in-swiftui" target="_blank" rel="noopener">https://stackoverflow.com/questions/56433665/what-is-the-some-keyword-in-swiftui</a> 和 <a href="https://juejin.im/post/5cfb1217f265da1b8a4f0f14" target="_blank" rel="noopener">https://juejin.im/post/5cfb1217f265da1b8a4f0f14</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">Text(&quot;Hello World&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用UIKit方法：新建swiftUI view用于包装UIKit，并实现UIViewRepresentable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct MapView : UIViewRepresentable &#123;</span><br><span class="line"></span><br><span class="line">typealias UIViewType = MKMapView</span><br><span class="line"></span><br><span class="line">func makeUIView(context: UIViewRepresentableContext&lt;MapView&gt;) -&gt; MKMapView &#123;</span><br><span class="line">return MKMapView(frame: .zero)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateUIView(_ uiView: MKMapView, context: UIViewRepresentableContext&lt;MapView&gt;) &#123;</span><br><span class="line">let coordinate = CLLocationCoordinate2D(</span><br><span class="line">latitude: 34.011286, longitude: -116.166868)</span><br><span class="line">let span = MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0)</span><br><span class="line">let region = MKCoordinateRegion(center: coordinate, span: span)</span><br><span class="line">uiView.setRegion(region, animated: true)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>list 的 identifiable 的数据，两种方法让数据变成 identifiable ：1、identified(by:) 提供一个唯一key；2、遵循 Identifiable 协议。这样比OC的dequeueReusableCellWithIdentifier强多了，虽然一般也是直接用cellClassName</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List(landmarkData, id: \.id) &#123; landmark in</span><br><span class="line">LandmarkRow(landmark: landmark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有意思的导航! NavigationView{} 表示有上面的导航条！最主要是NavigationButton，这个很有意思！一般UIKit写起来需要获取VC，现在使用seiftUI解放了这项工作，直接用一个特殊的NavigationButton就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var body: some View &#123;</span><br><span class="line">NavigationView &#123;</span><br><span class="line">List(landmarkData) &#123; landmark in</span><br><span class="line">NavigationButton(destination: LandmarkDetail()) &#123;</span><br><span class="line">LandmarkRow(landmark: landmark)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.navigationBarTitle(Text(&quot;Landmarks&quot;))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@state 看到state肯定是状态机，我好奇地是是不是也跟flutter一样，分为StatelessWidgets和 StatefulWidgets，几经检索找到一篇 <a href="https://mecid.github.io/2019/06/12/understanding-property-wrappers-in-swiftui/" target="_blank" rel="noopener">https://mecid.github.io/2019/06/12/understanding-property-wrappers-in-swiftui/</a>  简单总结一下：</p>
</li>
</ol>
<ul>
<li>@State 修饰的属性发生改变，通知一个view发生改变</li>
<li>@Binding 把值属性变成引用属性，使用 $ 前缀来访问一个状态变量或者它的属性的 binding</li>
<li>@ObservedObject 监听一个实现 ObservableObject 协议的对象，对象内部属性需用@Published 修饰。可通知多个view</li>
<li>@EnvironmentObject 修饰全局变量的 一般和 BindableObject协议一起用于viewModel</li>
<li>@Environment 监控系统级别object<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@State var showFavoritesOnly = false</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li><p>BindableObject 一开始写dome时，我理解撑了viewModel，但现在想想理解的有点狭隘，应该是有反射机制的缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final class UserData: BindableObject  &#123;</span><br><span class="line">let didChange = PassthroughSubject&lt;UserData, Never&gt;()</span><br><span class="line"></span><br><span class="line">var showFavoritesOnly = false &#123;</span><br><span class="line">didSet &#123;</span><br><span class="line">didChange.send(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var landmarks = landmarkData &#123;</span><br><span class="line">didSet &#123;</span><br><span class="line">didChange.send(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式动画，直接用 .animation() 即可，确实简单多了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Button(action: &#123;</span><br><span class="line">self.showDetail.toggle()</span><br><span class="line">&#125;) &#123;</span><br><span class="line">Image(systemName: &quot;chevron.right.circle&quot;)</span><br><span class="line">.imageScale(.large)</span><br><span class="line">.rotationEffect(.degrees(showDetail ? 90 : 0))</span><br><span class="line">.scaleEffect(showDetail ? 1.5 : 1)</span><br><span class="line">.padding()</span><br><span class="line">.animation(.spring())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示动画withAnimation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Button(action: &#123;</span><br><span class="line">withAnimation &#123;</span><br><span class="line">self.showDetail.toggle()</span><br><span class="line">&#125;</span><br><span class="line">&#125;) &#123;</span><br><span class="line">Image(systemName: &quot;chevron.right.circle&quot;)</span><br><span class="line">.imageScale(.large)</span><br><span class="line">.rotationEffect(.degrees(showDetail ? 90 : 0))</span><br><span class="line">.scaleEffect(showDetail ? 1.5 : 1)</span><br><span class="line">.padding()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var animation: Animation &#123;</span><br><span class="line">Animation.spring(initialVelocity: 5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var body: some View &#123;</span><br><span class="line">Capsule()</span><br><span class="line">.fill(Color.gray)</span><br><span class="line">.frame(height: height * heightRatio, alignment: .bottom)</span><br><span class="line">.offset(x: 0, y: height * -offsetRatio)</span><br><span class="line">.animation(animation)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>@Environment 能监控哪些系统级别value</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Environment(\.editMode) var mode</span><br><span class="line"></span><br><span class="line">extension EnvironmentValues &#123;</span><br><span class="line"></span><br><span class="line">@available(OSX, unavailable)</span><br><span class="line">@available(watchOS, unavailable)</span><br><span class="line">public var editMode: Binding&lt;EditMode&gt;?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">等等</span><br></pre></td></tr></table></figure>
</li>
<li><p>swiftUI和UIKit的协调员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">struct PageControl: UIViewRepresentable &#123;</span><br><span class="line">var numberOfPages: Int</span><br><span class="line">@Binding var currentPage: Int</span><br><span class="line"></span><br><span class="line">func makeCoordinator() -&gt; Coordinator &#123;</span><br><span class="line">Coordinator(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func makeUIView(context: Context) -&gt; UIPageControl &#123;</span><br><span class="line">let control = UIPageControl()</span><br><span class="line">control.numberOfPages = numberOfPages</span><br><span class="line">control.addTarget(</span><br><span class="line">context.coordinator,</span><br><span class="line">action: #selector(Coordinator.updateCurrentPage(sender:)),</span><br><span class="line">for: .valueChanged)</span><br><span class="line"></span><br><span class="line">return control</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func updateUIView(_ uiView: UIPageControl, context: Context) &#123;</span><br><span class="line">uiView.currentPage = currentPage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Coordinator: NSObject &#123;</span><br><span class="line">var control: PageControl</span><br><span class="line"></span><br><span class="line">init(_ control: PageControl) &#123;</span><br><span class="line">self.control = control</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@objc</span><br><span class="line">func updateCurrentPage(sender: UIPageControl) &#123;</span><br><span class="line">control.currentPage = sender.currentPage</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2019/06/15/swiftUI练习/" data-id="ckd90jom9005fxc51x3juapva" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Flutter入门学习步骤" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2019/01/01/Flutter入门学习步骤/">Flutter入门学习步骤</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2019/01/01/Flutter入门学习步骤/" class="article-date">
  <time datetime="2018-12-31T16:31:35.000Z" itemprop="datePublished">2019-01-01</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/flutter/">flutter</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;新年新气象，但…我却不知道水啥！Flutter上次看到还是0.3这次再看已经1.0了，必须的拿出时间好好学习学习，但现在也仅仅是刚靠近Flutter门槛，远远没达到入门的标准：知识要形成体系！构建简单页面这种也没啥可水的，毕竟<a href="https://flutterchina.club/upgrading/" target="_blank" rel="noopener">Flutter中文网</a>上讲的非常详细, <a href="https://github.com/flutter/flutter" target="_blank" rel="noopener">github</a>也有大量的问题解决方案。于是就把前段时间的学习步骤发出来吧</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h3><p>&emsp;&emsp;按<a href="https://flutterchina.club/upgrading/" target="_blank" rel="noopener">Flutter中文网</a> 安装环境，可能遇到问题下面列举</p>
<ol>
<li>安装过程中如果需要关闭SIP，如果电脑启用了SIP（System Integrity Protection），增加了rootless机制</li>
</ol>
<ul>
<li>1.1，重启，过程中按住 command+R，进入保护模式</li>
<li>1.2，打开terminal终端，输入 csrutil disable</li>
<li>1.3，再次重启，即可对 usr/bin 目录下文件进行修改</li>
<li>1.4，如果要恢复保护机制，重新进入保护模式，输入 csrutil enable</li>
</ul>
<ol start="2">
<li>Android studio 找不到 Flutter</li>
</ol>
<p>&emsp;&emsp;Android studio -&gt; Preferences -&gt; System Setting -&gt; updates -&gt; 去掉 use secure connection</p>
<ol start="3">
<li>PATH环境未生效</li>
</ol>
<p>&emsp;&emsp;user目录 -&gt; command+shift+.  打开隐藏文件 -&gt;  打开 .bash_profile 文件，添加相应PATH -&gt; 保存 -&gt; 重启</p>
<ol start="4">
<li>运行flutter就卡死</li>
</ol>
<p>&emsp;&emsp;偶然发现其实根本原因是mac限制了单进程最大线程个数为64，超过64就卡死了！验证方法：活动监视器 -&gt; 双击android studio -&gt; 取样 -&gt; 查看卡死信息！</p>
<p>&emsp;&emsp;几经周折找到<a href="https://www.cnblogs.com/augus007/articles/9088519.html" target="_blank" rel="noopener">修改内核的方法</a>：vim  /etc/sysctl.conf 添加如下代码 kern.wq_max_constrained_threads=128 修改保存后调用 sysctl -p 加载新配置，将单个进程最大线程数提升至128个。</p>
<p>&emsp;&emsp;PS:kern.wq_max_constrained_threads这个参数是通过全局搜64搜出来的然后慢慢试出来的，同志们修改前记得备份</p>
<ol start="5">
<li><a href="https://stackoverflow.com/questions/48650831/dart-sdk-is-not-configured" target="_blank" rel="noopener">Dart SDK is not configured</a>, android Studio -&gt; perference -&gt; framewoek -&gt; flutter</li>
</ol>
<h3 id="2-Flutter的State类"><a href="#2-Flutter的State类" class="headerlink" title="2 Flutter的State类"></a>2 Flutter的State类</h3><p>&emsp;&emsp;重点，响应式编程核心。先记住如下两张图，<a href="http://wiki.baidu.com/pages/viewpage.action?spaceKey=fmp&amp;title=Flutter" target="_blank" rel="noopener">参考</a></p>
<p>&emsp;&emsp;State 生命周期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A[开始]--&gt;B[构造函数]</span><br><span class="line">subgraph 构建</span><br><span class="line">B--&gt;C[initState]</span><br><span class="line">C--&gt;D[didChangeDependencies]</span><br><span class="line">D--&gt;E[build]</span><br><span class="line">end</span><br><span class="line">E--&gt;F&#123;显示在RenderTree&#125;</span><br><span class="line">subgraph 改变</span><br><span class="line">F--&gt;G[组件状态改变]</span><br><span class="line">G--&gt;H[didUpdateWidget]</span><br><span class="line">H--&gt;I[build]</span><br><span class="line">I--&gt;F</span><br><span class="line">end</span><br><span class="line">subgraph 销毁</span><br><span class="line">F--&gt;J[移除掉]</span><br><span class="line">J--&gt;K[deactivate]</span><br><span class="line">K--&gt;L[dispose]</span><br><span class="line">L--&gt;M[结束]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Stateless VS Stateful<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph StatelessWidgets</span><br><span class="line">A[constructor func]--&gt;B[build]</span><br><span class="line">end</span><br><span class="line">subgraph StatefulWidgets</span><br><span class="line">C[constructor func]--&gt;D[initState]</span><br><span class="line">D--&gt;F[build]</span><br><span class="line">F--&gt;E[setState]</span><br><span class="line">E--&gt;G[didUpdateWidget]</span><br><span class="line">G--&gt;H[build]</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="3-Dart语法预览"><a href="#3-Dart语法预览" class="headerlink" title="3 Dart语法预览"></a>3 Dart语法预览</h3><p>&emsp;&emsp;<a href="http://dart.goodev.org" target="_blank" rel="noopener">Dart 语法</a>对学过swift或者学过JS的同学，我建议<em>直接速读</em><a href="http://dart.goodev.org/guides/language/language-tour" target="_blank" rel="noopener">Dart 语法预览</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Spacecraft &#123;</span><br><span class="line">String name;</span><br><span class="line">DateTime launchDate;</span><br><span class="line">int launchYear;</span><br><span class="line"></span><br><span class="line">// Constructor, including syntactic sugar for assignment to members.</span><br><span class="line">Spacecraft(this.name, this.launchDate) &#123;</span><br><span class="line">// Pretend the following is something you&apos;d actually want to run in</span><br><span class="line">// a constructor.</span><br><span class="line">launchYear = launchDate?.year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Named constructor that forwards to the default one.</span><br><span class="line">Spacecraft.unlaunched(String name) : this(name, null);</span><br><span class="line"></span><br><span class="line">// Method.</span><br><span class="line">void describe() &#123;</span><br><span class="line">print(&apos;Spacecraft: $name&apos;);</span><br><span class="line">if (launchDate != null) &#123;</span><br><span class="line">int years = new DateTime.now().difference(launchDate).inDays ~/ 365;</span><br><span class="line">print(&apos;Launched: $launchYear ($years years ago)&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">print(&apos;Unlaunched&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-Flutter中文网"><a href="#4-Flutter中文网" class="headerlink" title="4 Flutter中文网"></a>4 Flutter中文网</h3><ul>
<li><a href="https://flutterchina.club/get-started/codelab/" target="_blank" rel="noopener">编写第一个Flutter应用</a></li>
<li><a href="https://flutterchina.club/get-started/learn-more/" target="_blank" rel="noopener">了解更多</a></li>
</ul>
<h3 id="5-先抄几个demo"><a href="#5-先抄几个demo" class="headerlink" title="5 先抄几个demo"></a>5 先抄几个demo</h3><ul>
<li>自带示例 flutter/examples </li>
<li>其它dome <a href="https://github.com/iampawan/FlutterExampleApps" target="_blank" rel="noopener">https://github.com/iampawan/FlutterExampleApps</a></li>
<li>资料汇总 <a href="https://github.com/Solido/awesome-flutter" target="_blank" rel="noopener">https://github.com/Solido/awesome-flutter</a></li>
</ul>
<h3 id="6-按部就班"><a href="#6-按部就班" class="headerlink" title="6 按部就班"></a>6 按部就班</h3><p>&emsp;&emsp;按中文网目录往下琢磨就好了</p>
<h3 id="7-了解更好"><a href="#7-了解更好" class="headerlink" title="7 了解更好"></a>7 了解更好</h3><ul>
<li><a href="https://flutterchina.club/flutter-for-ios/" target="_blank" rel="noopener">Flutter for iOS 开发</a>  速读即可</li>
<li><a href="https://flutterchina.club/faq/" target="_blank" rel="noopener">Flutter中文网-常见问题</a></li>
<li>Flutter右上角的《Flutter实战》快速浏览即可。附上我画的思维导图 链接:<a href="https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg</a> 提取码: 9w7a </li>
</ul>
<h3 id="8-Hot-reload-（热重载）Not-Hot-fix-（热修复）"><a href="#8-Hot-reload-（热重载）Not-Hot-fix-（热修复）" class="headerlink" title="8 Hot reload （热重载）Not Hot fix （热修复）"></a>8 Hot reload （热重载）Not Hot fix （热修复）</h3><h3 id="9-add-flutter-to-App"><a href="#9-add-flutter-to-App" class="headerlink" title="9 add flutter to App"></a>9 add flutter to App</h3><ul>
<li>官网 <a href="https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps" target="_blank" rel="noopener">https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps</a></li>
<li>官方dome（不能用） <a href="https://github.com/flutter/ios_add2app" target="_blank" rel="noopener">https://github.com/flutter/ios_add2app</a> ，稍微改了改 链接:<a href="https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg" target="_blank" rel="noopener">https://pan.baidu.com/s/1V9xufLLp9oIz0AcApnjhNg</a> 提取码: 9w7a</li>
</ul>
<h3 id="10-我遇到的小问题"><a href="#10-我遇到的小问题" class="headerlink" title="10 我遇到的小问题"></a>10 我遇到的小问题</h3><ul>
<li><a href="https://www.cnblogs.com/mmcc/p/5133645.html" target="_blank" rel="noopener">android studio 断点调试和高级调试</a></li>
<li><a href="https://juejin.im/post/5b2b21bc51882574b629f8a0" target="_blank" rel="noopener">Flutter视图基础简介–Widget、Element、RenderObject</a> Widget是类定义，Element是实例对象，rednerObject负责实例对象的布局</li>
<li><a href="https://stackoverflow.com/questions/51061147/what-is-the-difference-between-material-and-materialapp-in-flutter" target="_blank" rel="noopener">What is the difference between Material and MaterialApp in Flutter?</a> MaterialApp定义包含appbar之类的app，Scaffold帮助构建对应的appbar</li>
<li><a href="https://stackoverflow.com/questions/46717971/can-somebody-explain-this-dart-syntax?rq=1" target="_blank" rel="noopener">TapboxA({Key key}) : super(key: key); 是什么意思</a></li>
<li><a href="https://yq.aliyun.com/articles/604054" target="_blank" rel="noopener">Flutter Engine线程管理与Dart Isolate机制</a></li>
<li><a href="https://blog.csdn.net/w411207/article/details/80026649" target="_blank" rel="noopener">Dart - Isolate 并发</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1200792" target="_blank" rel="noopener">Flutter常用widget “Expanded”，“Flexible”</a></li>
<li><a href="https://blog.csdn.net/chenlove1/article/details/83032767" target="_blank" rel="noopener">Flutter Container 参数详解</a></li>
<li><a href="https://blog.csdn.net/lyh1299259684/article/details/80565419" target="_blank" rel="noopener">Dart学习之方法函数</a></li>
<li><a href="https://stackoverflow.com/questions/27683924/how-do-getters-and-setters-change-properties-in-dart" target="_blank" rel="noopener">How do getters and setters change properties in Dart?</a></li>
<li>Dart循环引用？Java的垃圾回收可采用引用计数和寻根两种算法，即java虚拟机循环引用不用管！Dart也是垃圾回收，应该也不用管，没找到关于Dart循环引用的资料</li>
<li><a href="https://www.jianshu.com/p/720b968f4e2c" target="_blank" rel="noopener">Dart中实现单例模式</a></li>
<li>rerturn (); 用分号，其它的情况用 , 逗号</li>
<li>Dart：并不支持函数的重载</li>
<li><a href="https://news.dartlang.org/2012/06/const-static-final-oh-my.html" target="_blank" rel="noopener">“static”, “final”, and “const” in Dart</a></li>
<li>lutter的ValueChanged 如果有多个不同的值都需要监听怎么办？</li>
<li>Category ？</li>
<li>runtime ？</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2019/01/01/Flutter入门学习步骤/" data-id="ckd90jokk001dxc51l67ajzi2" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Shell复习" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/09/10/Shell复习/">Shell复习</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/09/10/Shell复习/" class="article-date">
  <time datetime="2018-09-10T10:14:18.000Z" itemprop="datePublished">2018-09-10</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/shell/">shell</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <h3 id="1-基础复习"><a href="#1-基础复习" class="headerlink" title="1 基础复习"></a>1 基础复习</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"># 声明变量，注意不能有空格</span><br><span class="line">your_name=&quot;jzk&quot;</span><br><span class="line"># 使用变量，最好有大括号</span><br><span class="line">echo $&#123;your_name&#125;</span><br><span class="line"># 单引号，不转义也不能嵌套，一般用于常量字符串</span><br><span class="line">str1=&apos;http://www.baidu.com&apos;</span><br><span class="line"># 双引号，能转义也能嵌套，推荐使用</span><br><span class="line">str2=&quot;Hello, I know \&quot;you\&quot; are $&#123;your_name&#125;! \n&quot;</span><br><span class="line"># 拼接字符串，注意使用双引号！单引号不转义是个坑</span><br><span class="line">str3=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line"># 字符串长度</span><br><span class="line">echo $&#123;#str2&#125;</span><br><span class="line"># 字符串截断。从第2个开始截取4个</span><br><span class="line">echo $&#123;str2:1:4&#125;</span><br><span class="line"># #、## 表示从左边开始删除。一个 # 表示从左边删除到第一个指定的字符；两个 # 表示从左边删除到最后一个指定的字符。</span><br><span class="line"># %、%% 表示从右边开始删除。一个 % 表示从右边删除到第一个指定的字符；两个 % 表示从左边删除到最后一个指定的字符。</span><br><span class="line">str=&quot;www.runoob.com/linux/linux-shell-variable.html&quot;</span><br><span class="line">echo &quot;str    : $&#123;str&#125;&quot;</span><br><span class="line">echo &quot;str#*/    : $&#123;str#*/&#125;&quot;   # 从 字符串开头 删除到 左数第一个&apos;/&apos;</span><br><span class="line">echo &quot;str##*/    : $&#123;str##*/&#125;&quot;  # 从 字符串开头 删除到 左数最后一个&apos;/&apos;</span><br><span class="line">echo &quot;str%/*    : $&#123;str%/*&#125;&quot;   # 从 字符串末尾 删除到 右数第一个&apos;/&apos;</span><br><span class="line">echo &quot;str%%/*    : $&#123;str%%/*&#125;&quot;  # 从 字符串末尾 删除到 右数最后一个&apos;/&apos;</span><br><span class="line"></span><br><span class="line"># 一般自己写脚本都会注明使用方式 # usage: sh xxx.sh [参数1含义] [参数2含义] [参数3含义]</span><br><span class="line"># 获取执行shell脚本时参数方法如下</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br><span class="line"></span><br><span class="line"># 数组，不常用</span><br><span class="line">my_arry=(a b &quot;c&quot;,&quot;d&quot; abc)</span><br><span class="line">for i in $&#123;my_arry[@]&#125;;</span><br><span class="line">do</span><br><span class="line">echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</span><br><span class="line"># 注意使用的是反引号 ` 而不是单引号 &apos;,此外推荐用 $() 代替 ``</span><br><span class="line"># 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。</span><br><span class="line"># 注意：最好使用[[....]]的结构，尽量不用[....]</span><br><span class="line"># 算术运算符 +、-、*、/、%、=、==、！=</span><br><span class="line"># 关系运算符 -eq、-ne、-gt、-lt、-ge、-le #等同于C的==、!=、&gt;、&lt;、&gt;=、&lt;=</span><br><span class="line"># 布尔运算符 ！、-o、-a</span><br><span class="line"># 逻辑运算符 &amp;&amp;、||</span><br><span class="line"># 字符串运算符 =、!=、-z、-n、$</span><br><span class="line">val1=`expr 10 + 20`</span><br><span class="line">val2=$(expr 10 + 20)</span><br><span class="line"></span><br><span class="line"># if判断</span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># for</span><br><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># while</span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">echo $int</span><br><span class="line">let &quot;int++&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># case</span><br><span class="line"># 注意每一个value后面需要一个 ），;;表示C里面的break，最后结尾用esac，</span><br><span class="line">echo &apos;输入 1 到 4 之间的数字:&apos;</span><br><span class="line">echo &apos;你输入的数字为:&apos;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">1)  echo &apos;你选择了 1&apos;</span><br><span class="line">;;</span><br><span class="line">2)  echo &apos;你选择了 2&apos;</span><br><span class="line">;;</span><br><span class="line">3)  echo &apos;你选择了 3&apos;</span><br><span class="line">;;</span><br><span class="line">4)  echo &apos;你选择了 4&apos;</span><br><span class="line">;;</span><br><span class="line">*)  echo &apos;你没有输入 1 到 4 之间的数字&apos;</span><br><span class="line">;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line"># break命令允许跳出所有循环，continue仅仅跳出当前循环。</span><br><span class="line"></span><br><span class="line"># 函数, return返回值，$1第一个参数、$2第二个参数</span><br><span class="line">fun1()&#123;</span><br><span class="line">return $(($1+$2))</span><br><span class="line">&#125;</span><br><span class="line">fun1 1 2</span><br><span class="line"></span><br><span class="line"># 文件包含</span><br><span class="line">. ./function.sh</span><br><span class="line"># 如果function.sh是用户传入的参数，如何获得它的绝对路径呢？方法是：</span><br><span class="line">real_path=`readlink -f $1`#$1是用户输入的参数，如function.sh</span><br><span class="line">. $real_path</span><br></pre></td></tr></table></figure>
<h3 id="2-常用linux命令"><a href="#2-常用linux命令" class="headerlink" title="2 常用linux命令"></a>2 常用linux命令</h3><h4 id="2-1-帮助"><a href="#2-1-帮助" class="headerlink" title="2.1 帮助"></a>2.1 帮助</h4><ul>
<li><p>老规矩，先看帮助命令！help</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">These shell commands are defined internally.  Type `help&apos; to see this list.</span><br><span class="line">Type `help name&apos; to find out more about the function `name&apos;.</span><br><span class="line">Use `info bash&apos; to find out more about the shell in general.</span><br><span class="line">Use `man -k&apos; or `info&apos; to find out more about commands not in this list.</span><br></pre></td></tr></table></figure>
</li>
<li><p>更强大的帮助指令是man，使用man时可以指定不同的section来浏览，各个section意义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 - commands // 普通的命令</span><br><span class="line">2 - system calls // 系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件)</span><br><span class="line">3 - library calls // 库函数,如printf,fread</span><br><span class="line">4 - special files // 特殊文件,也就是/dev下的各种设备文件</span><br><span class="line">5 - file formats and convertions // 指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义</span><br><span class="line">6 - games for linux // 给游戏留的,由各个游戏自己定义</span><br><span class="line">7 - macro packages and conventions // 附件还有一些变量,比如向environ这种全局变量在这里就有说明</span><br><span class="line">8 - system management commands // 系统管理用的命令,这些命令只能由root使用,如ifconfig</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-目录"><a href="#2-2-目录" class="headerlink" title="2.2 目录"></a>2.2 目录</h4><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>ls</td>
<td>全拼list，功能是列出目录的内容及其内容属性信息。</td>
</tr>
<tr>
<td>cd</td>
<td>全拼change directory，功能是从当前工作目录切换到指定的工作目录。</td>
</tr>
<tr>
<td>cp</td>
<td>全拼copy，其功能为复制文件或目录。</td>
</tr>
<tr>
<td>mkdir</td>
<td>全拼make directories，其功能是创建目录。</td>
</tr>
<tr>
<td>mv</td>
<td>全拼move，其功能是移动或重命名文件。</td>
</tr>
<tr>
<td>pwd</td>
<td>全拼print working directory，其功能是显示当前工作目录的绝对路径。</td>
</tr>
<tr>
<td>rename</td>
<td>用于重命名文件。</td>
</tr>
<tr>
<td>rm</td>
<td>全拼remove，其功能是删除一个或多个文件或目录。</td>
</tr>
<tr>
<td>rmdir</td>
<td>全拼remove empty directories，功能是删除空目录。</td>
</tr>
<tr>
<td>touch</td>
<td>创建新的空文件，改变已有文件的时间戳属性。</td>
</tr>
<tr>
<td>which</td>
<td>查找二进制命令，按环境变量PATH路径查找。</td>
</tr>
<tr>
<td>find</td>
<td>从磁盘遍历查找文件或目录。</td>
</tr>
<tr>
<td>whereis</td>
<td>查找二进制命令，按环境变量PATH路径查找。</td>
</tr>
<tr>
<td>locate</td>
<td>从数据库(/var/lib/mlocate/mlocate.db)查找命令，使用updatedb更新库。</td>
</tr>
</tbody>
</table>
<h4 id="2-3-查看文件"><a href="#2-3-查看文件" class="headerlink" title="2.3 查看文件"></a>2.3 查看文件</h4><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>cat</td>
<td>查看文件内容,若文件不存在，创建对应文件：</td>
</tr>
<tr>
<td>more</td>
<td>分页显示文件内容。</td>
</tr>
<tr>
<td>head</td>
<td>显示文件内容的头部。</td>
</tr>
<tr>
<td>iconv</td>
<td>转换文件的编码格式。</td>
</tr>
<tr>
<td>diff</td>
<td>全拼difference，比较文件的差异，常用于文本文件。</td>
</tr>
<tr>
<td>grep/egrep</td>
<td>过滤字符串</td>
</tr>
<tr>
<td>join</td>
<td>按两个文件的相同字段合并。</td>
</tr>
<tr>
<td>tr</td>
<td>替换或删除字符。</td>
</tr>
<tr>
<td>vi/vim</td>
<td>命令行文本编辑器。</td>
</tr>
</tbody>
</table>
<h4 id="2-4-其它"><a href="#2-4-其它" class="headerlink" title="2.4 其它"></a>2.4 其它</h4><table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>sudo</td>
<td>以root执行命令</td>
</tr>
<tr>
<td>ping</td>
<td>测试主机之间网络的连通性。</td>
</tr>
<tr>
<td>chmod</td>
<td>改变文件或目录权限</td>
</tr>
<tr>
<td>chown</td>
<td>改变文件或目录的属主和属组。</td>
</tr>
<tr>
<td>echo</td>
<td>打印变量，或直接输出指定的字符串</td>
</tr>
<tr>
<td>rpm</td>
<td>管理rpm包</td>
</tr>
<tr>
<td>history</td>
<td>查看命令执行的历史纪录。</td>
</tr>
</tbody>
</table>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="https://www.runoob.com/linux/linux-shell-variable.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-shell-variable.html</a></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/09/10/Shell复习/" data-id="ckd90jola003cxc51ffgzq46h" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-Swift开发者必备Tips" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/04/10/Swift开发者必备Tips/">Swift开发者必备Tips</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/04/10/Swift开发者必备Tips/" class="article-date">
  <time datetime="2018-04-09T16:20:23.000Z" itemprop="datePublished">2018-04-10</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ol>
<li><p>柯里化: 通过模板来批量生成方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func greaterThan(_ comparer: Int) -&gt; (Int) -&gt; Bool &#123;</span><br><span class="line">return &#123; $0 &gt; comparer&#125;</span><br><span class="line">&#125;</span><br><span class="line">let greaterThan10 = greaterThan(10)</span><br><span class="line">greaterThan10(13) // true</span><br><span class="line">greaterThan10(0) // false</span><br></pre></td></tr></table></figure>
</li>
<li><p>将protocol的方法声明为mutating：mutating关键字是为了能在该方法里修改struct或enum变量，另外使用class实现protocol时，可以不用加mutating，因class可随意改变量，mutating对于class时完全透明的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">protocol Vehicle &#123;</span><br><span class="line">var color: UIColor &#123;get set&#125;</span><br><span class="line">mutating func changeColor()</span><br><span class="line">&#125;</span><br><span class="line">struct MyCar: Vehicle &#123;</span><br><span class="line">var color = UIColor.blue</span><br><span class="line">mutating func changeColor() &#123;</span><br><span class="line">color = .red</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for循环可用于实现了Sequence的类型上，要实现Sequence需要先实现IteratorProtocol协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ReverseIterator&lt;T&gt;: IteratorProtocol &#123;</span><br><span class="line">typealias Element = T</span><br><span class="line">var array:[Element]</span><br><span class="line">var currentIndex = 0</span><br><span class="line">init(array:[Element]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">currentIndex = array.count - 1</span><br><span class="line">&#125;</span><br><span class="line">func next() -&gt; Element? &#123;</span><br><span class="line">if currentIndex &lt; 0 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;else &#123;</span><br><span class="line">let element = array[currentIndex]</span><br><span class="line">currentIndex -= 1</span><br><span class="line">return element</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct ReverseSequence&lt;T&gt;: Sequence &#123;</span><br><span class="line">var array:[T]</span><br><span class="line">init(array:[T]) &#123;</span><br><span class="line">self.array = array</span><br><span class="line">&#125;</span><br><span class="line">typealias Iterator = ReverseIterator&lt;T&gt;</span><br><span class="line">func makeIterator() -&gt; ReverseIterator&lt;T&gt; &#123;</span><br><span class="line">return ReverseIterator(array: self.array)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let arr = [2,3,4,5,7,6]</span><br><span class="line">for (index, value) in ReverseSequence(array: arr).enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(value)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多元组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func swap&lt;T&gt;(a: inout T, b: inout T) &#123;</span><br><span class="line">(a, b) = (b, a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2</span><br><span class="line">var b = 3</span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">print(&quot;a is \(a) b is \(b)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@autoclosure 是把形如 ()-&gt;T 的一句表达式（无参数，就一句）自动封装成闭包，var c = a ?? b,表示a非nil时c=a，nil时c=b，其实跟连着写的?: 是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func logIfTure(_ predicate: ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure (&#123; () -&gt; Bool in</span><br><span class="line">return 2 &gt; 1</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure (&#123;</span><br><span class="line">return 3 &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123; 4 &gt; 3 &#125;)</span><br><span class="line">logIfTure &#123; 5 &gt; 4 &#125;</span><br><span class="line"></span><br><span class="line">func logIfTureAutoclosure(_ predicate:@autoclosure ()-&gt; Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;value is true!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 注意是小括号</span><br><span class="line">logIfTureAutoclosure(6&gt;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>@escaping逃逸闭包，异步回调那种函数执行完了闭包还需要执行，注意循环引用使用weak self unowned self；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 逃逸闭包</span><br><span class="line">func testEscapingFunc(printNum: @escaping (_ num: Int) -&gt; ())&#123;</span><br><span class="line">print(&quot;testEscapingFunc begin&quot;)</span><br><span class="line">DispatchQueue.global().async &#123;</span><br><span class="line">DispatchQueue.main.async &#123;</span><br><span class="line">printNum(66)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;testEscapingFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testEscapingFunc &#123; (num) in</span><br><span class="line">print(&quot;Escaping colsure begin&quot;)</span><br><span class="line">print(&quot;Escaping num is \(num)&quot;)</span><br><span class="line">print(&quot;Escaping colsure end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 非逃逸闭包</span><br><span class="line">func testNoescapeFunc(printNum: (_ num: Int) -&gt; ()) &#123;</span><br><span class="line">print(&quot;testNoescapeFunc begin&quot;)</span><br><span class="line">printNum(77)</span><br><span class="line">print(&quot;testNoescapeFunc end&quot;)</span><br><span class="line">&#125;</span><br><span class="line">testNoescapeFunc &#123; (num) in</span><br><span class="line">print(&quot;Noescape colsure begin&quot;)</span><br><span class="line">print(&quot;Noescape num is \(num)&quot;)</span><br><span class="line">print(&quot;Noescape colsure end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional chaining ，返回的都是最后一个的可选类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Pet &#123;</span><br><span class="line">let name: String</span><br><span class="line">init(name: String) &#123;</span><br><span class="line">self.name = name</span><br><span class="line">&#125;</span><br><span class="line">func play() -&gt; (String) &#123;</span><br><span class="line">return &quot;playing&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Child &#123;</span><br><span class="line">var pet: Pet?</span><br><span class="line">&#125;</span><br><span class="line">var xiaoming = Child()</span><br><span class="line">xiaoming.pet = Pet(name: &quot;dog&quot;)</span><br><span class="line">if let petName = xiaoming.pet?.name &#123;</span><br><span class="line">print(&quot;xiaoming pet name is \(petName)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">if let p = xiaoming.pet?.play() &#123;</span><br><span class="line">print(&quot;xiaoming pet is \(p)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载操作符，慎用避免冲突，应该是公开的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Vector2D &#123;</span><br><span class="line">var x = 0</span><br><span class="line">var y = 0</span><br><span class="line">&#125;</span><br><span class="line">func +(left:Vector2D, right:Vector2D) -&gt; Vector2D&#123;</span><br><span class="line">return Vector2D(x: left.x + right.x, y: left.y + right.y)</span><br><span class="line">&#125;</span><br><span class="line">let v1 = Vector2D(x: 1, y: 2)</span><br><span class="line">let v2 = Vector2D(x: 3, y: 4)</span><br><span class="line">let v3 = v1 + v2</span><br><span class="line">print(&quot;v3 is \(v3)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>func的参数修饰，默认参数都是copy的，inout关键字可以直接修改参数值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func incrementor1(x: Int) -&gt; Int &#123;</span><br><span class="line">x + 1</span><br><span class="line">return x</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;参数不可变 \(incrementor1(x: 1))&quot;)</span><br><span class="line">func incrementor2(x: inout Int) &#123;</span><br><span class="line">x = x + 1</span><br><span class="line">&#125;</span><br><span class="line">var x = 1</span><br><span class="line">incrementor2(x: &amp;x)</span><br><span class="line">print(&quot;参数可变 \(x)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字面量表达式，实现类似ExpressibleByBooleanLiteral的协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 以下就是字面量表达式，思考为啥写个true编译器就知道是BOOL类型的</span><br><span class="line">var aBool = true</span><br><span class="line">var aString = &quot;this is a string&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下标，数组下标注意越界，字典下标返回可选类型。可以重写数组或字典下标，也可以自定义下标,实现subscript方法，延伸阅读<a href="https://www.cnblogs.com/ludashi/p/5179275.html" target="_blank" rel="noopener">窥探Swift之数组安全索引与数组切片</a></p>
</li>
<li><p>方法嵌套，更清晰不用在别的地方调用一堆小方法了都在函数里面呢，访问权限更易管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func makeIncrementer(add: Int) -&gt; (inout Int) -&gt; Void &#123;</span><br><span class="line">func incrementer(x : inout Int) -&gt; Void &#123;</span><br><span class="line">x = x + add</span><br><span class="line">&#125;</span><br><span class="line">return incrementer;</span><br><span class="line">&#125;</span><br><span class="line">let incrementer2 = makeIncrementer(add: 2)</span><br><span class="line">var y = 3</span><br><span class="line">incrementer2(&amp;y)</span><br><span class="line">print(&quot;\(y)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名空间。基于module的而不是直接再代码中显示指明的，进行app开发时，默认添加app的主target里的内容都在同一命名空间里，即同一target里名称不能相同。</p>
</li>
<li><p>typealias，指定类型重命名。当实现多个协议时，也可以用 &amp; 连接多协议，用typealias重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol Dog &#123;</span><br><span class="line">func watch() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">protocol Cat &#123;</span><br><span class="line">func sleep() -&gt; Void</span><br><span class="line">&#125;</span><br><span class="line">typealias Pet = Dog &amp; Cat</span><br></pre></td></tr></table></figure>
</li>
<li><p>associatedtype 如果有多个协议，它们的方法和属性都一样，只有协议中用到的类型不同，则可合并为一个使用关联类型(associatedtype)进行区分。实现时自定义typealias相应类型即可。延伸阅读<a href="https://www.cnblogs.com/muzijie/p/6596164.html" target="_blank" rel="noopener">Swift—–协议Protocol</a></p>
</li>
<li>可变参数<br><a href="https://www.jianshu.com/p/5a1178f3c36f" target="_blank" rel="noopener">OC的可变参数</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 注意可变参数必须是最后一个参数，且name后面有一个英文逗号</span><br><span class="line">- (void)testMultiplePramar:(NSString *)name, ... &#123;</span><br><span class="line">// 一个字符类型的指针，指针指向当前的参数，需要通过这个指针取参数。</span><br><span class="line">va_list arg_list;</span><br><span class="line">// 初始化字符指针的函数，将把arg_list指针指向name这个可变形参的第一个位置</span><br><span class="line">va_start(arg_list, name);</span><br><span class="line">NSLog(@&quot;第一个 ： %@&quot;, name);</span><br><span class="line">while(YES)&#123;</span><br><span class="line">// 这是一个取参数的函数，这个函数需要两个参数，第一个参数是字符指针va_list，第二个参数是我们需要取的可变参数的数据类型</span><br><span class="line">// 这个函数需要做两件事：1：取到指定数据类型的参数。2：将指针ap指向下一个可变参数的地址。</span><br><span class="line">NSString * obj=va_arg(arg_list,NSString *);</span><br><span class="line">// 取完所有参数之后，跳出循环</span><br><span class="line">if(obj==nil)break;</span><br><span class="line">NSLog(@&quot;--- %@&quot;,obj);</span><br><span class="line">&#125;</span><br><span class="line">// 最后要将指针ap指向NULL。避免野指针。和va_start成对使用。</span><br><span class="line">va_end(arg_list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Swift版可变参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 只能有一个可变参数，位置不限类型相同</span><br><span class="line">func myFunc(numbers:Int..., str: String) &#123;</span><br><span class="line">numbers.forEach &#123; (i) in</span><br><span class="line">print(&quot;\(str)，第\(i)个&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunc(numbers: 1,2,3,4,5, str: &quot;hello&quot;)</span><br><span class="line">Swift版的stringformat方法 init(format:NSString, _ args: CVarArgType...)</span><br></pre></td></tr></table></figure></p>
<ol start="17">
<li><p>初始化方法顺序<br>明确一个问题<a href="https://stackoverflow.com/questions/8056188/should-i-refer-to-self-property-in-the-init-method-with-arc" target="_blank" rel="noopener">不要在init初始化方法里使用self.property</a> <br><br>A，OC是先初始化父类在初始化子类成员变量<br><br>B，1，先初始化子类成员变量，<br><br>2调用父类初始化，（若没第3步，可不写编译器自己加）<br><br>3对父类中需要改变的成员进行设定<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">let numA: Int</span><br><span class="line">// Designated 指定的 init初始化方法</span><br><span class="line">// 也可以加上required关键字以确保子类对其实现</span><br><span class="line">init(num: Int) &#123;</span><br><span class="line">numA = num; //可对let的实例常量赋值</span><br><span class="line">&#125;</span><br><span class="line">// 所有的便利构造器都必须调同一类中Designated初始化完成设置，且不能被子类重写或从子类中以super的方式调用</span><br><span class="line">convenience init(bigNum: Bool) &#123;</span><br><span class="line">self.init(num: bigNum ? 1000 : 1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ClassB: ClassA &#123;</span><br><span class="line">let numB: Int</span><br><span class="line">override init(num: Int) &#123;</span><br><span class="line">numB = num + 2</span><br><span class="line">super.init(num: num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let bObj = ClassB(bigNum: true)</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化返回nil<br>OC初始化失败可以返回nil，但swift没有return，因此swif中用 init? 表示返回可选值，即可能失败</p>
</li>
<li><a href="https://www.jianshu.com/p/c2c95c1c593d" target="_blank" rel="noopener">static 和 class</a>， 注意cpoy on write</li>
<li>容器(Array, Dictionary, Set)只能放同一类型元素，如果想放不同类型怎么办？<br><br>A。类型转换，信息损失十分危险，最好不要用！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">let mixed: [Any] = [1, &quot;Two&quot;,3]; // Any类型可以隐式转换</span><br><span class="line">// 转换为[NSObject]</span><br><span class="line">let objectArray = [1 as NSObject, &quot;two&quot; as NSObject, 3 as NSObject]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>B。如果有共同特征，可以添加实现同一协议的类型的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">let mixed2 : [CustomStringConvertible] = [1, &quot;two&quot;, 3]</span><br><span class="line">for obj in mixed2 &#123;</span><br><span class="line">print(obj.description)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C。将类型信息封装到enum中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">enum IntOrString &#123;</span><br><span class="line">case IntValue(Int)</span><br><span class="line">case StringValue(String)</span><br><span class="line">&#125;</span><br><span class="line">let mixed = [IntOrString.IntValue(1), IntOrString.StringValue(&quot;two&quot;), IntOrString.IntValue(3)]</span><br><span class="line">for value in mixed &#123;</span><br><span class="line">switch value &#123;</span><br><span class="line">case let .IntValue(i):</span><br><span class="line">print(i)</span><br><span class="line">case let .StringValue(str):</span><br><span class="line">print(str)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="21">
<li><p>default参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func hello(name:String = &quot;JZK&quot;, str:String)&#123;</span><br><span class="line">print(name+&quot; &quot;+str)</span><br><span class="line">&#125;</span><br><span class="line">hello(str: &quot;hello world&quot;)</span><br><span class="line">hello(name: &quot;dxm&quot;, str: &quot;hello world&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式。自定义符号还是麻烦，其实用OC的是最省事的，<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a>，<a href="https://code.tutsplus.com/tutorials/8-regular-expressions-you-should-know--net-6149" target="_blank" rel="noopener">8个常用正则</a></p>
</li>
<li><p>模式匹配,没看懂好像就是switch的使用而已呀，重载~/ 跟switch有啥子关系。。。</p>
</li>
<li><p>… 和 ..&lt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 包含3，即输出0 1 2 3</span><br><span class="line">for i in 0...3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 小于3（不含3），即输出0 1 2</span><br><span class="line">for i in 0..&lt;3 &#123;</span><br><span class="line">print(&quot;\(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 还可以通过 ... 或 ..&lt; 来连接两个字符串</span><br><span class="line">// 但经过试验发现很难用，例&quot;0&quot;...&quot;10&quot; 包含&quot;1&quot;但不包含&quot;2&quot;, 还有校验ASCII码 \0...~ 确实正确的</span><br></pre></td></tr></table></figure>
</li>
<li><p>AnyClass, 元类型和 .self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// swift中能够表示“任意”这个概念的除了 Any 和 AnyObject 外，还有AnyClass , AnyClass = AnyObject.Type</span><br><span class="line">// .Type 表示的是某个类型的元类型。.Protocol表示某个协议的元类型</span><br><span class="line">// 类型.self 表示获得该类型Class， 实例.self表示获得该实例对象</span><br><span class="line">import UIKit</span><br><span class="line">class AVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">class BVC: UIViewController &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 强转成AnyClass，类似工厂方法</span><br><span class="line">let VCTypes : [AnyClass] = [AVC.self, BVC.self]</span><br><span class="line">for type in VCTypes &#123;</span><br><span class="line">if type is UIViewController.Type &#123;</span><br><span class="line">// 想想为什么可以调init 类方法？</span><br><span class="line">let vc = (type as! UIViewController.Type).init()</span><br><span class="line">print(&quot;vc实例类型为：\(vc)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议和类方法中的Self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 协议没自己的上下文信息，也不知道谁实现。当我们希望在协议中使用的就是实现这个协议本身的类型的话，就需要使用Self（注意首字母大写）进行指代，此时Self不仅指代的是实现该协议的类型本身，也包括了这个类型的子类。</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态类型和多方法<br><a href="https://www.jianshu.com/p/7eb4053d339e" target="_blank" rel="noopener">dynamicType废除，用type(of:)代替</a></p>
</li>
<li>属性观察<br>存储型属性 willSet 和 didSet 方法中newValue表示将要设定的，oldValue表示已经设定的。注意初始化时不会调属性观察。计算形型属性只有get和set方法</li>
<li>final 表示不允许继承或重写。</li>
<li><p>lazy修饰符和lazy方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ClassA &#123;</span><br><span class="line">// class或struct 的变量属性，且需指明类型</span><br><span class="line">lazy var str : String = &quot;hello&quot;</span><br><span class="line">&#125;</span><br><span class="line">// lazy 也能修饰方法,对于可能提前退出情况，性能优化明显</span><br><span class="line">let arr = 1...3</span><br><span class="line">let result = arr.lazy.map &#123; (i: Int) -&gt; Int in</span><br><span class="line">print(&quot;map \(i)&quot;)</span><br><span class="line">return i * 2</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;begin&quot;)</span><br><span class="line">for i in result &#123;</span><br><span class="line">print(&quot;result \(i)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>refection 和 mirror , 知道有反射就行了，最好不用</p>
</li>
<li>强制解包，少用才好，多用可选链！</li>
<li><p>多重optional</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var aNil : String? = nil</span><br><span class="line">var anotherNil : String?? = aNil</span><br><span class="line">var literalNil : String?? = nil</span><br><span class="line">if anotherNil != nil &#123;</span><br><span class="line">print(&quot;anotherNil&quot;) // 输出</span><br><span class="line">&#125;</span><br><span class="line">if literalNil != nil &#123;</span><br><span class="line">print(&quot;literalNil&quot;) //</span><br><span class="line">&#125;</span><br><span class="line">// 但用po输出时，anotherNil和literalNil 都是nil，因lldb已经将optional展开了</span><br></pre></td></tr></table></figure>
</li>
<li><p>optional map ，没啥用</p>
</li>
<li><p>协议扩展 protocol extension， 可以为协议中定义的方法提供一个默认的实现</p>
</li>
<li><p>where 和模式匹配</p>
</li>
<li>indirect 和嵌套enum</li>
<li>swift的#selector 和OC的@selector一样，swift4中默认所有的swift方法在OC中都不可见，所以需要在方法前加上@objc 关键字。使用#selector时，swift的同名方法需要强制转化</li>
<li><p>实例方法动态调用，挺好玩的，虽然我也没想到有什么用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">func method(num: Int) -&gt; Int &#123;</span><br><span class="line">return num + 2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 实例化MyClass对象，再调用method方法就限定死了类型</span><br><span class="line">// 但swift中可直接用 Type.instanceMethod的语法生成一个可以柯里化的方法，只适用于实例方法，对getter或setter无效,同名方法需对 f 加上类型加以区别</span><br><span class="line">let f = MyClass.method</span><br><span class="line">let object = MyClass()</span><br><span class="line">let result = f(object)(1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 设置init方法为private来覆盖默认public的方法，保证其他地方不能init实例</span><br><span class="line">//方法一</span><br><span class="line">class AppShared &#123;</span><br><span class="line">private static let _sharedInstance = AppShared()</span><br><span class="line">class func sharedInstance() -&gt;AppShared&#123;</span><br><span class="line">return _sharedInstance</span><br><span class="line">&#125;</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//方法二</span><br><span class="line">class AppShared2 &#123;</span><br><span class="line">static let sharedInstance = AppShared2()</span><br><span class="line">private init() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// swift中没有宏，实质上是一些全局常量和函数</span><br><span class="line">//#if condition //注意condition大小写敏感</span><br><span class="line">//#endif</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>延伸阅读<a href="https://www.cnblogs.com/Bob-wei/p/5237761.html" target="_blank" rel="noopener">Swift中如何使用 #if DEBUG</a><br>condition  | 可选参数<br>—|—<br>os() | macOS,iOS,tvOS,watchOS,Linux<br>arch() | x86_64, arm, arm64, i386<br>swift() | &gt;= 某个版本</p>
<ol start="42">
<li>编译标记OC的#param，在swift中用 // MARK:- 代替（注意大写），此外还有// TODO: 和 // FIXME: , 但没有#warning的替代品</li>
<li>@UIApplicationMain， 和OC的main函数是一样的，如果我们想使用UIApplicaiton的子类(例如监听所有的点击事件)，就可以创建main.swift</li>
<li>@objc 和 dynamic，swift写的类继承自NSObject的话，swift会自动为所有非private的类和成员加上@objc，但@objc并不意味着会变成动态派发，动态派发需用dynamic关键字。延伸阅读<a href="https://www.jianshu.com/p/37f720df43ac" target="_blank" rel="noopener">iOS OC与Swift混编</a>，注意和OC的@dynamic没任何关系，@dynamic表示不用编译器自动生成getter和setter方法</li>
<li>可选协议和协议扩展</li>
<li>内存管理，weak和unowned，如果再在访问时不会被释放的话，尽量用unowned，如果存在被释放的课鞥呢，那就用weak</li>
<li>@autoreleasepool在swift中已经没有了, swift提倡用初始化方法而不是用类方法来生成对象</li>
<li>值类型和引用类型，swift中所有的内建类型都是值类型，甚至String，array以及Dictionary都是值类型，值类型复制值发生在内容发生改变时</li>
<li>String 还是 NSString？能用String尽量用String，但使用Range时还是NSString更好用</li>
<li><p>UnsafePointer, 用于对C语言的指针进行转换，C中的基本类型在swift中对应的类型都有统一的命名规则：前面加上 C 且首字母大写，例如int 对应的类型为 CInt，int的指针转换到swift中对应的就是UnsafePointer<cint>, C的指针不可变用UnsafePointer,可变指针用UnsafeMutablePointer</cint></p>
</li>
<li><p>C指针的内存管理，无法使用ARC，deallocate与deinitialize应该要和allocate与initialize成对出现。malloc和calloc要与free匹配</p>
</li>
<li>C中指向函数的指针可转为闭包，不过需要加上@convention标注</li>
<li>GCD和延时调用, <a href="https://www.jianshu.com/p/51fd1362249e" target="_blank" rel="noopener">OC多线程</a> 和 <a href="https://www.cnblogs.com/csdnIOS/p/6874839.html" target="_blank" rel="noopener">swift的GCD</a></li>
<li>获取对象类型 type(of:)</li>
<li>OC的 isKindOfClass 和 isMemberOfClass 在swift中继承自NSObject的依然可以使用，swift还有 is 关键字等同于isKindOfClass，但也可以用于struct或enum进行类型判断。as 关键字向上转型；as！向下转型；as？向下转型，如果失败返回nil</li>
<li><p>swift中的KVO实现, 延伸：可用属性观察自己实现，也可<a href="http://chris.eidhof.nl/post/references/" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">// 继承自NSObject</span><br><span class="line">class MyClass: NSObject &#123;</span><br><span class="line">// 要检测的属性必须标注 @objc dynamic</span><br><span class="line">@objc dynamic var date = Date()</span><br><span class="line">&#125;</span><br><span class="line">class KvoClass: NSObject &#123;</span><br><span class="line">var myObject : MyClass!</span><br><span class="line">var observation: NSKeyValueObservation?</span><br><span class="line">override init() &#123;</span><br><span class="line">myObject = MyClass()</span><br><span class="line">print(&quot;初始化时间：\(Date())&quot;)</span><br><span class="line">observation = myObject.observe(\MyClass.date, options: [.new], changeHandler: &#123; (_, change) in</span><br><span class="line">if let newDate = change.newValue &#123;</span><br><span class="line">print(&quot;变化时间：\(Date())&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var kvoObject = KvoClass()</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2) &#123;</span><br><span class="line">kvoObject.myObject.date = Date()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>局部scope，隔离代码的好方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// OC中使用方法</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// 局部scope</span><br><span class="line">&#123;</span><br><span class="line">UILabel *label1 = [[UILabel alloc] initWithFrame:CGRectMake(0, 100, 100, 44)];</span><br><span class="line">label1.text = @&quot;first label&quot;;</span><br><span class="line">[self.view addSubview:label1];</span><br><span class="line">&#125;</span><br><span class="line">// GNU C的声明扩展</span><br><span class="line">UILabel *label2 = (&#123;</span><br><span class="line">UILabel *tempLabel = [[UILabel alloc] initWithFrame:CGRectMake(0, 200, 100, 44)];</span><br><span class="line">tempLabel.text = @&quot;second label&quot;;</span><br><span class="line">tempLabel; // 注意没有return</span><br><span class="line">&#125;);</span><br><span class="line">[self.view addSubview:label2];</span><br><span class="line">&#125;</span><br><span class="line">// swift不允许直接使用大括号，和闭包冲突。而且没有GNU C的声明扩展</span><br><span class="line">// 但可以使用匿名闭包</span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">// Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">let titleLabel : UILabel = &#123;</span><br><span class="line">let label = UILabel(frame: CGRect(x: 0, y: 100, width: 100, height: 44))</span><br><span class="line">label.text = &quot;匿名闭包&quot;</span><br><span class="line">return label</span><br><span class="line">&#125;()</span><br><span class="line">self.view.addSubview(titleLabel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中==表示判断两个对象是否指向同一块内存，在swift中对应为 === ，而swift中的 == 是一个操作符声明，在 Equatable 协议里声明，可重载，没重载的话就是 isEqual </p>
</li>
<li>哈希</li>
<li>类簇，swift中使用工厂方法模式来实现，因swift中初始化方法只能得到完成所有配置的当前类实例，即不可能在公共类中返回子类信息</li>
<li>swift中直接使用C代码或库是不可能的，因此使用C库最好的办法是使用OC文件封装，通过 工程名-Bridging-Header.h 桥接文件来调OC的代码</li>
<li><p>输出格式化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line">var b = 1.234567890</span><br><span class="line">print(&quot;b is \(b)&quot;)</span><br><span class="line">let formatB = String(format: &quot;%.2f&quot;, b)</span><br><span class="line">print(&quot;保留两位小数 b is \(formatB)&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NS_ENUM对应swift的enum，OC的NS_OPTIONS被映射为满足OptionSet协议的struct类型，以及一组静态的get属性，对不需要选项的可以用[]空集合表示，可以参照 AnimationOptions </p>
</li>
<li><p>数组的enumerated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (index, item) in [2,4,1,4,5].enumerated() &#123;</span><br><span class="line">print(&quot;index is \(index) value is \(item)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC中可以通过@encode来获取类型编码，swift中可以通过转换为NSValue类型，使用objCType获取类型编码。类型编码这个运行时还是比较有用的</p>
</li>
<li>@asmname可直接将C函数映射为swift函数，但可能会有命名冲突，慎用</li>
<li><p>swift的protocol可以被class，struct，enum等类型遵守。而想要在swift中声明weak delegate，就最要将protocol限制在class内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 将protocol限制在class内</span><br><span class="line">// 1,在protocol声明前加上@objc</span><br><span class="line">@objc protocol MyClassDelegate &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br><span class="line">// 更好的办法</span><br><span class="line">// 2，在protocol声明后加上class</span><br><span class="line">protocol ClassDelegate : class &#123;</span><br><span class="line">func method()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>associated object</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private var key : Void?</span><br><span class="line">extension AppDelegate &#123;&apos;</span><br><span class="line">var associatedObject: String? &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return objc_getAssociatedObject(self, &amp;key) as? String</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_COPY)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中没有 @synchronized ，但可以自己实现一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// OC的@synchronized，也是调objc_sync_enter和objc_sync_exit，外加异常判断</span><br><span class="line">func syncchronized(_ lock: AnyObject, closure:()-&gt;())&#123;</span><br><span class="line">objc_sync_enter(lock) </span><br><span class="line">closure()</span><br><span class="line">objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC与CoreFoundation的转化规则：<strong>bridge转换OC和CF，不涉及内存；</strong>bridge_retained或CFBridgingRetain 将OC转换到CF，需要手动调用CFRelease来释放对象内存；__bridge_transfer或CFBridgingRelease将CF转化为OC，ARC负责释放对象。对于CF系API，如果API名字中含有Create，Copy或Retain的话，使用完成后要手动调CFRelease来释放内存。但在swift中，与CF的转化可以省掉了，也不用调CFRelease释放内存了，一个字：爽</p>
</li>
<li>swift命令号工具</li>
<li><p>随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// let num = Int(arc4random()) % 5 + 1 ;  iphone4，5上可能crash</span><br><span class="line">// 因swift的Int和CPU架构有关，在32位CPU上是Int32，64位CPU上是Int64，而arc4random不论什么平台上都是UInt32，故可能越界crash</span><br><span class="line">// 可用arc4random_uniform 实现相同效果</span><br><span class="line">let num = Int(arc4random_uniform()) % 5 + 1 ;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CustomStringConvertible 和 CustomDebugStringConvertible 协议可以格式化print样式</p>
</li>
<li><p>要throws另一个throws时，应将前者改为rethrows。<a href="https://www.cnblogs.com/junhuawang/p/6231084.html" target="_blank" rel="noopener">Swift异常处理</a> 和 <a href="https://www.jianshu.com/p/a71d87d92459" target="_blank" rel="noopener">swift的defer</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">//try? 抛出异常则返回nil,没抛出正常返回；try！肯定不会抛异常。但抛出异常就crash，慎用 </span><br><span class="line">//try somthing</span><br><span class="line">//try somthing</span><br><span class="line">&#125; catch let err as NSError &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OC的NSAssert宏 在swift中对应为assert函数</p>
</li>
<li>fatalError可以在release和debug下终止程序，类似于Debug下NSAssert(NO, @”说明”);的作用</li>
<li>代码组织和Framework</li>
<li><p>安全的资源组织方式，OC时经常将资源名称定义为宏，这样可相对集中的管理和修改。swift可以用enum和extension来处理资源，原理如下。<a href="https://github.com/SwiftGen/SwiftGen" target="_blank" rel="noopener">SwiftGen</a> 和 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 可扫描文件自动生成对应的enum或struct文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ImageName: String &#123;</span><br><span class="line">case myImage = &quot;my_image&quot;</span><br><span class="line">&#125;</span><br><span class="line">extension UIImage &#123;</span><br><span class="line">convenience init?(imageName: ImageName)&#123;</span><br><span class="line">self.init(named: imageName.rawValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let image = UIImage(imageName: .myImage)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Playground延时运行有问题，需要引入PlaygroundSupport框架</p>
</li>
<li>Playground与项目协作</li>
<li>Playground的可视化开发</li>
<li>NaN 是not a number的意思，很特殊，但好像没啥用！ isNaN 判断是否是NaN</li>
<li>swift4以后可以用Codable协议进行json解析，序列化和反序列化操作</li>
<li>swift中NSNull会默认通过可选链转化为nil</li>
<li>在方法或属性上面使用快捷键（ alt+cmd+/ ）快速生成注释。也可使用<a href="https://github.com/realm/jazzy" target="_blank" rel="noopener">jazzy</a></li>
<li>swift由于类型安全，性能比较高！</li>
<li><p>log输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// #file 文件路径，#line 行号，#function 方法名</span><br><span class="line">func Log&lt;T&gt;(_ message: T, file: String = #file, method:String = #function, line:Int = #line)&#123;</span><br><span class="line">print(&quot;\((file as NSString).lastPathComponent)[\(line)],\(method): \(message)&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>swift中可以通过 &amp;+，&amp;-，&amp;*，&amp;/, &amp;% 来忽略溢出的错误</p>
</li>
<li>swift中没有宏定义，使用let 或 get属性来替代宏定义</li>
<li>属性访问控制：open (跨模块) &gt; public（本模块） &gt; interal（本模块内部用） &gt; fileprivate（本文件可用） &gt; private（本类可用）</li>
<li>swift中的测试</li>
<li>swift的CoreData使用</li>
<li>闭包很好用，最好写全了，别用乱七八糟的简写</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/04/10/Swift开发者必备Tips/" data-id="ckd90jolb003fxc515w9xz9yv" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-复习swift：Swift-tips-tricks笔记下" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/03/28/复习swift：Swift-tips-tricks笔记下/">复习swift：Swift tips &amp; tricks笔记下</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/03/28/复习swift：Swift-tips-tricks笔记下/" class="article-date">
  <time datetime="2018-03-27T16:22:26.000Z" itemprop="datePublished">2018-03-28</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;上篇学习了前50个，本文学习剩下的。拆成2篇是因为有道同步太坑了，上篇前50个就一直同步失败！</p>
<p>&emsp;&emsp;想看全部的自己看<a href="https://github.com/JohnSundell/SwiftTips#1-namespacing-with-nested-types" target="_blank" rel="noopener">大神的Swift tips &amp; tricks</a>，</p>
<ol start="51">
<li><p>UIView bounds and transforms</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let view = UIView()</span><br><span class="line">view.frame.size = CGSize(width: 100, height: 100)</span><br><span class="line">view.transform = CGAffineTransform(scaleX: 2, y: 2)</span><br><span class="line"></span><br><span class="line">print(view.frame) // (-50.0, -50.0, 200.0, 200.0)</span><br><span class="line">print(view.bounds) // (0.0, 0.0, 100.0, 100.0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展equatable实现 多值命中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Equatable &#123;</span><br><span class="line">func isAny(of candidates: Self...) -&gt; Bool &#123;</span><br><span class="line">return candidates.contains(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let isHorizontal = direction.isAny(of: .left, .right)</span><br></pre></td></tr></table></figure>
</li>
<li><p>限制该协议只适用于class类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过将AnyObject协议添加到协议的继承列表中，来限制该协议只适用于class类型，而不适用于枚举和结构体。</span><br><span class="line">protocol DataContainer: AnyObject &#123;</span><br><span class="line">var data: Data? &#123; get set &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把实例方法当做static方法调用! 好牛逼</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In Swift, you can call any instance method as a static function and it will return a closure representing that method. This is how running tests using SPM on Linux works.</span><br><span class="line"></span><br><span class="line">More about this topic in my blog post &quot;https://www.swiftbysundell.com/posts/first-class-functions-in-swiftt&quot;.</span><br><span class="line"></span><br><span class="line">// This produces a &apos;() -&gt; Void&apos; closure which is a reference to the</span><br><span class="line">// given view&apos;s &apos;removeFromSuperview&apos; method.</span><br><span class="line">let closure = UIView.removeFromSuperview(view)</span><br><span class="line"></span><br><span class="line">// We can now call it just like we would any other closure, and it</span><br><span class="line">// will run &apos;view.removeFromSuperview()&apos;</span><br><span class="line">closure()</span><br><span class="line"></span><br><span class="line">// This is how running tests using the Swift Package Manager on Linux</span><br><span class="line">// works, you return your test functions as closures:</span><br><span class="line">extension UserManagerTests &#123;</span><br><span class="line">static var allTests = [</span><br><span class="line">(&quot;testLoggingIn&quot;, testLoggingIn),</span><br><span class="line">(&quot;testLoggingOut&quot;, testLoggingOut),</span><br><span class="line">(&quot;testUserPermissions&quot;, testUserPermissions)</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>where子句和associated关联类型提供更多自由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public protocol PathFinderMap &#123;</span><br><span class="line">associatedtype Node</span><br><span class="line">// Using the &apos;where&apos; clause for associated types, we can</span><br><span class="line">// ensure that a type meets certain requirements (in this</span><br><span class="line">// case that it&apos;s a sequence with Node elements).</span><br><span class="line">associatedtype NodeSequence: Sequence where NodeSequence.Element == Node</span><br><span class="line"></span><br><span class="line">// Instead of using a concrete type (like [Node]) here, we</span><br><span class="line">// give implementors of this protocol more freedom while</span><br><span class="line">// still meeting our requirements. For example, one</span><br><span class="line">// implementation might use Set&lt;Node&gt;.</span><br><span class="line">func neighbors(of node: Node) -&gt; NodeSequence</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义option sets，即OC的NS_OPTIONS</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 必须是实现OptionSet协议</span><br><span class="line">struct Options: OptionSet &#123;</span><br><span class="line">static let saveToDisk = Options(rawValue: 1)</span><br><span class="line">static let clearOnMemoryWarning = Options(rawValue: 1 &lt;&lt; 1)</span><br><span class="line">static let clearDaily = Options(rawValue: 1 &lt;&lt; 2)</span><br><span class="line"></span><br><span class="line">let rawValue: Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可用ChildViewController，它们会自动调整大小以匹配其父视图</p>
</li>
<li>使用元组来设置view状态，其实就是代替model，但不建议这么搞！因为没有规范，使用Class可明确含义，使用struct还能实现MVVM，元祖是最差的选择了，除非用于快速测试</li>
<li><p>swift访问剪贴板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Cocoa</span><br><span class="line"></span><br><span class="line">let clipboard = NSPasteboard.general.string(forType: .string)</span><br></pre></td></tr></table></figure>
</li>
<li><p>巧用self来实现链式…额不知道叫什么！不过，其实可以实现链式编程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Extension adding builder pattern-like properties that return</span><br><span class="line">// a new sequence value with the given configuration applied</span><br><span class="line">extension FileSequence &#123;</span><br><span class="line">var recursive: FileSequence &#123;</span><br><span class="line">var sequence = self</span><br><span class="line">sequence.isRecursive = true</span><br><span class="line">return sequence</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var includingHidden: FileSequence &#123;</span><br><span class="line">var sequence = self</span><br><span class="line">sequence.includeHidden = true</span><br><span class="line">return sequence</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// BEFORE</span><br><span class="line"></span><br><span class="line">let files = folder.makeFileSequence(recursive: true, includeHidden: true)</span><br><span class="line"></span><br><span class="line">// AFTER</span><br><span class="line"></span><br><span class="line">let files = folder.files.recursive.includingHidden</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用&amp; 来合成协议 UIViewController &amp; LoadableFromURL 、 protocolA &amp; protocolB</p>
</li>
<li><p>Parsing command line arguments using UserDefaults</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A really cool &quot;hidden&quot; feature of UserDefaults is that it contains any arguments that were passed to the app at launch!</span><br><span class="line"></span><br><span class="line">Super useful both in Swift command line tools &amp; scripts, but also to temporarily override a value when debugging iOS apps.</span><br><span class="line"></span><br><span class="line">let defaults = UserDefaults.standard</span><br><span class="line">let query = defaults.string(forKey: &quot;query&quot;)</span><br><span class="line">let resultCount = defaults.integer(forKey: &quot;results&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typealias Pair&lt;T&gt; = (T, T)</span><br><span class="line"></span><br><span class="line">extension Game &#123;</span><br><span class="line">func calculateScore(for players: Pair&lt;Player&gt;) -&gt; Int &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>associatedtype的使用,typealias 重命名RawValue是关键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protocol UnboxTransformable &#123;</span><br><span class="line">associatedtype RawValue</span><br><span class="line"></span><br><span class="line">static func transform(_ value: RawValue) throws -&gt; Self?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Array: UnboxTransformable where Element: UnboxTransformable &#123;</span><br><span class="line">typealias RawValue = [Element.RawValue]</span><br><span class="line"></span><br><span class="line">static func transform(_ value: RawValue) throws -&gt; [Element]? &#123;</span><br><span class="line">return try value.compactMap(Element.transform)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>throw是本函数异常，rethrow是本函数没事但本函数的闭包异常（即闭包有throw）</p>
</li>
<li><p>联类型的默认值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol Identifiable &#123;</span><br><span class="line">associatedtype RawIdentifier: Codable = String</span><br><span class="line"></span><br><span class="line">var id: Identifier&lt;Self&gt; &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct User: Identifiable &#123;</span><br><span class="line">let id: Identifier&lt;User&gt;</span><br><span class="line">let name: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Group: Identifiable &#123;</span><br><span class="line">typealias RawIdentifier = Int</span><br><span class="line"></span><br><span class="line">let id: Identifier&lt;Group&gt;</span><br><span class="line">let name: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Encodable &amp; Decodable的扩展</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extension Encodable &#123;</span><br><span class="line">func encoded() throws -&gt; Data &#123;</span><br><span class="line">return try JSONEncoder().encode(self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Data &#123;</span><br><span class="line">func decoded&lt;T: Decodable&gt;() throws -&gt; T &#123;</span><br><span class="line">return try JSONDecoder().decode(T.self, from: self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let data = try user.encoded()</span><br><span class="line"></span><br><span class="line">// By using a generic type in the decoded() method, the</span><br><span class="line">// compiler can often infer the type we want to decode</span><br><span class="line">// from the current context.</span><br><span class="line">try userDidLogin(data.decoded())</span><br><span class="line"></span><br><span class="line">// And if not, we can always supply the type, still making</span><br><span class="line">// the call site read very nicely.</span><br><span class="line">let otherUser = try data.decoded() as User</span><br></pre></td></tr></table></figure>
</li>
<li><p>Matching multiple enum cases with associated values</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum DownloadState &#123;</span><br><span class="line">case inProgress(progress: Double)</span><br><span class="line">case paused(progress: Double)</span><br><span class="line">case cancelled</span><br><span class="line">case finished(Data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func downloadStateDidChange(to state: DownloadState) &#123;</span><br><span class="line">switch state &#123;</span><br><span class="line">case .inProgress(let progress), .paused(let progress):</span><br><span class="line">updateProgressView(with: progress)</span><br><span class="line">case .cancelled:</span><br><span class="line">showCancelledMessage()</span><br><span class="line">case .finished(let data):</span><br><span class="line">process(data)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>展开可选值或抛出错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension Optional &#123;</span><br><span class="line">func orThrow(_ errorExpression: @autoclosure () -&gt; Error) throws -&gt; Wrapped &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case .some(let value):</span><br><span class="line">return value</span><br><span class="line">case .none:</span><br><span class="line">throw errorExpression()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let file = try loadFile(at: path).orThrow(MissingFileError())</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用associatedtype约束protocol</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protocol Component &#123;</span><br><span class="line">associatedtype Container</span><br><span class="line">func add(to container: Container)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Protocols that inherit from other protocols can include</span><br><span class="line">// constraints to further specialize them.</span><br><span class="line">protocol ViewComponent: Component where Container == UIView &#123;</span><br><span class="line">associatedtype View: UIView</span><br><span class="line">var view: View &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension ViewComponent &#123;</span><br><span class="line">func add(to container: UIView) &#123;</span><br><span class="line">container.addSubview(view)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>&emsp;&emsp;最后:下篇其实干货不是很多，而且写这个的大神非常推崇元组，光元祖就写了一大堆</p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/03/28/复习swift：Swift-tips-tricks笔记下/" data-id="ckd90jon0007pxc51bbzpvjag" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-复习swift：Swift-tips-tricks笔记上" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/03/27/复习swift：Swift-tips-tricks笔记上/">复习swift：Swift tips &amp; tricks笔记上</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/03/27/复习swift：Swift-tips-tricks笔记上/" class="article-date">
  <time datetime="2018-03-26T16:22:34.000Z" itemprop="datePublished">2018-03-27</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;本文只摘抄了自己觉得有用的tip并加了点自己的理解，并不是全部tips。想看全部的自己看<a href="https://github.com/JohnSundell/SwiftTips#1-namespacing-with-nested-types" target="_blank" rel="noopener">大神的Swift tips &amp; tricks</a></p>
<ol>
<li><p>嵌套类型，好处大大滴！权限控制、结构划分等等</p>
</li>
<li><p>自动闭包，能使用自动闭包类型是是这样的() -&gt; T</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func logIfTure(_ predicate: ()-&gt;Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;jzk&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure(&#123; () -&gt; Bool in</span><br><span class="line">return 2 &gt; 1</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123;</span><br><span class="line">return 3 &gt; 2</span><br><span class="line">&#125;)</span><br><span class="line">logIfTure(&#123;4&gt;3&#125;)</span><br><span class="line">logIfTure&#123;5&gt;4&#125;</span><br><span class="line"></span><br><span class="line">// 自动闭包写起来就优雅多了</span><br><span class="line">func logIfTure2(_ predicate:@autoclosure ()-&gt;Bool)&#123;</span><br><span class="line">if predicate() &#123;</span><br><span class="line">print(&quot;jzk&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">logIfTure2(6&gt;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用typealiases减少长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typealias DownSuccess = (json: NSURLResponse, filePath: String?) -&gt; ()</span><br><span class="line">func Post(url:String? ,success: DownSuccess)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用与库同名的类、结构体…，慎用！还是不重复的好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Command &#123;</span><br><span class="line">enum Error: Swift.Error &#123;</span><br><span class="line">case missing</span><br><span class="line">case invalid(String)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用#function来保证UserDefault的key不重复! 慎用，思路不错，但不严谨</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension UserDefaults &#123;</span><br><span class="line">var onboardingCompleted: Bool &#123;</span><br><span class="line">get &#123; return bool(forKey: #function) &#125;</span><br><span class="line">set &#123; set(newValue, forKey: #function) &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把func和操作符当做闭包传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let array = [3, 9, 1, 4, 6, 2]</span><br><span class="line">let sorted = array.sorted(by: &lt;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用guard拆分条件判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guard maxObjectDepth &gt; 0 else &#123; return &#125;</span><br><span class="line">guard maxObjectDepth &lt; 100 else &#123; return &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要使用swith的default，目的强制编译器检查case是否完全</p>
</li>
<li><p>使用 .语法和闭包来初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">public func logSomething(_ str: String = &quot;&quot;) &#123;</span><br><span class="line">print(&quot;----\(str)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 第一个比较好理解，参数默认值</span><br><span class="line">func test(log: Logger = .init())&#123;</span><br><span class="line">log.logSomething(&quot;1&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">/*</span><br><span class="line">但这个我就理解不了了，注意Logger.init后面没有括号</span><br><span class="line">*/</span><br><span class="line">func test2(log:@escaping () -&gt; Logger = Logger.init) &#123;</span><br><span class="line">let log2 = log();</span><br><span class="line">log2.logSomething(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 === 比较内存相等</p>
</li>
<li><p>枚举可有关联值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public enum JSONKey &#123;</span><br><span class="line">case index(Int)</span><br><span class="line">case key(String)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可变参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension Canvas &#123;</span><br><span class="line">func add(_ shapes: Shape...) &#123;</span><br><span class="line">shapes.forEach(add)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Avoiding mocking UserDefaults! mocking啥呀，建新的！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class LoginTests: XCTestCase &#123;</span><br><span class="line">private var userDefaults: UserDefaults!</span><br><span class="line">private var manager: LoginManager!</span><br><span class="line"></span><br><span class="line">override func setUp() &#123;</span><br><span class="line">super.setup()</span><br><span class="line"></span><br><span class="line">userDefaults = UserDefaults(suiteName: #file)</span><br><span class="line">userDefaults.removePersistentDomain(forName: #file)</span><br><span class="line"></span><br><span class="line">manager = LoginManager(userDefaults: userDefaults)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加速包测试速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift test --parallel</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用闭包创建lazy属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Logger &#123;</span><br><span class="line">private lazy var str: String = &#123;</span><br><span class="line">print(&quot;lazy str init&quot;)</span><br><span class="line">return &quot;jzk&quot;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">public func log()&#123;</span><br><span class="line">print(&quot;my name is \(str)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let log1 = Logger();</span><br><span class="line">log1.log();</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合函数序列! </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">internal func +&lt;A, B, C&gt;(lhs: @escaping (A) throws -&gt; B,</span><br><span class="line">rhs: @escaping (B) throws -&gt; C) -&gt; (A) throws -&gt; C &#123;</span><br><span class="line">return &#123; try rhs(lhs($0)) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public func run() throws &#123;</span><br><span class="line">try (determineTarget + build + analyze + output)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using DispatchWorkItem， OC用dispatch_block_t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let workItem = DispatchWorkItem &#123;</span><br><span class="line">// Your async code goes in here</span><br><span class="line">&#125;// 注意没括号</span><br><span class="line"></span><br><span class="line">// Execute the work item after 1 second</span><br><span class="line">DispatchQueue.main.asyncAfter(deadline: .now() + 1, execute: workItem)</span><br><span class="line"></span><br><span class="line">// You can cancel the work item if you no longer need it</span><br><span class="line">workItem.cancel()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用weak或o避免循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned ，如果存在被释放的可能，那就选择用 weak</span><br><span class="line">dataLoader.loadData(from: url) &#123; [weak self] result in</span><br><span class="line">// 这句检查self基本是定式了</span><br><span class="line">guard let self = self else &#123; </span><br><span class="line">return </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.cache(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>异步返回的尽量用enum</p>
</li>
<li><p>使用关联的枚举值以避免特定于状态的选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// BEFORE: Lots of state-specific, optional properties</span><br><span class="line"></span><br><span class="line">class Player &#123;</span><br><span class="line">var isWaitingForMatchMaking: Bool</span><br><span class="line">var invitingUser: User?</span><br><span class="line">var numberOfLives: Int</span><br><span class="line">var playerDefeatedBy: Player?</span><br><span class="line">var roundDefeatedIn: Int?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AFTER: All state-specific information is encapsulated in enum cases</span><br><span class="line"></span><br><span class="line">class Player &#123;</span><br><span class="line">enum State &#123;</span><br><span class="line">case waitingForMatchMaking</span><br><span class="line">case waitingForInviteResponse(from: User)</span><br><span class="line">case active(numberOfLives: Int)</span><br><span class="line">case defeated(by: Player, roundNumber: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var state: State</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型约束中使用闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension Sequence where Element == () -&gt; Void &#123;</span><br><span class="line">func callAll() &#123;</span><br><span class="line">forEach &#123; $0() &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extension Sequence where Element == () -&gt; String &#123;</span><br><span class="line">func joinedResults(separator: String) -&gt; String &#123;</span><br><span class="line">return map &#123; $0() &#125;.joined(separator: separator)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callbacks.callAll()</span><br><span class="line">let names = nameProviders.joinedResults(separator: &quot;, &quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用静态定义url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let url: URL = &quot;https://www.swiftbysundell.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak或lazy属性应该设置readoonly</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">private(set) weak var parent: Node?</span><br><span class="line">private(set) lazy var children = [Node]()</span><br><span class="line"></span><br><span class="line">func add(child: Node) &#123;</span><br><span class="line">children.append(child)</span><br><span class="line">child.parent = self</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Passing self to required Objective-C dependencies</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Using lazy properties in Swift, you can pass self to required Objective-C dependencies without having to use force-unwrapped optionals.</span><br><span class="line"></span><br><span class="line">class DataLoader: NSObject &#123;</span><br><span class="line">lazy var urlSession: URLSession = self.makeURLSession()</span><br><span class="line"></span><br><span class="line">private func makeURLSession() -&gt; URLSession &#123;</span><br><span class="line">return URLSession(configuration: .default, delegate: self, delegateQueue: .main)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Renderer &#123;</span><br><span class="line">lazy var displayLink: CADisplayLink = self.makeDisplayLink()</span><br><span class="line"></span><br><span class="line">private func makeDisplayLink() -&gt; CADisplayLink &#123;</span><br><span class="line">return CADisplayLink(target: self, selector: #selector(screenDidRefresh))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体初始化时可设置self值，但其他方法修改self需要添加mutabling</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Bool: AnswerConvertible &#123;</span><br><span class="line">public init(input: String) throws &#123;</span><br><span class="line">switch input.lowercased() &#123;</span><br><span class="line">case &quot;y&quot;, &quot;yes&quot;, &quot;👍&quot;:</span><br><span class="line">self = true</span><br><span class="line">default:</span><br><span class="line">self = false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用extension来组织代码</p>
</li>
<li><p>使用set减少枚举时的if/else if使用! 高，真高！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class RoadTile: Tile &#123;</span><br><span class="line">var connectedDirections = Set&lt;Direction&gt;()</span><br><span class="line"></span><br><span class="line">func render() &#123;</span><br><span class="line">switch connectedDirections &#123;</span><br><span class="line">case [.up, .down]:</span><br><span class="line">image = UIImage(named: &quot;road-vertical&quot;)</span><br><span class="line">case [.left, .right]:</span><br><span class="line">image = UIImage(named: &quot;road-horizontal&quot;)</span><br><span class="line">default:</span><br><span class="line">image = UIImage(named: &quot;road&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议可继承、可扩展！自然也就可重载、覆盖，然后就可以干点事情了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// Declare a public protocol that acts as your immutable API</span><br><span class="line">public protocol ModelHolder &#123;</span><br><span class="line">associatedtype Model</span><br><span class="line">var model: Model &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Declare an extended, internal protocol that provides a mutable API</span><br><span class="line">internal protocol MutableModelHolder: ModelHolder &#123;</span><br><span class="line">var model: Model &#123; get set &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// You can now implement the requirements using &apos;public internal(set)&apos;</span><br><span class="line">public class UserHolder: MutableModelHolder &#123;</span><br><span class="line">public internal(set) var model: User</span><br><span class="line"></span><br><span class="line">internal init(model: User) &#123;</span><br><span class="line">self.model = model</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Converting Swift errors to NSError</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">case .some(let error as NSError) where error.code == NSURLErrorNotConnectedToInternet:</span><br><span class="line">presenter.showOfflineView()</span><br></pre></td></tr></table></figure>
</li>
<li><p>lazy属性最好加上类型，外部调用最好加上self ！同时swift4也支持lazy的自动类型推断</p>
</li>
<li><p>静态依赖注入! 参数默认值的妙用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Before: Almost impossible to test due to the use of singletons</span><br><span class="line"></span><br><span class="line">class Analytics &#123;</span><br><span class="line">static func log(_ event: Event) &#123;</span><br><span class="line">Database.shared.save(event)</span><br><span class="line"></span><br><span class="line">let dictionary = event.serialize()</span><br><span class="line">NetworkManager.shared.post(dictionary, to: eventURL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// After: Much easier to test, since we can inject mocks as arguments</span><br><span class="line"></span><br><span class="line">class Analytics &#123;</span><br><span class="line">static func log(_ event: Event,</span><br><span class="line">database: Database = .shared,</span><br><span class="line">networkManager: NetworkManager = .shared) &#123;</span><br><span class="line">database.save(event)</span><br><span class="line"></span><br><span class="line">let dictionary = event.serialize()</span><br><span class="line">networkManager.post(dictionary, to: eventURL)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以元组作为闭包的参数！好处：简单、可扩展且命名更规范</p>
</li>
<li><p>任何静态方法或属性都可以与点语法一起使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public enum RepeatMode &#123;</span><br><span class="line">case times(Int)</span><br><span class="line">case forever</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public extension RepeatMode &#123;</span><br><span class="line">static var never: RepeatMode &#123;</span><br><span class="line">return .times(0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static var once: RepeatMode &#123;</span><br><span class="line">return .times(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view.perform(animation, repeated: .once)</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数的本地拷贝，swift中除了类是引用，其他都是值类型，即当做参数都是copy进入的let常量，这时候在函数内部使用，最好拷贝一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init(repeatMode: RepeatMode, closure: @escaping () -&gt; UpdateOutcome) &#123;</span><br><span class="line">// Shadow the argument with a local, mutable copy</span><br><span class="line">var repeatMode = repeatMode</span><br></pre></td></tr></table></figure>
</li>
<li><p>强大的where，可用于 协议、for in、case、catch、泛型 等，但if let、guard和while中被去掉了，使用 ，逗号分割不同条件</p>
</li>
<li>Extending optionals<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func validateTextFields() -&gt; Bool &#123;</span><br><span class="line">guard !usernameTextField.text.isNilOrEmpty else &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Since all optionals are actual enum values in Swift, we can easily</span><br><span class="line">// extend them for certain types, to add our own convenience APIs</span><br><span class="line"></span><br><span class="line">extension Optional where Wrapped == String &#123;</span><br><span class="line">var isNilOrEmpty: Bool &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case let string?:</span><br><span class="line">return string.isEmpty</span><br><span class="line">case nil:</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Since strings are now Collections in Swift 4, you can even</span><br><span class="line">// add this property to all optional collections:</span><br><span class="line"></span><br><span class="line">extension Optional where Wrapped: Collection &#123;</span><br><span class="line">var isNilOrEmpty: Bool &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case let collection?:</span><br><span class="line">return collection.isEmpty</span><br><span class="line">case nil:</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/03/27/复习swift：Swift-tips-tricks笔记上/" data-id="ckd90jomy007mxc51qmxw6pxi" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-复习swift：SwiftyJSON" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/03/24/复习swift：SwiftyJSON/">复习swift：SwiftyJSON</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/03/24/复习swift：SwiftyJSON/" class="article-date">
  <time datetime="2018-03-23T16:14:43.000Z" itemprop="datePublished">2018-03-24</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;继续复习swift，就平时写dome那点代码量，swift还是会忘光的，反正也不知道水啥！开始复习</p>
<ul>
<li><p>SwiftyJSON内部通过枚举和私有属性将Data转为具体类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public enum Type: Int &#123;</span><br><span class="line">case number</span><br><span class="line">case string</span><br><span class="line">case bool</span><br><span class="line">case array</span><br><span class="line">case dictionary</span><br><span class="line">case null</span><br><span class="line">case unknown</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// Private object</span><br><span class="line">fileprivate var rawArray: [Any] = []</span><br><span class="line">fileprivate var rawDictionary: [String: Any] = [:]</span><br><span class="line">fileprivate var rawString: String = &quot;&quot;</span><br><span class="line">fileprivate var rawNumber: NSNumber = 0</span><br><span class="line">fileprivate var rawNull: NSNull = NSNull()</span><br><span class="line">fileprivate var rawBool: Bool = false</span><br></pre></td></tr></table></figure>
</li>
<li><p>init的核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/// Private method to unwarp an object recursively</span><br><span class="line">// 递归的拆解object对象，拆成数组、字典或基本类型</span><br><span class="line">private func unwrap(_ object: Any) -&gt; Any &#123;</span><br><span class="line">switch object &#123;</span><br><span class="line">case let json as JSON:</span><br><span class="line">return unwrap(json.object)</span><br><span class="line">case let array as [Any]:</span><br><span class="line">return array.map(unwrap)</span><br><span class="line">case let dictionary as [String: Any]:</span><br><span class="line">// 小细节，dictionary是let常量</span><br><span class="line">var d = dictionary</span><br><span class="line">// 小细节2，手动命名元祖pair，命名更清晰</span><br><span class="line">dictionary.forEach &#123; pair in</span><br><span class="line">d[pair.key] = unwrap(pair.value)</span><br><span class="line">&#125;</span><br><span class="line">return d</span><br><span class="line">default:</span><br><span class="line">return object</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>merge的核心方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">Private woker function which does the actual merging</span><br><span class="line">Typecheck is set to true for the first recursion level to prevent total override of the source JSON</span><br><span class="line">*/</span><br><span class="line">fileprivate mutating func merge(with other: JSON, typecheck: Bool) throws &#123;</span><br><span class="line">if type == other.type &#123;</span><br><span class="line">switch type &#123;</span><br><span class="line">case .dictionary:</span><br><span class="line">for (key, _) in other &#123;</span><br><span class="line">try self[key].merge(with: other[key], typecheck: false)</span><br><span class="line">&#125;</span><br><span class="line">case .array:</span><br><span class="line">self = JSON(arrayValue + other.arrayValue)</span><br><span class="line">default:</span><br><span class="line">self = other</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if typecheck &#123;</span><br><span class="line">throw SwiftyJSONError.wrongType</span><br><span class="line">&#125; else &#123;</span><br><span class="line">self = other</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>厉害的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">这个枚举定义的好，支持泛型对子类型进行包装！</span><br><span class="line">又是实现协议，间接让JSON有了Collection的能力</span><br><span class="line">*/</span><br><span class="line">public enum Index&lt;T: Any&gt;: Comparable &#123;</span><br><span class="line">case array(Int)</span><br><span class="line">case dictionary(DictionaryIndex&lt;String, T&gt;)</span><br><span class="line">case null</span><br><span class="line"></span><br><span class="line">// 实现协议</span><br><span class="line">static public func == (lhs: Index, rhs: Index) -&gt; Bool &#123;</span><br><span class="line">switch (lhs, rhs) &#123;</span><br><span class="line">case (.array(let left), .array(let right)):           return left == right</span><br><span class="line">case (.dictionary(let left), .dictionary(let right)): return left == right</span><br><span class="line">case (.null, .null):                                  return true</span><br><span class="line">default:                                              return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static public func &lt; (lhs: Index, rhs: Index) -&gt; Bool &#123;</span><br><span class="line">switch (lhs, rhs) &#123;</span><br><span class="line">case (.array(let left), .array(let right)):           return left &lt; right</span><br><span class="line">case (.dictionary(let left), .dictionary(let right)): return left &lt; right</span><br><span class="line">default:                                              return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>厉害的数组path取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// Int从数组中取，string从字典中取</span><br><span class="line">fileprivate subscript(sub sub: JSONSubscriptType) -&gt; JSON &#123;</span><br><span class="line">get &#123;</span><br><span class="line">switch sub.jsonKey &#123;</span><br><span class="line">/*</span><br><span class="line">第一次看到self[index: index]差点就绕进去了，后来才反应过来</span><br><span class="line">调用上面的fileprivate subscript(index index: Int) -&gt; JSON</span><br><span class="line">*/  </span><br><span class="line">case .index(let index): return self[index: index]</span><br><span class="line">case .key(let key):     return self[key: key]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">switch sub.jsonKey &#123;</span><br><span class="line">case .index(let index): self[index: index] = newValue</span><br><span class="line">case .key(let key):     self[key: key] = newValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public subscript(path: [JSONSubscriptType]) -&gt; JSON &#123;</span><br><span class="line">get &#123;</span><br><span class="line">// 越来越喜欢swift了，OC最起码10行起!</span><br><span class="line">// 友情提示：self起始参数、$0[sub: $1]下标取值</span><br><span class="line">return path.reduce(self) &#123; $0[sub: $1] &#125;</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">switch path.count &#123;</span><br><span class="line">case 0: return</span><br><span class="line">case 1: self[sub:path[0]].object = newValue.object</span><br><span class="line">default:</span><br><span class="line">var nextJSON = self[sub: path[0]]</span><br><span class="line">// 这里是递归，前提必须用下标语法</span><br><span class="line">var aPath = path</span><br><span class="line">aPath.remove(at: 0)</span><br><span class="line">nextJSON[aPath] = newValue</span><br><span class="line"></span><br><span class="line">self[sub: path[0]] = nextJSON</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>吐槽OC的可变参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 摘抄这段是因为swift的可变参数比OC的强太多了</span><br><span class="line">// OC的可变参数取值麻烦还是次要的，主要是第一个参数很多人容易忘了取，具体见我很早前写的博客</span><br><span class="line">public subscript(path: JSONSubscriptType...) -&gt; JSON &#123;</span><br><span class="line">get &#123;</span><br><span class="line">return self[path]</span><br><span class="line">&#125;</span><br><span class="line">set &#123;</span><br><span class="line">self[path] = newValue</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重载标识符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// MARK: - Comparable</span><br><span class="line"></span><br><span class="line">extension JSON: Swift.Comparable &#123;&#125;</span><br><span class="line"></span><br><span class="line">public func == (lhs: JSON, rhs: JSON) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">switch (lhs.type, rhs.type) &#123;</span><br><span class="line">case (.number, .number): return lhs.rawNumber == rhs.rawNumber</span><br><span class="line">case (.string, .string): return lhs.rawString == rhs.rawString</span><br><span class="line">case (.bool, .bool):     return lhs.rawBool == rhs.rawBool</span><br><span class="line">case (.array, .array):   return lhs.rawArray as NSArray == rhs.rawArray as NSArray</span><br><span class="line">case (.dictionary, .dictionary): return lhs.rawDictionary as NSDictionary == rhs.rawDictionary as NSDictionary</span><br><span class="line">case (.null, .null):     return true</span><br><span class="line">default:                 return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/03/24/复习swift：SwiftyJSON/" data-id="ckd90jon2007vxc51drh9vn2w" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-复习swift：IQKeyboardManager" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/03/17/复习swift：IQKeyboardManager/">复习swift：IQKeyboardManager</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/03/17/复习swift：IQKeyboardManager/" class="article-date">
  <time datetime="2018-03-16T16:17:14.000Z" itemprop="datePublished">2018-03-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;关于IQKeyboardManager的原理，自己去<a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">github</a>上看吧，有完整的流程图（在最下面），我就写我自己感兴趣的，觉得好玩的东西</p>
<ol>
<li><p>大家都在用viewTag，但一般都是正数！其实是integer类型，可以是负数！另外tag值较小的，如0-100为苹果保留使用，自己用最好1000以上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">Default tag for toolbar with Done button   -1002.</span><br><span class="line">*/</span><br><span class="line">private static let  kIQDoneButtonToolbarTag         =   -1002</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什要保留通知 _kbShowNotification ? 看过源码发现，其实就是个标志位…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/** To save keyboardWillShowNotification. Needed for enable keyboard functionality. */</span><br><span class="line">private var         _kbShowNotification: Notification?</span><br></pre></td></tr></table></figure>
</li>
<li><p>as ad? as!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">is   用于类型检查</span><br><span class="line">as   向上转型</span><br><span class="line">as？ 尝试向下转型，可选值</span><br><span class="line">as！ 强制向下转型</span><br></pre></td></tr></table></figure>
</li>
<li><p>.self到底是啥?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">self可以用在类型后面取得类型本身，也可以用在实例后面取得这个实例本身</span><br><span class="line">Self表示特定类型，并且只能用在协议中或者作为某个类的方法的返回值类型, &apos;Self&apos; is only available in a protocol or as the result of a method in a class</span><br><span class="line">*/</span><br><span class="line">let classNameString = NSStringFromClass(type(of: textFieldViewController.self))</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">元类型用 .Type 表示。比如 Int.Type 就是 Int 的元类型，是类型不是实例值</span><br><span class="line">AnyClass 其实就是一个元类型 typealias AnyClass = AnyObject.Type</span><br><span class="line"></span><br><span class="line">扩展1：Any vs AnyObject</span><br><span class="line">AnyObject 可以代表任何 class 类型的实例</span><br><span class="line">Any 可以表示任意类型，甚至包括方法（func）类型。</span><br><span class="line">参考：https://swifter.tips/any-anyobject/</span><br><span class="line"></span><br><span class="line">扩展2：type(of:) vs .self</span><br><span class="line">通过 type(of:) 和 .self都可以获得元类型的值,但.self取到的是静态的元类型，声明的时候是什么类型就是什么类型。type(of:) 取的是运行时候的元类型，也就是这个实例 的类型</span><br><span class="line">*/ </span><br><span class="line">private var registeredClasses  = [UIView.Type]()</span><br></pre></td></tr></table></figure>
</li>
<li><p>关联对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import Foundation</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">public let kIQUseDefaultKeyboardDistance = CGFloat.greatestFiniteMagnitude</span><br><span class="line">private var kIQKeyboardDistanceFromTextField = &quot;kIQKeyboardDistanceFromTextField&quot;</span><br><span class="line"></span><br><span class="line">@objc var keyboardDistanceFromTextField: CGFloat &#123;</span><br><span class="line">get &#123;</span><br><span class="line">if let aValue = objc_getAssociatedObject(self, &amp;kIQKeyboardDistanceFromTextField) as? CGFloat &#123;</span><br><span class="line">return aValue</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return kIQUseDefaultKeyboardDistance</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">set(newValue) &#123;</span><br><span class="line">objc_setAssociatedObject(self, &amp;kIQKeyboardDistanceFromTextField, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>animate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">a.union(b) //并集</span><br><span class="line">a.intersection(b)//交集</span><br><span class="line">a.subtracting(b) //取差值</span><br><span class="line">a.symmetricDifference(b)//去掉相同值</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">swift版NSOption是  struct实现OptionSet协议 </span><br><span class="line">public struct AnimationOptions : OptionSet</span><br><span class="line">*/ </span><br><span class="line">UIView.animate(withDuration: _animationDuration, delay: 0, options: _animationCurve.union(.beginFromCurrentState), animations: &#123; () -&gt; Void in</span><br><span class="line">// 逃逸闭包，dosomething</span><br><span class="line">&#125;) &#123; _ in</span><br><span class="line">// 尾随闭包，dosomething</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多线程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OperationQueue.main.addOperation &#123;</span><br><span class="line">self.adjustPosition()</span><br><span class="line">self._privateHasPendingAdjustRequest = false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 写法1</span><br><span class="line"></span><br><span class="line">/*  Automatically called from the `+(void)load` method. */</span><br><span class="line">+ (IQKeyboardManager*)sharedManager</span><br><span class="line">&#123;</span><br><span class="line">//Singleton instance</span><br><span class="line">static IQKeyboardManager *kbManager;</span><br><span class="line"></span><br><span class="line">static dispatch_once_t onceToken;</span><br><span class="line">dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">kbManager = [[self alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return kbManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法2</span><br><span class="line">@objc public class var shared: IQKeyboardManager &#123;</span><br><span class="line">struct Static &#123;</span><br><span class="line">//Singleton instance. Initializing keyboard manger.</span><br><span class="line">static let kbManager = IQKeyboardManager()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** @return Returns the default singleton instance. */</span><br><span class="line">return Static.kbManager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法3</span><br><span class="line">static let sharedInstance = IQKeyboardManager()</span><br></pre></td></tr></table></figure>
</li>
<li><p>#selector</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// #selector() 的好处是不再需要使用字符串来构造</span><br><span class="line">// 但使用属性时，需要getter、setter前缀</span><br><span class="line">if textField.responds(to: #selector(setter: UITextField.inputAccessoryView)) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 实现多个协议方法大家都知道</span><br><span class="line">class ExampleTableViewController: UIViewController, UITableViewDataSource, UITableViewDelegate, UIPopoverPresentationControllerDelegate &#123;&#125;</span><br><span class="line">// 要求一个类型同时遵循多个协议，用协议合成</span><br><span class="line">@objc public weak var delegate: (UITextFieldDelegate &amp; UITextViewDelegate)?</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/03/17/复习swift：IQKeyboardManager/" data-id="ckd90jomw007gxc51vyw7g8an" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-生命之书365天的静心冥想" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/02/17/生命之书365天的静心冥想/">生命之书365天的静心冥想</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/02/17/生命之书365天的静心冥想/" class="article-date">
  <time datetime="2018-02-17T10:14:18.000Z" itemprop="datePublished">2018-02-17</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <ul>
<li>其实就是无欲则刚，学会淡定与从容！想要获得内心平静，就要正视自己所有的一切，既不否认、不肯定更不解释。</li>
<li>聆听需要心无杂念，不要以己度人，更不要武断猜疑！只是静心去听，听完之后自然会有相应的结论！</li>
<li>静心，需静坐！</li>
<li>己所不欲勿施于人，己所欲亦勿施于人</li>
<li>倾听需要放松自己，而不是压抑自己！不能做这个，必须做那个，当这个心态时，也许并不是倾听的好时机！</li>
<li>寻找自己，了解自己，接纳自己，顺势而为，点滴改变自己！切勿好高骛远，更勿自我放弃！</li>
<li>乐趣？现实就是有可为有不可为，坦然处之，摒弃杂念，学会接受，但不盲从，发现乐趣！我命由我不由天，就是如此吧</li>
<li>不要让过去的知识经验成为前进的阻碍，每日三省吾身，原来是这个意思</li>
<li>心若能完整的觉知，保持警醒和警觉。手段是工具</li>
<li>只有当心完全的寂静时，才有可能超越所有的经验！不要为了创造而创造，目标存在的意义是激励人不断地一步一步前行，而不是我达不到目标我就去死！</li>
<li>自我不是别人或自己打的一堆标签的集合。标签本身就是外在的，与自我无关！</li>
<li>只有当我们想逃避事实躲进幻想里的时候，才需要信仰！</li>
<li>面对现实和困难，人本能的会选择逃避，寻求依赖！无助和孤独是人生的必修课！</li>
<li>君子慎独，身体或心灵总的有一个在路上！强大的内心从点滴锻炼起来的！</li>
<li>对待欲望，既不否认也不抗拒，而是学会接受与忍受</li>
<li></li>
</ul>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/02/17/生命之书365天的静心冥想/" data-id="ckd90joo300abxc51i66w0ekn" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
          <article id="post-复习swift：Reachability" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>

    <div class="article-inner">
        
            <header class="article-header">
                
  
    <h2 itemprop="name">
      <a class="article-title" href="/2018/02/10/复习swift：Reachability/">复习swift：Reachability</a>
    </h2>
  
  




            </header>
            

                
                    <div class="article-meta">
                        <a href="/2018/02/10/复习swift：Reachability/" class="article-date">
  <time datetime="2018-02-09T16:18:40.000Z" itemprop="datePublished">2018-02-10</time>
</a>
                            
  <div class="article-category">
    <a class="article-category-link" href="/categories/swift/">swift</a>
  </div>

                    </div>
                    

                        

                                    <div class="article-entry" itemprop="articleBody">
                                        


                                            

                                                
                                                                    <p>&emsp;&emsp;刚转行的时候正好赶上Swift横空出世，但当时API非常不稳定，外加项目都是用OC写的就学了OC！对于Swift也是持观望态度！16年学习一段时间的Swift，后来来百度后发现都是用OC写的，而且还专门讨论过要不要引入Swift混编，结论自然是不行的：1、引入后编译变慢，包体积变大；2、其它同学都不会；再后来就不了了之了！</p>
<p>&emsp;&emsp;但现在已经8102年了，作为一个iOS开发你再说你不会Swift，那就真有点说不过去了！所以我决定从水Swift开始吧！至于为什么选择Reachability？因为权威和简单，好长时间不用Swift了，这次就当复习！作为复习资料，自然要找权威的、简单的！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line">// import Foundation.NSThread</span><br><span class="line">import SystemConfiguration</span><br><span class="line">import Foundation</span><br><span class="line"></span><br><span class="line">// 实现Error协议</span><br><span class="line">public enum ReachabilityError: Error &#123;</span><br><span class="line">// 枚举关联值，个人认为最NB的特性，其实理解成元组就好理解多了</span><br><span class="line">case failedToCreateWithAddress(sockaddr, Int32)</span><br><span class="line">case failedToCreateWithHostname(String, Int32)</span><br><span class="line">case unableToSetCallback(Int32)</span><br><span class="line">case unableToSetDispatchQueue(Int32)</span><br><span class="line">case unableToGetFlags(Int32)</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">@available 放在函数（方法），类或者协议前面,声明这些的生命周期依赖于特定的平台和操作系统版本。</span><br><span class="line">而#available用在判断语句中（if, guard, while等），在不同的平台上做不同的逻辑</span><br><span class="line">*/</span><br><span class="line">@available(*, unavailable, renamed: &quot;Notification.Name.reachabilityChanged&quot;)</span><br><span class="line">public let ReachabilityChangedNotification = NSNotification.Name(&quot;ReachabilityChangedNotification&quot;)</span><br><span class="line"></span><br><span class="line">// 基本已经成为通知命名的固定写法了</span><br><span class="line">public extension Notification.Name &#123;</span><br><span class="line">static let reachabilityChanged = Notification.Name(&quot;reachabilityChanged&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Reachability &#123;</span><br><span class="line">// 定义两个函数类型，入参Reachability，无返回值</span><br><span class="line">public typealias NetworkReachable = (Reachability) -&gt; ()</span><br><span class="line">public typealias NetworkUnreachable = (Reachability) -&gt; ()</span><br><span class="line"></span><br><span class="line">@available(*, unavailable, renamed: &quot;Connection&quot;)</span><br><span class="line">public enum NetworkStatus: CustomStringConvertible &#123;</span><br><span class="line">case notReachable, reachableViaWiFi, reachableViaWWAN</span><br><span class="line">public var description: String &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case .reachableViaWWAN: return &quot;Cellular&quot;</span><br><span class="line">case .reachableViaWiFi: return &quot;WiFi&quot;</span><br><span class="line">case .notReachable: return &quot;No Connection&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CustomStringConvertible协议就是用来输出的</span><br><span class="line">public enum Connection: CustomStringConvertible &#123;</span><br><span class="line">@available(*, deprecated, renamed: &quot;unavailable&quot;)</span><br><span class="line">case none</span><br><span class="line">case unavailable, wifi, cellular</span><br><span class="line">public var description: String &#123;</span><br><span class="line">switch self &#123;</span><br><span class="line">case .cellular: return &quot;Cellular&quot;</span><br><span class="line">case .wifi: return &quot;WiFi&quot;</span><br><span class="line">case .unavailable: return &quot;No Connection&quot;</span><br><span class="line">case .none: return &quot;unavailable&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">public var whenReachable: NetworkReachable?</span><br><span class="line">public var whenUnreachable: NetworkUnreachable?</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, renamed: &quot;allowsCellularConnection&quot;)</span><br><span class="line">public let reachableOnWWAN: Bool = true</span><br><span class="line"></span><br><span class="line">/// Set to `false` to force Reachability.connection to .none when on cellular connection (default value `true`)</span><br><span class="line">public var allowsCellularConnection: Bool</span><br><span class="line"></span><br><span class="line">// The notification center on which &quot;reachability changed&quot; events are being posted</span><br><span class="line">public var notificationCenter: NotificationCenter = NotificationCenter.default</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, renamed: &quot;connection.description&quot;)</span><br><span class="line">public var currentReachabilityString: String &#123;</span><br><span class="line">return &quot;\(connection)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(*, unavailable, renamed: &quot;connection&quot;)</span><br><span class="line">public var currentReachabilityStatus: Connection &#123;</span><br><span class="line">return connection</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 计算型属性</span><br><span class="line">public var connection: Connection &#123;</span><br><span class="line">// 习惯于OC的 _flags需要适应一下，swift里除非重名，都可以直接用相关属性</span><br><span class="line">if flags == nil &#123;</span><br><span class="line">/*</span><br><span class="line">Swift 中有 4 种处理错误的方式。你可以把函数抛出的错误传递给调用此函数的代码、用 do-catch 语句处理错误、将错误作为可选类型处理、或者断言此错误根本不会发生</span><br><span class="line">显然这里啥也没干，上层调用者不关心</span><br><span class="line">*/</span><br><span class="line">try? setReachabilityFlags()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch flags?.connection &#123;</span><br><span class="line">case .unavailable?, nil: return .unavailable</span><br><span class="line">case .none?: return .unavailable</span><br><span class="line">case .cellular?: return allowsCellularConnection ? .cellular : .unavailable</span><br><span class="line">case .wifi?: return .wifi</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">private 真正私有</span><br><span class="line">fileprivate 文件内私有</span><br><span class="line">Internal 默认，可以访问自己module或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体</span><br><span class="line">public 可以被任何人访问。但其他module中不可以被override和继承，而在module内可以被override和继承。</span><br><span class="line">open 可以被任何人使用，包括override和继承。</span><br><span class="line">*/</span><br><span class="line">fileprivate var isRunningOnDevice: Bool = &#123;</span><br><span class="line">#if targetEnvironment(simulator)</span><br><span class="line">return false</span><br><span class="line">#else</span><br><span class="line">return true</span><br><span class="line">#endif</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">// 只有set是fileprivate</span><br><span class="line">fileprivate(set) var notifierRunning = false</span><br><span class="line">// let 常量不可修改，但可init时赋值</span><br><span class="line">fileprivate let reachabilityRef: SCNetworkReachability</span><br><span class="line">fileprivate let reachabilitySerialQueue: DispatchQueue</span><br><span class="line">// 可选常量，因init是指定了默认值 .main</span><br><span class="line">fileprivate let notificationQueue: DispatchQueue?</span><br><span class="line">fileprivate(set) var flags: SCNetworkReachabilityFlags? &#123;</span><br><span class="line">// 属性观察器willSet和didSet使swift天然具备MVVM模式, 注意不要和set、get一起写没有意义</span><br><span class="line">didSet &#123;</span><br><span class="line">// 一开始我也不理解guard的作用，写起来感觉和if没什么区别，直到我遇到if嵌套</span><br><span class="line"></span><br><span class="line">// 当然下面这个写法我个人觉得还不如if</span><br><span class="line">guard flags != oldValue else &#123; return &#125;</span><br><span class="line">notifyReachabilityChanged()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 必要构造器，入参默认值是个好东西</span><br><span class="line">required public init(reachabilityRef: SCNetworkReachability,</span><br><span class="line">queueQoS: DispatchQoS = .default,</span><br><span class="line">targetQueue: DispatchQueue? = nil,</span><br><span class="line">notificationQueue: DispatchQueue? = .main) &#123;</span><br><span class="line">self.allowsCellularConnection = true</span><br><span class="line">self.reachabilityRef = reachabilityRef</span><br><span class="line">// C语言的GCD，在swift中被整成了class，不过使用方式没变</span><br><span class="line">// 为什么 DispatchQueue就一个class声明，所有的属性方法都在extension里？</span><br><span class="line">self.reachabilitySerialQueue = DispatchQueue(label: &quot;uk.co.ashleymills.reachability&quot;, qos: queueQoS, target: targetQueue)</span><br><span class="line">self.notificationQueue = notificationQueue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 便利构造器</span><br><span class="line">public convenience init(hostname: String,</span><br><span class="line">queueQoS: DispatchQoS = .default,</span><br><span class="line">targetQueue: DispatchQueue? = nil,</span><br><span class="line">notificationQueue: DispatchQueue? = .main) throws &#123;</span><br><span class="line">guard let ref = SCNetworkReachabilityCreateWithName(nil, hostname) else &#123;</span><br><span class="line">throw ReachabilityError.failedToCreateWithHostname(hostname, SCError())</span><br><span class="line">&#125;</span><br><span class="line">self.init(reachabilityRef: ref, queueQoS: queueQoS, targetQueue: targetQueue, notificationQueue: notificationQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public convenience init(queueQoS: DispatchQoS = .default,</span><br><span class="line">targetQueue: DispatchQueue? = nil,</span><br><span class="line">notificationQueue: DispatchQueue? = .main) throws &#123;</span><br><span class="line">var zeroAddress = sockaddr()</span><br><span class="line">zeroAddress.sa_len = UInt8(MemoryLayout&lt;sockaddr&gt;.size)</span><br><span class="line">zeroAddress.sa_family = sa_family_t(AF_INET)</span><br><span class="line"></span><br><span class="line">guard let ref = SCNetworkReachabilityCreateWithAddress(nil, &amp;zeroAddress) else &#123;</span><br><span class="line">throw ReachabilityError.failedToCreateWithAddress(zeroAddress, SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.init(reachabilityRef: ref, queueQoS: queueQoS, targetQueue: targetQueue, notificationQueue: notificationQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 析构，跟dealloc一样</span><br><span class="line">deinit &#123;</span><br><span class="line">stopNotifier()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public extension Reachability &#123;</span><br><span class="line"></span><br><span class="line">// MARK: - *** Notifier methods ***</span><br><span class="line">func startNotifier() throws &#123;</span><br><span class="line">guard !notifierRunning else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">let callback: SCNetworkReachabilityCallBack = &#123; (reachability, flags, info) in</span><br><span class="line">guard let info = info else &#123; return &#125;</span><br><span class="line"></span><br><span class="line">// `weakifiedReachability` is guaranteed to exist by virtue of our</span><br><span class="line">// retain/release callbacks which we provided to the `SCNetworkReachabilityContext`.</span><br><span class="line">/*</span><br><span class="line">OC对于 CF 系的 API，如果 API 的名字中含有 Create，Copy 或者 Retain的话，在使用完成后，我们需要调用 CFRelease 来进行释放</span><br><span class="line">Swift 中我们不再需要显式地去释放带有这些关键字的内容了。也就是说，CF 现在也在 ARC 的管辖范围之内了</span><br><span class="line">但是有一点例外（极少会用到），那就是对于非系统的CF的API(比如你自己写的或者是第三方的),将这些返回CF对象的API导入Swift时，它们的类型会被对对应为 Unmanaged&lt;T&gt;。这意味着在使用时我们需要手动进行内存管理，takeUnretainedValue 将保持原来的引用计数不变，在你明白你没有义务去释放原来的内存时，应该使用这个方法。而如果你需要释放得到的 CF 的对象的内存时，应该使用 takeRetainedValue 来让引用计数加一，然后在使用完后对原来的 Unmanaged 进行手动释放。为了能手动操作 Unmanaged 的引用计数，Unmanaged 中还提供了 retain，release 和 autorelease 这样的 &quot;老朋友&quot; 供我们使用</span><br><span class="line">*/</span><br><span class="line">let weakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info).takeUnretainedValue()</span><br><span class="line"></span><br><span class="line">// The weak `reachability` _may_ no longer exist if the `Reachability`</span><br><span class="line">// object has since been deallocated but a callback was already in flight.</span><br><span class="line">weakifiedReachability.reachability?.flags = flags</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let weakifiedReachability = ReachabilityWeakifier(reachability: self)</span><br><span class="line">let opaqueWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.passUnretained(weakifiedReachability).toOpaque()</span><br><span class="line"></span><br><span class="line">var context = SCNetworkReachabilityContext(</span><br><span class="line">version: 0,</span><br><span class="line">info: UnsafeMutableRawPointer(opaqueWeakifiedReachability),</span><br><span class="line">retain: &#123; (info: UnsafeRawPointer) -&gt; UnsafeRawPointer in</span><br><span class="line">let unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)</span><br><span class="line">_ = unmanagedWeakifiedReachability.retain()</span><br><span class="line">return UnsafeRawPointer(unmanagedWeakifiedReachability.toOpaque())</span><br><span class="line">&#125;,</span><br><span class="line">release: &#123; (info: UnsafeRawPointer) -&gt; Void in</span><br><span class="line">let unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)</span><br><span class="line">unmanagedWeakifiedReachability.release()</span><br><span class="line">&#125;,</span><br><span class="line">copyDescription: &#123; (info: UnsafeRawPointer) -&gt; Unmanaged&lt;CFString&gt; in</span><br><span class="line">let unmanagedWeakifiedReachability = Unmanaged&lt;ReachabilityWeakifier&gt;.fromOpaque(info)</span><br><span class="line">let weakifiedReachability = unmanagedWeakifiedReachability.takeUnretainedValue()</span><br><span class="line">let description = weakifiedReachability.reachability?.description ?? &quot;nil&quot;</span><br><span class="line">return Unmanaged.passRetained(description as CFString)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">if !SCNetworkReachabilitySetCallback(reachabilityRef, callback, &amp;context) &#123;</span><br><span class="line">stopNotifier()</span><br><span class="line">throw ReachabilityError.unableToSetCallback(SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if !SCNetworkReachabilitySetDispatchQueue(reachabilityRef, reachabilitySerialQueue) &#123;</span><br><span class="line">stopNotifier()</span><br><span class="line">throw ReachabilityError.unableToSetDispatchQueue(SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Perform an initial check</span><br><span class="line">try setReachabilityFlags()</span><br><span class="line"></span><br><span class="line">notifierRunning = true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func stopNotifier() &#123;</span><br><span class="line">// defer的作用就是函数结束前会调，无论函数是怎么结束的！</span><br><span class="line">defer &#123; notifierRunning = false &#125;</span><br><span class="line"></span><br><span class="line">SCNetworkReachabilitySetCallback(reachabilityRef, nil, nil)</span><br><span class="line">SCNetworkReachabilitySetDispatchQueue(reachabilityRef, nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MARK: - *** Connection test methods ***</span><br><span class="line">@available(*, deprecated, message: &quot;Please use `connection != .none`&quot;)</span><br><span class="line">var isReachable: Bool &#123;</span><br><span class="line">return connection != .unavailable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, message: &quot;Please use `connection == .cellular`&quot;)</span><br><span class="line">var isReachableViaWWAN: Bool &#123;</span><br><span class="line">// Check we&apos;re not on the simulator, we&apos;re REACHABLE and check we&apos;re on WWAN</span><br><span class="line">return connection == .cellular</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@available(*, deprecated, message: &quot;Please use `connection == .wifi`&quot;)</span><br><span class="line">var isReachableViaWiFi: Bool &#123;</span><br><span class="line">return connection == .wifi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var description: String &#123;</span><br><span class="line">return flags?.description ?? &quot;unavailable flags&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fileprivate extension Reachability &#123;</span><br><span class="line"></span><br><span class="line">// 上抛错误</span><br><span class="line">func setReachabilityFlags() throws &#123;</span><br><span class="line">try reachabilitySerialQueue.sync &#123; [unowned self] in</span><br><span class="line">var flags = SCNetworkReachabilityFlags()</span><br><span class="line">if !SCNetworkReachabilityGetFlags(self.reachabilityRef, &amp;flags) &#123;</span><br><span class="line">self.stopNotifier()</span><br><span class="line">throw ReachabilityError.unableToGetFlags(SCError())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self.flags = flags</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 发通知</span><br><span class="line">func notifyReachabilityChanged() &#123;</span><br><span class="line">/*</span><br><span class="line">swift中所有的class类型变量都默认采用strong修饰</span><br><span class="line">Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned ，如果存在被释放的可能，那就选择用 weak</span><br><span class="line">*/</span><br><span class="line">let notify = &#123; [weak self] in</span><br><span class="line">// 保证self存在</span><br><span class="line">guard let self = self else &#123; return &#125;</span><br><span class="line">// (Reachability) -&gt; ()类型的可选属性</span><br><span class="line">self.connection != .unavailable ? self.whenReachable?(self) : self.whenUnreachable?(self)</span><br><span class="line">// @escaping 逃逸闭包必须在闭包中显式地引用 self</span><br><span class="line">self.notificationCenter.post(name: .reachabilityChanged, object: self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// notify on the configured `notificationQueue`, or the caller&apos;s (i.e. `reachabilitySerialQueue`)</span><br><span class="line">// ?? 可选可用用可选，可选不能用用后面</span><br><span class="line">notificationQueue?.async(execute: notify) ?? notify()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;此外还有一个class，比较好玩！注释的很清楚了，思路挺好,其实就是weakproxy的作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">`ReachabilityWeakifier` weakly wraps the `Reachability` class</span><br><span class="line">in order to break retain cycles when interacting with CoreFoundation.</span><br><span class="line"></span><br><span class="line">CoreFoundation callbacks expect a pair of retain/release whenever an</span><br><span class="line">opaque `info` parameter is provided. These callbacks exist to guard</span><br><span class="line">against memory management race conditions when invoking the callbacks.</span><br><span class="line"></span><br><span class="line">#### Race Condition</span><br><span class="line"></span><br><span class="line">If we passed `SCNetworkReachabilitySetCallback` a direct reference to our</span><br><span class="line">`Reachability` class without also providing corresponding retain/release</span><br><span class="line">callbacks, then a race condition can lead to crashes when:</span><br><span class="line">- `Reachability` is deallocated on thread X</span><br><span class="line">- A `SCNetworkReachability` callback(s) is already in flight on thread Y</span><br><span class="line"></span><br><span class="line">#### Retain Cycle</span><br><span class="line"></span><br><span class="line">If we pass `Reachability` to CoreFoundtion while also providing retain/</span><br><span class="line">release callbacks, we would create a retain cycle once CoreFoundation</span><br><span class="line">retains our `Reachability` class. This fixes the crashes and his how</span><br><span class="line">CoreFoundation expects the API to be used, but doesn&apos;t play nicely with</span><br><span class="line">Swift/ARC. This cycle would only be broken after manually calling</span><br><span class="line">`stopNotifier()` — `deinit` would never be called.</span><br><span class="line"></span><br><span class="line">#### ReachabilityWeakifier</span><br><span class="line"></span><br><span class="line">By providing both retain/release callbacks and wrapping `Reachability` in</span><br><span class="line">a weak wrapper, we:</span><br><span class="line">- interact correctly with CoreFoundation, thereby avoiding a crash.</span><br><span class="line">See &quot;Memory Management Programming Guide for Core Foundation&quot;.</span><br><span class="line">- don&apos;t alter the public API of `Reachability.swift` in any way</span><br><span class="line">- still allow for automatic stopping of the notifier on `deinit`.</span><br><span class="line">*/</span><br><span class="line">private class ReachabilityWeakifier &#123;</span><br><span class="line">weak var reachability: Reachability?</span><br><span class="line">init(reachability: Reachability) &#123;</span><br><span class="line">self.reachability = reachability</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

                                                                        
                                    </div>
                                    <footer class="article-footer">
                                        <a data-url="http://jiaozhengkui.top/2018/02/10/复习swift：Reachability/" data-id="ckd90jomx007jxc5126tajya7" class="article-share-link">
                                            Share
                                        </a>
                                        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础/">基础</a></li></ul>

                                    </footer>

    </div>

    

                

</article>
        
    </article>
    
  
    
      <nav class="page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/">Next</a>
      </nav>
    
  </section>
</div>

  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-bar-chart"></i> <span id="busuanzi_value_site_pv"></span></li>
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 焦正奎的博客</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>

</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/author.jpg" alt="焦正奎的博客"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
<script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/ocean.js"></script>

</body>
</html>